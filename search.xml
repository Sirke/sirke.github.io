<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[10 种最常见的 Javascript 错误]]></title>
    <url>%2Fposts%2F33823.html</url>
    <content type="text"><![CDATA[我们查看了数千个项目的数据库，发现了 JavaScript 中频度最高的 10 种错误。我们会告诉你什么原因导致了这些错误，以及如何防止这些错误发生。如果你能够避免落入这些 “陷阱”，你将会成为一个更好的开发者。 原文：https://rollbar.com/blog/top-10-javascript-errors/ 数据才是王道，我们收集并分析了出现频次排前 10 的 JavaScript 错误。 Rollbar 会收集每个项目的所有错误，并总结每个错误发生的次数。我们通过根据 “指纹”（rollbar 用到的一种算法，详见：https://rollbar.com/docs/grouping-algorithm/）对错误进行分组。基本上，如果第二个错误只是第一个错误的重复，我们会把两个错误分到同一组。这会给用户一个很好的概括，而不是像在日志文件中看到的那样直接一大堆让人感觉到十分压迫的 dump。 我们专注于最有可能影响您和您的用户的错误。为此，我们通过研究各种不同公司的项目集来对于错误进行排列。如果我们只查看每个错误发生的总次数，那么客户量大的的项目产生的错误可能会压倒其他错误，导致实际收集到的是与大多数读者无关的错误数据集。 JavaScript 错误 Top 10： 为了便于阅读，我们将每个错误描述都缩短了。接下来，让我们深入到每一个错误，来确定什么会导致它，以及如何避免创建它。 1. Uncaught TypeError: Cannot read property如果你是一个 JavaScript 开发人员，可能你看到这个错误的次数比你敢承认的要多（LOL…）。当你读取一个未定义的对象的属性或调用其方法时，这个错误会在 Chrome 中出现。 您可以很容易的在 Chrome 开发者控制台中进行测试（尝试）。 发生这种情况的原因很多，但常见的一种是在渲染 UI 组件时对于状态的初始化操作不当。 我们来看一个在真实应用程序中发生的例子：我们选择 React，但该情况也同样适用于 Angular、Vue 或任何其他框架。 12345678910111213141516class Quiz extends Component &#123; componentWillMount() &#123; axios.get('/thedata').then(res =&gt; &#123; this.setState(&#123;items: res.data&#125;); &#125;); &#125; render() &#123; return ( &lt;ul&gt; &#123;this.state.items.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125; 这里有两件重要的事情要实现： 组件的状态（例如 this.state）从 undefined 开始。 当异步获取数据时，不管它是在构造函数componentWillMount还是componentDidMount中获取的，组件在数据加载之前至少会呈现一次，当 Quiz 第一次呈现时，this.state.items 是未定义的。 这又意味着 ItemList 将 items 定义为 undefined，并且在控制台中出现错误 - “Uncaught TypeError: Cannot read property ‘map’ of undefined”。 这很容易解决。最简单的方法：在构造函数中用合理的默认值来初始化 state。 123456789101112131415161718192021222324class Quiz extends Component &#123; // Added this: constructor(props) &#123; super(props); // Assign state itself, and a default value for items this.state = &#123; items: [] &#125;; &#125; componentWillMount() &#123; axios.get('/thedata').then(res =&gt; &#123; this.setState(&#123;items: res.data&#125;); &#125;); &#125; render() &#123; return ( &lt;ul&gt; &#123;this.state.items.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125; 在你的应用程序中的具体代码可能是不同的，但我们希望我们已经给你足够的线索，以解决或避免在你的应用程序中出现的这个问题。如果还没有，请继续阅读，因为我们将在下面覆盖更多相关错误的示例。 2. TypeError: ‘undefined’ is not an object这是在 Safari 中读取属性或调用未定义对象上的方法时发生的错误。您可以在 Safari Developer Console 中轻松测试。这与 1 中提到的 Chrome 的错误基本相同，但 Safari 使用了不同的错误消息提示语。 3. TypeError: null is not an object这是在 Safari 中读取属性或调用空对象上的方法时发生的错误。 您可以在 Safari Developer Console 中轻松测试。 有趣的是，在 JavaScript 中，null 和 undefined 是不一样的，这就是为什么我们看到两个不同的错误信息。undefined 通常是一个尚未分配的变量，而 null 表示该值为空。 要验证它们不相等，请尝试使用严格的相等运算符 ===： 在现实世界的例子中，这种错误可能发生的一种场景是：如果在加载元素之前尝试在 JavaScript 中使用元素。 因为 DOM API 对于空白的对象引用返回值为 null。 任何执行和处理 DOM 元素的 JS 代码都应该在创建 DOM 元素之后执行。 JS 代码按照 HTML 中的规定从上到下进行解释。 所以，如果 DOM 元素之前有一个标签，脚本标签内的 JS 代码将在浏览器解析 HTML 页面时执行。 如果在加载脚本之前尚未创建 DOM 元素，则会出现此错误。 在这个例子中，我们可以通过添加一个事件监听器来解决这个问题，这个监听器会在页面准备好的时候通知我们。 一旦 addEventListener被触发，init() 方法就可以使用 DOM 元素。 123456789101112131415161718&lt;script&gt; function init() &#123; var myButton = document.getElementById("myButton"); var myTextfield = document.getElementById("myTextfield"); myButton.onclick = function() &#123; var userName = myTextfield.value; &#125; &#125; document.addEventListener('readystatechange', function() &#123; if (document.readyState === "complete") &#123; init(); &#125; &#125;);&lt;/script&gt;&lt;form&gt; &lt;input type="text" id="myTextfield" placeholder="Type your name" /&gt; &lt;input type="button" id="myButton" value="Go" /&gt;&lt;/form&gt; 4. (unknown): Script error当未捕获的 JavaScript 错误（通过window.onerror处理程序引发的错误，而不是捕获在try-catch中）被浏览器的跨域策略限制时，会产生这类的脚本错误。 例如，如果您将您的 JavaScript 代码托管在 CDN 上，则任何未被捕获的错误将被报告为“脚本错误” 而不是包含有用的堆栈信息。这是一种浏览器安全措施，旨在防止跨域传递数据，否则将不允许进行通信。 要获得真正的错误消息，请执行以下操作： 发送 ‘Access-Control-Allow-Origin’ 头部 将 Access-Control-Allow-Origin 标头设置为 * 表示可以从任何域正确访问资源。 如有必要，您可以将域替换为您的域：例如，Access-Control-Allow-Origin：www.example.com。 但是，处理多个域会变得棘手，如果你使用 CDN，可能由此产生更多的缓存问题会让你感觉到这种努力并不值得。 在这里看到更多。 这里有一些关于如何在各种环境中设置这个头文件的例子： Apache 在 JavaScript 文件所在的文件夹中，使用以下内容创建一个 .htaccess 文件： 1Header add Access-Control-Allow-Origin &quot;*&quot; Nginx 将 add_header 指令添加到提供 JavaScript 文件的位置块中： 1234&gt; location ~ ^/assets/ &#123;&gt;&gt; add_header Access-Control-Allow-Origin *;&gt; &#125; HAProxy 将以下内容添加到您为 JavaScript 文件提供资源服务的后端： 1&gt; rspadd Access-Control-Allow-Origin: * 在 &lt;script 中设置 crossorigin=”anonymous” 在您的 HTML 代码中，对于您设置了Access-Control-Allow-Origin header 的每个脚本，在 script 标签上设置crossorigin =“anonymous”。在脚本标记中添加 crossorigin 属性之前，请确保验证上述 header 正确发送。 在 Firefox 中，如果存在crossorigin属性，但Access-Control-Allow-Origin头不存在，则脚本将不会执行。 5. TypeError: Object doesn’t support property这是您在调用未定义的方法时发生在 IE 中的错误。 您可以在 IE 开发者控制台中进行测试。 这相当于 Chrome 中的 “TypeError：”undefined“ is not a function” 错误。 是的，对于相同的逻辑错误，不同的浏览器可能具有不同的错误消息。 对于使用 JavaScript 命名空间的 Web 应用程序，这是一个 IE l浏览器的常见的问题。 在这种情况下，99.9％ 的原因是 IE 无法将当前名称空间内的方法绑定到 this 关键字。 例如：如果你 JS 中有一个命名空间 Rollbar 以及方法 isAwesome 。 通常，如果您在 Rollbar 命名空间内，则可以使用以下语法调用isAwesome方法： 1&gt; this.isAwesome(); Chrome，Firefox 和 Opera 会欣然接受这个语法。 另一方面 IE，不会。 因此，使用 JS 命名空间时最安全的选择是始终以实际名称空间作为前缀。 1&gt; Rollbar.isAwesome(); 6. TypeError: ‘undefined’ is not a function当您调用未定义的函数时，这是 Chrome 中产生的错误。 您可以在 Chrome 开发人员控制台和 Mozilla Firefox 开发人员控制台中进行测试。 随着 JavaScript 编码技术和设计模式在过去几年中变得越来越复杂，回调和关闭中的自引用范围也相应增加，这是这种/那种混淆的相当常见的来源。 考虑这个代码片段： 123456function testFunction() &#123; this.clearLocalStorage(); this.timer = setTimeout(function() &#123; this.clearBoard(); // what is "this"? &#125;, 0);&#125;; 执行上面的代码会导致以下错误：“Uncaught TypeError：undefined is not a function”。 你得到上述错误的原因是，当你调用setTimeout()时，实际上是调用window.setTimeout()。 因此，在窗口对象的上下文中定义了一个传递给setTimeout()的匿名函数，该函数没有clearBoard()方法。 一个传统的，旧浏览器兼容的解决方案是简单地将您的 this 保存在一个变量，然后可以由闭包继承。 例如： 1234567function testFunction () &#123; this.clearLocalStorage(); var self = this; // save reference to 'this', while it's still this! this.timer = setTimeout(function()&#123; self.clearBoard(); &#125;, 0);&#125;; 或者，在较新的浏览器中，可以使用bind()方法传递适当的引用： 1234567function testFunction () &#123; this.clearLocalStorage(); this.timer = setTimeout(this.reset.bind(this), 0); // bind to 'this'&#125;;function testFunction()&#123; this.clearBoard(); //back in the context of the right 'this'!&#125;; 7. Uncaught RangeError: Maximum call stack这是 Chrome 在一些情况下会发生的错误。 一个是当你调用一个不终止的递归函数。您可以在 Chrome 开发者控制台中进行测试。 此外，如果您将值传递给超出范围的函数，也可能会发生这种情况。 许多函数只接受其输入值的特定范围的数字。 例如：Number.toExponential(digits) 和 Number.toFixed(digits) 接受 0 到 20 的数字，Number.toPrecision(digits) 接受 1 到 21 的数字。 1234567891011var a = new Array(4294967295); //OKvar b = new Array(-1); //range errorvar num = 2.555555;document.writeln(num.toExponential(4)); //OKdocument.writeln(num.toExponential(-2)); //range error!num = 2.9999;document.writeln(num.toFixed(2)); //OKdocument.writeln(num.toFixed(25)); //range error!num = 2.3456;document.writeln(num.toPrecision(1)); //OKdocument.writeln(num.toPrecision(22)); //range error! 8. TypeError: Cannot read property ‘length’这是 Chrome 中发生的错误，因为读取未定义变量的长度属性。 您可以在 Chrome 开发者控制台中进行测试。 您通常会在数组中找到定义的长度，但是如果数组未初始化或者变量名称在另一个上下文中隐藏，则可能会遇到此错误。让我们用下面的例子来理解这个错误。 1234567var testArray = ["Test"];function testFunction(testArray) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(); 当你用参数声明一个函数时，这些参数变成了函数作用域内的本地参数。这意味着即使你函数外有名为 testArray 的变量，在一个函数中具有相同名字的参数也会被视为本地参数。 您有两种方法可以解决您的问题： 删除函数声明语句中的参数（事实上你想访问那些声明在函数之外的变量，所以你不需要函数的参数）： 12345678var testArray = ["Test"];/* Precondition: defined testArray outside of a function */function testFunction(/* No params */) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(); 用声明的数组调用该函数： 1234567var testArray = ["Test"];function testFunction(testArray) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(testArray); 9. Uncaught TypeError: Cannot set property当我们尝试访问一个未定义的变量时，它总是返回 undefined，我们不能获取或设置任何未定义的属性。 在这种情况下，应用程序将抛出 “Uncaught TypeError: Cannot set property”。 例如，在 Chrome 浏览器中： 如果测试对象不存在，错误将会抛出 “Uncaught TypeErrorUncaught TypeError: Cannot set property”。 10. ReferenceError: event is not defined 当您尝试访问未定义的变量或超出当前范围的变量时，会引发此错误。 您可以在 Chrome 浏览器中轻松测试。 如果在使用事件处理系统时遇到此错误，请确保使用传入的事件对象作为参数。像 IE 这样的旧浏览器提供了一个全局变量事件，但并不是所有浏览器都支持。像 jQuery 这样的库试图规范化这种行为。尽管如此，最好使用传入事件处理函数的函数。 123456function myFunction(event) &#123; event = event.which || event.keyCode; if(event.keyCode===13)&#123; alert(event.keyCode); &#125;&#125; 结论我们希望你学到了新的东西，可以避免将来的错误，或者本指南帮助你解决了头痛的问题。 尽管如此，即使有最佳实践，生产中也会出现意想不到的错误。能够查看影响用户的错误，并拥有快速解决问题的好工具，这一点非常重要。推荐 Rollbar。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）简介]]></title>
    <url>%2Fposts%2F5502.html</url>
    <content type="text"><![CDATA[根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。 设计模式的类型这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。 适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 过滤器模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构件语法树，定义终结符与非终结符。 关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。 迭代器模式迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。 观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 空对象模式在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。 在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 MVC 模式MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 业务代表模式业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 组合实体模式组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。 策略（Strategies） - 策略表示如何实现组合实体。 数据访问对象模式数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。 前端控制器模式前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 拦截过滤器模式拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象。 服务定位器模式服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。 缓存（Cache） - 缓存存储服务的引用，以便复用它们。 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。 传输对象模式传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 设计模式相关的网站 Wiki Page for Design Patterns) - 以一种非常通用的方式检查设计模式。 Java Programming/Design Patterns - 一篇关于设计模式的好文章。 The JavaTM Tutorials - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。 JavaTM 2 SDK, Standard Edition - JavaTM 2 SDK, Standard Edition 的官网。 Java DesignPatterns - 关于设计模式的短文。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）之一]]></title>
    <url>%2Fposts%2F13897.html</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简介设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）、抽象工厂模式（Abstract Factory Pattern）、单例模式（Singleton Pattern）、建造者模式（Builder Pattern）、原型模式（Prototype Pattern） 2 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）、桥接模式（Bridge Pattern）、过滤器模式（Filter、Criteria Pattern）、组合模式（Composite Pattern）装饰器模式、（Decorator Pattern）、外观模式（Facade Pattern）、享元模式（Flyweight Pattern）、代理模式（Proxy Pattern） 3 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）、命令模式（Command Pattern）、解释器模式（Interpreter Pattern）、迭代器模式（Iterator Pattern）、中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、观察者模式（Observer Pattern）、状态模式（State Pattern）、空对象模式（Null Object Pattern）、策略模式（Strategy Pattern）、模板模式（Template Pattern）、访问者模式（Visitor Pattern） 4 J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）、业务代表模式（Business Delegate Pattern）、组合实体模式（Composite Entity Pattern）、数据访问对象模式（Data Access Object Pattern）、前端控制器模式（Front Controller Pattern）、拦截过滤器模式（Intercepting Filter Pattern）、服务定位器模式（Service Locator Pattern）、传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 笔记： 开闭原则：实现热插拔，提高扩展性。 里氏代换原则：实现抽象的规范，实现子父类互相替换； 依赖倒转原则：针对接口编程，实现开闭原则的基础； 接口隔离原则：降低耦合度，接口单独设计，互相隔离； 迪米特法则，又称不知道原则：功能模块尽量独立； 合成复用原则：尽量使用聚合，组合，而不是继承； ​ Java就是要搞对象啊 创建型模式–&gt;对象怎么来 结构型模式–&gt;对象和谁有关 行为型模式–&gt;对象与对象在干嘛 J2EE 模式–&gt;对象合起来要干嘛（表现层,文中表示层个人感觉用的不准确）java是面向对象的语言,所以要搞好对象,模式（套路）就是用来更加好的搞对象滴。 工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现 Hibernate 换数据库只需换方言和驱动就可以。 优点： 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1创建一个接口。 Shape.java 12345package com.test;public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 Rectangle.java 12345678package com.test;public class Rectangle implements Shape &#123; public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java 12345678package com.test;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; Square.java 12345678package com.test;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。 ShapeFactory.java 1234567891011121314151617package com.test;public class ShapeFactory &#123; public Shape getShape(String shapeType)&#123; if (shapeType==null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125;else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125;else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。 FactoryPatternDemo.java 12345678910111213141516171819package com.test;public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); // 获取 CIRCLE 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); // 调用 Circle 的 draw 方法 shape1.draw(); // 获取 rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); // 调用 rectangle 的 draw 方法 shape2.draw(); // 获取 square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); // 调用 square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤 5验证输出。 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 笔记: 使用反射机制可以解决每次增加一个产品时，都需要增加一个对象实现工厂的缺点 1234567891011121314151617public class ShapeFactory &#123; public static Object getClass(Class&lt;?extends Shape&gt; clazz) &#123; Object obj = null; try &#123; obj = Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 使用的使用采用强制转换 1234Rectangle rect = (Rectangle) ShapeFactory.getClass(Rectangle.class);rect.draw();Square square = (Square) ShapeFactory.getClass(Square.class);square.draw(); 这样就只需要一个对象实现工厂 ​ 1234567891011121314151617public class ShapeFactory &#123; public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) &#123; T obj = null; try &#123; obj = (T) Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 省略类型强制转换，支持多态 12345Rectangle rect = ShapeFactory.getClass(Rectangle.class);rect.draw();Shape square = ShapeFactory.getClass(Square.class);square.draw(); 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： QQ 换皮肤，一整套一起换。 生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1为形状创建一个接口。 Shape.java 123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 Rectangle.java 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3为颜色创建一个接口。 Color.java 123public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类。 Red.java 1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125; Green.java 1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125; Blue.java 1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125; 步骤 5为 Color 和 Shape 对象创建抽象类来获取工厂。 AbstractFactory.java 1234public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape);&#125; 步骤 6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 ShapeFactory.java 12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; return null; &#125; @Override Shape getShape(String shapeType) &#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125; &#125; ColorFactory.java 1234567891011121314151617181920212223public class ColorFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; if (color == null) &#123; return null; &#125; if (color.equalsIgnoreCase("RED")) &#123; return new Red(); &#125; else if (color.equalsIgnoreCase("GREEN")) &#123; return new Green(); &#125; else if (color.equalsIgnoreCase("BLUE")) &#123; return new Blue(); &#125; return null; &#125; @Override Shape getShape(String shapeType) &#123; return null; &#125;&#125; 步骤 7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 FactoryProducer.java 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if (choice.equalsIgnoreCase("SHAPE")) &#123; return new ShapeFactory(); &#125;else if (choice.equalsIgnoreCase("COLOR")) &#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤 8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。 AbstractFactoryPatternDemo.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor("Green"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor("BLUE"); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 步骤 9验证输出。 123456Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method. 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 一个党只能有一个主席。 Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2. 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1创建一个 Singleton 类。 SingleObject.java 1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 关于对象的实例化 大家想到的通常是直接new，除了这个，还有些单实例模式，层次间调用等等 getInstance的使用: 在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。 getInstance 和 new的区别；大部分类都可以用new，new就是通过生产一个新的实例对象，或者在栈上声明一个对象，每部分的调用都是用的一个新的对象 getInstance在单例模式(保证一个类仅有一个实例，并提供一个访问它的全局访问点)的类中常见，用来生成唯一的实例，getInstance往往是static的。 1234567891011121314&gt; public abstract class TestInstance &#123; &gt; static int i = 1; &gt; public static TestInstance getInstance() &#123; &gt; System.out.println(i++); &gt; return null; &gt; &#125; &gt; &#125; &gt; public class TestGetInstance &#123; &gt; public static void main(String[] args) &#123; &gt; TestInstance ins1 = TestInstance.getInstance(); &gt; TestInstance ins2 = TestInstance.getInstance(); &gt; &#125; &gt; &#125; &gt; &gt; 使用实例，在定义的新类当中加入getInstance()方法，返回值即为该类的一个对象，此方法常常应用在Java的单例模式当中 12345678&gt; public class OAuthConstant &#123; &gt; public static synchronized OAuthConstant getInstance()&#123; &gt; if(instance == null) &gt; instance = new OAuthConstant(); &gt; return instance; &gt; &#125; &gt; &#125;&gt; &gt; //主函数当中使用此类的getInstance()函数，即可得到系统当前已经实例化的该类对象，若当前系统还没有实例化过这个类的对象，则调用此类的构造函数 //实例化一个对象，并返回 OAuthConstant.getInstance(); 对象使用之前通过getInstance得到而不需要自己定义，用完之后不需要delete； new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new； new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是创建static静态实例方法的。 对于抽象类，是只能用getInstance()方法,是不能new出来的， 总结： getInstance这个方法在单例模式用的甚多，为了避免对内存造成浪费，直到需要实例化该类的时候才将其实例化，所以用getInstance来获取该对象，至于其他时候，也就是为了简便而已，为了不让程序在实例化对象的时候，不用每次都用new关键字，索性提供一个instance方法，不必一执行这个类就初始化，这样做到不浪费系统资源！单例模式 可以防止 数据的冲突，节省内存空间。 步骤 2从 singleton 类获取唯一的对象。 SingletonPatternDemo.java 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 步骤 3验证输出。 1Hello World! 单例模式的几种实现方式单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 代码实例： 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 代码实例： 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 代码实例： 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 代码实例： 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、登记式/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 代码实例： 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 6、枚举JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 代码实例： 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 介绍意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 JAVA 中的 StringBuilder。 优点： 建造者独立，易扩展。 便于控制细节风险。 缺点： 产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。 使用场景： 需要生成的对象具有复杂的内部结构。 需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 步骤 1创建一个表示食物条目和食物包装的接口。 Item.java 12345public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125; Packing.java 123public interface Packing &#123; public String pack();&#125; 步骤 2创建实现 Packing 接口的实体类。 Wrapper.java 1234567public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "Wrapper"; &#125;&#125; Bottle.java 1234567public class Bottle implements Packing &#123; @Override public String pack() &#123; return "Bottle"; &#125;&#125; 步骤 3创建实现 Item 接口的抽象类，该类提供了默认的功能。 Burger.java 12345678910public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125; ColdDrink.java 12345678910public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 步骤 4创建扩展了 Burger 和 ColdDrink 的实体类。 VegBurger.java 123456789101112public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return "Veg Burger"; &#125;&#125; ChickenBurger.java 123456789101112public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return "Chicken Burger"; &#125;&#125; Coke.java 123456789101112public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return "Coke"; &#125;&#125; Pepsi.java 123456789101112public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return "Pepsi"; &#125;&#125; 步骤 5创建一个 Meal 类，带有上面定义的 Item 对象。 Meal.java 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125; &#125; 步骤 6创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 MealBuilder.java 12345678910111213141516public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 步骤 7BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。 BuilderPatternDemo.java 123456789101112131415public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); System.out.println("Total Cost: " +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); System.out.println("Total Cost: " +nonVegMeal.getCost()); &#125;&#125; 步骤 8验证输出。 12345678910Veg MealItem : Veg Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost: 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.5Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost: 85.5]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）导学]]></title>
    <url>%2Fposts%2F56017.html</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 基础知识 设计模式概述 从招式与内功谈起——设计模式概述（一）：设计模式从何而来？ 从招式与内功谈起——设计模式概述（二）：设计模式是什么？ 从招式与内功谈起——设计模式概述（三）：设计模式有什么用？附：个人观点 面向对象设计原则 面向对象设计原则概述 面向对象设计原则之单一职责原则 面向对象设计原则之开闭原则 面向对象设计原则之里氏代换原则 面向对象设计原则之依赖倒转原则 面向对象设计原则之接口隔离原则 面向对象设计原则之合成复用原则 面向对象设计原则之迪米特法则 六个创建型模式 简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 工厂三兄弟之简单工厂模式（一）：图表库的设计 工厂三兄弟之简单工厂模式（二）：简单工厂模式概述 工厂三兄弟之简单工厂模式（三）：图表库的简单工厂模式解决方案 工厂三兄弟之简单工厂模式（四）：图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结 工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 工厂三兄弟之工厂方法模式（一）：日志记录器的设计 工厂三兄弟之工厂方法模式（二）：工厂方法模式概述 工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件 工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结 抽象工厂模式-Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】 工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计 工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族 工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述 工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案 工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结 单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述 确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现 确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论 确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类） 确保对象的唯一性——单例模式 （五）：单例模式总结 原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述 对象的克隆——原型模式（二）：工作周报的原型模式解决方案 对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】 对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结 建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 复杂对象的组装与创建——建造者模式（一）：游戏角色设计，建造者模式概述 复杂对象的组装与创建——建造者模式（二）：游戏角色设计的建造者模式解决方案 复杂对象的组装与创建——建造者模式（三）：关于Director的进一步讨论，建造者模式总结 七个结构型模式 适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述 不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案 不兼容结构的协调——适配器模式（三）：类适配器，双向适配器 不兼容结构的协调——适配器模式（四）：缺省适配器，适配器模式总结 桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：**★★★☆☆**】 处理多维度变化——桥接模式（一）：跨平台图像浏览系统 处理多维度变化——桥接模式（二）：桥接模式概述 处理多维度变化——桥接模式（三）：跨平台图像浏览系统的桥接模式解决方案 处理多维度变化——桥接模式（四）：适配器模式与桥接模式的联用，桥接模式总结 组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 树形结构的处理——组合模式（一）：设计杀毒软件的框架结构 树形结构的处理——组合模式（二）：组合模式概述 树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案 树形结构的处理——组合模式（四）：透明组合模式与安全组合模式 树形结构的处理——组合模式（五）：公司组织结构，组合模式总结 装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 扩展系统功能——装饰模式（一）：图形界面构件库的设计 扩展系统功能——装饰模式（二）：装饰模式概述 扩展系统功能——装饰模式（三）：图形界面构件库的装饰模式解决方案 扩展系统功能——装饰模式（四）：透明装饰模式与半透明装饰模式，装饰模式注意事项，装饰模式总结 外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 深入浅出外观模式（一）：外观模式概述，外观模式结构与实现 深入浅出外观模式（二）：外观模式应用实例（文件加密模块） 深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景 享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 实现对象的复用——享元模式（一）：围棋棋子的设计，享元模式概述（上） 实现对象的复用——享元模式（二）：享元模式概述（下） 实现对象的复用——享元模式（三）：围棋棋子的享元模式解决方案 实现对象的复用——享元模式（四）：带外部状态的围棋棋子解决方案 实现对象的复用——享元模式（五）：单纯享元模式和复合享元模式，关于享元模式的几点补充，享元模式总结 代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 代理模式（一）：代理模式概述，代理模式结构与实现 代理模式（二）：代理模式应用实例（收费商务信息查询系统） 代理模式（三）：远程代理，虚拟代理，缓冲代理 代理模式（四）：代理模式效果与适用场景 十一个行为型模式 职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 请求的链式处理——职责链模式（一）：采购单的分级审批 请求的链式处理——职责链模式（二）：职责链模式概述 请求的链式处理——职责链模式（三）：采购单分级审批的职责链模式解决方案 请求的链式处理——职责链模式（四）：纯与不纯的职责链模式，职责链模式总结 命令模式-Command Pattern【学习难度：★★★☆☆**，使用频率：★★★★☆】** 请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述 请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案 请求发送者与接收者解耦——命令模式（三）：命令队列的实现 请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现 请求发送者与接收者解耦——命令模式（五）：请求日志 请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结 解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 自定义语言的实现——解释器模式（一）：机器人控制程序 自定义语言的实现——解释器模式（二）：文法规则和抽象语法树 自定义语言的实现——解释器模式（三）：解释器模式概述 自定义语言的实现——解释器模式（四）：机器人控制程序的解释器模式解决方案 自定义语言的实现——解释器模式（五）：再谈Context的作用 自定义语言的实现——解释器模式（六）：解释器模式总结 迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历 遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述 遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案 遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器 遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用 遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结 中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 协调多个对象之间的交互——中介者模式（一）：客户信息管理窗口的初始设计 协调多个对象之间的交互——中介者模式（二）：中介者模式概述 协调多个对象之间的交互——中介者模式（三）：客户信息管理窗口的中介者模式解决方案 协调多个对象之间的交互——中介者模式（四）：中介者与同事类的扩展 协调多个对象之间的交互——中介者模式（五）：中介者模式总结 备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】 撤销功能的实现——备忘录模式（一）：可悔棋的中国象棋 撤销功能的实现——备忘录模式（二）：备忘录模式概述 撤销功能的实现——备忘录模式（三）：中国象棋的备忘录模式解决方案 撤销功能的实现——备忘录模式（四）：实现多次撤销 撤销功能的实现——备忘录模式（五）：再谈备忘录的封装，备忘录模式总结 观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 对象间的联动——观察者模式（一）：多人联机对战游戏的设计 对象间的联动——观察者模式（二）：观察者模式概述 对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案 对象间的联动——观察者模式（四）：JDK对观察者模式的支持 对象间的联动——观察者模式（五）：观察者模式与Java事件处理 对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结 状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计 处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述 处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案 处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现 处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换 处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结 策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 算法的封装与切换——策略模式（一）：电影票打折方案 算法的封装与切换——策略模式（二）：策略模式概述 算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案 算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结 模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现 模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块） 模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景 访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 操作复杂对象结构——访问者模式（一）：OA系统中员工数据汇总 操作复杂对象结构——访问者模式（二）：访问者模式概述 操作复杂对象结构——访问者模式（三）：OA系统中员工数据汇总的访问者模式解决方案 操作复杂对象结构——访问者模式（四）：访问者模式与组合模式联用，访问者模式总结 设计模式趣味学习（复习） 设计模式与足球（一）：创建型模式 设计模式与足球（二）：结构型模式 设计模式与足球（三）：行为型模式（上） 设计模式与足球（四）：行为型模式（下） 设计模式综合应用实例 多人联机射击游戏 多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式 多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式 数据库同步系统 设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式 设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式 设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式 【作者：刘伟 http://blog.csdn.net/lovelion】]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品设计-产品架构和业务逻辑]]></title>
    <url>%2Fposts%2F36961.html</url>
    <content type="text"><![CDATA[在分析产品的时候，快速理解产品架构；产品细节设计时，能围绕核心业务逻辑展开；能独立开始搭建产品架构和业务逻辑 目标 在分析产品的时候，快速理解产品架构 产品细节设计时，能围绕核心业务逻辑展开 能独立开始搭建产品架构和业务逻辑 1.了解产品架构、业务逻辑和业务流程1.1 如何理解流程化产品设计 设计产品，就是设计流程 流程不是独立存在的，而是在一个整体体系下发生的 体系=产品架构+业务逻辑+业务流程 Fig 1.1 流程.png 1.1.1产品架构=设计图=目标 未来一段时间你希望完成的蓝图 1.1.2业务逻辑=框架设计图=功能模块 用户要解决问题需要走过的路径 不同的模块之间的关联性 1.1.3业务流程=施工图=实施方法如： 注册流程图 下单流程图 支付流程图 小结：做产品如盖楼，不断逐级解构，剥橘子般一片片分离的过程 2.搭建产品架构2.1为什么做产品要先理解产品架构 深入了解一个产品的运作逻辑 看产品的时候，不再只看界面与交互，而是背后的逻辑 指导产品设计和运营 进可观星：评估产品的生命力 退可照妖：识别忽悠型产品 2.1.1 为什么做产品要先理解产品架构？ Fig 1.2三节课官网产品架构.png 2.1.2 从产品的角度理解产品 Fig 1.3 17APP产品架构.png 2.1.3 识别忽悠型产品2.2 产品架构的关键点是什么？ 最关注人、信息、渠道和流转过程 内容从哪里来，到哪里去 用户从哪里来，到哪里去 Fig 1.4 关键点.png 2.3 有哪些人（角色）参与产品 分别有哪些人先后会做什么动作？ 不同的角色，会做什么事？ 人和人之间的关系是什么？ 2.4 会产生什么信息？ 有哪些信息产生 信息由谁产生的？ 信息与信息之间的关系是什么？ Fig 1.6 信息与信息之间的关系.png 2.5 流转过程与渠道 Fig 1.7 流程过程与渠道.png 小结：产品架构可以调研相关产品获得，如果已经被市场验证的，没必要搞独创。 3.搭建产品业务逻辑3.1为什么要理解业务逻辑？ 业务逻辑是功能模块设计，关键功能与参与者流程 业务逻辑有助于统一各参与者的角色与分工 有助于产品业务流程的设计 Fig 1.8 业务逻辑.png Fig 1.9 三节课官网开课业务逻辑.png 3.3 如何开始业务逻辑设计？ 有哪些功能模块 有哪些页面 不同模块之间是如何关联的 Fig 1.10过程.png 3.4 以内容为主线、明确数据流向 关键数据是什么？ 数据从哪里来？到哪里去？需要经过哪些系统？ 3.5 以用户为主线，明确行为 重要的角色是什么？辅助的角色是什么？ 不同的角色的行为分别是什么？ 用户从哪里来，到哪里去？会经过哪些系统，用到哪些功能？ 3.6 以渠道（终端）为界面，区分类型 有哪些渠道（终端）？ 这些终端是如何展现内容的？ 用户在不同终端的操作行为有哪些不同？ 3.7 把以上模块串联起来 用户、系统、终端等之间是如何关联的？ 先通顺再细化 先能用再美化 小结：业务逻辑是指导产品经理的工作方向的，明确需求解决什么环节的问题。 4.设计产品业务流程图4.1业务流程图关注后续《业务流程设计》的课程 4.2 产品架构、业务逻辑、业务流程 Fig 1.11 三种图.png 小结：业务流程是业务逻辑中模块的细化，是每个需求文档中必备的内容 总结： 1.如何理解产品架构、业务逻辑和业务流程 产品架构-&gt;业务逻辑-&gt;业务流程 2.如何开展搭建产品架构 以用户为中心，人与人，人与信息，信息与信息之间的关系 3.如何开始搭建业务逻辑 内容主线-&gt;用户主线-&gt;终端-&gt;关联起来]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说软件产品和业务、业务过程(流程)、业务逻辑]]></title>
    <url>%2Fposts%2F16499.html</url>
    <content type="text"><![CDATA[作为一名程序猿，需要懂产品，不懂产品的程序猿不是好程序猿猴。而业务逻辑是软件产品的支柱，所以，要懂产品，就必须懂业务逻辑。 介绍业务逻辑之前，先介绍下相关的一些概念。 什么叫业务？从企业的角度来讲，业务是企业运用科学方法和生产工艺生产出可交付用户使用的产品与服务，并以此为企业带来利益的行为。 举例： 对服装企业来说，业务一般是生产服装；对银行企业来说，业务可以是办理贷款；对软件公司来说，业务可以是开发某种类型的软件，比如开发防火墙软件；对医院来说，业务可以是提供医疗服务。 什么叫业务过程？“业务流程”和“业务过程”是两个经常出现的词，含义相似，但有轻微区别，这里暂且不做区分，都统一叫做业务过程。 1）业务过程开始于客户需求，终止于客户需求的满足，为客户创造价值。 2）业务过程是为了产生产品或服务而设计的一系列步骤，一些过程的结果可能是由组织外的客户所接受的产品或服务，称为主要过程；另一些过程的产出不为外部客户所见，但是有效管理所必须的，称为支持过程。 举例： 业务过程，对于服装工厂来说，可以是产出可穿戴衣物的一系列活动；对医院来说，可以是提供医疗服务的一系列活动；对软件公司来说，可以是开发出满足客户需求的软件产品的一系列活动。 软件产品和业务过程 软件产品具有它的特殊性，通常情况下，企业提供的软件产品、服务，主要用于外部组织、用户实现其业务过程。 举例： 假设有两家公司,A公司和B公司。A公司的业务是提供医疗服务；B公司是开发医疗相关的软件。A公司找到B公司说，我需要你们帮忙开发一个系统，实现XXX功能。这时，B公司考虑的不仅是自己的业务过程：产品，设计，测试，开发，运维等怎么配合去做这件事情，而且还要考虑A公司的业务过程：病人挂号，就诊，住院，缴费结算等等。 什么是业务逻辑？业务逻辑是系统架构中体现核心价值的部分，典型的三层结构模型中（如下图），介于表现层和数据访问层之间。 通俗的讲，业务逻辑就是个“怎么做”的问题，是产品的灵魂，它的关注点主要集中在业务流程的实现，业务规则的定制等与业务过程相关的。 细说业务逻辑 业务实体 业务实体完整性约束 业务流程(业务过程) 业务规则 业务实体关键业务相关的动态的概念性对象 比如，电商企业，业务过程中的买家，商品，就是业务实体，软件实现过程中先将其抽象为概念模型(通常用E-R图表示)，然后对其建立结构模型，展现在计算机世界中，可能表现为买家表中或商品表中的一条表记录。 实体业务完整性约束（Validation）业务实体完整性约束简单说就是对业务实体的约束，比如对商品实体，商品编号必须唯一 注：关于业务实体和业务实体完整性约束，可以看下数据库的相关资料，理解会比较深刻一点 业务流程(业务过程)如果把产品比作一个人，那么这个业务过程就是产品的骨架。产品只有实现了这个流程，用户才能用它来实现业务。 例子：购物网站为例子 购买者登录网站 -&gt; 浏览商品 -&gt;下单 -&gt; 结算 -&gt; 确认收货 -&gt; 评价 例：以学校申请助学金为例子 学生登陆终端 -&gt; 提交申请 -&gt; 班主任审批 -&gt; 分院负责人审批 -&gt; 学工处审批 -&gt; 资领处审批 业务规则定义1：业务规则是与特定行业中的特定业务功能有关的决策逻辑的表示形式 定义2：业务规则是对业务的某些方面进行定义和约束的声明 例1：以学校申请助学金为例子 “申请助学金的学生必须是贫困生”，这便是一条业务规则，对申请助学金的做了一个前提申明。 那又为何说是决策逻辑呢？程序中，实现经常会这样： if 学生 is not 平困生 then 拒绝申请 例2：以购物网站为例子 未登录顾客点击购买商品时，提示先登录 例3：以购物网站为例子 买家下单后，通知卖家商品被拍下。 从上面的例子可以看出，业务规则它不会告诉你怎么做，仅是“决策”，告诉你要做什么，而不会告诉你怎么做。比如，上面的贫困生的例子，它不会告诉你怎么申请贫困生，但是会告诉你要去申请贫困生，再如，上面购物网站的例子，它约定说要去通知卖家，但是不会告诉你怎么通知卖家(通过邮件、电话、短信还是其它？？) 小知识点：一般做系统，都避免不了数据验证，完整性约束是业务逻辑的一部分，按理应该放在业务层。但是实际不然，不提倡在“表示层的服务端”放置过多完整性验证。因为，表示层的职责应该仅仅是接收数据并传递给业务层，不应对数据是否合法负责。过多的数据验证，不但令表示层代码臃肿，而且使得表示层职责变得不明确。 可以在“表示层的服务端”放置一些简单的验证，如空值验证，两次输入密码是否一致等，但业务关系紧密的验证，最好放在业务层，甚至有些验证只能在业务层验证，如“当前用户名不能与已有用户名重复”，这种验证需要访问持久化数据，需要由业务层完成。 这里之所以强调“表示层的服务端”，是因为一般在B/S系统中，都会在JavaScript里加入一些基本的数据验证，如空值检查，格式正则匹配 等。这主要是为了减轻服务器负担，将大多数显然包含不合法数据的请求拒绝掉，而不发给服务端验证。当然，因为可能会出现JS被屏蔽或黑客恶意攻击行为，所以，所有验证不论JS中是否验证过，服务端（可能是表示层的服务端部分或业务层）一定要再进行验证。 难题：什么是业务逻辑？业务是指一个实体单元向另一个实体单元提供的服务。逻辑是指根据已有的信息推出合理的结论的规律。 业务逻辑是指一个实体单元为了向另一个实体单元提供服务，应该具备的规则与流程。 就像你家的规矩–“吃饭前必须洗手”“有客人来要起立”“睡觉前各自说晚安”-就是业务逻辑的生活化实例。 软件系统架构一般分为三个层次表示层、业务逻辑层和数据访问层： 表示层：负责界面和交互； 业务逻辑层：负责定义业务逻辑（规则、工作流、数据完整性等），接收来自表示层的数据请求，逻辑判断后，向数据访问层提交请求，并传递数据访问结果，业务逻辑层实际上是一个中间件，起着承上启下的重要作用； 数据访问层：负责数据读取。 业务逻辑的内容包括四部分 领域实体：定义了业务中的对象，对象有属性和行为； 业务规则：定义了需要完成一个动作，必须满足的条件； 数据完整性：某些数据不可少； 工作流：定义了领域实体之间的交互关系。 以大毛网购裤子为例 领域实体：大毛、资金账户、订单、裤子、发货单 业务规则：大毛点击购买就会生成订单，但必须付了钱，才会发货，生成发货单。 数据完整性：淘宝网下订单必须登录账号，没有账号就不能成功购买。 工作流：搜索裤子-找到合意裤子-下单购买-付账-收货。 业务逻辑：搜索“裤子”-找到合意裤子-下单-必须登录账号-结算-付账-收货。 当当必须登录账号才能下单成功，亚马逊就不需要，今天发现淘宝也不需要登录账号就能购买商品了，所以每个网站的规则的不同，就形成了不同的业务逻辑，业务逻辑不仅仅包括规则，还包括实体、数据完整性、工作流。如图： 业务逻辑图：业务逻辑也需要画图，叫做业务逻辑图，它跟业务流程图有什么区别呢？ 业务流（工作流）是业务逻辑的一部分，它定义了对象之间的交互关系，但不涉及到规则的制定，数据的完整性方面。其实，我们平常画的业务流程图多数是业务逻辑图。 表示层 分层是为了实现“高内聚，低耦合”。采用“分而治之”的思想，把问题划分开来各个解决，易于控制，延展和分配资源。 所谓的三层开发就是将系统的整个业务应用划分为表示层，业务逻辑层和数据访问层，这样有利于系统的开发、维护、部署和扩展。 分层是为了实现“高内聚，低耦合”。采用“分而治之”的思想，把问题划分开来各个解决，易于控制，延展和分配资源。 业务逻辑层负责系统领域业务的处理，负责逻辑性数据的生成、处理及转换。对所输入的逻辑性数据的正确性及有效性负责，但对输出的逻辑性数 据及用户性数据的正确性不负责，对数据的呈现样式不负责。 JavaEE三层架构MVC，把视图控制器模型分开来 那么在这里业务逻辑就是M。 但是什么样的算是业务逻辑如：上传一个文件，上传代码算是一个业务逻辑吗？ 数据库操作增加时需要判断，和一些其它这算业务逻辑吗？（我觉得算） 但是hibernate又提供了一个离线查询对象（DetachedCriter），提供这个接口的意思我想是在外面处理业务逻辑。 但是三层架构不是独立的吗？互相不干涉吗？在service层出现sql，hql，criter不是又把dao与service连在一起了吗？ DTO（VO），POJO，BO这些是什么，POJO对应数据库，BO对应业务逻辑，DTO对应页面的传输与显示。 业务逻辑就是处理数据的逻辑啦。 后台代码分三层 action(controller) service DAO （这里的三层不是MVC） 比如 我得到用户名 但是在存入数据库的时候 用户名字段应该是前台的用户名加上当前日期拼成的字符串 action或者controller层是第一层 一般是用来及接受数据并且做数据的非空啊 格式是否正确的验证 如用户名是否为空 是不是安全字符串之类的 service层一般是用来做一个业务逻辑的实现 这时候 userName = userName + new Date(); DAO层 就是与数据库交互层 也就是读写数据库 将逻辑层得到的新的userName插入到数据库 MVC和三层架构并没有可比性 三层架构是指将程序分为数据访问、业务处理、界面三个层次，是软件整体架构 MVC是仅仅是界面架构，也就是它其实只是三层架构的界面部分 M是指实体模型或者实体模型的一个代理，而非领域模型 C是指控制器，仅仅是做转向，不应该包含任何业务逻辑 V就是视图 至于那些个什么什么O，都是实体在不同层的映射。另外值得一提的是，MVC在一些小的程序中也经常被当做软件整体架构，那个时候M往往就是实体模型了，但是这种时候，V就对M产生了直接引用，也就是界面对实体产生依赖，这是很不好的（但小程序问题不大），此时可以尝试使用MVP模式解耦。至于业务，看你怎么定义领域模型了，一般像上传文件这种操作并不会牵扯企业的业务，那就不应该当做一个业务，但如果这个上传是在工作流或者一些特殊处理中，则有可能上升到业务。怎么做，要看具体问题。]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计规范]]></title>
    <url>%2Fposts%2F13930.html</url>
    <content type="text"><![CDATA[数据库设计规范 1 基本原则Ø 产品根据业务功能的不同，划分为多个相对独立的业务子系统。对应于一个业务子系统，数据库中都应建立一个用户，该业务子系统中的数据、业务规则都在此用户下的对象中描述。如：数据库中建立MES用户，来对应制造执行系统，制造执行系统中的数据、业务逻辑都由MES用户下的对象（如表、包及存储过程等等）来描述，系统管理由APPSYS用户来管理； Ø 除两个公共用户APPS，APPVIEW外，其他用户下的所有对象，都需要在APPS中建立同义词，并对APPS授权； Ø 除两个公共用户APPS，APPVIEW外，其他用户下的所有的视图， 都需要在APPVIEW中建立对应的表； Ø 系统管理部分的表，需用设置多语言； 2 表及字段规范2.1 表命名约定数据库中以描述表中内容的英文为表名，前面以该表所属的用户+下划线作为开头，具体遵循以下规则： 用户 + ‘_’+ 英文，如MDS_Route表示MDS用户下的工艺路线表， 英文如果是两个单词及以上，单词之间尽量用下划线分割。如果英文有公共熟知的缩写，可以使用缩写。如MES_Control_Dept表示MES用户下的受控部门表 2.2 表字段约定 每个表中必须包含7个字段： 字段名称及作用 字段代码 类型 表ID，作为表主键 ID Number(16,0) 创建人 CREATED_BY Number(16,0) 创建时间 CREATION_DATE Date 最后修改人 LAST_UPDATED_BY Number(16,0) 最后修改时间 LAST_UPDATE_DATE Date 最后更新IP LAST_UPDATE_IP VARCHAR2(20) 版本 VERSION Number(16,0) 主键字段：每个表必须以ID作为主键，通过建立UniqueKey来实现实际的主键组合。如部门表中，将部门代码建立为Unique Key 外键字段：系统不显式建立外键，表中的字段如果需要引用其他表的主键，尽量以其他表的表名+ ‘_ID’作为此字段名，并在注释中显式说明，如：员工表中引用部门表的主键的字段，命名为HR_Dept_ID；如果表中有两个及以上的字段需要引用同一个表的主键，需要在此规则的基础上，前面添加用途，如两个字段都引用部门表主键，制造部门命名为：Manufact_HR_Dept_ID，使用部门命名为：User_HR_Dept_ID。 字段注释：每个字段必须有注释，说明该字段的含义，值的来源。对于标识，状态之类的字段，必须注明其每个可能的取值，及每个取值的含义。如对于标识字段，注释需要标明：Y-是，N-否，说明此字段的取值为Y和N，含义分别为是和否。 字段数据类型：对于标识，状态字段，一般取值为一个字符（Varchar2(1)），如果状态较多，可以设置为2个字符（Varchar2(2)）；对于数量等字段，设置为数值（Number(20，7)）；对于代码、名称、说明、描述的字段，一般为Varchar2，字符的多少可根据需要设置。 字段取值：对于涉及到是和否的标识字段，取值必须为Y/N，但 “是否显示”字段除外，其取值为0/1；对于状态字段，一般取值为0，1，2……,对应不同的状态。 3 序列规范每个表都必须有一个主键序列，作为主键ID的值. 命名：表名 + ‘_S’， 如：MDS_Route_S; 取值：初始值，最小值，步长均为1，最大值为999999999 在后来的数据库设计中，不再需要为每个表创建一个序列，用以产生主键ID。表主键的数据类型变为Varchar2(32)，用Oracle函数SYS_GUID()产生，具体方法如下： Select SYS_GUID() into v_tableId from dual; 4 包及存储过程规范对于业务系统的逻辑处理，需要建立包及存储过程来实现。如果多个存储过程实现同一业务，尽量封装在包中。 包的命名：与表的命名规则类似，但需要以’ _P’结尾，如：MES_Route_P 存储过程命名规范：命名尽量表示此存储过程功能； 存储过程参数规范：最后两个参数必须为返回值，并遵循以下约定： 倒数第二个参数为Number，表示执行的结果，成功/失败等等 ，其取值为Codecollection里的Success/Fail/Warn 倒数第一个参数为Varchar2, 表示执行中出现的错误或警告信息 传入的参数中如果需要有日期或时间，需要设置为字符串 存储过程中必须包含的处理： 如果传入的参数中如日期或时间字符串，必须进行转换的异常处理，转换时，使用Codecollection里的Date_Format_Date/Date_Format_Datetime来进行时间格式设置 插入数据时，7个必须的字段必须赋值，其中主键使用相应的序列取值，Version设为1，涉及到人员的，使用Get_Session_Info里的Get_User_Id，涉及到时间的，使用当前系统时间，IP使用Get_Session_Info里的Get_Logon_Ip 更新数据时，最后修改人，最后修改时间，最后更新IP，版本 必须更新，取值同样来源于Get_Session_Info，Version 增1 异常处理：如果执行成功，返回值中Return_Int 设为Codecollection里的 Success 如果捕捉到异常，需要返回Codecollection里的Fail/Warn，并设置Return_String的内容 需要读取配置文件中的设置时，使用Sys_Profile_Option_p的Get_Profile_Option_Value方法，来取得值。如：末工序的最大号 存储过程的参数、变量命名规范 传入参数：命名以 i_开头，譬如i_Sys_Function_Tl_Id，具体参照appsys用户下sys_form_p包中的存储过程Delete_Form_Tl_Id的定义， PROCEDUREDelete_Form_Tl_Id(i_Sys_Form_Tl_Id VARCHAR2,o_Return_Int OUT INT,o_Return_String OUT VARCHAR2); 返回值：命名以o_开头，目前只支持两个返回值，o_Return_Int和o_Return_String，分别表示执行的结果及消息； 变量：命名以v_开头，如果变量是用来存储数据库表中某列的数值，其数据类型一般会采取tableName.columnName%TYPE的定义方式，如v_Sys_Function_IdSys_Function.Id%TYPE; 存储过程及函数的注释 对存储过程和函数的注释主要包括功能描述、编写人、编写日期信息，一般写在包体中存储过程或函数的名称前面。如appsys用户下sys_form_p包中的存储过程Delete_Form_Tl_Id： /* 功能描述:级联删除form_with_tl信息 编写人：刘岩 编写日期: 2008-04-22 */ PROCEDURE Delete_Form_Tl_Id(i_Sys_Form_Tl_IdVARCHAR2, ​ o_Return_Int OUT INT, ​ o_Return_String OUT VARCHAR2) IS ​ v_Sys_Form_Id Sys_Form.Id%TYPE; BEGIN ​ SELECT Sys_Form_Id ​ INTO v_Sys_Form_Id ​ FROM Sys_Form_Tl ​ WHERE Id = i_Sys_Form_Tl_Id; ​ Delete_Form(v_Sys_Form_Id, o_Return_Int,o_Return_String); EXCEPTION ​ WHEN OTHERS THEN ​ o_Return_Int := Codecollection.Fail; ​ o_Return_String := ‘删除表单失败：’ || SQLERRM; END Delete_Form_Tl_Id; 5 视图规范每个表必须建立视图，命名规范为： 如果没有多语言，则视图名为：表名 + ‘_V’ 如果有多语言，则视图名为：表名 + ‘_VL’ 如果在视图的基础上再建立视图，命名规范为：视图名 +‘V’ 如果视图带数据权限，则视图名为：表名 + ‘_VS’ 6 常用包及用途APPSYS.Codecollection:常量设置 APPSYS.Sys_Profile_Option_p:读取配置文件 APPSYS.Get_Session_Info:获取当前用户信息 APPS.Gen_Appview：根据视图在APPVIEW中建立表 APPS.Sys_Auto_Code_p：管理编码 APPS.Sys_Util_p：将字符串表示的计算式格式化，计算值]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程文档汇编]]></title>
    <url>%2Fposts%2F54252.html</url>
    <content type="text"><![CDATA[实用软件工程文档汇编 1《立项建议书》《立项建议书》编写参考指南 1．引言（Introduction） 1.1 目的（Purpose） 本文档是软件立项书，目的是代替可行性分析。 1.2 范围（Scope） 本文档只适应于软件立项。 1.3 术语定义（Terms Glossary） 对软件组织内部和外部有关的行业术语、专用名词进行定义。 [1] …… [2] …… 1.4 参考资料（References） 对书写该立项书所用到的有关资料进行说明。 [1] …… [2] …… 1.5 相关文档（Related Documents） 当该文档变更时，可能对其他文档产生影响，受影响的文档叫做相关文档，需将它们一一列出。 [1] …… [2] …… 1.6 版本更新记录（Version Updated Record） 任何一次版本创建或维护更新，都要追加一条记录。一个版本创建只有一次，但对它的维护更新可能有多次。大版本升级一次，定义为创建一次，如V1.0到V2.0。而V1.0到V1.1，只是维护更新一次。版本更新记录格式，如表3-2所示。 表3-2 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/01/03 — — — V1.0.1 — — 王小林 2001/02/10 网络版功能维护 2．项目概述及架构（Project Summary and Framework） 2.1 项目概述（Project Summary） 宏观上说明该项目是什么、能干什么、要求干得怎么样。 2.2 项目架构（Project Framework） 宏观上描述该项目的架构：单机结构、C/S结构、B/S结构。并说明结构具体详细的运行平台：硬件的要求、操作系统的要求、数据库管理系统的要求、对外接口的要求。 3．客户群分析（Client Analysis） 3.1 客户群定位（Client Orientation） 单机结构、C/S结构、B/S结构对应哪三种客户群，每种客户群的数量、素质、市场前景等。 3.2 当前客户群分析（Current Client Analysis） 当前客户群是指已签订合作协议或将要签订合作协议的客户群，分析他们的数量、素质、市场前景等。 3.3 潜在客户群分析（Latency Client Analysis） 潜在客户群是指将来可能发展的客户群，分析他们的数量、素质、市场前景等。 4．项目功能（Project Function） 4.1 单机版功能（Stand-alone Function） 单机版功能，如表3-3所示。 表3-3 单机版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 4.2 网络版功能（Network Function） 网络版功能，如表3-4所示。 表3-4 网络版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 4.3 互联网络版功能（Internet Function） 互联网络版功能，如表3-5所示。 表3-5 互联网络版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 5．项目性能（Project Performance） 5.1 响应时间（Response Time） 单机结构（包括主机多用户结构，即H/T结构）、C/S结构、B/S结构三种架构的终端数量，要求响应时间小于0.XX秒。 5.2 处理速度（Disposal Speed） C/S结构、B/S结构两种架构的后台结算方式，结算速度分析。 5.3 最大终端负载（The Highest Terminal Load） C/S结构、B/S结构两种架构的并发处理最大终端（用户）负载数量分析。 以上性能要求，最好也用列表的形式给出。 6．项目接口（Project Interface） 6.1 金融接口（Finance Interface） 金融接口列表，如表3-6所示。 表3-6 金融接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 6.2 政府接口（Government Interface） 政府接口列表，如表3-7所示。 表3-7 政府接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 6.3 互联网接口（Internet Interface） 互联网接口列表，如表3-8所示。 表3-8 互联网接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 7．投入产出分析（Analysis of the Devotion and the Output） 7.1 人力资源投入（Manpower Devotion） 人力资源投入，如表3-9所示。 表3-9 人力资源投入 阶段名称 需求岗位 需求人数 工作量（人/月） 到岗日期 需求分析 分析师 概要设计 设计师 详细设计 设计师 / 高级程序员 编码 程序员 测试 测试员 包装与发布 包装师 总人数： 总工作量（人/月）： 7.2 设备资源投入（Facility Devotion） 设备资源投入，如表3-10所示。 表3-10 设备资源投入 设备名称 规格型号 数量 单价（元） 金额（元） 到位日期 7.3 其他经费资源投入（Other Outlay Devotion） 其他经费资源投入，如表3-11所示。 表3-11 其他经费资源投入 开支项目 开支金额（元） 支付日期 支付方式（现金/支票） 备注 项目总投入（人力费用+设备费用+其他经费资源投入）经费（元）： 7.4 产出分析（Output Analysis） 产出分析，如表3-12所示。 表3-12 产 出分 析 单机版单价（元） 单机版 数量 C/S版单价（元） C/S版数量 B/S版单价（元） B/S版数量 年产出合计金额（元） 第1年 第2年 第3年 8．开发计划（Development Scheme） 8.1 进度计划（Plan Scheme） 开发进度计划，如表3-13所示。 表3-13 进 度计 划 阶段名称 需求分析 概要设计 详细设计 编码 测试 包装与发布 第1周进度 第2周进度 第3周进度 第4周进度 第5周进度 …… 8.2 评审计划（Review Scheme） 各里程碑的评审计划，如表3-14所示。 表3-14 评 审计 划 阶段名称 评审日期 评审地点 主持人 参加人 应交文档 需求分析 概要设计 详细设计 测试报告 包装 9．案例分析（Cases Analysis） 案例分析包括成功案例和失败案例分析。 9.1 国外案例分析（Cases Analysis in Foreign Countries） 案例1：…… 案例2：…… 9.2 国内案例分析（Cases Analysis in China） 案例1：…… 案例2：…… 10．风险分析（Risk Analysis） 10.1 需求风险（Risk of Requirement） 指项目组对用户需求获取的途径和能力有何风险，用户主动配合需求的程度。 10.2 政策风险（Risk of Policy） 指国家政策、行业政策、企业内部政策的变化对项目将会产生有利或不利的影响。 10.3 资源风险（Risk of Resource） 指开发和运行所需资源的风险程度。 10.4 技术风险（Risk of Technology） 指项目组采用新技术的风险程度。如最新开发工具的风险程度、最新设计思想的风险程度。 10.5 技能风险（Risk of Skill） 指项目组成员掌握新技术的风险程度。 2《软件项目投标书》表3-15 《软件项目投标书》编写参考指南 序号 章节名称 章节内容 1 项目概况 按照招标书的内容，陈述项目概况 2 总体解决方案 按照招标书的要求，提出项目的总体解决方案： 网络结构总体方案 系统软件配置方案 应用软件设计方案 系统实施方案 3 项目功能、性能和接口描述 应用软件的具体功能点列表 应用软件的具体性能点列表 应用软件的具体接口列表 续表 序号 章节名称 章节内容 4 项目工期、进度和经费估算 项目工期（单位：人月）估算 项目进度估算：需求、设计、编程、测试、验收的时间表 项目经费（单位：人民币元）估算 5 项目质量管理控制 质量标准 质量管理控制方法 项目开发和管理的组织结构及人员配备 6 附录 附录1：本软件公司的特点与强项简介 附录2：本软件公司的成功案例 附录3：本软件公司的资质证明材料 3《软件产品开发任务书》《软件产品开发任务书》正文样本 任务书名称：大型商业MIS产品开发任务书。 下达日期：1999/04/01。 发出部门：XX公司研发中心。 接受部门：研发中心商业软件部。 1．目标 （1）做成商业MIS产品，其产品化程度要求很高。因此，一切信息都要规范化、标准化、代码化。保证在产品实施时，其客户化工作只需录入代码和修改代码，绝对不允许修改数据结构和表结构； （2）配合市场销售部门、全国各地的分支机构和产品代理商，第一年开拓市场3~5个客户，第二年占领10% 的商业MIS市场。 2．功能模块划分及要求 大型商业MIS软件产品拟分为以下6个功能模块，要求每个功能模块具有高内聚、低耦合、信息隐蔽的性质，如表3-16所示。 表3-16 大型商业MIS产品的6个功能模块 序号 模块名称 功能要求 1 商业物流配送中心管理 商业物流采购、配送 2 大型商场（大型连锁超市）管理 商品零售 3 便利店（小型连锁超市）管理 商品零售 4 远程数据交换管理 点对点通信 5 电子商务模块 网上订货、销售 6 商业类库管理 基础类库、商业类库、构件库管理 3．功能模块详述 大型商业MIS软件，从组织结构上来说包括三个层次： （1）物流配送中心 （2）大型商场（大型连锁超市） （3）便利店（小型连锁超市） 作为一个完整的商业MIS系统来说，物流配送中心与大型商场（大型连锁超市）之间会发生物流、资金流、信息流的关系；大型商场（大型连锁超市）与便利店（小型连锁超市）之间也会发生物流、资金流、信息流的关系；而物流配送中心与便利店（小型连锁超市）之间没有任何关联。若将这三个模块分开来看，它们又可以各自独立成为一个单独的小型商业系统来使用。实际上，本大型商业MIS系统完成后，可以对功能模块进行组合或拆分，使其成为如下5个不同的小型商业MIS系统，供用户选择： （1）物流配送中心 ＋ 大型商场（大型连锁超市）＋ 便利店（小型连锁超市）的完整的商业MIS软件。 （2）物流配送中心 ＋ 大型商场（大型连锁超市）的商业MIS软件。 （3）大型商场（大型连锁超市）＋ 便利店（小型连锁超市）的商业MIS系统。 （4）物流配送中心MIS系统。 （5）大型商场的商业MIS系统。 作为本软件的第一层，物流配送中心可以具有多个配送仓库，它根据大型商场（大型连锁超市）的需要以及各个仓库库存情况，向供应商订货，进行货物采购；并根据订货的情况进行配货，组织运输工具进行发货；期间，还伴随着向供应商付款、索取发票，以及向客户催款、开出发票等等。大型商场（大型连锁超市）作为本软件的第二层，除了要进行本商场的各种业务管理外，还要向上级物流配送中心订货、付款、索取发票，向下级便利店（小型连锁超市）送货，收取钱款等等。便利店（小型连锁超市）作为本软件的第三层，一要进行本商场的各种业务管理；二要根据库存情况，向大型商场（大型连锁超市）要货，并定期将销售金额上交给大型商场（大型连锁超市）。 考虑到目前有些商场，已经有了其他的商业管理软件，虽然软件还有不完善的地方，但已经购买前台POS机。为了给客户节省开支，有效地将前台POS机利用好，所以，本系统的前台销售软件就要做两个版本：Windows 版本与DOS 版本。 由于配送中心与大型商场（大型连锁超市）之间、大型商场（大型连锁超市）与便利店（小型连锁超市）之间在物理位置上有一定的距离，所以，它们之间的网络连接也是一个需要重视的大问题。本系统考虑采用两种解决方案：一是采用DDN专线（或光缆），本方案数据传输速度快，性能高，程序设计、实现都很简单，但用户每月都要支付价格不低的线路费用，这种方案比较适合那些经济实力比较雄厚的用户；二是采用电话线，用X.25通信协议，此方案数据传输速度稍慢，但也能满足用户需要，程序设计和实现要复杂许多，用户每月支付的线路费用将大幅度下降。 随着计算机网络技术的飞速发展，电子商务在流通领域的应用也越来越多。本MIS系统也准备在电子商务方面有所扩展，条件允许，可以实现网上订货、网上销售，甚至网上货币支付。 作为一个软件企业，应该不断地提取、积累自己的软件资源。不同开发平台的开发规范、商业类库、应用框架、构件、中间件等都是十分重要的软件资源，是软件公司的基础建设。因此，在设计、编码之前，要制订相应的开发规范，要组织开发、设计、管理一些类库和构件库。 软件产品是软件公司的财富来源，而软件的有效加密是保护公司产品、产权的有效手段，更是保障公司效益的有效途径。所以，还要考虑软件加密算法设计。 4．功能模块任务分配 根据研发中心商业软件部目前的人员情况，本系统的项目经理由商业软件部副经理亲自担任，负责整个系统的规划、设计、协调与实施；商业软件部主任工程师担任产品经理，负责项目的整体需求、数据库设计与Alpha测试。整个项目分为4个任务组，各个任务组组长在项目实施阶段，承担小项目经理职责。4个任务组的人数及开发任务，如表3-17所示。 表3-17 任务组的人数及开发任务 任务组 人数 具体开发任务 第1任务组 4 1）POS机模块改造 2）利用X.25协议进行远程数据交换 3）电子商务模块 第2任务组 6 物流配送中心管理模块。本模块的主要功能包括：货物的采购管理，配送中心的库存管理，货物的销售管理三大部分 1）货物的采购管理包括：供应商管理，采购计划管理，订货管理，货物验收管理，退货管理，应付账款管理，应收发票管理，往来账管理等 2）库存管理包括：货位管理，入库管理，出库管理，盘库管理等 3）销售管理包括：客户管理，销售定单管理，配货管理，运输工具管理，发货管理，退货管理，应收账款管理，应付发票管理，往来账管理等 第3任务组 6 1）全局数据库设计 2）商业管理模块（包括大型商场与便利店的管理）。本模块的主要功能包括：货物的采购管理，退货管理（退给供应商），价格管理，库存管理，销售管理，前台销售管理，退货管理（客户退货管理），应付、应收账款管理，发票管理，送货管理（给便利店送货），收款管理（便利店上交金额）等等 第4任务组 2 1）PowerBuilder 开发规范 2）PowerBuilder 类库建设 3）构件的提取和构件库的管理 4）产品的加密处理 5）安装盘的制作 5．数据库与开发工具的选择 考虑到数据库的性能与价格比，数据库首选Sybase，其次是MS SQL Server。由于这两个数据库的天然联系，使得两个版本的程序设计的差异将十分微小。数据库设计工具采用PowerDesigner，程序开发工具选择为PowerBuilder 。某些PowerBuilder 不宜实现的功能，可由 VC++ 去完成。文档制作工具为Office 和PowerDesigner。 6．开发进度计划 研发中心商业软件部现有18人进入了本项目组。根据以往的实际工作经验，下面列出研发进度，如表3-18所示。 表3-18 进度计划（1999/04/01-1999/10/15） 阶段名称 需求分析 概要设计 详细设计 编码 测试 包装 发布 第1周进度 需求培训 第2周进度 需求获取 第3周进度 需求获取 第4周进度 需求获取 第5周进度 需求确认 第6周进度 概要设计 第7周进度 概要设计 第8周进度 概要设计 第9周进度 详细设计 第10周进度 详细设计 第11周进度 详细设计 第12周进度 详细设计 第13周进度 编码 第14周进度 编码 第15周进度 编码 第16周进度 编码 第17周进度 编码 第18周进度 编码 第19周进度 编码 第20周进度 Alpha测试 第21周进度 Alpha测试 第22周进度 Alpha测试 第23周进度 Alpha测试 第24周进度 Beta测试 第25周进度 Beta测试 第26周进度 包装 第27周进度 发布 第28周进度 机动 7．评审计划 各里程碑的评审计划，如表3-19所示。 表3-19 里程碑评审计划 阶段名称 评审日期 评审地点 主持人 参加人 应交文档 需求分析 1999/05/05 公司第一会议室 部门经理 项目组成员 用户需求报告/需求规格说明书 概要设计 1999/05/26 公司第一会议室 部门经理 项目组成员 概要设计说明书 详细设计 1999/06/25 公司第一会议室 项目经理 项目组成员 详细设计说明书 Alpha测试 1999/09/12 公司第一会议室 项目经理 测试人员 Alpha测试报告 Beta测试 1999/09/26 客户单位 项目经理 客户代表 Beta测试报告 包装 1999/09/31 公司第一会议室 部门经理 销售人员 包装光盘，用户指南，广告材料 附件：《商业MIS立项建议书》，此处省略。 4《软件开发计划书》《软件开发计划书》编写参考指南 1．引言（Introduction） 1.1 目的（Purpose） 本章提供整个软件开发计划的综述。主要是确定以下内容： （1）软件生存周期的选取及裁剪。 （2）软件规范、方法和标准的选择。 （3）软件工作产品的规模估计。 （4）软件工作量和成本的估计。 （5）软件进度表的制定。 （6）软件风险的估计。 （7）软件项目培训计划。 1.2 范围（Scope） 说明该软件开发计划的范围，简要描述软件开发计划的内容。一般而言，对于一个较大的软件项目（工期6个人月以上），计划书包括如下内容： （1）软件规模估计 （2）工作模块计划 （3）人力资源计划 （4）其他资源计划 （5）进度安排计划 （6）配置管理计划（可单独做一个计划） （7）质量保证计划（可单独做一个计划） 1.3 术语定义（Terms Glossary） 将该软件开发计划中的术语、缩写词进行定义。包括用户应用领域与计算机领域的术语与缩写词等。例如： [1] 软件相关组：指软件配置管理组、文档支持组、测试组。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员的集合。 1.4 参考资料（References） 说明该软件开发计划使用的参考资料，如项目的用户需求报告、商务合同、用户领域的资料等，每一个文件、文献要有标题、索引号或文件号，发布或发表日期以及出版单位。 [1] …… [2] …… 1.5 相关文档（Related Documents） 当该文档变更时，可能对其他文档产生影响，受影响的文档叫相关文档，需将它们列出。 [1] …… [2] …… 1.6 版本更新记录（Version Updated Record） 版本更新记录格式，如表4-8所示。 表4-8 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/06 — — — V1.0.1 — — 王小林 2001/02/25 成本估算维护 …… 2．项目概述（Project Summary） 2.1 项目的目的（Project Purpose） 说明该软件项目的目的。 2.2 项目的范围（Project Scope） 本章的内容，主要参照《立项建议书》/《合同》与《用户需求报告》中相关章节，简要描述该软件项目的实现范围： （1）主要功能点列表 （2）主要性能点列表 （3）主要接口列表 （4）本软件项目与其他软件项目之间的关系 （5）项目实施方面的限制等内容 2.3 项目的使用对象（Project Reader） 在本章节中，要识别出顾客与最终用户，对顾客与最终用户的情况要有简单描述，如最终用户的教育水平、技术水平及本系统的使用频度等。 3．项目组织（ProjectOrganization） 项目组织是为开发项目而组建的队伍。建议以框图的方式表示项目的组织结构，并对每一组织的负责人和职责加以说明。可能的项目组织单元，如： （1）项目管理组 （2）质量保证组 （3）配置管理组 （4）软件工程组 （5）测试组 （6）需求管理组 各组织说明如下： （1）项目管理组，执行SPP和SPTO过程，对项目实施负全部责任。 （2）质量保证组，执行SQA过程，负责项目过程与产品的质量控制和报告。 （3）配置管理组，执行SCM过程，负责项目产品的版本、配置管理以及配置库状态报告。 （4）软件工程组，执行软件项目工程过程，负责项目产品的开发和维护工作。 （5）测试组，执行软件项目测试过程，负责项目产品的测试。 （6）需求管理组，负责对需求基线和需求变更进行管理。 4．软件生存周期（Software Life Cycle） 本章节记录项目策划生存期定义的工作结果，需要描述的主要内容： （1）项目生存期框图 （2）项目生存期说明 5．规范、方法和标准（Criterion，Means，Standard） 本章节中需要描述采用的供开发和维护软件用的规范、方法和标准。 6．任务与工作产品（Task and Work Products） 项目任务和工作产品，是指根据项目生存期阶段划分的任务，和相应阶段的工作产品。记录项目生存期各阶段确定的需重点控制的阶段任务和工作产品。建议以表格的形式，列出生存期各阶段的任务和工作产品。项目包含的任务，如： （1）需求分析 （2）系统设计 （3）系统实现 （4）测试 （5）产品交付 （6）产品维护 项目可能包含的产品，如： （1）需求分析说明书 （2）规格分析说明书 （3）系统设计说明书 （4）源代码 （5）各种测试报告 （6）用户手册 （7）软件问题维护记录 7．工作产品、任务规模、工作量估计（Estimates of Work Product，Task Size and Workload） 项目规模估算是为了确定项目所需的人工。需要描述的主要内容有： （1）对软件工作产品规模估计依据的简要描述。 （2）每种任务和工作产品规模估计的结果。 （3）规模估算的结果，建议用《任务规模和工作量估算表》的形式列出。 8．成本估计（Estimates of Costs） 成本估计，是指对项目完成过程中耗费的人力、物力、财力资源的估算。成本估计应按类别进行估算，可能的成本估算类别，如： （1）直接人工 （2）直接费用 （3）间接成本 （4）制造费用 （5）管理费用 （6）不可预见费用 9．关键计算机资源计划（Critical Computer Resource Plan） 项目的关键计算机资源计划，是指系统在开发环境、测试环境、及用户目标环境中，对关键计算机资源，如计算机存储能力、计算机处理器速度、通信通道容量、服务器处理能力等的估计，使之能满足软件开发、测试、运行的要求。 10．软件项目进度计划（Software Project Schedule） 件项目进度计划，是对项目的进度、人员工作分工所做的计划，此计划依据上述各章的估算和分析结果，计划方式建议采用表格的形式。若采用工具制定项目计划，应将工具生成的图表作为项目计划的附件。本章节中需要描述的主要内容有： （1）软件项目每个阶段的进度时间表 （2）设定的里程碑 （3）评审时间 （4）缓冲时间 11．配置管理计划（可单独做一个计划）（Configuration ManagementPlanning） 本书单独作为一章论述。 12．质量保证计划（可单独做一个计划）（Software Quality AssurancePlanning） 本书单独作为一章论述。 13．风险分析（Risks Analysis） 项目风险分析，是指对可能发生的将会对项目按预期时间、资源和预算完成产生重大影响的事件的分析包括： （1）被识别出的重大风险事件：政策风险、技术风险、技能风险等。 （2）易发生重大风险事件的高风险区域：用户需求、设计、测试、运行平台等。 （3）重大风险事件的级别：功能不全、性能不稳、迅速受限制等。 （4）拟采取的预防措施：增加投入、纠错、延时等。 （5）风险事件发生后建议采用的处理措施：更改计划、降低难度系数等。 14．设备工具计划（Equipment and Tools Planning） 项目设备工具计划，是根据项目的工作指派及进度确定项目所需要的设备和工具，以确保设备工具在任务执行前到位，保证项目任务的顺利执行，在本计划中应包含以下几方面的内容： （1）所需的设备 （2）基本的要求 （3）应到位的时间 15．培训计划（Training Planning） 项目的培训计划，应根据项目的特点和项目组成员技能情况，制定出项目组成员所需的培训内容，培训计划中应包含以下几方面： （1）培训内容 （2）培训时间 （3）教员 （4）接受培训的人员 （5）培训目的（应达到的效果） 16．项目评审（Project Reviews） 项目评审，是对项目策划过程所做的定期性评审。其内容可分为： （1）评审点 （2）评审周期 （3）评审层次 （4）评审条款和措施 （5）管理评审活动中提交的工作产品（列出被评审的工作产品） 17．度量（Measurement） 度量是按规定在项目进行过程中，需要采集的度量数据，以便量化地反映项目的进展情况，为管理者提供对项目进展的适当的可视性，同时度量数据是项目过程改善的数据基础。应规定项目度量值的记录人（一般为项目经理或其指定人员）、记录时间（一般以定期评审为基础）和记录的数据。常用的度量数据如： （1）项目过程的评审次数 （2）项目计划修改次数 （3）项目各阶段的人员投入（各阶段投入的人月数） （4）各类任务耗用时间统计（如设计、编码、测试、文档编写等） （5）工作产品统计（如文档字数、功能点数、用况数、源代码行数等） 5《用户需求报告》《用户需求报告》编写参考指南 1．概述（Summary） 本文档是进行需求规格定义、项目策划、概要设计的基础，也是用户进行验收的依据。 1.1 用户简介（User Synopsis） 在本章节中要将用户的基本情况描述清楚，以便于分析人员划定系统范围，进行关于功能、进度、成本、性能等方面的平衡决策。 对于产品开发类项目，需要在此将该产品定义的用户群的特点描述清楚。 1.2 项目的目的与目标（Purpose and Aim of Project） 项目的目的是对开发本系统意图的总概括。项目的目标是将目的细化后的具体描述。项目目标应是明确的、可度量的、可以达到的, 项目的范围应能确保项目的目标可以达到。 对于项目的目标可以逐步细化，以便与系统的需求建立对应关系，检查系统的功能是否覆盖了系统目标。 1.3 术语定义（Terms Glossary） 将该用户需求报告中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.4 参考资料（References） 说明该用户需求报告使用的参考资料，如： [1] 商务合同 [2] 招标书 [3] 用户领域的资料 [4] 用户需求调查表 [5] 参照的标准 每一个文件、文献要有标题、或文件号，发布或发表日期以及出版单位。 1.5 相关文档（Related Documents） 说明用户需求报告的变更，以及可能受变更影响的其他相关文档，如： [1] 项目开发计划 [2] 需求规格说明书 1.6 版本更新信息（Version Updated Record） 版本更新记录格式，如表5-11所示。 表5-11 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/18 — — — V1.0.1 — — 王小林 2001/02/26 账本格式维护 2．现有系统描述（System in Existence） 2.1 组织结构与职责（Organizing Framework and Function） 将用户的组织结构逐层详细描述，建议采用树状的组织结构图进行表达，每个部门的职责也应进行简单的描述。组织结构是用户企业业务流程与信息的载体，对分析人员理解企业的业务、确定系统范围很有帮助。取得用户的组织结构，是需求获取步骤中的工作任务之一。 2.2 岗位定义（Role Definition） 用户环境中的企业岗位和组织结构一样，也是分析人员理解企业业务的基础，是需求获取的工作任务，同时也是分析人员提取对象的基础。每个岗位的职责可以进行详细的描述，建议采用表格的形式，如表5-12所示。 表5-12 岗 位定 义 编 号 岗 位 所在部门 职 责 相关的业务 1008 采购员 业务部 商品采购、合同签订、供应商选择 进货、合同管理 1009 …… 对用户岗位的识别，也包括使用了计算机系统后的系统管理人员岗位。 2.3 作业流程（Busywork Flow） 企业的作业流程，首先要有一个总的业务流程图，将企业中各种业务之间的关系描述出来，然后对每种业务进行详细的描述，使业务流程与部门职责结合起来。详细业务流程图可以采用直式业务流程图、Use case图、程序流程图加上文字说明。 图形可以将流程描述得很清楚，但是还要附加一些文字说明，如关于业务发生的频率、意外事故的处理、高峰期的业务频率等，不能在流程图中描述的内容，需要用文字进行详细描述。 2.4 单据、账本、报表（Bill of Document，Account and Report） 现行系统中用户正在使用的正式的或非正式的单据、账本、报表等可以收集起来，并进行穷举、分类、归纳。单据、账本、报表是用户系统中信息的载体，是进行系统需求分析的基础，无论采用哪种分析方法，这都是必不可少的信息源。 2.4.1 单据（Bill of Document） 单据的格式可用表格描述，如表5-13所示。 表5-13 单据的描述格式 单据名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 类型、长度、精度 数据项的取值范围 1 2 3 2.4.2 账本（Account） 因为账本上的数据是统计数据，所以一个账本一般对应一张中间表，账本的格式可用表格描述，如表5-14所示。 表5-14 账本的描述格式 账本名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据来源 1 2 3 2.4.3 报表（Report） 因为报表上的数据是统计数据，所以一个报表一般对应一张中间表，报表的格式可用表格描述，如表5-15所示。 2.5 存在的问题（Existent Question） 在现行的系统中，决策层、管理层、操作层各存在哪些方面的问题需要计算机来解决，尤其是决策层、管理层这些问题中包含了用户的需求与期望，有些问题是新系统可以解决的，有些问题则不是。 表5-15 报表的描述格式 报表名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据来源 1 2 3 2.6 可能的变化（Possible Change） 对于现行的系统，将来可能会有哪些变化，需要在此描述。企业中的变化是永恒的，系统分析员需要描述哪些变化可能引起系统范围变更。 3．目标系统功能需求（Function of Target System） 3.1 功能需求分析（Function Analysis） 决策层、管理层、操作层各有哪些具体功能要求。 3.2 功能需求点列表（Function List） 在功能需求分析完成后，要详细列出用户需求功能点列表，提供给后续设计、编程、测试中使用，更是为了用户测试验收中使用。功能需求点列表的格式，如表5-16所示。 表5-16 功能需求点列表 编 号 功 能 名 称 使 用 部 门 使 用 岗 位 功 能 描 述 输 入 内 容 输 出 内 容 1 2 3 4．目标系统性能需求（Performance of Target System） 4.1 时间要求（Time Request） 如： （1）响应时间，如查询的最长等待时间。 （2）更新处理时间，如记账的最长时间。 （3）数据的转换和传送时间，如远程数据传输的时间要求。 （4）解题时间。 4.2 空间要求（Space Request） 如： （1）支持的终端数。 （2）支持的并行操作的使用者数。 （3）处理的文件和记录数。 （4）表和文件的大小规模（要按可预见的增长，对数据及其分量的存储要求做出估算）。 （5）处理任务的数量。 （6）在正常情况下和峰值工作条件下，在一定时间周期中要处理的数据总数。 （7）对输入和输出数据的精度要求。 （8）对处理和传输过程中的精度要求。 4.3 性能需求点列表（Performance List） 详细列出用户性能点列表，提供给后续分析、设计、编程、测试中使用，更是为了用户测试验收中使用。需求性能点列表的格式，如表5-17所示。 表5-17 性能需求点列表 编 号 性能名称 使用部门 使用岗位 性能描述 输入内容 输出内容 1 2 3 5．目标系统界面与接口需求（Interface of Target System） 5.1 界面需求（Interphase Requirement） 界面的原则要求，如方便、简洁、美观、一致等。整个系统的界面风格定义，某些功能模块的特殊的界面要求。 （1）输入设备：键盘、鼠标、条码扫描器、扫描仪等； （2）输出设备：显示器、打印机、光盘刻录机、磁带机、音箱等； （3）显示风格：图形界面、字符界面、IE界面等； （4）显示方式：1024768、640480等； （5）输出格式：显示布局、打印格式等。 5.2 接口需求（Interface Requirement） 与其他系统的接口，如监控系统、控制系统、银行结算系统、税控系统、财务系统、政府网络系统及其他系统等。 （1）与系统特殊外设的接口，如CT机、磁共振、柜员机（ATM）、IC卡、盘点机等。 （2）与中间件的接口，要列出接口规范、入口参数、出口参数、传输频率等。 应在此列举出所有的外部接口名称、接口标准、规范。外部接口列表，如表5-18所示。 表5-18 外部接口需求点列表 编 号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 6．目标系统其他需求（Other Requirements of Target System） 6.1 安全性（Security） 6.2 可靠性（Dependability） 6.3 灵活性（Agility） 6.4 特殊需求（Special requirements） 如： （1）进度需求：系统的阶段进度要求。 （2）资金需求：投资额度。 （3）运行环境需求：平台、体系结构、设备要求。 （4）培训需求：用户对培训的需求，是否提供多媒体教学光盘。 （5）推广需求：推广的要求，如在上百个远程部门推广该系统，是否要有推广的支持软件。 7．目标系统假设与约束条件（Suppose and Restriction ofTarget System） 假设与约定条件是对预计的系统风险的描述, 如： （1）法律、法规和政策方面的限制。 （2）硬件、软件、运行环境和开发环境方面的条件和限制。 （3）可利用的信息和资源。 （4）系统投入使用的最晚日期。 （5）需求中的风险分析：技术风险、技能风险、时间风险、资源风险。 6《需求规格说明书》《需求规格说明书》编写参考指南 1．概述（Summary） 本文档是进行项目策划、概要设计和详细设计的基础，也是软件企业测试部门进行内部验收测试的依据。 1.1 用户简介（User Synopsis） 在本章节中要将用户的基本情况描述清楚，以便于分析人员划定系统范围，进行功能、进度、成本、性能等方面的平衡决策。 对于产品开发类项目，需要在此将该产品定义的用户群的特点描述清楚。 1.2 项目的目的与目标（Purpose and Aim of Project） 项目的目的是对开发本系统的意图的总概括。项目的目标是将目的细化后的具体描述。项目目标应是明确的、可度量的、可以达到的, 项目的范围应能确保项目的目标可以达到。 对于项目的目标可以逐步细化，以便与系统的需求建立对应关系，检查系统的功能是否覆盖了系统的目标。 1.3 术语定义（Terms Glossary） 将该需求规格说明书中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.4 参考资料（References） 说明该用户需求报告使用的参考资料，如： [1] 商务合同 [2] 招标书 [3] 用户领域的资料 [4] 用户需求调查表 [5] 用户需求报告 [6] 参照的标准 每一个文件、文献要有标题、或文件号，发布或发表日期以及出版单位。 1.5 相关文档（Related Documents） [1] 项目开发计划 [2] 概要设计说明书 [3] 详细设计说明书 1.6 版本更新信息（Version Updated Record） 版本更新记录格式，如表5-19所示。 表5-19 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/03/03 — — — V1.0.1 — — 王小林 2001/03/16 业务模型维护 2．目标系统描述（System in Target） 2.1 组织结构与职责（Organizing Framework and Function） 将目标系统的组织结构逐层详细描述，建议采用树状的组织结构图进行表达，每个部门的职责也应进行简单的描述。组织结构是用户企业业务流程与信息的载体，对分析人员理解企业的业务、确定系统范围很有帮助。取得用户的组织结构，是需求获取步骤中的工作任务之一。 2.2 角色定义（Role Definition） 用户环境中的企业角色，和组织机构一样，也是分析人员理解企业业务的基础，是需求获取的工作任务，同时也是分析人员提取对象的基础。每个角色的授权可以进行详细的描述，建议采用表格的形式，如表5-20所示。 表5-20 角 色定 义 编号 角色 所在部门 职 责 相关的业务 1008 采购员 业务部 商品采购、合同签订、供应商选择 进货、合同管理 1009 对用户角色的识别也包括使用了计算机系统后的系统管理人员。 2.3 作业流程（业务模型）（Busywork Flow）（Operation Model） 目标系统的作业流程是对现有系统作业流程的重组、优化与改进。企业的作业流程首先要有一个总的业务流程图，将企业中各种业务之间的关系描述出来，然后对每种业务进行详细的描述，使业务流程与部门职责结合起来。详细业务流程图可以采用直式业务流程图、Use case图、其他示意图的形式。 图形可以将流程描述得很清楚，但是还要附加一些文字说明，如关于业务发生的频率、意外事故的处理、高峰期的业务频率等，不能在流程图中描述的内容，需要用文字进行详细描述。 2.4 单据、账本、报表（Bill of Document，Account and Report） 目标系统中用户将使用的正式单据、账本、报表等，并进行穷举、分类、归纳。单据、账本、报表是用户系统中信息的载体，是进行系统需求分析的基础，无论采用哪种分析方法，这都是必不可少的信息源。 2.4.1 单据（Bill of Document） 因为单据上的数据是原始数据，所以一种单据一般对应一个实体，一个实体一般对应一张基本表。单据的格式可用表格描述，如表5-21所示。 表5-21 单据的描述格式 单据名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 属性中文名 属性英文名 属性类型、长度、精度 属性的值域 Pk/fk 2.4.2 账本（Account） 因为账本上的数据是统计数据，所以一个账本一般对应一张中间表，账本的格式可用表格描述，如表5-22所示。 表5-22 账本的描述格式 账本名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据项算法 1 2 3 2.4.3 报表（Report） 因为报表上的数据是统计数据，所以一个报表一般对应一张中间表，报表的格式可用表格描述，如表5-23所示。 表5-23 报表的描述格式 报表名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据项算法 1 2 3 2.5 可能的变化（Possible Change） 对于目标系统，将来可能会有哪些变化，需要在此描述。企业中的变化是永恒的，系统分析员需要描述哪些变化可能引起系统范围变更。 3．目标系统功能需求（Function of Target System） 3.1 功能需求分析（Function Analysis） 决策层、管理层、操作层各有哪些具体功能要求。 3.2 功能需求点列表（功能模型）（Function List）（Function Model） 在功能需求分析完成后，要详细列出用户需求功能点列表，提供给续设计、编程、测试中使用，更是为了用户测试验收中使用。需求功能点列表的格式，如表5-24所示。 表5-24 功能需求点列表 编号 功能名称 使用部门 使用岗位 功能描述 输入 系统响应 输出 1 2 3 4．目标系统性能需求（Performance of Target System） 4.1 时间要求（Time Request） 如： （1）响应时间，如查询的最长等待时间。 （2）更新处理时间，如记账的最长时间。 （3）数据的转换和传送时间，如远程数据传输的时间要求。 （4）解题时间。 4.2 空间性能（Space Request） 如： （1）支持的终端数。 （2）支持的并行操作的使用者数。 （3）处理的文件和记录数。 （4）表和文件的大小规模（要按可预见的增长，对数据及其分量的存储要求做出估算）。 （5）处理任务的数量。 （6）在正常情况下和峰值工作条件下，在一定时间周期中要处理的数据总数。 （7）对输入和输出数据的精度要求。 （8）对处理和传输过程中的精度要求。 4.3 性能需求点列表（性能模型）（Performance List）（Performance Model） 详细列出用户性能点列表，提供给后续分析、设计、编程、测试中使用，更是为了用户测试验收中使用。需求性能点列表的格式，如表5-25所示。 表5-25 性能需求点列表 编号 性能名称 使用部门 使用岗位 性能描述 输入 系统响应 输出 1 2 3 5．目标系统界面与接口需求（Interface of Target System） 5.1 界面需求（Interphase Requirement） 界面的原则要求，如方便、简洁、美观、一致等。整个系统的界面风格定义，某些功能模块的特殊的界面要求。 （1）输入设备：键盘、鼠标、条码扫描器、扫描仪等； （2）输出设备：显示器、打印机、光盘刻录机、磁带机、音箱等； （3）显示风格：图形界面、字符界面、IE界面等； （4）显示方式：1024×768、640×480等； （5）输出格式：显示布局、打印格式等。 5.2 接口需求点列表（接口模型）（Interface Requirement）（Interface Model） （1）与其他系统的接口，如监控系统、控制系统、银行结算系统、税控系统、财务系统、政府网络系统及其他系统等。 （2）与系统特殊外设的接口，如CT机、磁共振、柜员机（ATM）、IC卡、盘点机等。 （3）与中间件的接口，要列出接口规范、入口参数、出口参数、传输频率等。 应在此列举出所有的外部接口名称、接口标准、规范。外部接口列表，如表5-26所示。 表5-26 接口需求点列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 6．目标系统其他需求（Oher Requirement of Target System） 6.1 安全性（Security） 6.2 可靠性（Dependability） 6.3 灵活性（Agility） 6.4 特殊需求（Special Requirement） 如： （1）进度需求：系统的阶段进度要求。 （2）资金需求：投资额度。 （3）运行环境需求：平台、体系结构、设备要求。 （4）培训需求：用户对培训的需求，是否提供多媒体教学光盘。 （5）推广需求：推广的要求，如在上百个远程的部门推广该系统，是否要有推广的支持软件。 7．目标系统假设与约束条件（Suppose and Restriction ofTarget System） 假设与约定条件是对预计的系统风险的描述,如： （1）法律、法规和政策方面的限制。 （2）硬件、软件、运行环境和开发环境方面的条件和限制。 （3）可利用的信息和资源。 （4）系统投入使用的最晚时间。 （5）需求中的风险分析：技术风险、技能风险、时间风险、资源风险。 7《需求报告 / 需求规格说明书评审记录表》《用户需求报告 / 需求规格说明书评审记录表》 （Review Table of Requirements） 项目名称 项目经理 评审阶段 用户需求报告/需求规格说明书 第 次评审 评审组组长 评审时间 评审地点 评审组成员 不符合项跟踪记录（Check list of noncompliance items） 不符合项名称 不符合项内容 限期改正时间 实际改正时间 测试合格时间 测试员签字 审计员签字 评审意见 评审结论 ​ 评审组长签字： 评审组成员签字： 表5-28 《需求变更管理表》 （Modification Tableof Requirements） 项目名称 申请日期 用户名称 审批日期 变更原因 实际变更日期 原来需求 变更内容 审批意见 ​ 申请人： 审批人： 8“图书馆信息系统”“图书馆信息系统”数据模型设计案例 “图书馆信息系统”的概念数据模型CDM（见图6-10）和物理数据模型PDM（见图6-11）分析。 首先，介绍一下在E-R图中实体的表示法，如图6-10所示。一个矩形框表示一个实体，框内第一部分（第一行）的文字表示该实体的名称，如“图书”。第二部分表示该实体的多个属性，每个属性占一行，如“图书号、书名、单价、作者”等。带下划线的属性为主关键字，即主键PK（或主码），如“图书号”。两个实体之间的关系，用一条连线表示。关系有三种：一对一关系，就是一条连线；一对多关系，多的一端是一个三叉线（ERwin工具中为一个黑色小圆球）；多对多关系，两端都是三叉线。连线的一端若有一个小圆圈，则表示非强制型的关系；连线的一端若有一个小十字架，则表示强制型的关系。 图6-10 “图书馆信息系统”的概念数据模型CDM 系统的E-R图又称为系统的概念数据模型CDM，有了它以后，利用PowerDesigner工具，就能自动生成物理数据模型PDM。 首先分析“图书馆信息系统”的概念数据模型CDM，如图6-10所示。因为图书馆的主要功能不外乎两点，藏书与为读者服务。其他许多功能都是围绕这两项功能而展开的。所以“图书馆信息系统”的主要实体是“图书”和“读者”。 “图书”的属性有图书号、书名、作者、出版社、单价等，“读者”的属性有读者号、姓名、电话等。 由于一本图书可以被多个读者在不同时间借阅，一名读者又可以一次或多次借阅多本图书，所以该两个实体之间是多对多的关系。为了消除这个多对多关系，在两者之间插入第3个实体，该实体取名为“借还书”。“借还书”至少有两个属性：借书还书时间、借书还书标志。另外，它还有两个外键，图书号和读者号。当增加“借还书”这个实体之后，原来一个多对多的关系，现在变为两个一对多的关系：“图书”对“借还书”，“读者”对“借还书”。 “图书馆信息系统”中还有许多其他实体，它们都是围绕这3个主要实体及其关系而展开的。这3个实体是“图书馆信息系统”的核心。例如，“书库”和“单位”这两个实体，就是分别围绕“图书”和“读者”而展开的。“书库”表示图书存放在什么地方，以及该书是否借出，即该本书的架位号、架位地址，以及借出标志位的状态。由于一个架位号上可放多本书，所以“书库”和“图书”是一对多的关系。同样，“单位”表示读者在什么单位，即该读者的单位名称、单位地址和单位电话等，由于一个单位可有多个读者，所以“单位”和“读者”是一对多的关系。以上实体、属性、关系如图6-10所示。 图6-11 “图书馆信息系统”的物理数据模型PDM 再来分析“图书馆信息系统”的物理数据模型PDM，如图6-11所示。此PDM是由CDM生成的。不难发现：在生成PDM的过程中，凡是CDM中的一对多的关系，主表中的主键PK都自动拷贝到子表中去，作为子表的外键FK，这就是数据库设计工具PowerDesigner的一项功能。该PDM比较整齐规范，那是因为在生成之后进行了手工调整。 9《概要设计说明书》《概要设计说明书》编写参考指南 1．导言（Introduction） 本章对该文档的目的、功能范围、术语、相关文档、参考资料、版本更新进行说明。 1.1目的（Purpose） 本文档的目旨在推动软件工程的规范化，使设计人员遵循统一的概要设计书写规范，节省制作文档的时间，降低系统实现的风险，做到系统设计资料的规范性与全面性，以利于系统的实现、测试、维护、版本升级等。 1.2范围（Scope） 本文档用于软件设计阶段的概要设计，它的上游（依据的基线）是《需求分析规格书》，它的下游是《详细设计说明书》，并为《详细设计说明书》提供测试的依据。 软件概要设计的范围是：软件系统总体结构设计、全局数据库和数据结构设计、外部接口设计、主要部件功能分配设计、部件之间的接口设计等方面的内容。该范围应覆盖《需求规格说明书》中的功能点列表、性能点列表、接口列表。 1.3 命名规则（Naming Rule） 变量对象命名规则：申明全局变量、局部变量对象的命名规则。 数据库对象命名规则：申明数据库表名、字段名、索引名、视图名等对象的命名规则。 1.4 术语定义（Terms Glossary） 术语定义或解释一般用表格形式给出，如表6-5所示。 表6-5 术语定义或解释表 序 号 术 语 名 称 术 语 定 义 1 总体结构 软件系统的总体逻辑结构。按照不同的设计方法，有不同的总体逻辑结构。若采用面向功能或面向数据的设计方法，则总体逻辑结构为一树形的功能模块结构图。若采用面向对象或面向部件（构件）的设计方法，则总体逻辑结构为部件（构件）的组装图 2 外部接口 本软件系统与其他软件系统之间的接口，接口设施可以是中间件。接口描述包括：传输方式、带宽、数据结构、传输频率、传输量、传输协议 3 数据结构 数据结构包括：数据库表的结构、其他数据结构等 4 概念数据 模型CDM 关系数据库的逻辑设计模型，叫做概念数据模型。主要内容包括一张逻辑E-R图及其相应的数据字典 5 物理数据 模型PDM 关系数据库的物理设计模型，叫做物理数据模型。主要内容包括一张物理表关系图及其相应的数据字典 6 视图 在基表或其他视图之上建立的一张虚表，叫做视图，它具有物理表的许多性质，在数据处理和授权上很有用 7 角色 数据库中享有某些特权操作的用户，叫做角色。角色的权利通过授权来实现 8 子系统 具有相对独立功能的小系统叫做子系统。一个大的软件系统可以划分为多个子系统，每个子系统可由多个模块或多个部件组成 9 模块 具有功能独立、能被调用的信息单元叫做模块。模块是结构化设计中的概念 10 内部接口 软件系统内部各子系统之间、各部件之间、各模板之间的接口，叫做内部接口。接口描述包括：调用方式、入口信息、出口信息等 11 相关文件 相关文件是指当本文件内容变更后，可能引起变更的其他文件。如需求分析报告、详细设计说明书、测试计划、用户手册 12 参考资料 参考资料是指本文件书写时用到的其他资料。如各种有关规范、模板、标准、准则 1.5 参考资料（References） [1] 用户需求报告 [2] 软件开发合同 [3] 数据库设计规范 [4] 命名规范 1.6 相关文档（Related Documents） [1] 《详细设计说明书》 [2] 源程序清单 [3] 测试计划及报告 [4] 《用户使用手册》 1.7版本更新记录（Version UpdatedRecord） 版本更新记录格式，如表6-6所示。 表6-6 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/18 — — — V1.0.1 — — 王小林 2001/02/26 E-R图维护 2．总体设计（Design ofCollective） 2.1 总体结构设计（Design ofCollective Structure） 软件系统的总体逻辑结构，按照不同的设计方法，有不同的总体逻辑结构。本指南以结构化设计方法为主，画出系统总体结构图，列出系统的功能模块清单编号、名称、功能，并尽可能描绘出功能模块之间的关系。若用面向对象的Rose工具进行分析和设计，则遵照Rose的要求进行。 总体结构示意图 ， 如图 6-13 所示。 图6-13 总体结构示意图 2.2 运行环境设计（Design of RunningEnvironment） 该软件系统的运行环境： 硬件平台： （1）服务器的最低配置要求 （2）工作站的最低配置要求 （3）外设的要求 软件平台： （1）服务器操作系统 （2）数据库管理系统 （3）中间件 （4）客户端的操作系统 （5）客户端的平台软件 网络平台： （1）通信协议 （2）通信带宽 2.3 子系统清单（Subsystem List） 子系统清单，如表6-7所示。 表6-7 子系统清单 子系统编号 子系统英文名 子系统功能简述 子系统之间的关系 SS1 SS2 SS3 2.4 功能模块清单（Function ModuleList） 功能模块清单，如表6-8所示。 表6-8 功能模块清单 模 块 编 号 模块英文名 模块功能简述 模块的接口简述 M 1-1 M 1-2 M 2-1 M 2-2 3．模块（部件）功能分配（FunctionalDistribution of Module） 具有功能独立、能被调用的信息单元叫做模块。模块是结构化设计中的概念，部件是面向对象设计中的概念。 模块功能分配的目的，就是为了将具有相同功能的模块合并，从中提取公用模块，形成公用部件，按照构件或中间件的方式加以实现，作为本系统的公用资源，甚至作为公司级组织的公用资源，从而充实公司级的构件库或中间件库，优化系统设计，加快开发速度，提高开发质量。 3.1 专用模块功能分配（FunctionalDistribution of Expert Module） 专用模块功能分配，如表6-9所示。 表6-9 专用模块功能分配 专用模块编号 模块英文名 模块详细功能分配 模块的接口标准 M1-1 M1-2 M2-1 M2-2 3.2 公用模块功能分配（FunctionDistribute of Public Module） 公用模块功能分，如表6-10所示。 表6-10 公用模块功能分配 公用模块编号 模块英文名 模块详细功能分配 模块的接口标准 G-1 G-2 G-3 4．数据结构设计（Design of Data Structure） 数据库设计的工具目前主要有3个：ERwin，PowerDesigner，OracleDesigner。后面两种工具都支持中文的概念数据模型设计，并能自动将概念数据模型转换为物理数据模型，自动生成建表程序和主键索引程序。前面一种工具只能支持英文的物理数据模型设计。3个工具的共同特点是都能生成E-R图及其相应的数据字典。 4.1 数据库表名清单（DB Table List） 数据库表名清单，如表6-11所示。 表6-11 数据库表名清单 序号 中文表名 英文表名 表功能说明 1 2 3 4.2 数据库表之间关系说明（Relation of DBTable） 可以用E-R图表示，也可以用文字说明。 4.3 数据库表的详细清单（Particular List ofDB Table） 每个表的详细清单内容包括：表名、字段中文名、字段英文名、字段的类型、宽度、精度、主键/外键、空否、取值约束（默认值、最大值、最小值）、索引否。同时要指出该表的索引：索引文件名、索引字段名、索引特性（主键索引、惟一索引unique、聚集索引clustered）。详细清单可以用列表给出，如表6-12所示。 表6-12 表名：XXXX 序号 字段中文名 字段英文名 类型、宽度、精度 取值约束 空否 默认值 主键/外键 索引否 1 2 3 4.4 视图设计（View Design） 视图设计与授权有关，设计时参照需求文档的用户授权范围。视图设计中要给出视图的中文名、英文名，视图中的中文列名、英文列名、类型、宽度、精度，每一列的具体算法，对应的基本表名。 4.5 其他数据结构设计（Design of OtherData Structure） 此小节描述系统的其他数据结构设计内容。 5．接口设计（Interface Design） 对应每一个接口，都要详细列出下列内容。 （1）接口名称 （2）接口内容 （3）接口设施 （4）接口的数据结构 （5）接口的传输速率（Mbps） （6）接口带宽 （7）接口协议 6．其他设计（Other Design） 本章描述前面没有说明的设计。 7．设计检查列表（Check-up List of Design） 按照需求文档的功能、性能和接口3个列表，设计出概要设计检查列表，以检查概要设计是否覆盖需求分析，没有覆盖就是不符合项，并将检查结果列出。 7.1 功能设计检查列表（Check-up List of Function Design） 功能设计检查列表，如表6-13所示。 表6-13 功能设计检查列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 系统响应 输出内容 是否覆盖 1 2 3 7.2 性能设计检查列表（Check-up List of Performance Design） 性能设计检查列表，如表6-14所示。 表6-14 性能设计检查列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 系统响应 输出内容 是否覆盖 1 2 3 7.3 接口设计检查列表（Check-up List of Interface Design） 接口设计检查列表，如表6-15所示。 表6-15 接口设计检查列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 是否覆盖 1 2 3 10《详细设计说明书》《详细设计说明书》编写参考指南 1．导言（Introduction） 本章对该文档的目的、功能范围、术语、相关文档、参考资料、版本更新进行说明。 1.1 目的（Purpose） 本文档的目旨在推动软件工程的规范化，使设计人员遵循统一的详细设计书写规范，节省制作文档的时间，降低系统实现的风险，做到系统设计资料的规范性与全面性，以利于系统的实现、测试、维护、版本升级等。详细设计的详细程度，应达到可以编写程序的程度。 1.2 范围（Scope） 本文档用于软件设计阶段的详细设计，它的上游（依据的基线）是《概要设计说明书》，它的下游是源程序清单及单元测试计划，并为单元测试报告提供测试依据。该范围应覆盖《概要设计说明书》中的功能点列表、性能点列表、接口列表。 软件详细设计的范围是：各子系统的公用模块实现设计、专用模块实现设计、存储过程实现设计、触发器实现设计、外部接口实现设计、部门角色授权设计、其他详细设计等。 按照3层结构（B/A/S）的布局，详细设计应从下面3个方面进行。数据库服务器上的面向数据的设计：数据字典物理设计、基本表物理设计、中间表物理设计（报表设计）、临时表物理设计、视图物理设计、存储过程物理设计、触发器物理设计。应用服务器上的面向业务逻辑的设计：接口数据设计、中间件设计、数据通信传输设计、可视构件设计、非可视构件设计、角色授权设计、功能点设计（功能点列表设计）。浏览器上的面向对象的设计：录入修改界面设计、浏览查询界面设计、登录注册界面设计、信息发布界面设计。 1.3 术语定义（Terms Glossary） 术语定义，如表6-16所示。 表6-16 术语定义 序号 术语名称 术 语 定 义 1 详细设计 在概要设计的基础上，对其功能模块或部件进行实现设计，使编程人员据此能顺利书写出程序代码 2 存储过程 存放在数据库服务器上的一段程序，它能被其他程序调用，以完成对数据库表的某些规定操作 3 触发器 存放在数据库服务器上的一段程序，当触发条件满足时它就被执行，以完成对数据库表的某些规定操作 4 算法 详细设计中实现某项功能的数据处理方法及处理流程 1.4 参考资料（References） [1] 《概要设计说明书》 [2] 《需求分析说明书》 [3] 《软件合同》 [4] 命名规范 [5] 程序设计规范 [6] 界面设计规范 1.5 相关文档（Related Documents） [1] 源程序清单 [2] 单元测试计划及报告 [3] 《用户使用手册》 1.6 版本更新记录（Version UpdatedRcord） 版本更新记录，如表6-17所示。 表6-17 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/0318 — — — V1.0.1 — — 王小林 2001/03/26 报表4格式维护 2．模块实现设计（Implemental Design of Module） 功能模块包括：登录注册模块、信息发布模块、菜单模块、录入修改模块、查询统计模块、数据处理模块、报表输出模块、前台网站模块、后台处理模块、数据传输与接收模块等等。详细设计是面向模块的，或者说是面向部件（或构件）的，不是面向组织结构或部门单位的。一个组织或单位，根据角色的授权，可以挂上某些功能模块。若为C/S或B/A/S结构，则要说明该模块运行在哪一层上。 2.1 公用模块设计（Design of Public Module） 公用模块的提取与设计特别重要，设计它的目的是为了复用，因此它直接影响到系统的详细设计、编程、运行的质量。每个公用模块的设计要包括如下内容： （1）模块编号：按照命名规则，如：G-XXX，将此公用模块编号写上。 （2）模块名称：此公用模块的英文名。 （3）模块功能：详细列出此公用模块的所有功能。 （4）模块背景描述：对背景进行简单的描述。为什么需要此模块功能，其上下文环境。涉及业务背景内容，与需求相结合。 （5）模块算法设计：用伪语言（例如，if…endif，case…endcase， do…enddo，…）详细描述出此公用模块的算法，标准是使程序人员据此能顺利地书写程序。 （6）模块调用方法：详细列出调用的方式、入口参数、出口参数、异常处理。 （7）模块编写者：编写者姓名。 （8）模块编写日期：编写日期：yyyy/mm/dd。 （9）模块修订者：修订者姓名。 （10）模块修订日期：修订日期：yyyy/mm/dd。 （11）模块测试者：测试者姓名。 （12）模块测试日期：测试日期：yyyy/mm/dd。 2.2 专用模块设计（Design of Expert Module） 非公用模块是为了处理一些特殊需求，它不可复用，每个非公用模块设计包括如下内容： （1）模块编号：按照命名规则，如：M1-XXX，将此专用模块编号写上。 （2）模块名称：此模块的中文名。 （3）模块功能：详细列出此模块的所有功能。 （4）模块背景描述：对背景进行简单的描述。为什么需要此模块功能，其上下文环境。涉及业务背景内容，与需求相结合。 （5）模块算法设计：用伪语言（例如，if…endif，case…endcase， do…enddo，…）详细描述出此专用模块的算法，标准是使程序人员据此能顺利地书写程序。 （6）模块编写者：编写者姓名。 （7）模块编写日期：编写日期：yyyy/mm/dd。 （8）模块修订者：修订者姓名。 （9）模块修订日期：修订日期：yyyy/mm/dd。 （10）模块测试者：测试者姓名。 （11）模块测试日期：测试日期：yyyy/mm/dd。 2.3 存储过程设计（Design of Storage Process） 存储过程是一种特殊的公用模块，它在数据库服务器上执行，这里将它单独列出来，规定其详细设计模板为： （1）存储过程中文名：此存储过程的中文名。 （2）存储过程英文名：此存储过程的英文名。 （3）存储过程功能: 详细描述其功能。 （4）存储过程算法: 用伪语言详细描述其算法，使编程人员据此能顺利书写程序。 （5）存储过程调用方式：详细列出调用的方式、入口参数、出口参数、异常处理。 （6）模块编写者：编写者姓名。 （7）模块编写日期：编写日期：yyyy/mm/dd。 （8）模块修订者：修订者姓名。 （9）模块修订日期：修订日期：yyyy/mm/dd。 （10）模块测试者：测试者姓名。 （11）模块测试日期：测试日期：yyyy/mm/dd。 2.4 触发器设计（Design of Trigger） 触发器也是一种公用模块，不过它是隐式执行，这里将它单独列出来，规定其详细设计模板为： （1）触发器中文名：此触发器的中文名。 （2）触发器英文名：此触发器的英文名。 （3）触发器功能：详细描述其功能。 （4）触发器算法：用伪语言详细描述其算法，使编程人员据此能顺利书写程序。 （5）触发器激活条件：详细描述其激活条件，使编辑人员据此能顺利书写程序。 （6）触发器编写者：编写者姓名。 （7）触发器编写日期：编写日期：yyyy/mm/dd。 （8）触发器修订者：修订者姓名。 （9）触发器修订日期：修订日期：yyyy/mm/dd。 （10）触发器测试者：测试者姓名。 （11）触发器测试日期：测试日期：yyyy/mm/dd。 注意：过多地使用触发器反而会使系统的效率降低。因此，凡是能用存储过程代替触发器功能的地方，一律用存储过程来实现。 3. 接口实现设计（Implemental Design ofInterface） 每个外部接口实现模块的设计要包括如下内容： （1）接口中文名称：此接口的中文名。 （2）接口英文名称：此接口的英文名。 （3）接口内容与功能：详细描述接口的内容与功能，如实现数据传输或数据交换。 （4）接口硬件设施：详细描述接口的硬件设施，如交换机、传感器或输出设备。 （5）接口软件或中间件：详细描述接口软件或中间件的名称、功能、使用方法、生产厂商。 （6）接口的数据结构：详细描述接口的数据结构，如文件结构、数据库表结构。 （7）接口的传输速率（Mbps）：定量说明每秒最大流量。 （8）接口带宽：定量说明带宽，如XXMbps。 （9）接口协议：说明具体协议。 （10）接口程序的算法：用伪语言详细描述其算法，使编码人员据此能顺利书写程序。 （11）接口编写者：编写者姓名。 （12）接口编写日期：编写日期：yyyy/mm/dd。 （13）接口修订者：修订者姓名。 （14）接口修订日期：修订日期：yyyy/mm/dd。 （15）接口测试者：测试者姓名。 （16）接口测试日期：测试日期：yyyy/mm/dd。 4．其他实现设计（Other Implemental Designs） 本章描述前面没有说明的设计。如部门角色授权设计、界面设计、包装设计、维护设计等。 4.1 角色授权设计（Accredited Designof Role） 授权表的横坐标表示角色（部件、单位或岗位），纵坐标表示功能模块，“●”表示授权。该授权表是工作站上菜单设计的依据，如表6-18所示。 表6-18 角色授权设计 模块名 角色1 角色2 角色3 角色4 角色5 模块英文名1 ● 模块英文名2 ● ● 模块英文名3 ● ● ● 模块英文名4 ● ● 模块英文名5 ● ● ● 模块英文名6 ● ● 模块英文名7 ● 模块英文名8 ● ● … ● ● 4.2 其他详细设计（Other ParticularDesigns） 根据需要进行设计。如界面设计、包装设计、维护设计等。 5．详细设计检查列表（Check-up List of Design） 按照概要设计文档的功能、性能和接口3个列表，设计出详细设计检查列表，以检查详细设计是否覆盖概要，没有覆盖就是不符合项，并将检查结果列出。 5.1 功能设计检查列表（Check-up List of Function Design） 功能设计检查列表，如表6-19所示。 表6-19 功能设计检查列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 系统响应 输出内容 是否实现 1 2 3 5.2 性能设计检查列表（Check-up List of Performance Design） 性能设计检查列表，如表6-20所示。 表6-20 性能设计检查列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 系统响应 输出内容 是否实现 1 2 3 5.3 接口设计检查列表（Check-up List of Interface Design） 接口设计检查列表，如表6-21所示。 表6-21 接口设计检查列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 是否实现 1 2 3 《概要设计说明书/详细设计说明书评审记录表》 （Review Table ofDesign） 项目名称 项目经理 评审阶段 概要设计说明书/详细设计说明书 第 次评审 评审组组长 评审时间 评审地点 评审组成员 不符合项跟踪记录 不符合项名称 不符合项内容 限期改正时间 实际改正时间 测试合格时间 测试员签字 审计员签字 评审意见 评审结论 评审组长签字： 评审组成员签字： 11《用户使用手册》《用户使用手册》编写参考指南 1．前言(Preface) 提供手册的概述，在此可以说明编写这份手册的目的、指明本手册的读者。 1.1 内容简介(Introduction) 简单地介绍编写背景，系统适用的用户。 1.2 基本概念(Basic Concept) 说明定义的术语在本手册中的含义。 1.3 主要功能(Mostly Function) 对系统进行简单讲解和功能介绍。 1.4 操作流程(Operate Flow) 操作流程说明。全面模拟用户操作，从安装、进入、初始化、到用户具体操作，对整个流程进行描述。 1.5 步骤说明(Step Show) 针对操作流程的每一步进行说明。如果在使用说明中有相应的解释，应指明用户查找的位置。 2．功能(Function) 这部分包括用户使用的所有功能，是用户使用手册的最重要的部分，要详细描述。 2.1 使用流程(Use Flow) 描述具体功能的使用顺序。如果功能之中有分类，比如，有些功能用户用不到，有些用得到，就要分开写流程。 2.2 具体描述(Description) 描述顺序是按照使用流程的每一步进行的。 2.3 进行此功能的业务介绍(Operation Introduce) 对此功能进行简单介绍，说明所能完成的功能。 2.4 操作步骤(Handle Step) 用鼠标选择相应的功能，进入相应的界面，进行功能键以及栏目的介绍。 2.5 举例(Example) 针对某一功能，对于一些比较难的问题，应该进行举例说明。 2.6 特殊提示及注意事项(Prompt and Notice) 在使用说明中，每一部分都会归纳一些问题，需要提示用户或者让用户注意，应按照以下规定的格式进行编写：字体采用仿宋字，字号采用小五号字。 3．附录(Appendix) 对一些在正文中描述不够详尽的地方，可在附录中进行补充；用户经常遇到的问题及问题解答也可放在附录中。 12《用户安装手册》《用户安装手册》编写参考指南 1．前言(Preface) 指明编制该手册的目的和预期的读者，简介该系统的运行环境：操作系统OS，数据库系统DBMS，C/S二层结构或B/A/S三层结构，界面特点，以及技术特色。 1.1 内容简介(Introduction) 介绍本书提供的几个部分：简单介绍大概内容。 1.2 使用约定(Use Assumpsit) 提示：安装过程的一些好的方法。 注意：安装过程中特殊注意的地方。 警告：指出危险动作或状态，否则，会对您的安装造成破坏。 2．单机版的安装及配置(Installation and Configuration for PC) 2.1 运行环境(Run Environment) （1）硬件环境：列出运行本系统所要求的硬设备的最小配置。微机要求包括型号、内存、硬盘，显示器要求，以及一些其他的I/O设备。 （2）软件环境：列出运行本系统所需要的支持软件。如操作系统，程序语言以及数据库管理系统。 2.2 安装单机版(Installation for PC) （1）简单介绍单机版打包光盘的定义和内容。 （2）介绍该系统单机版的安装步骤。 2.3 安装后的系统配置(Configuration After Installation) 介绍系统安装之后，查看该系统配置信息的情况，以确定是否需要改动，是否是最优配置。 另外，运行系统的时候，有时会出现数据库联接不成功。在这部分应介绍会有哪几种可能的原因，并分别简述。 3．网络版的安装及配置(Installation and Configuration for Network) 3.1 运行环境(Run Environment) 除了对硬件环境提出要求外，对软件环境的要求应列出运行本系统所需的操作系统、与操作系统兼容的网络环境、程序语言以及数据库管理系统。 另外，还应简单介绍一下安装网络和数据库所需注意事项和可参考的工具书。 3.2 安装网络版(Installation for Network) 介绍该系统网络版的安装步骤。 如何进行系统环境配置。 数据库的默认用户及口令等。 3.3 安装后的系统配置(Configurationafter Installation) 4．附录(Appendix) 附录1 安装过程提供的技术支持。说明技术支持的几种方式，及常见安装疑难问题解答。 附录2 参考资料，应写上书名、版本号、作者、出版社、出版日期。 13《测试报告》《测试报告》编写参考指南 概述(Summary) 1.1 项目简介(Project Synopsis) 在本章节中简介项目的基本情况。 1.2 术语定义(Terms Glossary) 将该测试报告中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.3 参考资料(References) 说明该测试报告使用的参考资料，如： [1]《商务合同》 [2]《用户需求报告》 [3]《需求规格说明书》 1.4 版本更新信息(Version Updated Record) 版本更新记录格式，如表9-3所示。 表9-3 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/02/18 — — — V1.0.1 — — 王小林 2002/02/26 不符合项测试 目标系统功能需求(Function of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的功能需求点列表，如表9-4所示。 表9-4 功能需求点列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 输出内容 1 2 3 目标系统性能需求(Performance of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的需求性能点列表，如表9-5所示。 表9-5 性能需求点列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 输出内容 1 2 3 目标系统接口需求(Interface of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的接口列表，如表9-6所示。 表9-6 外部接口需求点列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 功能测试报告(Report forFunction Test) 搭建功能测试平台，使测试平台与运行平台一致。按照功能点列表内容，设计测试用例（输入/输出内容），进行现场测试，记录测试数据，评定测试结果。测试活动的记录格式，如表9-7所示。 表9-7 功能测试记录 编号 功能名称 功能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 √ 2 √ 3 √ 4 × 性能测试报告(Rreport forPerformance Test) 搭建性能测试平台，使测试平台与运行平台一致。按照性能点列表内容，设计测试用例（输入/输出内容），进行现场测试，记录测试数据，评定测试结果。测试活动的记录，如表9-8所示。 表9-8 性能测试记录 编号 性能名称 性能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 √ 2 √ 3 × 4 √ 7. 接口测试报告(Report forInterface Test) 搭建接口测试平台，使测试平台与运行平台一致。按照接口列表内容，设计测试用例(输入/输出内容)，进行现场测试，记录测试数据，评定测试结果。测试活动的记录，如表9-9所示。 表9-9 接口测试记录 编号 接口名称 入口参数 出口参数 传输频率 发现问题 测试结果 测试时间 测试人 1 × 2 √ 3 √ 不符合项列表(Check List of Noncompliance Items) 将测试中的所有不符合项(Bug项)，整理后分别记录到表9-10、表9-11和表9-12中。 表9-10 功能测试不符合项列表 编号 功能名称 功能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 4 × 表9-11 性能测试不符合项列表 编号 性能名称 性能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 4 × 表9-12 接口测试不符合项列表 编号 接口名称 入口参数 出口参数 传输频率 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 以上不符合项，限期XX天内改正。改正完毕后重新进行回归测试。 9. 测试结论(Test Verdict) 当测试完成之后，测试组应对本次测试做出结论。格式如下： 测试日期： 测试地点： 测试环境： 参与测试的人员： 列出系统的强项： 列出系统的弱项： 列出不符合项的统计结果： 测试组组长签字： 测试组成员签字： 14软件质量保证关键过程域SQACMM2中“软件质量保证”关键过程域SQA详细说明文档 Software Quality Assurance (a key process area for Level2：Repeatable) 软件质量保证的目的，是向管理者提供软件项目正在使用的过程和正在构造的产品的可视性。 软件质量保证包括评审和审计软件产品及活动，以验证它们符合相应的规程和标准，给项目经理和其他有关经理提供评审和审计结果。 在软件项目的早期阶段，软件质量保证组与软件项目一起工作，制定计划、标准和规程等。这些计划、标准和规程，将增加软件项目的价值，并将满足项目和组织方针上的要求。通过参与制定计划、标准和规程，软件质量保证组帮助确保这些计划、标准和规程适合项目的需要，并且帮助验证这些计划、标准和规程对完成整个软件生存周期中的评审和审计将是适用的。软件质量保证组在整个生存周期内评审项目活动，审计软件工作产品，并就软件项目是否遵守已制定的计划、标准和规程等，为管理者提供可视性。 首先，在软件项目内部处理符合性问题，如可能的话就解决它。对于那些无法在软件项目组内部解决的问题，软件质量保证组逐级上递该问题到恰当层次的管理者那里以求解决。 这个关键过程域，只包括该组履行软件质量保证功能的实践。而识别软件质量保证组要评审和审计的具体活动和工作产品的实践，一般包含在其他关键过程域的验证实施共同特性之中。 （作者注：为了实现软件质量保证的目的，CMM规定了该KPA有“4个目标、1项约定、4项能力、8项活动、1项测量、3项验证”，该KPA的17个关键实践KP，就分布在“执行约定、执行能力、执行活动、测量和分析、验证实施”之中，具体内容简述如下。） 目标（Goals） 目标1：软件质量保证活动是有计划的。 目标2：软件产品和活动遵守适用的标准、规程和需求，能得到客观验证。 目标3：受影响的组和个人接到了软件质量保证活动和结果的通知。 目标4：高级管理者处理在软件项目内部不能解决的不符合问题。 执行约定（Commitment to Perform，CO） 约定1：项目遵守书面的实施软件质量保证(SQA)的组织方针。 该方针一般规定： 1．对全部软件项目，SQA功能到位； 2．SQA有一个向高级管理者报告质量问题的独立渠道，它独立于： ——项目经理 ——项目软件工程组 ——其他软件有关组 其他软件有关组的例子有： ──软件配置管理组 ──文档支持组 组织必须确定一种组织机构，它在组织的战略经营目标和经营环境中，支持那些引发独立性要求的活动，例如SQA。 独立性应该表现在： ──给担当SQA角色的个人提供组织上的自由度，使它们成为高级管理者在软件项目中的“耳目”。 ──使担当SQA角色的个人，免受管理者对他们正在评审的软件项目的所做的性能评价的影响。 ──使高级管理者相信，正在报告的有关项目过程和产品的信息是客观的。 3．高级管理者定期评审SQA活动和结果。 执行能力（Ability to Perform，AB） 能力1：存在负责协调和实施项目的SQA组（即SQA组）。 一个组是负责一组作业或活动的部门、经理和个人的集合。组的规模可以变化，可以包括一个受指派的非全日制的单个个人，也可以包括几个从不同部门指派来的非全日制的个人或几个全日制的个人。建立一个组时，应考察的因素包括指派的作业和活动、项目的规模、组织机构和组织文化。某些组，例如，软件质量保证组，集中注意力于项目活动；而其他组，例如，软件工程过程组，则集中关注全组织的活动。 能力2：为进行SQA活动提供足够的资源和投资。 1．指派一个经理，专门负责项目的SQA活动。 2．指派一个在SQA方面博学的、并有权采取监督行动的高级经理，接受和处理软件不符合问题。 ——在SQA中，处在向高级经理报告链上的全部经理，均是在SQA的任务、责任和权利方面富有独到见解、富于智慧和决策能力的管理者。 3．保证支持SQA活动的工具好用。 支持工具的例子有： ──工作站 ──数据库程序 ──电子表格程序 ──审计工具 能力3：SQA组的成员要接受培训，以利于完成他们的SQA活动。 培训的例子有： ──软件工程技巧和实践 ──软件工程组和其他软件有关组的岗位及职责 ──用于软件工程的标准、规程和方法 ──软件项目的应用领域 ──SQA的对象、规程和方法 ──SQA组对软件活动的参与 ──SQA方法和工具的有效使用 ──人员间的交流 能力4：软件项目的成员接受有关SQA组的任务、职责、权利和价值的定向培训。 执行活动（Activities Performed，AC） 活动1：按照已建档的规程为软件项目制定SQA计划。 该规程一般规定： 1．SQA计划的制定是在项目策划的早期阶段，平行于整个项目策划。 2．受影响的组和个人评审该SQA计划。 受影响的组和个人的例子有： ──项目软件经理 ──其他软件经理 ──项目经理 ──顾客的SQA代表 ──SQA组负责解决其报告不符合问题的高级经理 ──软件工程组（包括全部小组，如软件设计小组及软件作业领导） 3．对计划进行管理和控制。 “管理和控制”意味着，在给定时间（过去或现在）内使用的工作产品的版本是已知的（即版本控制），而且以受控的方式引进更改（即更改控制）。 如果希望有比“管理和控制”更高程度的控制，则工作产品可置于配置管理的完备规范之下，正如在“软件配置管理”关键过程域中所描述的。 活动2：按照SQA计划进行SQA组的活动。 该计划包括： 1．SQA组的职责和权利 2．SQA组的资源要求（包括员工、工具和设施） 3．SQA组活动的进度表和投资 4．SQA组参加制定项目的软件开发计划、标准和规程的情况 5．确定将由SQA完成的评价 待评价的产品和活动的例子有： ──运行软件和支持软件 ──可交付的和不可交付的产品 ──软件和非软件产品（例如，文档） ──产品开发和产品验证活动（例如，运行测试用例） ──生成产品时所从事的活动 6．将由SQA组进行的审计和评审。 7．将用做SQA组评审和审计基础的标准和规程。 8．用于对不符合性问题建立文档和进行跟踪直至结束的规程。 这些规程可以作为计划的一部分而纳入计划，也可以通过对包含它们的其他文档进行索引的方式而纳入计划。 9．要求SQA组生成的文档。 10．就SQA活动给软件工程组和其他相关组提供反馈信息的方法和频率。 活动3：SQA组参与准备和评审项目的软件开发计划、标准和规程。 1．SQA就以下几个方面对计划、标准和规程提供咨询和评审： ——对组织方针的符合性 ——对外部强加的标准和要求的符合性（例如，工作陈述所要求的标准） ——适合项目使用的标准 ——在软件开发计划中应阐述的专题 ——项目指定的其他领域 2．SQA组验证计划、标准和规程已到位，并可用于评审与审计软件项目。 活动4：SQA组评审软件工程活动，以验证符合性。 1．用软件开发计划和指定的软件标准及规程，进行评价活动。 参考其他关键过程域中的验证实施共同特性，以便找到包括由SQA组进行特定评审和审计的实践。 2．对偏差进行鉴别和建立文档，并跟踪到结束。 3．验证纠正措施。 活动5：SQA组审计指定的软件工作产品，以验证其符合性。 1．在交付给顾客之前，评价可交付的软件产品。 2．对照指定的软件标准、规程和合同要求，评价软件工作产品。 3．对偏差进行鉴别和建立文档，并跟踪到结束。 4．验证纠正措施。 活动6：SQA组定期向软件工程组报告其活动的结果。 活动7：按照已文档化的规程，对软件活动和软件工作产品中所鉴别出的偏差，建立文档并加以处理。 该规程一般规定： 1．将不符合软件开发计划和指定的项目标准及规程的问题写成文档，并在可能处，与有关的软件作业领导、软件经理或项目经理，一起加以解决。 2．有些不符合软件开发计划和指定标准及规程的问题，不能与软件作业领导、软件经理或项目经理一起加以解决，将这些不符合问题写成文档，并提交给指定的接收不符合问题的高级经理。 3．定期评审提交给高级经理的不符合问题，直至解决它们为止。 4．对不符合问题的文档进行管理和控制。 活动8：SQA组和顾客的SQA人员一起，适时地对软件质量保证的活动和发现进行定期评审。 测量与分析（Measurement and Analysis，ME） 测量1：进行测量，并将测量结果用于确定SQA活动的成本和进度状态。 测量的例子有： ──SQA活动的里程碑完成的情况与计划做比较。 ──在SQA活动中完成的工作、所花费的工作量、所消耗的资金与计划做比较。 ──产品审计和活动评审的次数与计划做比较。 验证实施（Verifying Implementation，VE） 验证1：高级管理者定期参与评审SQA活动。 高级管理者定期评审的主要目的，是在合适的抽象层次上，及时地了解和洞察软件过程活动。评审间隔应满足组织的需求，只要已有报告例外情况的合适机制许可，间隔可以长些。 参考“软件项目跟踪和监督”关键过程域的验证1，以便找到包括高级管理者监督评审典型内容的实践。 验证2：项目经理定期地、按事件驱动方式参与评审SQA活动。 参考“软件项目跟踪和监督”关键过程域的验证2，以便找到包括项目管理者监督评审典型内容的实践。 验证3：独立于SQA组的专家，定期评审SQA组的活动和软件工作产品。 15《CMM软件质量保证过程文件》《CMM软件质量保证过程文件》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 本文档是软件质量保证过程的定义，它规定了角色、进入准则、输入、活动、输出、结束准则等。 1.2 范围(Scope) 本文档只适应于软件质量保证过程。 1.3 术语定义(Terms Glossary) [1] 软件相关组：指软件配置管理组、文档支持组、测试组。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员的集合。 1.4 参考资料(References) [1] Mark C. Paulk等人，《The Capability Maturity Model Guidelines forimproving the software process》，Carnegie Mellon University Software Engineering Institute [2] Mark C. Paulk，《Key practices of the Capability Maturity Model》，Version 1.1，1993 1.5 相关文档(Related Documents) [1] 《软件质量保证程序文件》 1.6 版本更新记录(Version Updated Record) 版本更新记录，如表12-8所示。 表12-8 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/03/03 — — — V1.0.1 — — 王小林 2002/03/16 进入准则维护 2．软件质量保证过程(SQA Process) ──参与角色(Roles) R1：软件质量保证组。 R2：项目经理。 R3：软件工程组代表。 R4：软件相关组代表。 R5：高级经理。 ──进入准则(Entry Criteria) E1：软件项目立项报告或下达任务书。 E2：组织的责任人到位，且经过软件质量保证过程的培训。 ──输入(Inputs) I1：《立项建议书》或《项目合同》。 I2：《软件开发计划》。 ──活动(Activities) A1：SQA组成员与项目经理共同选定开发过程中的标准和规范，并参与《软件开发计划》的评审。 A2：SQA成员按软件质量保证程序文件编制《SQA计划》，并经过相关组及个人的评审。 A3：SQA成员按《SQA计划》/《软件开发计划》，参与软件项目的定期或事件驱动的评审与审计活动。 A4：SQA组对审计出的不符合项，按程序文件进行跟踪处理。 A5：SQA组按程序文件，及时向相关组及个人报告其活动结果。 A6：负责软件质量保证的高级经理，处理软件项目内部不能解决的不符合项。 ──输出(Outputs) O1：软件质量保证计划。 O2：软件工程活动评审报告。 O3：软件工作产品审计报告。 O4：不符合项跟踪报告。 ──结束准则(Finish Criteria) F1：软件项目终止。 ──评审与审计(Reviews andAudits) RA1：SQA主管定期参与评审SQA活动。 RA2：项目经理定期或并事件驱动地参与评审SQA活动。 ──测量(Measurements) M1：SQA组成员按程序文件记录SQA活动实际投入的资源、工作量、进度等数据。 ──培训(Training) T1：对SQA组成员进行SQA知识定向培训。 T2：对非SQA组成员，进行软件工程知识定向培训。 ──工具(Tools) T1：MS Word。 T2：MS Project。 16《CMM软件质量保证程序文件》《CMM软件质量保证程序文件》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 本文档是《软件质量保证过程文件》的补充文件，它规定了《软件质量保证过程文件》中的工作产品定义和执行步骤。 1.2 范围(Scope) 本文档规定了软件质量保证活动的工作产品及其执行步骤。 1.3 术语定义(Terms Glossary) [1] 工作产品，是指软件生存周期各个阶段所产生的文档化的阶段成果，它包括开发文档、管理文档及软件产品。如软件开发计划、概要设计说明书、源程序等。 1.4 参考资料(References) [1] Mark C. Paulk等人，《The Capability Maturity Model Guidelines forimproving the software process》，Carnegie Mellon University Software Engineering Institute [2] Mark C. Paulk，《Key practices of the Capability Maturity Model》，Version 1.1，1993 1.5 相关文档(Related Documents) [1] 《软件质量保证过程文件》 1.6 版本更新记录(Version Updated Record) 版本更新记录，如表12-9所示。 表12-9 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/03/09 — — — V1.0.1 — — 王小林 2002/03/26 术语定义维护 2．软件质量保证过程(SQA Process) 2.1 软件质量保证策划程序(SQA Planning) ──工作产品(Work Product) W1：SQA计划。 W2：SQA计划评审报告。 ──执行步骤(Execute Step) E1：SQA组为软件项目指派SQA成员，并确定其岗位职责。 E2：SQA成员在项目早期，参与制定该软件项目的SQA计划。 E3：SQA成员与项目经理协商识别出该项目的质量保证对象，即该项目的工作产品。 E4：参照《软件质量保证计划制定指南》，制定出该项目的《SQA计划》。 E5：SQA成员估算每个质量保证活动的工作量和所需资源。 E6：项目经理、SQA组、软件相关组评审《SQA计划》。 E7：项目软件开发计划更改时，SQA成员适时调整《SQA计划》。 2.2 定期或事件驱动的评审与审计(Periodic Review and Audit or Review and Audit Drivenby Event) ──工作产品(Work Product) W1：评审报告。 W2：不符合项跟踪表。 ──执行步骤(Execute Step) E1：按照SQA计划，项目组提交工作产品给SQA成员。 E2：SQA成员对提交的工作产品进行评审或审计。 E3：SQA成员填写《评审报告》及《不符合项跟踪表》。 2.3 跟踪处理不符合项(Tracking and Resolution of Noncompliance Items) ──工作产品(Work Product) W1：不符合项跟踪表。 ──执行步骤(Execute Step) E1：SQA成员对每次质量保证活动后产生的不符合项，编制《不符合项跟踪表》。 E2：SQA成员将《不符合项跟踪表》通知项目经理，项目组解决后反馈给SQA成员。 E3：SQA成员对解决的内容进行验证。 E4：SQA成员将项目经理解决不了、或不能由项目经理解决的问题，提交给高层经理解决。 E5：SQA成员对高层经理解决的情况，进行跟踪记录。 2.4 报告活动结果(Report of Activity Results) ──工作产品(Work Product) W1：SQA工作报告。 ──执行步骤(Execute Step) E1：SQA成员编制《SQA工作报告》。 E2：SQA成员将《SQA工作报告》提交给相关经理、相关组及个人。 2.5 软件质量保证管理评审(Assurance Review of Software Quality) ──工作产品(Work Product) W1：SQA管理过程评审报告。 ──执行步骤(Execute Step) E1：SQA组长定期或以事件驱动方式组织召开SQA管理过程评审会。 E2：参加评审会的成员为高级经理、项目经理、独立于SQA组的外部专家。 E3：SQA组长整理《SQA管理过程评审报告》，并改进SQA组的工作。 2.6 记录测量数据(Record of Measurement Data) ──工作产品(Work Product) W1：软件质量保证活动度量表。 ──执行步骤(Execute Step) E1：项目组的SQA成员，每周记录软件质量保证活动，填写到《软件质量保证活动度量表》； E2：SQA成员定期或项目完成后，将度量记录汇总，通报给高级经理和项目经理。 17《软件质量保证计划》《软件质量保证计划》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 软件质量保证计划建立的目的，是为了使软件质量保证组及项目组双方能以此软件质量保证计划为依据，执行一系列的SQA活动，从而对软件过程和软件产品的质量提供可视性管理。 1.2 范围(Scope) 本文档适应于软件项目的质量保证全过程。 1.3 术语定义(Terms Glossary) [1] 软件质量：指软件产品满足用户明确和隐含需求的能力特性的总和。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员集合。 1.4 参考资料(References) [1] 列出有关的参考资料1。 [2] 列出有关的参考资料2。 1.5 相关文档(Related Documents) [1] 列出有关的软件合同。 [2] 列出有关的软件任务书。 1.6 版本更新记录(Version Updated Record) 版本更新记录格式，如表14-3所示。 表14-3 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/04/03 — — — V1.0.1 — — 王小林 2001/04/18 管理机构维护 2．管理机构(Management Organization) 2.1 机构(Organization) 质量保证活动组织关系图见图14-1，它给出了软件组织内部与软件质量保证活动有关的各个小组及个人之间的关系。 图14-1 质量保证活动组织关系图 2.2 职责(Responsibility) 说明与软件质量保证活动有关的各个小组及个人的责任，如表14-4所示。 表14-4 与软件质量保证活动有关的各个小组及个人的责任 小组及个人名称 责 任 高级经理 负责小组之间、部门之间、组织内外的沟通协调 项目经理 负责整个软件项目的业务、技术、资源、活动 软件质量保证组长 保证软件项目的标准、规程、约定得到遵守 软件质量保证成员 制定软件质量保证计划，组织软件质量保证活动，书写软件质量保证报告。重点是对软件工作产品进行评审与审计 续表表 小组及个人名称 责 任 测试组 制定测试计划、用例，组织测试活动，书写测试报告 软件工程组 软件工程项目的分析、设计、编程、测试、培训、实施 配置管理组 软件基线、配置项的认定，配置活动审定，配置资源保证 同行专家 同行专家（外部专家）评审 3．质量保证活动(SQA Activities) 表14-5是《软件质量保证计划任务进度表》(Schedule for SQA)（又称软件质量保证活动表），该表是根据《软件质量保证程序文件》的内容制定的，建议读者将两者结合起来阅读。 表14-5 软件质量保证计划任务进度表 序 号 工作产品名称 组 织 者 参 加 者 计划日期 实际日期 计划工作量 实际工作量 计划资金 实际资金 计划评审次数 实际评审次数 1 《SQA计划》 SQA成员 项目经理、软件相关组 2 《SQA计划》评审报告 SQA成员 项目经理、软件相关组及个人 3 《用户需求报告》评审报告 项目经理 用户、SQA成员、软件相关组、外部专家 4 《用户需求报告》不符合项跟踪表 SQA成员 项目经理、软件相关组 5 《软件需求规格说明书》评审报告 SQA成员 项目经理、软件相关组 6 《软件需求规格说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 7 《概要设计说明书》评审报告 SQA成员 项目经理、软件相关组 8 《概要设计说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 续表表 序 号 工作产品名称 组 织 者 参 加 者 计划日期 实际日期 计划工作量 实际工作量 计划资金 实际资金 计划评审次数 实际评审次数 9 《详细设计说明书》评审报告 SQA成员 项目经理、软件相关组 10 《详细设计说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 11 《Alpha测试报告》评审报告 SQA成员 项目经理、测试组 12 《Beta测试报告》评审报告 项目经理 用户、SQA成员、测试组 13 《用户使用手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 14 《用户安装手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 15 《系统管理手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 16 《SQA工作报告》评审报告 SQA组长 高级经理、项目经理、软件相关组 17 《SQA管理过程》评审报告 SQA组长 高级经理、项目经理、外部专家 18 软件质量保证活动度量表 SQA成员 高级经理、项目经理 其中，用户需求报告评审和Beta测试报告评审的组织者均为项目经理，这是因为这两次评审均需用户参与，并且要用户确认。 4．工具、技术和方法(Tools，Technique and Methods) 根据需要，指明SQA计划中用到的工具、技术和方法。 5．对供货商的控制(Controls to the Suppliers) 供货商包括软件外包商和软件产品销售商，对外包商承包开发软件的过程管理，要按照CMM2的关键过程域“软件子合同管理”(SoftwareSubcontract Management)进行管理。对销售软件产品的销售商，要按照软件组织事先定义好的标准进行控制。 6．活动记录的收集和整理(Collecting，Maintaining and Keep Records) 对SQA计划实施中的活动记录要整理入库，长期保存，由它可生成《软件质量保证活动度量表》，送给高级经理、项目经理阅读。]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[医院信息管理信息系统]]></title>
    <url>%2Fposts%2F8499.html</url>
    <content type="text"><![CDATA[本手册以系统中的各功能模块为线索，以医院服务主要流程为导向，简单描述了医院信息管理系统中各主要模块的功能及操作方法，主要面向广大的软东医院信息管理系统的用户，目的在于协助其尽快掌握软件的基础使用与操作，同时也可以作为集中培训的基础教材。 前言因本手册其旨在于给医院各岗位工作人员提供快速操作指导，内容不足之处，敬请原谅，若有疑难问题请致电公司客服中心，我们将竭诚为您服务！ 系统简介“软东医院信息管理信息系统”是一套集成门诊挂号收费、住院收费、 药品管理等工作站的医院网络管理系统，本系统适应于二级医院，它操作简单方便，性能稳定；支持按大类收费和明细收费；大类项目和明细项目都能自定义；支持多种发票格式和收据格式，并且每种发票格式都可以自由修改；药品管理部分参考了国外一些优秀医院网络系统的先进经验，具有完善的药品进销存管理包括药品调价报损退库等强到管理功能，处方从门诊收费到药房完全通过网络传输，完全实现无纸化，数据一次性发生，摆药发药全部自动完成，99% 以上的操作实现了零输入。本系统采用先进的服务器客户端结构，客户端运行的只是和用户交互的界面，安装方便，对硬件的要求也极低，只要能运行winXP 以上操作系统的计算机都能正常运行。 系统配置 服 务 器 硬件最低配置 2.0G CPU/2G内存/250G双硬盘 硬件推荐配置 2.8G CPU/4G内存/500G双硬盘 支持Raid-1 操作系统 Windows 2003 server 数据库平台 MS SQLserver2008 工 作 站 操作系统Windows 2003/XP 系统登录点击RdClientManage.exe进入系统后，会有登录界面出现。 输入用户名的助记码，按回车键，如果用户存在，系统将自动显示该用户所对应的科室，输入口令，单击登录或者按回车键。如果口令正确，将根据系统管理员设置给该操作员的权限来登录系统。若口令不正确，系统将提示错误信息。如果不想进入系统点击取消即可。 门诊部分1.1挂号管理1.1.1门急诊挂号 在左边导航栏中出现“挂号管理”的子系统图标，右边会列出挂号管理子系统的主要模块。如下! 找到门急诊挂号模块图标点击进入。如下! 根据要求填写相关信息，输入病人姓名等信息，可以使用回车键进行下一栏的输入（诊疗号不需要手动输入，系统会自动生成），填写完之后单击‘保存’，保存的病人信息会在挂号信息处显示。(保存完成后，系统会自动产生诊疗号和门诊号)如图： 如果要查看是否有预约患者的话，可以单击预约患者信息来查看。 如图： 如果未领票或票已用完系统也会给出提示信息. 如果在保存之前不对该病人进行信息输入，可以单击‘取消’。保存之前，但是信息已经输入完整，可以对该病人信息进行‘删除’。操作完成后，单击‘退出’以退出该界面。 1.1.2 挂号退号 在挂号管理窗口中选择挂号退号，如图： 输入该病人所对应的发票号或门诊号，单击‘查询’，选中该病人信息，单击‘确定’即可对该病人进行退号。发票号或门诊号输入错误时，单击‘取消’，重新输入。 1.1.3 门诊病人信息修改 在挂号管理窗口中选择门诊病人信息修改，进入如下界面： 输入病人挂号时的门诊号或诊疗号，单击‘查询’，就可以对查出来的病人的信息进行修改，修改完成后单击‘确定’，否则单击‘取消’，操作完成后单击‘退出’。 1.1.5 操作员挂号报账单 在挂号管理窗口中选择专家挂号，进入如下界面： 选择起始时间和结束时间以及需要的统计类型和打印方式、所要报账的操作员，单击确定。 1.2.1门诊管理 在左边导航栏中找到门诊医生站子系统图标点击进入门诊管理子系统，右边会列出门诊管理子系统的主要模块。找到门诊医生工作站模块图标点击进入。 门诊医生工作站窗口打开： 如果病人是按专家挂号或者选择了相关医师，那么就选择左边的‘个人’按钮，如果病人按科室挂号，那么就选择左边的‘科室’按钮。 如果挂过号的病人信息没有出现，那么就单击‘刷新列表’。 若病人信息为白色，可以按鼠标右键，弹出菜单，点击‘呼叫病人’就可以将病人转化为待诊状态。 也可以将处于待诊状态的病人通过按鼠标右键的方法将其转为续诊。 若病人信息为橘黄色，则表明该病人处于待诊状态，可以就诊，双击病人信息，就会将病人的详细信息输出，如图所示： .医生可以根据病人的情况填写相关内容（门诊病历、检查治疗、药品处方）。在填写过程中，输入栏中出现图标时，表示可以进行选择，也可以手动输入。如图： 使用从待选项移到已选项，也可以手动输入进行筛选，然后单击‘确定’。 在输入‘检查治疗’‘药品处方’‘中草药处方’时，单击‘新增’就可以输入相关内容，选择处方内容时，可以输入药品名称汉语拼音的第一个字母按‘回车键’就可以出现相关信息，如图： 完成后单击‘保存’， 1.2.2诊断证明在右边列出的门诊管理子系统的主要模块中找到诊断证明模块图标点击进入。 1.2.3个人处方维护在右边列出的门诊管理子系统的主要模块中找到个人处方模块图标点击进入： 个人处方维护所列出的组合名称只能为常用药品、常用检查、常用检验，在此维护的信息将在门诊医生工作站处调用。 1.2.4门诊医生接诊患者信息查询在右边列出的门诊管理子系统的主要模块中找到门诊医生急诊患者信息查询模块图标点击进入。 输入要查询的条件，单击‘查询’即可找到要查询的科室、医师所对应的所有病人信息。 1.3 门诊收费站1.3.1门诊划价收费在左边导航栏中找到门诊管理子系统，右边会列出门诊收费站子系统的主要模块。找到门诊划价收费模块图标点击进入。输入就诊号或挂号号如图： 单击‘确定’，屏幕中会列出该病人所有要划价的费用，如图： 单击‘保存’，如图： 最后单击确定即可。如果以上信息输入不正确，可以单击‘取消’，重新输入。 1.3.2 病人信息维护在右边的主要模块中找到病人信息维护模块图标点击进入，如图： 根据需要输入相关信息（所有部门、检索条件、是否在院都是可选的），单击回车键或‘查询‘按钮，如图： 选中要修改的病人，单击‘编辑’按钮，如图： 修改完成后单击‘确定’即可。 1.3.3 门诊发票重打在右边的主要模块中找到门诊发票重打模块图标点击进入，如图： 单击要重新打印的发票或输入要打印的发票号，单击‘确定‘，如图; 需要重打的话单击‘确定‘，不需要的话单击‘取消’。 1.3.4 门诊退费在右边的主要模块中找到门诊退费模块图标点击进入，输入诊疗号或发票号，如图： 双击该发票号对应的信息，如图： 选择要退的费用，单击‘保存’ 如图： 单击‘确定’即可退费，否则不退费。 1.3.5 门诊日结账（在启用日结配置的情况下才能使用）在右边的主要模块中找到门诊操作员结账模块图标点击进入，如图： 根据具体需要进行选择。 1.3.6 结账信息取消（该功能慎用）在右边的主要模块中找到结账信息取消模块图标点击进入，如图： 输入要撤销结账的操作员代码，如图： 如果要撤销记账的话，选中要撤销的账目，如果需要的话选中删除结账信息单选框，直接单击‘撤销结账数据’，如图： 住院部分根据系统管理员设置给该操作员的权限来登录系统。若口令不正确，系统将提示错误信息。如果不想进入系统点击取消即可。点击左边的住院管理系统，右边会出现相关模块 2.1入院2.1.1 入院登记双击右边的入院登记模块进入如图界面： 单击‘新增’按钮，输入要住院的病人信息（从‘姓名栏’开始可以用‘回车键’依次输入其他信息），单击保存，如图： 然后单击‘确定’，出现如下对话框： 如果要打印病历首页的话，单击‘确定’，否则单击‘取消’。 2.1.2 新生儿入院登记双击右边的新生儿入院登记模块进入如图界面： 单击‘新增’，输入相关信息（输入母亲的住院号，按‘回车键’进行其他项的选择），完成后单击 ‘保存’，出现如下对话框： 再次输入母亲住院号，单击回车键，会出现对应孩子的信息，如图： 双击该婴儿的信息，就可以对婴儿信息进行编辑。 2.1.3 入院登记许可项配置双击右边的入院登记许可项配置模块进入如图界面： 对需要的项打上勾，然后单击提交。 2.2住院医生站2.2.1 导航管理双击右边的导航管理模块进入如图界面： 选中某一病人，单击鼠标右键，会出现长期医嘱、临时医嘱、账目查询、电子病历、床头卡等选项，根据需要进行选择。 例：建立长期医嘱：如图： 单击‘新增’，输入要增加的长期医嘱，如图： 输入完成后，单击保存，如图：，保存完成后，要进行‘确认’，如图： 之后再单击‘保存’，如图 如果确定该遗嘱的话，单击确定即可，否则单击取消，对该医嘱进行‘追加’、‘修改’、‘作废’等操作。对该病人进行长期医嘱时，也可填写临时医嘱。 2.2.2 住院电子病历双击右边的住院电子病历模块进入如图界面： 用鼠标选中左边的病人信息，右击鼠标，会出现收治患者、病案首页、书写病历、病历套打、会诊管理等选项，根据要求进行选择。 例： ‘病案首页’：（如果登录医生不是该病人的主治医生，那么如果要为该病人书写病案首页时，就要先收治该病人） 填写病人的基本情况、诊断情况、治疗情况，完成后单击‘保存’即可。 2.3住院收费2.3.1 住院划价记账双击右边的住院划价记账模块进入如图界面： 可以在对应的科室下面选择病人，也可以输入病人的住院号，按回车键调出病人的相关信息，输入执行科室和收费项目（收费项目可以输入项目的汉语拼音的第一个字母按回车键进行选择），然后单击保存。如果该病人余额不足，如果有“欠费权限的话”可以在‘允许欠费’栏输入金额或者在有担保人的情况下可以填写相关的担保金额。 2.3.2 允许欠费金额设置双击右边的允许欠费金额设置模块进入如图界面： 输入相关的检索条件，单击‘查询’，就可以调出该病人的信息（用以核对），如图： 然后在设定允许欠费金额文本框中输入允许欠费金额，单击‘设定’，如图： 表示设定成功。 2.3.8 增加担保人双击右边的增加担保人模块进入如图界面： 在左边的菜单栏根据科室选择病人或输入病人的住院号，按‘回车键’调出病人的相关信息，然后填写担保人、担保金额等内容。输入完成后，单击‘保存’即可。 2.3.3 预交款管理双击右边的预交款管理模块进入如图界面： 在左边的菜单栏根据科室选择病人或输入住院号，按回车键，调出病人的相关信息，然后输入缴款金额，单击‘收费’按钮即可，如图： 该页面的下面还会出现该病人的明细账信息，如果要该病人要退费的话，可以选择相关的要退的费用，单击‘退费’按钮即可，如图： 2.3.4 预交款发票重打双击右边的预交款发票重打模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键，页面中会出现该病人所有的预交款信息，如图： 选择要重打的发票，单击‘重打’按钮进行重打，如图： 单击‘确定’即可重打，否则‘取消’。 2.3.5 住院收入按科室统计双击右边的住院收入按科室统计模块进入如图界面： 选择要统计的起止时间、科室等信息，单击‘确定’即可。 2.3.6 住院收入按医师统计 选择要统计的起止时间、医师等信息，单击‘确定’即可。 2.3.7 病人费用类别修改双击右边的病人费用类别修改模块进入如图界面： 输入住院号，按回车键调出病人基本信息，然后输入要修改的病人费用类别信息，单击‘转换’即可。 2.3.9 住院退费双击右边的住院退费模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键调出病人的相关信息和相关费用，如图： 选中需要退的费用，然后单击‘保存’，如图： 需要退的话，单击‘确定’，否则单击‘取消’。 退费成功后，可以单击‘显示退费’，即可以看到该病人的退费情况。如图： 2.3.10 滚动退费双击右边的滚动退费模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键调出病人信息和相关的滚动费用，如图： 选择要退的滚动费用，单击保存即可，如图： 2.3.11 病人账目查询双击右边的病人账目查询模块进入如图界面： 输入病人的住院号，按回车键，调出病人的相关信息。如图： 可以通过按‘总账信息’，‘明细账信息’，‘未发药品信息’，‘未记账医嘱’按钮得出相关信息。 2.3.12 病人账目结算双击右边的病人账目结算模块进入如图界面： 输入病人的住院号，按回车键调出病人信息，（如果该病人有未发药品，系统会出现如下对话框： 发药动作完成后，就可以正常结算，单击‘确定’，会出现“确定现在办理患者结算手续吗”的对话框，单击‘确定’即可办理结算手续，如图： 。 2.3.13 结算召回 双击右边的结算召回模块进入如图界面： 在左边的菜单中根据科室选择结算的病人信息或输入要召回的病人的住院号，单击‘查询’，如果确定要召回该病人的话就单击‘确定’，如图： 2.3.14 住院结账双击右边的住院结账模块进入如图界面： 2.3.15 催拖欠款 双击右边的催拖欠款模块进入如图界面： 以上即为所有欠款病人的信息。 2.3.16出院发票重打双击右边的出发票重打模块进入如图界面： 左边的菜单会列出相关的出院病人信息，选择出院病人或输入住院号，按回车键调出出院的病人信息，如图： 单击‘确定’即可完成发票重打。 2.3.17 出院收入按医师统计 双击右边的出院收入按医师统计模块进入如图界面： 输入要统计的信息，按‘确定’即可。 2.3.18出院收入按科室统计 输入要统计的信息，按‘确定’即可。 2.3.19出院病人账目查询双击右边的出院病人账目查询模块进入如图界面： 输入要查询的病人的住院号，按‘回车键’调出病人的相关信息，通过按‘总账信息’，‘明细账信息’查出对应的账目信息。 2.4护士站2.4.1 导航管理 双击右边的导航管理模块进入如图界面： 选择要执行医嘱的病人信息，按鼠标左键，会出现长期医嘱、临时医嘱、床位调整、账目查询、出院结算等选项卡。以长期医嘱为例，如图： 如果该护士对该病人执行了以上操作，就可以单击‘查对’，如果病人余额不足，就可以选择部分查对，如图： 2.4.2 长期医嘱单双击右边的长期医嘱单模块进入如图界面： 输入已经执行的长期医嘱的病人的住院号，如图： 单击确定，就可以看到该病人的长期医嘱单。 2.4.3 临时医嘱单临时医嘱单的操作同长期医嘱单。 2.4.4 转床管理双击右边的转床管理模块进入如图界面； 输入要转床的病人的住院号按回车键就会调出病人的原床位号，然后输入病人要转入的现床位号，单击保存即可。 2.4.5 包床设置双击右边的包床设置模块进入如图界面： 输入住院号，调出相关信息，按‘包床’键即可 2.4.6 临时加床双击临时加床模块进入如图界面： 选择科室名，对该科室按照提示进行临时加床。 2.4.7 临时撤床双击右边的临时撤床模块进入如图界面： 选择科室名，对该科室按照提示进行临时撤床。 2.4.8 转科管理双击右边的转科管理模块进入如图界面： 2.4.9 在院病人一日清单双击右边的在院病人一日清单模块进入如图界面： 选择要统计的方式（按住院号还是按科室），修改要统计的起止时间，按‘确定’键即可。 2.5.10 出院病人一日清单双击右边的出院病人一日清单模块进入如图界面： 出院病人一日清单操作同在院病人一日清单 2.5.11 请领药单（汇总）双击右边的请领药单（汇总）模块进入如图界面： 如果是住院药房的话选择住院药房，起始时间为上次打印或预览的时间，终止时间为当前时间，根据需要进行选择（重打（注：要输入申请号）、预览、打印），单击‘确定’即可。 2.5.12 请领药单（明细）双击右边的请领药单（明细）模块进入如图界面： 选择医嘱类型和药品类别，其他操作同请领药单（汇总） 2.5.13 静滴单（输液卡）双击右边的静滴单（输液卡）模块进入如图界面： 输入住院号，选择要打印或预览的静滴单的起止时间，单击确定即可，如果要按科室查询的话，就选择‘是否按科室查询’单选框，单击确定即可。 2.5.14 请领药单（口服和非口服）双击右边的请领药单（口服和非口服）模块进入如图界面： 操作同请领药单（汇总）。 2.5.15 口服药单双击右边的口服药单模块进入如图界面： 基本操作同静滴单 2.5.16 注射单双击右边的注射单模块进入如图界面： 操作同口服药单。 2.5.17 处置单（医技）双击右边的处置单模块进入如图界面： 操作同上。 2.5.18 治疗处方单双击右边的治疗处方单模块进入如图界面： 2.5.19 皮试结果查询双击右边的皮试结果查询模块进入如图界面： 输入住院号就会出现做过皮试的病人的皮试结果信息查询。 2.5.20 护理记录单双击右边的护理记录单模块进入如图界面： 记录护士在护理过程中病人的基本信息。 2.5出院2.5.1 出院 双击右边的出院模块进入如图界面： 左边菜单会出现相关的可以出院的病人或输入住院号，按回车键，单击‘确定’如图： 要办理出院的话，直接单击‘确定’即可。否则单击‘取消’。 2.5.2 出院病人召回管理双击右边的出院病人召回管理模块进入如图界面：** 输入要召回的病人的住院号，按‘回车键’调出病人的信息，单击‘确定’即可。 药库药房部分3.1 药库管理 3.1.1. 药品初始录入双击右边的药品初始录入模块进入如图界面： 选择药房名称、库房名称等信息（输入药品名称的时可以输入药品名称的汉语拼音的首字母，按回车键，选择相关药品）。输入完成后，单击‘保存’即可。 3.1.2药品入库双击右边的药品入库模块进入如图界面： 点击‘新增’，输入入库的药品信息，如图： 单击‘保存’即可。 3.1.3 药品库存调整双击右边的药品库存调整模块进入如图界面： 输入调整部门，点击‘显示’，屏幕中会列出该药房的所有药品信息，如图： 也可以在按拼音码检索中输入药品的汉语拼音的首字母，如图： 选中要调整的药品，，输入实际库存和调整原因，单击‘确定’，如图： 点击‘调整’即可，如图： 3.1.4 药品调拨管理双击右边的药品调拨管理模块进入如图界面： 单击‘新增’，输入要调拨的库房名称和药品，如图： 单击‘保存’即可，如图： 也可以对已经调拨的药品进行编辑，单击‘编辑’，如图： 选择要编辑的药品，进行‘编辑’即可。 保存完成后，要对药品信息要进行审核，单击‘审核’，如图： 选中要审核的药品信息，双击即可。 3.1.5 药品盘点双击右边的药品盘点模块进入如图界面： 单击‘新增盘点表’，如图： 如果要显示这些药品对应的库存，可以单击‘导入库存’，盘点完成后，单击‘保存’，数据无误后，单击‘审核’、‘保存’，药品盘点任务完成。 3.1.6药品库存上下限维护双击右边的药品库存上下限维护模块进入如图界面： 输入库存下限和库存上限，单击‘保存’即可，如图： 3.1.7药品调价双击右边的药品调价模块进入如图界面： 单击‘新增’，输入相关信息（文件号、调价原因必写），输入药品的新购入价如图： 单击保存即可，如图： 保存之后，要对修改过的信息进行审核，点击‘审核’，如图： 选择部门，单击‘查询’，选择要审核的调价号，单击‘确定’，如图： 选中要审核的药品信息，单击‘确定’即可。 3.1.8药品报损管理双击右边的药品报损管理模块进入如图界面： 单击‘新增’，选择损益类别，输入报损的药品数量，如图： 单击‘保存’即可，如图： 保存完成后，要对输入的信息进行审核，单击‘审核’，如图： 双击要审核报损信息或者选择该审核报损信息单击‘确定’，再次单击‘保存’即可审计成功，如图： 单击‘确定’； 3.1.9药品购物计划双击右边的药品购物计划模块进入如图界面： 单击‘新增’，输入相关信息，即可出现该库房的药品记录信息，如图： 如果只想显示小于库存下限的药品信息，可以在药品信息（仅显示小于库存下限的药品）前面方框点击即可。也可以利用辅助查找（输入药品汉语拼音的第一个字母）来查找有关药品信息。 选中某一药品，右击，会出现‘定位查找’，‘添加到购物计划明细’对话框。 定位查找，如图：点击‘ok’进行查找。 也可以利用单价进行查找。 添加到购物计划明细，输入采购数量和购入价等相关信息，单击‘保存’，如图： 确定信息无误后，单击‘审核’，如图： 选中要审核的药品，单击‘保存’即可，如图： 完成购物计划后，点击‘保存’即可。会出现相关的审核单； 3.1.10药品退货管理双击右边的药品退货管理模块进入如图界面： 单击‘新增’，输入相关信息和要退的药品信息，如图： 单击‘保存’即可。保存完成后，也要对该信息进行审核。 3.1.11 药库药品出入库汇总双击右边的药库药品出入库汇总模块进入如图界面： 选择要统计的药库名称、历史数据、汇总数据的时间，单击‘汇总’即可。 3.1.12 药房药品出入库汇总双击右边的药房药品出入库汇总模块进入如图界面： 选择要统计的药库名称、历史数据、汇总数据的时间，单击‘汇总’即可。 3.2药房药房操作员根据自己的代码进入药房管理系统，如图： 3.2.1药房发药双击右边的药房发药模块，如图所示： 确定是门诊发药还是住院发药，选择药方名称，系统会调出相关的未发药的病人信息，如果病人过多的话，也可以通过输入诊疗号按回车键调出该病人的未发药的信息。如图： 发完药后，点击‘确定’即可，如图： 点击‘确定’之后，会打印相应的发药单； 3.2.2药房退药双击右边的药房发药模块，如图所示： 选择退药的部门，单击‘查询’，如图： 选择要退药的病人信息，单击‘确定’，然后双击该病人信息，如图： 选择要退的药品，单击‘确定’，如图： 单击是，即可完成退药，否则单击‘否’。 3.2.3 药品有效期管理双击右边的药品有效期管理模块，如图所示： 根据提示，输入要查询的药品的有效期，单击‘查询’即可。 3.2. 4药房药品维护双击右边的药房药品维护模块，如图所示： 输入库存上下限，单击‘保存’即可。 3.2.5药品医保类型维护双击右边的药品医保类型维护模块，如图所示： 输入要将修改的药品的汉语拼音的首字母或药品编号、药品名称等相关信息，调出该药品的信息，选择‘修改’按钮，如图： 选择该药品的医保类型，最后‘保存’即可。 3.2. 6药品划价双击右边的药品划价模块，如图所示： 左边列出了已挂号未划价的病人信息，对该病人信息进行双击，如图： 输入处方的药品名称，如图： 单击保存即可：]]></content>
      <categories>
        <category>case</category>
      </categories>
      <tags>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术变化那么快，如何做到不被淘汰]]></title>
    <url>%2Fposts%2F63607.html</url>
    <content type="text"><![CDATA[在浩大的软件世界里，作为一名普通程序员，显得十分渺小，甚至会感到迷茫。我们内心崇拜技术，却也对日新月异的技术抱有深深的恐惧。有时候我会思考难道在技术领域内不断紧跟新潮，不断提升技能就是我的价值所在？那么我是技术的主人还是技术的奴隶？ 人之所以迷茫往往是找不到工作生活的重心，感受不到工作或生活的价值。那么什么是价值呢？说的大一点就是我改变了世界，说的小一点就是我的所作所为改善了某些问题。如果不清楚自己的行为、目标、价值三者的关系，那么又何来重心？又如何能分得清重要性与优先级呢？ 程序员的迷茫不仅仅是面对技术繁杂的无力感，更重要的是因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致。 很多程序员打心底不喜欢业务，这一点我曾经也经历过，我更宁愿从事框架工具、技术组件研究的相关事情。我有个朋友经常吐槽我说：”你们天天加班加点写了那么多代码，然后呢？有改变什么吗？还不是写出了一堆垃圾。”仔细想想很多时候业务在我们脑海中存留的只是逻辑和流程，我们丢失的是对业务场景的感受，对用户痛点的体会，对业务发展的思考。这些都是与价值紧密相关的部分。我们很自然的用战术的勤快掩盖战略的懒惰！那么这样的后果就是我们把自己限死在流水线的工位上，阉割了自己能够发现业务价值的能力，而过多关注新技术对职场竞争力的价值。这也就是我们面对繁杂技术，而产生技术学习焦虑症的根本原因。 业务、技术与软件系统的价值链那么什么是业务呢？就是指某种有目的的工作或工作项目，业务的目的就是解决人类社会与吃喝住行息息相关的领域问题，包括物质的需求和精神的需求，使开展业务活动的主体和受众都能得到利益。通俗的讲业务就是用户的痛点，是业务提供方（比如公司）的盈利点。而技术则是解决问题的工具和手段。比如为了解决用户随时随地购物的业务问题时，程序员利用web技术构建电子商务App，而当需求升级为帮助用户快速选购商品时，程序员会利用数据算法等技术手段构建推荐引擎。技术如果脱离了业务，那么技术应用就无法很好的落地，技术的研究也将失去场景和方向。而业务脱离了技术，那么业务的开展就变得极其昂贵和低效。 所以回过头来我们想想自己没日没夜写了那么多的代码从而构建起来的软件系统，它的价值何在呢？说白了就是为了解决业务问题，所以当你所从事的工作内容并不能为解决业务问题带来多大帮助的时候，你应该要及时做出调整。那么软件系统又是如何体现它自身的价值呢？在我看来有如下几个方面的体现： 业务领域与功能：比如支付宝立足支付领域而推出的转账、收款功能等，比如人工智能自动驾驶系统等。 服务能力：这就好比火车站购票窗口，评判它的服务能力的标准就是它能够同时处理多少用户的购票业务，能不能在指定时间内完成购票业务，能不能7*8小时持续工作。对应到软件系统领域，则表现为以下三个方面： 系统正确性(程序能够正确表述业务流程，没有Bug) 可用性（可以7＊24小时＊365不间歇工作） 大规模（高并发，高吞吐量） 互联网公司正是借助大规模的软件系统承载着繁多的业务功能，使其拥有巨大的服务能力并借助互联网技术突破了空间限制，高效低廉解决了业务问题，创造了丰厚的利润，这是人肉所不可比拟的。 理解了这一层面的概念，你就可以清楚这个价值链条：公司依靠软件系统提供业务服务而创造价值，程序员则是通过构建并持续演进软件系统服务能力以及业务功能以支撑公司业务发展从而创造价值。 有了这个价值链条，我们就可以反思自己的工作学习对软件系统的服务能力提升起到了多大的推动作用？可以反思自己的工作学习是否切实在解决领域的业务问题，还是只是做一些意义不大的重复性工作。 前两天面试了一个候选人，他的工作是从事票务系统开发，他说自己在研究linux内核与汇编语言，我就问他linux内核和汇编语言的学习对你的工作产生了哪些帮助？能否举一个例子？他哑口无言，我内心就觉得这样一个热爱学习的好苗子正迷茫找不到重心，正在做一件浪费精力的事情。正确的学习方式应该是将学习与具体业务场景结合起来，和公司通过软件系统开展业务服务而创造价值，程序员通过提升软件系统服务能力创造价值这一链条串接起来，从对这些价值产生帮助的程度去思考优先级。学习本身没有错，错的往往就是那颗初心。 现在你再来看高并发分布式相关的知识，你会发现并不是因为这些知识比较高深、比较时髦，很多公司有需求才值得学习，而是他们对价值链条有着实实在在的贡献。 价值驱动的架构一谈到软件系统，人们免不了想起架构这件事来。之所以此处去谈及架构是因为每一个程序员本质都是软件架构体系中的一分子，我们可能深埋于体系流水线之中，感受不到位置和价值。但如果站在架构这一高度去看这些问题则将会非常透彻。那么架构究竟是什么？和上述的价值链又有什么关系呢？ 什么是架构？在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义： 组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。 组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如RPC框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。 组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。 组织全局，对外输出：架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。 所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。 很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。 成本与收益正如之前所说软件系统只有在运行的时候才能创造价值，也就是说软件系统能否7*24小时＊365天稳定的工作关系到公司的收益水平。所以开发团队对生产环境的发布总是小心翼翼，对解决生产环境的问题总是加班加点。而软件系统的成本则体现在软件构建过程，这时候我们就能理解那些工程技术如项目管理、敏捷开发、单元测试、持续集成、持续构建，版本管理等的价值了，他们有的是保证软件系统正确性，有的是为了降低沟通成本，有的是为了提升开发效率等但总的来说就是为了降低软件的构建成本。所以在提升系统服务能力，创造更多业务收益的同时，降低构建成本也是一种提升收益的有效手段。 作为一名软件工程师而言，我们往往处在软件构建过程体系中的某个环节，我们可以基于成本与收益的关系去思考自己每一项技能的价值，学习新的有价值的技能，甚至在工作中基于成本与收益的考量选择合适的技术。比如在逻辑不大发生变化的地方，没有必要去做过多的设计，应用各种花俏的设计模式等浪费时间。这样我们才能成为技术的主人。 架构目标需要适应业务的发展架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单300万，基于对未来的可能预测，明年可能有3000万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到2个9还是3个9。 回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。 另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以不久leader就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。 当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。 成也分工，败也分工正如在程序员的迷茫那一章节提到的：程序员的迷茫因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致，所以在这里我想谈谈分工。架构师为了使软件系统更好的服务业务，必然将软件系统生命周期进行拆分，比如分出开发生命周期、测试生命周期、用户访问生命周期、软件运维生命周期，并根据不同的生命周期划分出不同的职责与角色。 比如开发人员负责开发周期负责完成软件研发，测试人员负责对开发人员交付的成果进行测试等，于是就形成了分工。一旦分工形成，每一个分工组织都会有自己的价值追求，架构师关注的顶层的价值即软件系统能否支撑业务增长被分工的形式打碎到各个组织中。分工是有其价值的，他使得复杂昂贵的任务可以被简单、并行、可替换的流水线方式解决。但久而久之，价值碎片化的问题就出现了，比如测试人员只关注找出更多问题，开发人员只关注快速开发更多的系统，运维人员只关注保障系统稳定。 三者之间常常都只站在自己的立场去要求对方怎么做，没有人再关注整体价值，产生诸多矛盾增加软件实施成本。而身处流水线中的一员，又因为困扰于重复性工作，迷茫于工作的意义，甚至感觉自己做为了人的创意与灵感都被扼杀了。所以我的朋友吐槽我说你写了那么多代码然后并没有怎么样是非常有道理的，那是因为我只关注着做为流水工人的价值要求，看不到生态链最顶端的价值。 我们仔细想想那些团队领导，精英领袖哪一个不是为着更广大的价值所负责，比如项目经理只需要关心自身项目的商业价值，而公司CEO则关心公司范畴内所有业务的总体商业价值。所以关注的价值越大且职位也就越高。这些高层领导者们把控着整体的价值链条，及时纠正底层分工组织的价值目标与整体价值目标出现偏差的问题。 从价值出发－找寻学习与工作的新思路迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？ 明确自身的业务相关主体：找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。 向前一步，为更大的价值负责：不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。 像架构师一样思考，用价值找寻重心：人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。 学会连接，构建体系：前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。 或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。 作者简介：空融，网名“D调的暖冬”。现就职蚂蚁金服，从事支付宝身份认证相关领域的技术开发。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle入门笔记]]></title>
    <url>%2Fposts%2F12275.html</url>
    <content type="text"><![CDATA[gradle在语法上是基于Groovy语言的（Groovy 是一种基于JVM的敏捷开发语言，可以简单的理解为强类型语言java的弱类型版本），在项目管理上是基于Ant和Maven概念的项目自动化建构工具。 基础知识准备 Java基础，命令行使用基础 官方文档：https://docs.gradle.org/current/dsl/ Gradle使用指南： https://gradle.org/docs/current/userguide/userguide Android插件文档：https://github.com/google/android-gradle… AndroidGradle使用文档：http://tools.android.com/tech-docs/new-build-system/user-guide Groovy基础： http://attis-wong-163-com.iteye.com/blog/1239819 Groovy闭包的Delegate机制：http://www.cnblogs.com/davenkin/p/gradle-learning-3.html 搭建Gradle运行环境 Gradle 运行依赖JVM，也就是java运行的环境。所以要安装jdk和jre，好像目前的Gradle的运行环境要求jdk的版本在1.6以上，应该的，现在jdk都到1.8了。 然后到Gradle官网现在Gradle的压缩包。地址，这个页面里面又两种方式，一种手动安装，一种通过脚本安装。我一般喜欢自己动手，这样将来清理起来比较方便。 下载压缩包后，解压，然后配置环境变量，手动安装过jdk的人应该都配置环境变量很熟了吧。每个平台下配置环境变量的方式不一样 MacOS 下配置。在~/.bash_profile中添加如下代码 1234#gradle 注意gradle-2.14.1是自己解压的路径export GRADLE_HOME=$&#123;HOME&#125;/gradle-2.14.1PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/binexport PATH 保存后在终端输入source ~/.bash_profile回车执行让刚刚的配置生效。然后命令行输入gradle -v查看是否安装成功。 12345678910111213$ gradle -v------------------------------------------------------------Gradle 2.14.1------------------------------------------------------------Build time: 2016-07-18 06:38:37 UTCRevision: d9e2113d9fb05a5caabba61798bdb8dfdca83719Groovy: 2.4.4Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_111 (Oracle Corporation 25.111-b14)OS: Mac OS X 10.12.2 x86_64 有用的信息 您可以每两个月通过Gradle核心工程师免费注册现场培训 我们的指南和参考文件制作了很好的阅读材料 您可以使用构建扫描来可视化和调试您的构建 该摇篮通讯是跟上最新与制作月度问题的好方法 命令行完成脚本可用于bash和zsh Gradle在所有主要操作系统上运行，只需要安装Java JDK或JRE版本7或更高版本。检查，运行java -version： 12$ java -versionjava version &quot;1.8.0_121&quot; 安装gradle与包管理器一起安装安装SDKMAN安装SDKMAN！在类UNIX平台上一样简单。SDKMAN！在Mac OSX，Linux，Cygwin，Solaris和FreeBSD上顺利安装。我们也支持Bash和ZSH shell。只需打开一个新的终端并输入： 1$ curl -s &quot;https://get.sdkman.io&quot; | bash 按照屏幕上的说明完成安装。接下来，打开一个新的终端或输入： 1$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 最后，运行以下代码片段以确保安装成功： 1$ sdk version 如果一切顺利的话，应该显示版本。就像是： 1sdkman 5.0.0+51 卸载SDKMAN在不太可能发生的情况下，您想要卸载SDKMAN！，我们还没有自动执行此操作的方法。如果你确实想把它从你的系统中删除，那么这样做很容易。下面将指导你完成备份，然后从系统中删除整个安装。 12tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman 最后一个步骤涉及编辑和您删除初始化片段 1.bashrc ， 1.bash_profile 和/或 1.profile 文件。如果您使用ZSH，请将其从 1.zshrc 文件中删除。要删除的代码片段如下所示： 12#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; ]] &amp;&amp; source &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; 一旦删除，您已经成功卸载SDKMAN！从你的机器。 安装SDKMAN到自定义位置可以安装SDKMAN！到一个自定义的位置以外 1$HOME/.sdkman 。这可以通过 1SDKMAN_DIR 在安装之前导出您的自定义位置来实现。 只需打开一个新的终端并输入： 1$ export SDKMAN_DIR=&quot;/usr/local/sdkman&quot; &amp;&amp; curl -s &quot;https://get.sdkman.io&quot; | bash 为了这个工作，至关重要的是你的用户有这个文件夹的完全访问权限。它也是重要的，该文件夹不存在作为SDKMAN！将尝试创建它。 自动安装gradle1$ sdk install gradle 4.5 Homebrew是“macOS缺少的包管理器”。 1$ brew install gradle Scoop是受Homebrew启发的Windows命令行安装程序。 1$ scoop install gradle chocolatey是“Windows的包管理器”。 1$ choco install gradle MacPorts是一个在macOS上管理工具的系统： 1$ sudo port install gradle 手动安装gradle下载最新的Gradle发行版目前的Gradle版本是在2018年1月24日发布的版本4.5。分发zip文件有两种版本： 仅限二进制 （sha256） 完整的文档和来源（sha256） 如果有疑问，请选择仅二进制版本，并在线浏览文档和来源。 解压分发Linux和MacOS用户解压缩您选择的目录中的分发zip文件，例如： 1234$ mkdir /opt/gradle$ unzip -d /opt/gradle gradle-4.5-bin.zip$ ls /opt/gradle/gradle-4.5LICENSE NOTICE bin getting-started.html init.d lib media Microsoft Windows用户C:\Gradle用文件资源管理器创建一个新目录。 打开第二个文件资源管理器窗口，并转到下载Gradle分配的目录。双击ZIP存档以显示内容。将内容文件夹gradle-4.5拖到新创建的C:\Gradle文件夹中。 或者，您可以C:\Gradle使用您选择的归档工具将Gradle发行版ZIP解压缩。 配置您的系统环境Linux和MacOS用户配置您的PATH环境变量以包含bin解压缩分发的目录，例如： 1$ export PATH=$PATH:/opt/gradle/gradle-4.5/bin Microsoft Windows用户在文件资源管理器中，右键单击This PC（或Computer）图标，然后单击Properties- &gt; Advanced System Settings- &gt; Environmental Variables。 在System Variables选择下Path，然后单击Edit。添加一个条目C:\Gradle\gradle-4.5\bin。点击确定保存。 验证您的安装打开控制台（或Windows命令提示符）并运行gradle -v以运行gradle并显示版本，例如： 12345$ gradle -v------------------------------------------------------------Gradle 4.5------------------------------------------------------------ 用Gradle包装器升级如果您现有的基于Gradle的版本使用Gradle Wrapper，那么可以通过运行wrapper指定所需的Gradle版本的任务轻松升级： 1$ ./gradlew wrapper --gradle-version=4.5 --distribution-type=bin 请注意，没有必要安装Gradle来使用Gradle包装器。下一次调用gradlew或gradlew.bat将下载并缓存指定版本的Gradle。 123$ ./gradlew tasksDownloading https://services.gradle.org/distributions/gradle-4.5-bin.zip... 弄一个HelloWorld看看创建一个test_gralde文件夹。然后在文件夹里面创建一个build.gradle文件。注意文件名不要乱起。在build.gradle中添加如下代码： 123456789task helloworld&#123; doLast&#123; println'Hello World!' &#125;&#125;#后者等同于下面的代码,task helloworld2 &lt;&lt;&#123; println "Hello World!"&#125; 然后来运行一下： 123456789liuqiangs-MacBook-Pro:test_gralde liuqiang$ gradle helloworld:helloworldHello World!BUILD SUCCESSFULTotal time: 1.52 secsThis build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.14.1/userguide/gradle_daemon.html 我们分析一下执行步骤。build.gradle是Gradle默认的构建脚本文件，执行Gradle命令的时候，会默认加载当前目录下的build.gradle脚本文件，当然你也可以通过 -b 参数指定想要加载执行的文件。这只是个最简单的task例子，后面详细介绍task的常见定义。 这个构建脚本定义一个任务（Task），任务名字叫helloworld，并且给任务helloworld添加了一个动作，官方名字是Action，阅读Gradle源代码你会到处见到它，其实他就是一段Groovy语言实现的闭包，doLast就意味着在Task执行完毕之后要回调doLast的这部分闭包的代码实现。第二个方法中的“&lt;&lt;”表示向helloworld中加入执行代码。至于语法部分，基本是Groovy语法（包括一些语法糖，也就是写简写方式，如果写个JavaScript或者Python会好理解一些，但是还是建议去读一下groovy的基本语法），加上一些DSL（domain specific language）的约定。 执行流程和基本术语和Maven一样，Gradle只是提供了构建项目的一个框架，真正起作用的是Plugin。Gradle在默认情况下为我们提供了许多常用的Plugin，其中包括有构建Java项目的Plugin，还有Android等。与Maven不同的是，Gradle不提供内建的项目生命周期管理，只是java Plugin向Project中添加了许多Task，这些Task依次执行，为我们营造了一种如同Maven般项目构建周期。 Gradle是一种声明式的构建工具。在执行时，Gradle并不会一开始便顺序执行build.gradle文件中的内容，而是分为两个阶段，第一个阶段是配置阶段，然后才是实际的执行阶段。配置阶段，Gradle将读取所有build.gradle文件的所有内容来配置Project和Task等，比如设置Project和Task的Property，处理Task之间的依赖关系等。 看一个基本结构的Android多Moudule（也就是gradle中的多Project Multi-Projects Build）的基本项目结构。 12345678910111213141516171819202122232425├── app #Android App目录│ ├── app.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── module #Android 另外一个module目录│ ├── module.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── build│ └── intermediates├── build.gradle #工程构建文件├── gradle│ └── wrapper├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat├── LibSqlite.iml├── local.properties #配置Androod SDK位置文件└── settings.gradle #工程配置 上面的是完整的AndroidStudio中的项目结构，我们抽象成Gradle多个Project的样子 1234567891011├── app │ ├── build.gradle #构建脚本├── module │ ├── build.gradle #构建脚本├── build.gradle #工程构建文件├── gradle│ └── wrapper #先不去管它├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat└── settings.gradle #工程配置 Gradle为每个build.gradle都会创建一个相应的Project领域对象，在编写Gradle脚本时，我们实际上是在操作诸如Project这样的Gradle领域对象。在多Project的项目中，我们会操作多个Project领域对象。Gradle提供了强大的多Project构建支持。 要创建多Project的Gradle项目，我们首先需要在根（Root）Project中加入名为settings.gradle的配置文件，该文件应该包含各个子Project的名称。Gradle中的Project可以简单的映射为AndroidStudio中的Module。 在最外层的build.gradle。一般干得活是：配置其他子Project的。比如为子Project添加一些属性。 在项目根目录下有个一个名为settings.gradle。这个文件很重要，名字必须是settings.gradle。它里边用来告诉Gradle，这个multiprojects包含多少个子Project（可以理解为AndroidStudio中Module）。 读懂Gradle配置语法Gradle向我们提供了一整套DSL，所以在很多时候我们写的代码似乎已经脱离了groovy，但是在底层依然是执行的groovy所以很多语法还是Groovy的语法规则。看一个AndroidStudio中app下的build.gradle的配置 12345678910111213141516171819202122232425apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.0" defaultConfig &#123; applicationId "me.febsky.demo" minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:25.1.0'&#125; 分析第一行apply plugin: &#39;com.android.application&#39;这句其实是Groovy语法糖，像Ruby和Js都有这种语法糖，apply实际上是个方法，补上括号后的脚本：apply (plugin: &#39;com.android.application&#39;),看起来还是有点别扭是不？还有个语法糖，如果方法参数是个map类型，那么方括号可以省略，进一步还原apply([ plugin: &#39;com.android.application&#39;]),不理解的可以去看下Groovy的map的写法，和js一样。所以这行的意思是：apply其实是个方法，接收一个Map类型的参数。 总结两点：1. 方法调用，圆括号可以省略 2. 如果方法参数是个Map，方括号可以省略。 Groovy语言的闭包语法看上面的dependencies 这其实是个方法调用。调用了Project的dependencies方法。只不过参数是个闭包，闭包的用法在文章开始给出了链接。我们对其进行还原一下： 12345#方法调用省略了（）我们加上dependencies (&#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:25.1.0&apos;&#125;) 提示一点：如果闭包是方法的最后一个参数，那么闭包可以放在圆括号外面 12345#所以代码还能写成这样dependencies ()&#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:25.1.0&apos;&#125; Getter和SetterGroovy语言中的两个概念，一个是Groovy中的Bean概念，一个是Groovy闭包的Delegate机制。Java程序员对JavaBeans和Getter/Setter方法肯定不陌生，被设计用来获取/设置类的属性。但在Groovy中就不用那些没用的方法了。即Groovy动态的为每一个字段都会自动生成getter和setter，并且我们可以通过像访问字段本身一样调用getter和setter。比如Gradle的Project对象有个version属性（Property）下面这两行代码执行结果是一样的: 12println project.version // Groovy println(project.getVersion()) // Java Project，Task ，ActionGradle的Project之间的依赖关系是基于Task的，而不是整个Project的。 Project:是Gradle最重要的一个领域对象，我们写的build.gradle脚本的全部作用，其实就是配置一个Project实例。在build.gradle脚本里，我们可以隐式的操纵Project实例，比如，apply插件、声明依赖、定义Task等，如上面build.gradle所示。apply、dependencies、task等实际上是Project的方法，参数是一个代码块。如果需要，也可以显示的操纵Project实例，比如：project.ext.myProp = &#39;myValue&#39; Task:被组织成了一个有向无环图（DAG）。Gradle中的Task要么是由不同的Plugin引入的，要么是我们自己在build.gradle文件中直接创建的。Gradle保证Task按照依赖顺序执行，并且每个Task最多只被执行一次。 Gradle在默认情况下为我们提供了几个常用的Task，比如查看Project的Properties、显示当前Project中定义的所有Task等。可以通过一下命令行查看Project中所有的Task：$ gradle tasks （具体log不再贴出来）。可以看到，Gradle默认为我们提供了dependencies、projects和properties等Task。dependencies用于显示Project的依赖信息，projects用于显示所有Project，包括根Project和子Project，而properties则用于显示一个Project所包含的所有Property。 Tips: 查看Project中所有的Task：$ gradle tasks查看Project中所有的properties：$ gradle properties 在上面的build.gradle中加入如下代码： 12345678task myTask &#123; doFirst &#123; println &apos;hello&apos; &#125; doLast &#123; println &apos;world&apos; &#125; &#125; 这段代码的含义：给Project添加一个名为“myTask”的任务用一个闭包来配置这个任务,Task提供了doFirst和doLast方法来给自己添加Action。 其实build.gradle脚本的真正作用，就是配置一个Project实例。在执行build脚本之前，Gradle会为我们准备好一个Project实例，执行完脚本之后，Gradle会按照DAG依次执行任务。 自定义Task的写法看下面代码文件路径~/Test/build.gradle： 123456789#1task helloWorld &lt;&lt; &#123; println &quot;Hello World&quot;&#125;#2 Test文件夹下建一个src目录，建一个dst目录，src目录下建立一个文件，命名为test.txttask copyFile(type: Copy)&#123; from &quot;src&quot; into &quot;dst&quot;&#125; 第一个这里的helloWorld是一个DefaultTask类型的对象，这也是定义一个Task时的默认类型，当然我们也可以显式地声明Task的类型，甚至可以自定义一个Task类型。第二个代码中（type：Copy）就是“显式地声明Task的类型”，执行gradle copyFile test.txt也跑到dst中去了。 如果task声明在根Project的build.gradle中的allprojects()方法中，那么这个Task会应用于所有的Project。 task的依赖关系Gradle不提供内建的项目生命周期管理，只是java Plugin向Project中添加了许多Task，这些Task依次执行，为我们营造了一种如同Maven般项目构建周期。那么这些task是如何依次执行的这就用到声明的依赖关系taskA.dependsOn taskB看下面代码： 123456789task taskA &lt;&lt; &#123; println &apos;this is taskA from project 1&apos;&#125;task taskB &lt;&lt; &#123; println &apos;this is taskB from project 1&apos;&#125;taskA.dependsOn taskB 然后我们在命令行运行：$ gradle taskA运行结果会先执行taskB的打印，然后执行taskA的打印 如果是Muliti-Project的模式，依赖关系要带着所属的Project，如taskA.dependsOn &#39;:other-project:taskC&#39; 其中taskC位于和taskA不同的Project中，相对于AndroidStudio来说，就是位于不同的Module下的build.gradle中，而other-project为Module名字。 Task 的type可以自定义（没有深入研究）自定义Plugin的写法没有深入研究，给出一个网上的例子： 12345678910111213141516171819202122232425262728293031apply plugin: DateAndTimePlugindateAndTime &#123; timeFormat = &apos;HH:mm:ss.SSS&apos; dateFormat = &apos;MM/dd/yyyy&apos;&#125;class DateAndTimePlugin implements Plugin&lt;Project&gt; &#123; //该接口定义了一个apply()方法，在该方法中，我们可以操作Project， //比如向其中加入Task，定义额外的Property等。 void apply(Project project) &#123; project.extensions.create(&quot;dateAndTime&quot;, DateAndTimePluginExtension) project.task(&apos;showTime&apos;) &lt;&lt; &#123; println &quot;Current time is &quot; + new Date().format(project.dateAndTime.timeFormat) &#125; project.tasks.create(&apos;showDate&apos;) &lt;&lt; &#123; println &quot;Current date is &quot; + new Date().format(project.dateAndTime.dateFormat) &#125; &#125;&#125;//每个Gradle的Project都维护了一个ExtenionContainer，//我们可以通过project.extentions进行访问//比如读取额外的Property和定义额外的Property等。//向Project中定义了一个名为dateAndTime的extension//并向其中加入了2个Property，分别为timeFormat和dateFormatclass DateAndTimePluginExtension &#123; String timeFormat = &quot;MM/dd/yyyyHH:mm:ss.SSS&quot; String dateFormat = &quot;yyyy-MM-dd&quot;&#125; 每一个自定义的Plugin都需要实现Plugin接口，除了给Project编写Plugin之外，我们还可以为其他Gradle类编写Plugin。该接口定义了一个apply()方法，在该方法中，我们可以操作Project，比如向其中加入Task，定义额外的Property等。 原文地址 Gradle WrapperWrapper，顾名思义，其实就是对Gradle的一层包装，便于在团队开发过程中统一Gradle构建的版本，然后提交到git上，然后别人可以下载下来，这样大家都可以使用统一的Gradle版本进行构建，避免因为Gradle版本不统一带来的不必要的问题。（所以要明白这个东西可以没有，有了只是为了统一管理，更加方便） 生成wrappergradle 内置了生成wrapper的task，我们可以命令行下执行：$ gradle wrapper 生成后的目录结构如下(用过AndroidStudio的很熟悉了)： 123456├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat gradlew和gradlew.bat分别是Linux和Window下的可执行脚本，他们的用法和gradle原生命令是一样的，gradle怎么用，他们也就可以怎么用。在MacOS下运行$ ./gradlew myTask gradle-wrapper.jar是具体业务逻辑实现的jar包，gradlew最终还是使用java执行的这个jar包来执行相关gradle操作。 gradle-wrapper.properties是配置文件，用于配置使用哪个版本的gradle等 详细的看下gradle-wrapper.properties内容123456#Sat Jan 21 14:02:40 CST 2017distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-bin.zip 从上面内容和文件的名称都可以看出，这就是个java的配置文件,上面看到的是自动生成的，我们也可以手动修改。然后看下各个字段的含义： distributionBase 下载的gradle压缩包解压后存储的主目录 distributionPath 相对于distributionBase的解压后的gradle压缩包的路径 zipStoreBase 同distributionBase，只不过是存放zip压缩包的 zipStorePath 同distributionPath，只不过是存放zip压缩包的 distributionUrl gradle发行版压缩包的下载地址，也就是你现在这个项目将要依赖的gradle的版本。 生成wrapper可以指定参数 生成wrapper可以通过指定参数的方式来指定gradle-wrapper.properties内容。 使用方法如gradle wrapper –gradle-version 2.14这样，这样就意味着我们配置wrapper使用2.14版本的gradle，它会影响gradle-wrapper.properties中的distributionUrl的值，该值的规则是http://services.gradle.org/distributions/gradle-${gradleVersion}-bin.zip 如果我们在调用gradle wrapper的时候不添加任何参数呢，那么就会使用你当前Gradle的版本作为生成的wrapper的gradle version。例如你当前安装的gradle是2.10版本的，那么生成的wrapper也是2.10版本的。注：当前版本指的是环境变量中配置的那个版本。]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晋升研究员，阿里十年他都经历了什么]]></title>
    <url>%2Fposts%2F1042.html</url>
    <content type="text"><![CDATA[在上海工作8年后，身为部门经理的钱磊，管理着一家ERP公司的百十来号员工，“再往上爬就是老板和他儿子了……从这个领域的技术角度来讲算是做到了顶。”05年，钱磊就开始关注一家名字奇怪，做事也奇怪的公司。 要不要折腾一下？2008年5月的一天钱磊对新婚的妻子说，想去杭州发展，那里有个公司叫阿里巴巴…… 阿里技术人钱磊 #侧面像马总，正面比马总帅# ——他的内网标签之一 01 不扒层皮，你怎么知道自己是谁？告别上海的家和妻子，钱磊拖着行李箱独自来了杭州。 豪情万丈地入职，不料压根没有“蜜月期”……“刚来的那两周，时时刻刻觉得自己是不是要背着包回上海了……”钱磊并不回避刚入职时的囧境。 “不舒服，压力大。在原来的公司里，我就是拍板的人，来了以后发现其它人都挺厉害的。端着架子放不下，总想着自己好歹也是在业内干了八九年的人，在这里被刚毕业一两年的工程师挑战……” 像他这样外地来杭的人，一般入职后就开始着手找房子，钱磊则是在宾馆里住了整整两周。 “那段经历对我来说还是蛮宝贵的，不是有句阿里土话嘛，当你觉得不舒服的时候，就是成长的时候。一个人四平八稳时，很难获得成长。” 02 主管搭了半条命，我学到了两个字“担当”“硬”着陆半个月后，扒了层“皮”的钱磊又被主管砸了块“石头”。 他们要用技术的手段彻底解决业务问题——为阿里巴巴最早的“产品后台”B2B的CRM做系统重构。这就好比开着汽车换引擎，百年老宅动地基…… “最重要的一个责任落在了我身上，研发框架。当时业务给我们的时间只有两个月。我用了两周时间搭框架、做论证。对于一个入职不久的新人来讲，挑战非常大。” 这种打仗的感觉，让钱磊渐渐忘记了自己是谁，业务在奔跑，系统延迟一天上线，影响就越大。每天几百人依靠这个系统工作。 “……我的主管被业务方总经理请去喝了两个小时的茶，他是把半条命都搭上了。做不好，没有退路。为了系统上线，当时还停了两天业务，对公司来说每一分钟都是损失。” 系统上线后虽然又经历了多次调试，但这是一次技术对业务的引领，而不是以往那样跟在后面打配合。因为框架的通用性还不错。直到现在，这套CRM还在使用。 把业务风险和技术风险搭在一起，并不是一个最好的选择，但却是当时唯一的选择。“我从主管身上学到了两个字‘担当’，这是一个管理者的气质。” 阿里管理者气质：担当 03 离开场景和业务的修炼都是伪命题接手用户权限中心的技术团队后，钱磊开始实打实地接触客户。在这几年里，他从偏技术的架构，转为偏业务的架构。“离业务太远，做出来的东西不是场景驱动，后续会有较多的问题。架构师别把自己修炼成仙了，给公司留下的却是与业务无关的垃圾。” 当时B2B的ICBU遇到了用户权益打包的问题，底层需要一个产品化的解决方案，“原来每年销售做完规划以后，技术同学都要算，会花掉多少人力去做一个新的产品配置。每次都靠研发同学冲到代码里面写一大堆。我们做了权益包功能后，只花几个小时就能配置好了。权益的产品化解决了ICBU的一个大问题。这又是一次技术引领业务的实例。” 阿里土话：业绩永远都是附属品 04 越想证明自己 死得越快两年前，钱磊调到共享平台，做会员和安全。他们团队从技术和产品端入手，解决了移动端与PC端会员整体链路兼容的问题。降低了一半与帐户相关的客服电话量。“现在帐户相关的客服量在7%左右，我们的目标是三年后降到0。” 从中间件到信息平台，再到共享平台，钱磊接的摊子越来越大，2015年，入职的第7年，他获得了一次提名晋升P10（研究员）的机会。 “面试的时候，自我感觉还不错，毕竟这几年也做了几件拿得出手的东西……”一个月后，钱磊却得知了自己晋升失败的消息。 “心里肯定有波动啊。”提起两年前的那次晋升面试，钱磊坦白：“我当时还请了两天假，出去放空了一下。想明白了几件事，第一，这几年我在阿里巴巴学到的东西是不是已经远远超出过去？第二，公司给予的平台和空间是不是足够我成长？第三，我为业务创造最大化的价值了吗？当我连续问了自己几个问题后，一下子就看透了。证明自己没什么大意思，给业务和用户创造价值才是最踏实的。越想证明自己的人，死得越快。” 阿里土话：总是想要证明自己时，就没有了投入工作的心态 05 善于总结才能获得加速度钱磊觉得自己这九年来做得最正确的事，就是坚持总结和反思。“我几乎每个月都会给自己留出做总结的时候，这个月自己和团队做了什么事，还有哪些提升空间。一定要趁热打铁记录下来，反思能让我保持头脑的清晰。 我觉得一个不善于总结的人，就是在吃老本，吃惯性，吃你的智商和知识。反思就是获得加速度的那个点。这是工作多年来，让我最受益的一个习惯。” 06 技术人千万别陷在技术的圈子里钱磊在自己的内网签名里写着“知行合一”四个字。身为技术男，在业务相关的书之外，他独爱王阳明和南怀瑾，“王阳明的知行合一，是我的座右铭，倾听内心的声音，力量强大。南怀瑾的《庄子》我读了好几遍，佩服他为人的格局。我觉得技术同学特别需要打开思路，千万不要局限在技术这个圈子里。要有自己丰富的阅历，去看很多东西，触类旁通，在某些时候形成链接，对你的技术思考、业务思考都有帮助。” 阿里土话：成长是自己的事 07 好奇心与三个Why带了七八年团队，最多的时候钱磊一年要参加50多场面试，有招聘新人的，也有晋升的。他选人用人会特别看重对方的心态： “我觉得心态非常重要，我们面试人的时候，一定要去看他的进取心和好奇心。我觉得这两者是面向未来的能力。 我会问三个Why：为什么这样做？这样做背后有什么问题和思考？你的业务价值支撑点是什么？我对技术同学的要求是：至少你自己做的事儿，如果到‘P7’这个级别，一定是问不倒的，一定经得起我问三个‘为什么’。如果你经不起问的话，我认为你做这个事要么是需求驱动，要么你就是一个吃瓜群众。我非常在意一个人的独立思考能力。” 终极三问，why,how,who 08 一个计较KPI的主管肯定会带出一个计较KPI的团队 钱磊说自己的管理之道就是四个字“言传身教”，“首先，要做好自己，不要对别人要求很高，对自己要求很低。再有，你是业务驱动、客户价值驱动，还是KPI驱动？一个天天计较自己KPI的人，肯定带不出一个不计较KPI的团队。 我们团队的KPI很简单，就是回归到业务场景。我的KPI已经连续几年都是以客服量为衡量点。你这个产品怎么样，上了多少功能，都不是最主要的因素，关键是你最终解决了客户的什么问题。客户用脚来投票。我会带着团队的D（业务负责人）一起review团队的KPI。 阿里土话：刚工作的几年比谁更踏实，再过几年比谁更激情 09 人生没有白走的路2017年7月，钱磊通过“绿色通道”（免试）晋升为P10（研究员），既在意料之中，又在意料之外。尽管不做要求，他还是准备了一个简单的PPT，那是写给自己的9年总结。 钱磊的办公桌面一如典型的技术男那样简单。桌上摆着他5岁女儿的照片。问起他印象最深刻的一个瞬间，他不加思索地回答：“2015年双11，连续熬了两个通宵后，11月13日的凌晨，我走到园区一号楼取车，眼前的夜空很美，身后是灯火通明的楼宇。就是一种很幸福的感觉。我，在这里，和大家在一起。我们和这家公司，挺伟大的……” 这就是一个阿里技术男的成长史。哪有那么多成长快乐，每一步都不是白走的路。你怎样选择和对待人生，人生就怎么样待你。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hybrid app技术开发APP应用]]></title>
    <url>%2Fposts%2F3405.html</url>
    <content type="text"><![CDATA[hybrid app技术开发APP应用。而现在主流的Hybrid app框架是phonegap。在使用phonegap做混合式开发之前需要下载很多软件及插件。如：JavaJDK、node.js、cordova、ionic、Android studio、AndroidSDK等软件及相应的插件。（请不要下载phonegap应用程序，不要混淆）下面就来简单介绍一下，如何安装cordova和ionic及常用的命令总结。 第一部分 安装时总结win系统下nodejs安装及环境配置第一步：下载nodejs官网：http://nodejs.org/download/ 第二步：安装nodejs 下载完成之后，双击”node-v0.10.28-x86.msi”，开始安装nodejs，自定义安装在D:\dev\nodejs下面。 在cmd控制台输入：node -v，控制台将打印出：v0.10.28，出现版本提示表示安装成功。 该引导步骤会将node.exe文件安装到D:\dev\nodejs\目录下，并将该目录添加进PATH环境变量。 第三步：npm安装由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行输入”npm -v”来测试是否成功安装。出现版本提示表示安装成功。 第四步：安装相关环境npm install -g express-generator npm install jade -g npm install mysql -g 默认情况下上述组件都是安装在D:\dev\nodejs\node_modules文件夹下，这也是nodejs相关组件的自动查找路径。 第五步：安装CoffeeScript1npm install coffee-script -g 确认安装的命令：coffee -v，出现版本号表示成功安装。 补充说明：所有命令都是-g进行全局安装的，这样安装的安装包都在当前用户下，在磁盘的所有其他地方都可以访问到，比较方面。否则安装在当前目录下，只能在当前目录下使用。 安装express问题安装nodejs安装包后，通过npm安装express后，运行express提示” express”不是内部或外部命令，原因是版本问题，当前版本是4.0.0，改成3.5.0即可运行。 1npm install -g express@3.5.0 注意：express 测试版本用大写V npm命令集合： npm install moduleNames：安装Node模块 npm install express默认会安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.6 npm install -g将包安装到全局环境中 但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令 npm install –save安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了。 全局安装命令为npm install -g moduleName。 npm view moduleNames：查看node模块的package.json文件夹 npm list：查看当前目录下已安装的node包 npm help：查看帮助命令 npm view moudleName dependencies：查看包的依赖关系 npm view moduleName repository.url：查看包的源文件地址 npm view moduleName engines：查看包所依赖的Node的版本 npm help folders：查看npm使用的所有文件夹 npm rebuild moduleName：用于更改包内容后进行重建 npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新 npm update moduleName：更新node模块 npm uninstall moudleName：卸载node模块 一个npm包是包含了package.json的文件夹，package.json描述了这个文件夹的结构。访问npm的json文件夹的方法如下： $ npm help json 此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开。 发布一个npm包的时候，需要检验某个包名是否已存在 $ npm search packageName npm init：会引导你创建一个package.json文件，包括名称. 版本. 作者这些信息等 npm root：查看当前包的安装路径 npm root -g：查看全局的包的安装路径 npm -v：查看npm安装的版本 npm install –save moduleName 安装模块到本目录 更多命令请参看npm官方文档：https://www.npmjs.org/doc/ npm install -g cnpm –registry=https://registry.npm.taobao.org（npm镜像源指向淘宝） cnpm install -g cordova ionic（安装cordova ionic） cnpm update -g cordova ionic（更新cordova ionic） ionic -help（查看帮助） ionic -v（查看版本） ionic start myApp blank（空项目） ionic start myApp tabs（带导航条） ionic start myApp sidemenu（带侧滑菜单） ionic platform add android（添加android平台） ionic platform remove android（移除android平台） ionic build android（编译项目apk） ionic emulate android（运行项目apk 手机连接在手机运行 模拟器连接在模拟器运行） ionic run android （相当于build + emulate） ionic serve （开启服务调试） ionic build ios（编译项目ipk） ionic emulate ios（运行项目ipk） 第六步：创建项目express /tmp/foo &amp;&amp; cd /tmp/foo npm install //下载依赖包 npm start //启动项目 目录介绍: node_moduls 存放所有的项目依赖库 package.json 项目依赖配置及开发者信息 app.js 程序启动文件 public 静态文件（css js img） routes 路由文件（MVC中的C，controller） Viesws 页面文件（Ejs模板） 第七步 创建cordova项目（注意：当第一次创建或编译项目的时候，可能系统会自动下载一些东西，需要一些时间。） 在某个目录下创建cordova项目，打开命令行 输入： 1cordova create test com.cordova.test test （创建cordova工程 &lt;文件夹名&gt; &lt;包名&gt; ） 文件夹目录 hooks：存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。没用过，不展开了。 platforms：平台目录，各自的平台代码就放在这里，可以放一下平台专属的代码，现在这个目录应该是空的，后面会介绍如何创建平台。 plugins：插件目录，安装的插件会放在这里。后面会有专门的文章介绍开发插件。 www：最重要的目录，存放项目主题的HTML5和JS代码的目录。app一开始打开的就是这个目录中index.html文件。 config.xml：主要是cordova的一些配置，比如：项目使用了哪些插件、应用图标icon和启动页面SplashScreen，修改app的版本，名字等信息，还有平台的配置。 添加平台支持 用命令行打开对应的文件夹， 添加平台 输入： 1cordova platforms add android 移除平台 输入： 1cordova platforms rm android （移除android平台支持） 也可以通过@版本号，来添加不同版本的android平台，如： 1cordova platforms rm android @4.1.1 现在就可以在www文件夹内写自己的js和html代码了。 添加插件 输入: 1cordova plugin add cordova-plugin-file (cordova plugin add &lt;插件官方名称&gt;) 插件搜索地址：http://cordova.apache.org/plugins/ 也可以通过github查找一些第三方插件 输入： 1cordova plugin add https://github.com/phonegap/phonegap-plugin-barcodescanner.git //这个是扫描二维码插件 (github项目地址) github地址：https://github.com/ 删除插件 输入： 1cordova plugin rm cordova-plugin-file （使用rm和remove都可以） 插件列表 输入： 1cordova plugin list （查看当前安装了哪些插件） 编译调试程序 不是每一句代码都需要运行，根据自己的需求进行选择。 cordova install android //将编译好的应用程序安装到模拟器上。 cordova emulate android //在模拟器上运行（前提是创建好AVD） cordova serve android //在浏览器运行 cordova build android //打包cordova项目到android平台。 cordova run android //通过USB直接安装到真机（该语句已经包括了build命令） 例如：我现在是手边直接连着测试手机，所以我就会直接用cordova run android 中间省略… 出现LAUNCH SUCCESS则编译成功，已经安装到手机上了。 第八步 安装Android SDK 下载Android SDK，点击安装，直接默认路径即可！ 下载地址：http://developer.android.com/sdk/index.html 默认路径安装后，安装完成，开始配置环境变量。 打开计算机属性——高级系统设置——环境变量（如上文） 新建一个环境变量，变量名：ANDROID_HOME，变量值：C:\Program Files (x86)\Android\android-sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹），点击确认。 在变量PATH后面加上变量值%ANDROID_HOME%\tools;点击确认即可。 如果没有这个变量，新建一个即可！新建方法见上文！ Android SDK配置完成，接下来验证配置是否成功。 点击运行——输入cmd——回车——输入android -h——回车 ionic Android 环境搭建过程遇到的问题 http://bbs.ionic-china.com/read.php?tid=7&amp;fid=4 第九步 安装Ionic 执行npm install -g ionic 创建一个Ionic APP 执行ionic start myapp[template]Template 有如下三种 默认是tabs project:tabs（默认）. sidemenu. blank 安装模板 ionic install –save 模板 cordova 是页面与设备桥接 npm install –save bower 第十步 安装gulp相关代码合并. 混淆工具npm install gulp npm install gulp-concat:合并文件 npm install gulp-rename:重命名文件 npm install gulp-sass:支持sass npm install gulp-minify-css:压缩css npm install gulp-connect 配置一个web服务器 第十一步 编译测试 android版本 cd myapp ionic platform add android ionic build android ionic run android 如果要在虚拟机中测试，可以改用 ionic emulate android ios版本 $ ionic start myapp tabs $ cd myapp $ ionic platform add ios $ ionic build ios $ ionic emulate ios 浏览器同时修改端口号 cd myapp ionic serve -p 8105 连接数据线直接测试 ionic run android 重点集合ionic安装失败或者cordova安装失败解决方法镜像使用方法（三种办法任意一种都能解决问题，建议使用##### 第三种，将配置写死，下次用的时候配置还在）: 通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 命令行指定 npm –registry https://registry.npm.taobao.org info underscore 编辑 ~/.npmrc 加入下面内容 registry = https://registry.npm.taobao.org 搜索镜像: https://npm.taobao.org 建立或使用镜像,参考: https://github.com/cnpm/cnpmjs.org 使用cnpm(强烈建议) 安装cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 以后所有的npm可用cnpm代替，如:cnpm install ionic 如果还是一直失败，将ionic文件下载解压后放到C:\Users\Auser\AppData\Roaming\npm\node_modules中 配置环境变量 node的npm命令Path : C:\Documents and Settings\Administrator\Application Data\npm 补齐npm文件夹下有关于ionic的文件 http://download.csdn.net/detail/superjunjin/8417723 补齐ionic项目下node_modules等文件 http://download.csdn.net/detail/superjunjin/8417731（具体文件见最后的压缩包） 12ionic start myApp sidemenu //创建带有左侧带有menu栏的示例项目ionic start myApp blank //创建空白项目 第二部分 开发过程总结Angular 提供3种方法创建并注册服务 Provider Factory Service Providers 是唯一一种你可以传进 .config() 函数的 service。当你想要在 service对象启用之前，先进行模块范围的配置，那就应该用 provider。 bower安装restangular失败（报错：Bower : ENOGIT git is not installed or not in the PATH） 添加git路径到环境变量PATH中（命令：set PATH=%PATH%;D:\Program Files\Git\bin） 运行bower install restangular 即可安装成功 http://www.ng-newsletter.com/posts/restangular.html restangular文档：https://github.com/mgonto/restangular#element-methods 安装bower install underscore restangular需要用到的js(js少引入报错：Uncaught ReferenceError: _ is not defined from restangular) 12&lt;script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.jsdelivr.net/restangular/latest/restangular.min.js"&gt;&lt;/script&gt; 跨域错误解决办法（XMLHttpRequest cannot load ‘’. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘ ‘ is therefore not allowed access. ） Java代码中返回结果集前增加 1response.setHeader("Access-Control-Allow-Origin", "*"); 国际化 http://yijiebuyi.com/blog/3b55056c87b73ba606c19e9338dca679.html 安装bower install angular-translate 安装bower install angular-translate-loader-static-files angular国际化不存在乱码，如果出现乱码可能是中文json文件编码非UTF-8格式 国际化使用（移动端有问题 无法使用）： 需要引入JS 123&lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt;&lt;script src="lib/angular-translate/angular-translate.js"&gt;&lt;/script&gt;&lt;script src="lib/angular-translate-loader-static-files/angular-translate-loader-static-files.js"&gt;&lt;/script&gt; 建立文件夹i18n存放cn.json /en.json 12en.json：&#123;&quot;100001&quot;:&quot;Login&quot;,&quot;100002&quot;:&quot;Register&quot;&#125;cn.json：&#123;&quot;100001&quot;:&quot;登录&quot;,&quot;100002&quot;:&quot;注册&quot;&#125; 在app.js中config里配置如下 123456//国际化配置$translateProvider.preferredLanguage('cn');$translateProvider.useStaticFilesLoader(&#123; prefix: '/i18n/', suffix: '.json'&#125;); html页面使用 1234567&#123;&#123;'100001' | translate &#125;&#125;5.按钮切换语种.controller('LanguageSwitchingCtrl', ['$scope', '$translate', function (scope, $translate) &#123;scope.switching = function (lang) &#123; $translate.use(lang); &#125;;&#125;]); AngularJS iframe跨域打开内容时报错误的解决办法1&lt;iframe id="myFrame" ng-src="&#123;&#123;url&#125;&#125;" width="100%" height="100%" seamless frameborder="0" &gt;&lt;/iframe&gt; 打开不同域的内容时报下面的错误Blocked loading resource from url not allowed by $sceDelegate policy 解决方案： 1234567app.config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ // Allow same origin resource loads. 'self', // Allow loading from our assets domain. Notice the difference between * and **. 'http://media.w3.org/**']);&#125;);]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Bind，Call和Apply]]></title>
    <url>%2Fposts%2F55294.html</url>
    <content type="text"><![CDATA[js 中的 上下文 Context，可以说是一个，你即使不知道，没听过，也不影响你继续写 js 代码的一个概念。但是，它又确确实实是无所不在的一个东西，是的，无所不在。 上下文解释所谓上下文，它是用来存储系统的一些初始化信息，例如在jboss中通过配置文件指定了数据源，那么在jboss启动的时候就把这个文件的相关信息上下文中，于是在我们使用这个数据源的时候，就需要先获得系统的上下文，然后再通过一定的方式将数据源取出来。至于在系统启动时，是如何将这些初始化信息加载到上下文中，而上下文在程序中具体又是以什么形式体现的，应该随着系统的不同而不同。 上下文即ServletContext,是一个全局的储存信息的空间，服务器启动，其就存在，服务器关闭，其才释放。所有用户共用一个ServletContext。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。如，做一个购物类的网站，要从数据库中提取物品信息，如果用session保存这些物品信息，每个用户都访问一便数据库，效率就太低了；所以要用来Servlet上下文来保存，在服务器开始时，就访问数据库，将物品信息存入Servlet上下文中，这样，每个用户只用从上下文中读入物品信息就行了。 获取ServletContext的方法： 12HttpSession session = request.getSession(); session.getServletContext(); 从我自己的经验来看，对上下文的认识，算是分成了三个阶段，每一个阶段，都让我从外在的表现中，理解了一些更本质上的东西。 1. 第一阶段，不知我最开始接触 js 的时候，看到了它的 new ，看到了它的 this ，很自然地会把 js 和其它的一些 OOP 语言等同起来看待，并且，好像，也是这么回事。比如： 12345678910var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = new Class(1);ins.add();console.log(ins.a); //2 上面的代码，可以按预期的那样，最后得到 2 的输出。 但是，如果仅仅是 类，实例 这种层面的认识，我无法解释下面的问题： 1234var ins = new Class(1);var func = ins.add;func();console.log(ins.a); //1 甚至解释不清楚下面的代码： 12345678var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125;obj.add();console.log(obj.a); //2 这里可没有 类 ，也没有 实例 。 我上面的最开始对 js 的认识当中，局限就在于，把 this 理解成了 实例 。也许在其它语言中（比如 Python 常用的实例方法第一个参数 self），是这样。但是在 js 中， this 跟 实例 完全没有关系。 2. 第二阶段，this当我明白问题出在 this 上，或者说，当我终于理解了 this 这个东西之后，上面的代码，再也不会困扰我了。 我知道了， js 中有一个东西叫 上下文 ，可惜的是，这时，我对上下文的概念，仅仅停留在 this上。 这时我的理解是： this 表示的是，函数调用时的 上下文 。 说得详细一点，就是 this 不是表示的 实例 ，而是函数调用时的 上下文 。 上下文 这个东西，默认是 window ，即 全局 。但是，你可以明确地为函数指定一个 上下文 。回到 this 上，就是在定义时你根本不知道 this 是什么，因为在调用时，它可以是任何东西（因为 上下文 是可以人为指定的）。 回到刚开始的代码： 12345678910var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = new Class(1);ins.add();console.log(ins.a); //2 这段代码的结构之所以是 2 ，不是因为 实例 ，而是因为 上下文 。 首先说一下 new 。 new 在 js 中，不考虑原型链它的作用，相当于是先创建了一个空的对象，然后把这个空的对象，作为 构造函数 的 上下文 ，再去执行 构造函数 ，最后再返回这个当初的空对象。即： 12345678910111213141516var what_new = function(func, a)&#123; var context = &#123;&#125;; func.apply(context, [a]); return context;&#125;var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = what_new(Class, 1);ins.add();console.log(ins.a); 当然， new 除了上面的 func.apply 的作用之外， 它还会处理原型链 ，这里就不介绍了。上面的代码仅是为了说明 new 对于所谓的构造函数做了什么事。 有了上下文，就不难解释 ins 这个东西了。所谓的构造函数，只是在指定了 this 到底是哪一个对象之后，作了相应的赋值操作而已，最后得到这个对象的返回，经过了一些赋值操作，对象中就有了新的东西了。 同样，对于一个在定义时包含了 this 的函数，比如前面的例子： 123456var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125; 如果来一句： 123var func = obj.add;func(); //undefinedfunc.apply(&#123;a: 0&#125;) //1 这些都很容易明白了。 js 中的函数，都是一些很单纯的函数，所有的函数跟它在哪里定义完全没有关系（考虑闭包的情况除外）。所以上面的代码，虽然 add 函数是写在 obj 中的，但是，它跟你在 window 中写一个函数是 完全一样 的： 12345var add = function()&#123;this.a++&#125;var obj = &#123; a: 1, add: add&#125; 既然 add 函数中有 this ，那么这个函数执行时的行为，就要小心一点了。所以上面明确地指定了一个上下文给它 func.apply({a: 0}) 。 还是回到开始的代码： 123456var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125; 对于上面的代码，我知道了： 1obj.add(); 和： 12var func = obj.add();func(); 会得到不一样的结果。并且知道，这个不一样的结果是上下文引起的，还知道，后者 func() 执行时，上下文是全局的 window 了。 我虽然知道是这样的一个情况，但是，为什么？执行同一个函数结果怎么就不一样了呢？ 我在很长时间里，都没有去细细考虑过这个问题。不过，因为知道了“上下文是一个在定义时无意义，其具体值完全由执行时决定”这点之后，我都尽量避免去使用 this ，实在要用，在调用时，我都会通过 apply 或 call 明确指定上下文，这样，至少不会踩坑里。 3. 第三阶段，一切都是上下文某天，我在网上看到了这样一段代码（原始出处不知道）： 1var bind = Function.prototype.call.bind(Function.prototype.bind) 这个新定义的 bind 函数具体做什么事先不管它，我好奇的是 call.bind() 这个调用。因为 call 这个函数，之前一直以为它是 Function 对象的一个方法（它本身也是一个函数），但是，如果按“对象的方法”这个角度去想的话，那对它绑定一个上下文（ bind() 的调用 ）不就完全没有意义了么？（因为对象的方法应该是跟上下文无关的） 不久之前，我在一条tweet上看到了这样一段js代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 第一眼看上去，我能猜出它究竟是用来做什么的。它把x.y(z)转化成了y(x,z)。我欣喜万分的给我的同事看这段代码。他们问我这是什么意思。而我当我正要开口向他们解释时却发现不知道怎么说才好。我徘徊了一会然后郁闷的走开了。 编写良好的代码会向人们传达它的作用。在读完Functional Javascript和 JavaScript Allongé （两本都是相当好的书）这两本书之后，再加上我在Javascript函数式编程方面有些经验，弄懂上面这段代码的意思毫无压力。但是应该怎么向没有函数式编程经验的人解释呢（正如大多数人关心的那样）？ 我决定亲自来完成这个任务，通过简单地例子和注释。我的结果如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 //设立一个简单地对象作为“上下文”var context = &#123; foo: "bar" &#125;;//一个在this上下文中指向foo变量的函数function returnFoo () &#123; return this.foo;&#125;// 变量在作用域中不存在，因此显示undefinedreturnFoo(); // =&gt; undefined// 如果我们把它绑定在context上下文中var bound = returnFoo.bind(context);// 现在的作用域中有这个变量了bound(); // =&gt; "bar"//// 这就是Function.prototype.bind的作用. //由于returnFoo也是函数，因此它继承了function的原型//// 如果你觉得享受，接着往下读，下面更精彩//// 有许多方法将函数绑定在一个上下文中// Call和Apply让你能在上下文中调用函数returnFoo.call(context); // =&gt; barreturnFoo.apply(context); // =&gt; bar// 将函数添加到对象中context.returnFoo = returnFoo;context.returnFoo(); // =&gt; bar//// 现在我们来玩一点诡异的东西//// Array.prototype 中有一个叫做slice的方法// 对一个数组调用slice，可以返回一个从start index到end index的数组[1,2,3].slice(0,1); // =&gt; [1]// 因此我们把Array.slice赋值给一个本地变量slicevar slice = Array.prototype.slice;//现在的slice是"自由的"，由于Array.prototype中的slice一般指定了上下文//或者默认为this,此时slice将不起作用slice(0, 1); // =&gt; TypeError: can't convert undefined to objectslice([1,2,3], 0, 1); // =&gt; TypeError: ...// 但是如果我们使用call或者apply，slice又将在一个上下文中执行slice.call([1,2,3], 0, 1); // =&gt; [1]// Apply和Call差不多，知识参数要放在一个数组中slice.apply([1,2,3], [0,1]); // =&gt; [1]// 使用call没错了，那么能不呢使用bind呢？// 没错，我们来把"call"绑定在slice上slice = Function.prototype.call.bind(Array.prototype.slice);// 现在slice可以把第一个参数作为上下文了slice([1,2,3], 0, 1); // =&gt; [1]//// 很酷，对吧。现在再来完成一件事//// 现在我们对bind本身做一件刚才对silce做的事var bind = Function.prototype.call.bind(Function.prototype.bind);// 在这里总结一下，好好想想// 发生了什么事? 我们改变了call，// 返回一个接收一个函数和一个上下文作为ic桉树的函数//并且返回了一个完全绑定的函数// 回到最初的例子var context = &#123; foo: "bar" &#125;;function returnFoo () &#123; return this.foo;&#125;// 现在来使用神奇的"bind"函数var amazing = bind(returnFoo, context);amazing(); // =&gt; bar 其中以 slice 函数举的例子让我恍然大悟： 上下文控制不仅仅是 apply / call，所有的点 . ，都是在指定上下文。 js 中的函数比我想像的还要纯，根本没有“对象中的方法”这个东西，即使是“原生对象”中。（它仅仅起一个名字空间的作用） 所有的函数调用，都有两层意义，比如 c.f()： f 这个函数，它在 c 中。（名字空间的问题） 把 c 作为 f 的上下文，去调用 f 。（前提是 f 没有绑定过上下文） 如果 c 没有，则默认是 window 。 所有的，js 中所有的函数调用，都是如此。即使是 f.call(context, x) ，我之前只看到了第一层意义（ f 中有一个 call 方法可以使用），则忽略了第二层意义 —— 把 f 作为 call 的上下文。 简单来说，我们可以相像 call 这个函数，它的代码大概是这样的（可变参数的问题先不管）： 1234var call = function(context, a)&#123; var new_func = this.bind(context); retur new_func(a);&#125; 它的作用，就是把 指定的上下文（context） 作为 自己的上下文（this） 的 上下文 ，然后再调用 自己的上下文（绑定上下文之后的 this） 。 上面一句话有些纠结哈，主要搞明白多种上下文的关系， f.call(context, x) 当中， 自己的上下文上面是 f 。 指定的上下文 上面是 context 。 再看 f.call(context, x) 这个代码，结合“函数是单纯”这点，我想到，即使是原生对象的那些方法， 也不过是把一些单纯的函数放到了 prototype 中而已 ，比如把 call 函数放到了 Function.prototype 当中。 至此，再看 c.f() ， a.b.c() 这些，不要去想是调用 c 对象中的 f 方法（这么说没错，但是名字空间的问题是显而易见的嘛），而是想成，调用时把 c 作为 f 的上下文。 好了，回到开始的那行例子： 1var new_bind = Function.prototype.call.bind(Function.prototype.bind) 这个就非常好理解了（为了描述方便，我改成 new_bind 了），把 bind 作为上下文绑定到 call中。 这里注意一下，绑定了上下文的 call 函数，还是 call 函数，但是 “此 call 已经非彼 call” 了。 所以： 1new_bind != Function.prototype.call 虽然调用形式上， new_bind 和 call 完全一样，但是他们的上下文行为不一样： call 是未绑定状态，所以 f.call() 会在执行时把 f 作为上下文绑定到 call 函数中。 new_bind 是已绑定状态，所以 f.new_bind() 对 new_bind() 的执行完全没影响。 我们可以以这样的流程来帮助我们理解： 1new_bind =&gt; call =&gt; bind.call =&gt; bind.call(f, context) =&gt; f.bind(context) 一步一步解释： new_bind =&gt; call new_bind 在形式上就是 call 。 call =&gt; bind.call 只是这个 call ，是指定了 bind 作为它的上下文的。既然是 bind 作为它的上下文，那我们可以写成是 bind.call 的样式。 bind.call(f, context) =&gt; f.bind(context) new_bind 的调用 new_bind(f, context) 就相当于是 bind.call(f, context) 。考虑 call 函数之前的行为： f.call(context, a) 是把 context 作为 f 的上下文，也就是 context.f(a) ，那么 bind.call(f, context) 对应的就是 f.bind(context) 。 f.bind(context) 不用多说了吧，把 context 绑定到 f 上，返回一个绑定了上下文的新函数。 完全是最基本的代数推导嘛，形式上，上下文前置总是没有问题的。 4. 结语我一直认同，要理解 js 的东西，从函数式语言入手，非常合适。硬要往面向对象的那套东西上套，太纠结了（我不管概念上到底什么样才叫面向对象，原生没有类定义，没有继承，没有实例化，就别扯这些就完了。对了，我认为原型追溯那不叫继承哈）。 当然，我不知道弄明白了最后那个“代数推导”到底有什么好处，也许没有，因为就算不明白这些也不影响我写了很多可以正常工作的 js 代码嘛。只是，我以后再写，思路上的可能会有一些不同了。比如代码组织的形式上，可以尝试把很多的小函数做到不同的“名字空间”中，然后再在业务层面，通过 Mixin 来拼出不同的业务对象。这些函数中可能到处充斥着 this ，我能控制好它们了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs技术]]></title>
    <url>%2Fposts%2F39022.html</url>
    <content type="text"><![CDATA[前端技术的发展是如此之快，各种优秀技术、优秀框架的出现简直让人目不暇接，紧跟时代潮流，学习掌握新知识自然是不敢怠慢。 AngularJS这是一个AngularJS Guide的中文分支版本，提供关于AngularJS的视频、入门、使用与论坛等中文互联网内容，这里的分类并没有完全参照英文版，也并不固定，如果你有发现新的内容需要添加新类别，直接加吧。 视频 Angular教学视频youku转载 入门指南 使用AngularJS构建大型Web应用 AngularJS入门教程 AngularJS学习笔记 使用经验 AngularJS开发一些经验总结 再谈AngularJS DI(Dependency Injection) Angularjs的IOC Inject分析 细说Angular ng-class AngularJS Controller 间通信机制 AngularJS表达式-Expression AngularJS关于依赖和模块与amd/cmd的区别，分享下结合使用示例 搞懂 AngularJS 預設模組 select 標籤的 ngOptions 參數用法 如何讓 Visual Studio 2012 支援 AngularJS 的 Intellisense 如何组织大型JavaScript应用中的代码？ 论坛 AngularJS中文社区 angulargirl 繁体中文翻译 学习AngularJS译者: 这是jmcunningham/AngularJS-Learning的简体中文翻译 我会尽量依照原文翻译 某些专有名词就不另外翻译 如果翻译错误也请提出建议指教 希望大家可以帮忙提供更多更好的AngularJS学习资源 谢谢 这里提供一些学习AngularJS的部落格链接, 文章, 和影片. 这个列表还在持续成长中. 如果你有想提供的链接与资源, 欢迎提出pull request. 我也会尽量确认以下的资源是有用的(不是只有两段文字的灌水文). 如果你有更好的方法来分类这些资源, 请让我知道. 在一般主题分类中的类似文章, 我之后也会把他们另外分类出来. 注意：**开头的链接是讨论ANGULAR 1.2版的新功能. 许多人希望快速了解Angular 1.2版的新功能, 所以我也会在之后开出新的分类标题. 等内容整理差不多或者1.2版分类变得太大我再来编辑, 不过现在的话Angular 1.2链接可以在两处同时看到. Angular 1.2 的新功能 **AngularJS 1.2 &amp; Beyond **Error Message Minification with MinErr **AngularJS路由的变化 **AngularJS缺失的指令: Focus &amp; Blur **Remastered Animation in AngularJS 1.2 **Preparing for Animations in Angular 1.2.0 **AngularJS 1.2中的5个超酷新特性 **在AngularJS 1.2.0中使用ngAnimate替代jQuery.slideDown() **为AngularJS 1.2做好准备 书籍 Books AngularJS 立刻快速开发 AngularJS AngularJS 菜单 AngularJS 在行动 AngularJS For .Net 开发员 AngularJS 浏览器应用程序开发 发现自己的 AngularJS 优势 AngularJS Directives ng-book 打造你的AngularJS AngularJS依赖注入 通过Bootstrap和AngularJS学习Web开发 AngularJS 设计模式 AngularJS 网路应用开发蓝图 实用 AngularJS 影片 Videos Egghead.io — 44 videos of about 4 minutes each — source code 视频教程: 60分钟教你 AngularJS 基础入门 — 1:10:50 AngularJS YouTube 主页 — several videos, mostly presentations of 1h or more Angular JS 入门 — 50:05 Angular JS 端对端测试 — 52:59 Angular JS 安全性 — 29:45 Grunt 和 Angular JS 前端开发流程 — 1:02:37 AngularJS 教程 — 12:19 AngularJS 秀 (Tekpub) — 8 videos (paid) 用 AngularJS 快速开发 Javascript 应用程序(Tuts+) — 22 videos of about 5 minutes each, in 8 sections (paid) AngularJS 基础入门 (Pluralsight) - 6 hours 15 minutes total (paid) **AngularJS 1.2 和未来 AngularJS 实例 - Growing list of 5 minute or less videos 用 AngularJS 和 Firebase 开发实时程序 MongoDB 和 AngularJS， MEAN 堆 AngularJS, EmberJS 和 KnockoutJS 双向绑定的比较 Angular最佳实践 - 64 videos(paid) Neosavvy的 Angular &amp; Jasmine 视频系列 - 16 videos of about 2-3 minutes each AngularJS 视频集合 — Collection of Videos from Various websites. ng-conf YouTube 页面 — YouTube channel with all the presentations given at the Angular Conference in January 2014. 通过50个例子学习 Angular.js (第1部分) 在线课程 Courses Thinkster.io - 学习 AngularJS 更好的方法 - 免費的線上 AngularJS 課程 AngularJS互动教程 和Dan Wahlin一起学习AngularJS Tuts+: 开始使用 Angular Code School Shaping Up with Angular.js Lynda Up and Running with AngularJS Codecademy AngularJs 帮助 Help StackOverflow AngularJS 邮件列表（谷歌小组） Chatroom （基于浏览器的在线聊天系统） AngularJS Google+的社区 reddit 一般主题 General Topics AngularJS 速查表 AngularJS 乐趣 AngularJS Philly ETE 幻灯 随机技巧使用 AngularJS AngularJS 难倒我的是什么 5个理由在企业应用程序世界中使用 AngularJS 在 AngularJS 中实现延迟加载 用更多 AngularJS 魔力来大力增压你的浏览器应用程序 HashKeyCopier - 一个 AngularJS 合并缓存和实时数据的实用工具类 在 AngularJS 中探索 Directive 指令，$scope，DOM 渲染和时序 在 AngularJS 资源上应用缓存的响应 Angularytics: 在 SPA 中用 AngularJS 来跟踪页面访问量和事件的解决方案 在 AngularJS 上共享数据，状态和模型： 方案选择，比较和我的解决方案 Angular.js 和 IE8 缓存 AngularJS 和 SEO 模板，路由和共享数据视图之间的一个 AngularJS 的应用 用 AngularJS 改善最终用户体验 AngularJS 控制器教程与实例 HTML5 本地存储与 Angular JS 动态路由和 AngularJS 以及 Silex 在你的 AngularJS 应用中建模数据和状态 AngularJS 代码重用 在 AngularJS 和 RequireJS 中动态加载控制器和视图 用AngularJS的orderby筛选器对多个字段用不同顺序排序 $http 响应拦截器 AngularJS: 先进的设计模式和最佳实践 AngularJS 的自动 JSON 数据解析 AngularJS 抽象：模块 在 AngularJS 中用 ngSwitch 和 ngSwitchWhen 来混合静态内容 AngularJS 构建大型应用程序 **错误信息与微小MinErr 如何让你的AngularJS 应用程序在IE8工作 AngularJS 性能优化的长列表 AngularJS 响应网站 在 AngularJS 减少初始化时间 用 Yeoman, Grunt 和 Bower快速开发 Angular 程序 **AngularJS 1.2 准备 10个理由网页开发人员应该了解AngularJS AngularJS partials 的懒惰预取 让你加快速度 AngularJS 开发的资源 使用装饰提升 AngularJS $log 使用 AngularJS 和 Stacktrace.js 记录客户端错误 AngularJS表单自动完成，并记住密码 优化AngularJS: 从1200ms到35ms 为AngularJS应用创建一个RequireJS服务 在你的应用开始后加载AngularJS组件 根据需求加载AngularJS模块 用Grunt来配置AngularJS环境 服务器在单页应用(SPAs)中的作用? 通过Websockets将Angular.js实时化 丰富的对象模型和Angular.js 丰富的对象模型和Angular: 一致性映射 AngularJS中的障碍和实用例子 通过故事理解AngularJS路径 重构AngularJS Angular模型和javascript的类 angularjs控制器的状态 怎么使用AngularJS的ngMessages 深度挖掘Angular的控制器 AngularJS自定义过滤器 理解Angular的$scope和$rootScope事件系统中的$emit,$broadcast和$on AngularJS无阻碍数据预载 介绍/开始学习 AngularJS AngularJS 入门 你需要开始了解的 AngularJS 的一切 要成为 AngularJS 专家必备的知识 5个很棒的 AngularJS 功能 AngularJS for jQuery 开发者 AngularJS 入门指南 用 AngularJS 从头开始写应用程序 AngularJS: 概述 AngularJS教程 - 建立一个应用程序使用的指令和数据绑定 在30分钟内教会你 AngularJS 用 Yeoman, Grunt 和 Bower 快速开发 10个你需要开始用 AngularJS 的理由 AngularJS 筛选器 一天学会 AngularJS 7 种成功学习Angular的方法 用Node and Angular创建单页应用 通过 5 个实例学习Angular 考虑的AngularJS的效率 Environment Specific Configuration in AngularJS Using Grunt 用装饰来提升Angular日志 Picking Up Angular, build a twitter-like application AngularJS网页应用的异常处理 AngularJS 101: 从0开始学 Angular 使用及学习心得 Lessons Learned 经验教训：一年一个大AngularJS项目 一些AngularJS陷阱 我希望我事先被告知关于 Angular.js 的事实 我希望我当时就知道我现在知道的东西 — 我和AngularJS 如何建立一个大型Angular.js应用 对新手和全能好奇的开发人员的 AngularJS 提示和技巧 分段式文章 Multipart Articles 开始使用elasticsearch和AngularJS: Part1 - 搜索, Part 2: Faceting, Part 3: Visualization 用AngularJS开发可维护网络应用: Part 1, Part 2 Google,Twitter和AngularJS: 1: Google, Twitter, and AngularJS, 2: Let’s Make a Feed Reader, 3: 生成源, 4: 管理源, 5: 测试, 6: 增加依赖, 7: 表格验证, 8: 迭代程序 &amp; 过滤器, 9: 安装 用AnuglarJS打造 SignalR Stock Ticker: Part 1, Part 2 AngularJS 最佳实践: 我之前都做错了!: Part 1, Part 2, Part 3 AngularJS简介 Part 1, Part 2 深入AngularJS : Part 1, Part 2: 过滤器 The 7 成为Angularjs大师, Part 2: Scopes, Part 3: 双向绑定, Part 4 and 5: Expressions and directives, Part 6: 服务 AngularJS 概况: 1:开始 AngularJS编程, 2:创造 一个 AngularJS 控制器, 3: AngularJS $scope 不是MVC 模型, 4:在 AngularJS中重复使用元素, 5: 在一个 AngularJS ngRepeat 元素中过滤数据, 6:用 #AngularJS 表格控制器来控制表格提交, 7:创造 #AngularJS Directive, 8:在一个 AngularJS 应用中使用DOM 打造一个基于MongoDB, ExpressJS, AngularJS, 和 Node.js的Google日历订阅App Part 1 创造组建: Part 1: 30秒将jQuery转成AngularJS, Part 2: AngularJS Directive 控制器 范例应用程序 Sample Apps 建有AngularJS购物车应用程序 用谷歌feed API 和 AngularJS建立一个 feed 阅读器 Scopes &amp; Compile AngularJS 和 scope.$apply AngularJS 什么是范围原型/原型继承的细微之处？ angularjs.org watch, on pub sub, 和你. AngularJS 中使用 Ng-bind In AngularJS 中解除绑定 $watch() Listeners 使用AngularJS 对DOMZ中的 $scope 进行访问 指令链路, $observe, 和 $watch 功能在AngularJS语境执行的内部 Hailing All Frequencies – 在 AngularJS 用 Pub / Sub 设计模式进行内部沟通 AngularJS 嵌套作用域 AngularJS: 6个常见的使用作用域的陷阱 Scoping AngularJS Directives: Part 1, Part 2 $watch $apply 是怎么运行 $digest 的 AngularJS: $watch, $digest 和 $apply 删除不需要的 Watches Angular - $compile: 它是如何工作，如何使用它。 通过实例来了解 Angular.js $scope 在AngularJS控制器之间共享状态 依賴注入 Dependency Injection AngularJS依赖注入背后的魔法 AngularJS: 更多关于依赖注入 Angularjs 依赖注入 在 AngularJS 中配置依赖注入 在AngularJS依赖注入框架中定义实例化的类 指令 Directives AngularJS指令和JavaScript的计算机科学 AngularJS指令 - 特定于域的扩展为HTML AngularJS指令教程 Commentable： AngularJS 的多态嵌套注释指令 AngularJS的ngForm指令 执行指令后，DOM完成渲染 使用AngularJS指令的案例 我的方法来构建绑定到JavaScript的事件的 AngularJS指令 AngularJS 委派嵌套指令行为转到父指令 AngularJS 探索指令控制器，编译，链接和优先级 AngularJS 在指令中使用控制器 Angular.js 使用JSON参数的指令 指令的漫游指南 创建一个简单的AngularJS指令 扩展的HTML AngularJS指令 Angular 嵌套递归指令 AngularJS一个全功能于一身的指令控制器 平了 AngularJS 的战场: 构建可重用点击编辑指令 AngularJS 覆盖标准的HTML标签的指令 AngularJS 移动滑块指令 在AngularJS中使用命名空间一次性指令 AngularJS 和 $compile 深度了解指令 AngularJS: 引用父作用域的指令 提示：具有相同的名称的指令 将数据移入一个AngularJS指令 构建自定义 AngularJS 指令的独特价值 从现有的插件/脚本之一创建 AngularJS 指令 Angular.js指令 - 控制器和链路之间的区别 AngularJS指令教程 AngularJS指令设计一点通 重构 AngularJS 指令 服务/供应商 Services/Providers Angular service 还是 factory? 如何在4种不同的方式创建 （Singleton） AngularJS服务 Angular JS 中移动AJAX调用到定制服务 消费服务 了解服务的类型 理解 angular $http 拦截器 在 AngularJS 中 provider 供应商之间的差异 Angular 的模块：工厂服务，服务，价值，噢，我的天啊 路由 Routing 如何在AngularJS Web应用程序中推迟路由定义 AngularJS UI路由器状态管理 AngularJS 嵌套视图，路由和深层链接 Angular UI 路由器 AngularJS 使用UI路由器基础 **AngularJS 路由变化 承诺/递延 Promises/Deferred 加强 Angular 承诺: 从当初的诺言的结果中返回字段或方法的新的承诺 AngularJS 承诺，或在AngularJS处理异步请求 在 AngularJS 中利用 Futures 在 AngularJS 视图中使用承诺 使用 AngularJS 承诺 只有在所有的承诺都解决了再显示路由 表单 Forms AngularJS 表单验证 AngularJS指令来测试密码强度 AngularJS 指令来检查密码是否匹配 在 AngularJS 选择菜单中混合静态和动态数据 Angular.js: ng-select 和 ng-options Angular.js: 用 $watch和 blur自动完成和启用表单 创建AngularJS指令在表格中来删除重复的代码 In AngularJS 在指令中强制重绘会导致意外滚动 在 AngularJS 中使用 ngOptions 用 Angular JS 验证表单显示大量验证消息 在AngularJS应用程序管理文件上传的指令 AngularJS 单选按钮 AngularJS Referece 当前的 FormController 在AngularJS 中监听变化的验证 A Select $watch() 教我关于 ngModel 和 AngularJS 最前沿的：高级AngularJS表单验证 Twitter Bootstrap control-group directive for AngularJS 在AngularJS 中防止重复的请求 AngularJS 缺少的指令：原表单复位 **AngularJS 缺少的指令：焦点和模糊 Angular JS: 重复验证表单元素 Angular JS: 通过指令自定义验证 Angular JS: 表单验证 深入学习表单验证 Ng-model 和自定义表单验证 Angular JS Ajax 下拉菜单，日期选择器和保存数据 AngularJS 表单的概念 认证 Authentication AngularJS Web 应用程序处理用户身份验证 Angular.js 单页应用程序验证 AngularJS – 快速的基于角色的认证 单页应用验证 Collections (&amp; ngRepeat Stuff) 使用 AngularJS 继承来的Collection 在 AngularJS 中 添加 ngRepeat 列表分隔符 在 AngularJS 中分组嵌套 ngRepeat 列表 在 AngularJS 中使用 ngController 和 ngRepeat 在 AngularJS 中通过 ngRepeat 渲染DOM元素 原始码组织架构 Code Organization 用 AngularJS 开发超大的应用程序 大 AngularJS 和 JavaScript 的应用的代码组织 Angular 应用程序的网页结构构想 如何组织一个普通 Web 应用程序： 编码 AngularJS 的正确方法。基本示例 AngularJS 模块 ngDefine: AngularJS &amp; RequireJS 模块化AngularJS应用设计 在 AngularJS DI 中使用 RequireJS 测试 Testing 用 AngularJS 和 Testacular 进行全频谱测试 在单元测试中 Mocking 承诺 如何测试AngularJS指令 用 Jasmine 单元测试 AngularJS 控制器 使用 QUnit 和 Sinon 单元测试 AngularJS 控制器 测试 AngularJS Directive： 处理外部模板 如何进行 Angular 应用程序的单元测试 单元测试 - 指令 Directives 单元测试 - 服务 单元测试 - 控制器 在JavaScript 和 AngularJS 中 mock 服务器依赖性 AngularJS 先进的测试和调试的 AngularJS 单元测试的最佳实践 在 AngularJS 中装饰你的测试 RESTful Stuff 在 AngularJS 资源中使用 REST 风格的控制器 Restangular: 新AngularJS框架来适当地，轻松地处理 REST API REST 风格的资源 Restangular 新功能: 针对 Angular的终极 REST API 客户端 使用 AngularJS 厂服务与 RESTful 服务实现互动 在 AngularJS web应用程序中实现一个 REST 风格的 Web 服务身份验证 本地化 Localization Localizing Your AngularJS Apps Internazionalization (i18n) with AngularJS AngularJS And i18n 界面 UI Stuff Angular UI 套件（包括一些子项目） AngularJS 动画 在AngularJS增强的动画功能 可重复使用的 AngularJS 弹出的对话框中服务 在 AngularJS 中创建自定义显示/隐藏 Directive 在 Angular.js 中实现 Bootstrap Tabs 使用拦截器的响应显示和隐藏一个装载小工具 用 AngularJS 建立一个 Typeahead Directive AngularJS Modal 服务 AngularJS 中实现交叉衰落图像 AngularJS 和 SVG AngularJS: 滚动动画 AngularJS 动画 用 AngularJS 实现拖放文件上传 **在 AngularJS 1.2 中重新掌握动画 Angular JS - 通过ID滚动到某个元素 构建 AngularJS 对话服务 **在 Angular 1.2.0 中准备使用动画 **在 AngularJS 1.2.0 中用 ngAnimate 替换 jQuery.slideDown() AngularJS: 模糊图像 directive 使用AngularJS，Ajax和 Bootstrap 3 来建立一个“加载更多”小工具 整合其他语言/框架 Integration With Other Languages/Frameworks AngularJS 和 TypeScript 用 AngularJS 和 D3 来建立一个 WordCloud Directive 在 AngularJS 中用 jQuery Event Delegation Hooking up ASP.NET SignalR with Angular JS 在你的 AngularJS 应用程序进行 Facebook 的身份验证 用 Yeoman, Grunt &amp; Bower 来全面自动化你的 Angular 开发过程 用 Bower 编写可重用的 AngularJS 组件 用 ngularJS 开发谷歌地图的组件 无需服务器来通过 PouchDB 来同步多个 AngularJS 应用程序 用 AngularJS 和 PouchDB构建离线应用 如何AngularJS和Rails集成4 后端代管 Hosted Backends Parse.com boilerplate 建设大型，复杂 AngularJS 应用 用 Firebase用于 Angular 应用程序的实时数据库 用 Backlift开发针对 Angular 的 CRUD 后端 用 AngularJS 和 PouchDB 构建离线应用 用 DreamFactory 开发 针对 Angular 的 CRUD 后端 Firebase 和 Angular 三个双向数据绑定 移动装置 Mobile PhoneGap+AngularJS 快速入门指南 用 AngularJS 开发 PhoneGap 引用程序 PhoneGap 和 AngularJS: In App Browser PhoneGap 和 AngularJS: Notification Service 用 Phonegap, AngularJS 和 ExpressJS 开发移动程序第一部分 编译器 Text editor bundles/IDE Stuff Sublime text 2 包 VIM UltiSnip &amp; Snipmate AngularJS 代码片段 在 WebStorm 7 中运行 Javscript 测试 Visual Studio 开发工具 AngularJS Batarang Chrome 浏览器扩展 从JSON或者 restful API生成 JavaScript 和 HTML，使用 AngularJS 和 JQuery]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码（HTTP Status Code）]]></title>
    <url>%2Fposts%2F17073.html</url>
    <content type="text"><![CDATA[HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 100客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200请求已成功，请求所希望的响应头或数据体将随此响应返回。 201请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306在最新版的规范中，306状态码已经不再被使用。 307请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 4001、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402该状态码是为了将来可能的需求而预留的。 403服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426客户端应当切换到TLS/1.0。（RFC 2817） 449由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510获取资源所需要的策略并没有没满足。（RFC 2774）]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson和Jackson的使用]]></title>
    <url>%2Fposts%2F13911.html</url>
    <content type="text"><![CDATA[现在json的第三方解析工作很多，如json-lib，gson，jackson，fastjson等，先学习下面两种。 JackSON使用：Jackson主要使用ObjectMapper对象来进行序列化以及反序列化操作。 使用Jackson可以毫无压力的将复杂对象进行完全序列化，也可以将各种类型的对象反序列化 以下代码均省略异常处理 普通对象 序列化Order order对象：1234ObjectMapper mapper = new ObjectMapper();Writer strWriter = new StringWriter();mapper.writeValue(strWriter, order);String json = strWriter.toString(); 反序列化：1Order order = mapper.readValue(json, Order.class); 链表、Map等 序列化List orderList：1234ObjectMapper mapper = new ObjectMapper();Writer strWriter = new StringWriter();mapper.writeValue(strWriter, orderList);String json = strWriter.toString(); 反序列化：需要用到TypeReference 123List&lt;Order&gt; orderList = mapper.readValue(json, new TypeReference&lt;List&lt;Order&gt;&gt;() &#123; &#125;); 反序列化List&lt;LinkedHashMap&gt;1List orderList = mapper.readValue(json, List.class); 解析某个字段12JsonNode node = mapper.readTree(json);String name= node.get("name"); Jackson的JSON操作方法准备工作首先去官网下载Jackson工具包，下载地址http://wiki.fasterxml.com/JacksonDownload。Jackson有1.x系列和2.x系列，截止目前2.x系列的最新版本是2.2.3，2.x系列有3个jar包需要下载： jackson-core-2.2.3.jar（核心jar包，下载地址） jackson-annotations-2.2.3.jar（该包提供Json注解支持，下载地址） jackson-databind-2.2.3.jar（下载地址） 12345678910111213141516171819202122232425262728293031323334353637//JSON序列化和反序列化使用的User类import java.util.Date;public class User &#123; private String name; private Integer age; private Date birthday; private String email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; JAVA对象转JSON[JSON序列化]12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; User user = new User(); user.setName("小民"); user.setEmail("xiaomin@sina.com"); user.setAge(20); SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateformat.parse("1996-10-01")); /** * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。 * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。 * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。 * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。 * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。 * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。 */ ObjectMapper mapper = new ObjectMapper(); //User类转JSON //输出结果：&#123;"name":"小民","age":20,"birthday":844099200000,"email":"xiaomin@sina.com"&#125; String json = mapper.writeValueAsString(user); System.out.println(json); //Java集合转JSON //输出结果：[&#123;"name":"小民","age":20,"birthday":844099200000,"email":"xiaomin@sina.com"&#125;] List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(user); String jsonlist = mapper.writeValueAsString(users); System.out.println(jsonlist); &#125;&#125; JSON转Java类[JSON反序列化]12345678910111213141516import java.io.IOException;import java.text.ParseException;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; String json = "&#123;\"name\":\"小民\",\"age\":20,\"birthday\":844099200000,\"email\":\"xiaomin@sina.com\"&#125;"; /** * ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。 */ ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(json, User.class); System.out.println(user); &#125;&#125; JSON注解Jackson提供了一系列注解，方便对JSON序列化和反序列化进行控制，下面介绍一些常用的注解。 @JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。 @JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)。 @JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(“name”)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Date;import com.fasterxml.jackson.annotation.*;public class User &#123; private String name; //不JSON序列化年龄属性 @JsonIgnore private Integer age; //格式化日期属性 @JsonFormat(pattern = "yyyy年MM月dd日") private Date birthday; //序列化email属性为mail @JsonProperty("mail") private String email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 1234567891011121314151617181920212223import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; User user = new User(); user.setName("小民"); user.setEmail("xiaomin@sina.com"); user.setAge(20); SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateformat.parse("1996-10-01")); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(user); System.out.println(json); //输出结果：&#123;"name":"小民","birthday":"1996年09月30日","mail":"xiaomin@sina.com"&#125; &#125;&#125; GSON的使用：Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为串行化Java对象为JSON字符串，或反串行化JSON字符串成Java对象。GSON核心jar包不到1M，非常精简，但提供的功能无疑是非常强大的，如果使用JDK自带的JSON解析API，使用起来相对比较繁琐一点，而且代码量较多。 GSON目前的发展状况初始版本 2008年5月22日最新版本(稳定版本) 2.2.4/2013年5月13日；2个月前编程语言 Java操作平台 各种平台许可协议 Apache License 2.0官方网站 http://code.google.com/p/google-gson/下载地址 http://code.google.com/p/google-gson/downloads/listGSON帮助文档 http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/index.html 使用GSON转换时报的一个异常。1234567891011Exception in thread "main" com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:176) at com.google.gson.Gson.fromJson(Gson.java:803) at com.google.gson.Gson.fromJson(Gson.java:768) at com.google.gson.Gson.fromJson(Gson.java:717) at com.google.gson.Gson.fromJson(Gson.java:689) at com.demoone.UseGson.testOneBeanFromJSON(UseGson.java:54) at com.demoone.UseGson.main(UseGson.java:89) Caused by: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 //注意这句话跟数组集合有关 at com.google.gson.stream.JsonReader.beginObject(JsonReader.java:374) at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:165) ... 6 more 下面贴出，笔者的测试源码，注意上述异常，在代码的注释中已经指出问题原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.demoone; import java.util.ArrayList; import java.util.List; import com.entity.Person; import com.google.gson.Gson; import com.google.gson.reflect.*; /*** * 使用gson * 进行序列化,反序列化的操作 * json * **/ public class UseGson &#123; static Gson g=new Gson(); /** * 由集合类型的实体类 * 转换成Json类型 * **/ public static void testToJSON()&#123; List&lt;Person&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;2;i++)&#123; Person p=new Person(i, "散仙"+i, "北京市"+i, "54152541@qq.com", 500.0); list.add(p); &#125; String json=g.toJson(list); System.out.println(json); &#125; /** * 由json转换为实体类 * */ public static void testOneBeanFromJSON()&#123; /** * 转换一个Java Bean的时候 * 记住不能使用[],只有在使用集合的时候才可以使用 * 如上图贴的那个异常就是由此原因造成的，另外 * 格式要规范，中间不能出现空格字符 * * **/ String jsonBean="[&#123;\"id\":0,\"name\":\"散仙0\",\"address\":\"北京市0\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;]"; Person p=g.fromJson(jsonBean, Person.class); System.out.println(p); &#125; /** * 由json转换为实体类集合 * * */ public static void testListBeanFromJSON()&#123; /** * 转换一个集合 的实体Bean * 注意前面加上[]方括号，代表一个数组 * **/ String jsonBeanList="[&#123;\"id\":0,\"name\":\"散仙0\",\"address\":\"北京市0\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;,&#123;\"id\":1,\"name\":\"散仙1\",\"address\":\"北京市1\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;]"; List&lt;Person&gt; lists=g.fromJson(jsonBeanList,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); System.out.println("反序列之后"); for(Person pp:lists)&#123; System.out.println(pp); &#125; &#125; public static void main(String[] args) &#123; testListBeanFromJSON();//测试集合反序列化 testOneBeanFromJSON();//测试单个实体类反序列化 //testToJSON();//测试序列化 &#125; &#125; 运行结果: 123456testListBeanFromJSON() 方法: 反序列之后 编号：0 名字:散仙0 地址:北京市0 E-mail:54152541@qq.com 钱:500.0 编号：1 名字:散仙1 地址:北京市1 E-mail:54152541@qq.com 钱:500.0 testOneBeanFromJSON() 方法: 编号：0 名字:散仙0 地址:北京市0 E-mail:54152541@qq.com 钱:500.0 实体类Person: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.entity; /** * 实体类 * **/ public class Person &#123; private int id; private String name; private String address; private String email; private double money; @Override public String toString() &#123; // TODO Auto-generated method stub return "编号："+id+" 名字:"+name+" 地址:"+address+" E-mail:"+email+" 钱:"+money; &#125; public Person() &#123; // TODO Auto-generated constructor stub &#125; public Person(int id, String name, String address, String email, double money) &#123; super(); this.id = id; this.name = name; this.address = address; this.email = email; this.money = money; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; &#125;]]></content>
      <categories>
        <category>Json</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS是什么]]></title>
    <url>%2Fposts%2F16024.html</url>
    <content type="text"><![CDATA[SASS 是 CSS 的一个预处理工具，简单来说，它通过自己的一套语法规则来写源码，然后通过编译器，得到 CSS 代码。 1. SASS是什么为什么需要这东西呢？因为如果每天都要写很多的 CSS ，那么里面重复的内容会很多，同时，CSS 本身并没有相应的逻辑抽像工具，这就造成在项目中要对样式做有效的管理，似乎没有什么好办法了。 SASS 本身是来源于 Ruby 的一个项目，它目前的标准，应该是一个叫 libSass 的 C 语言库，有了这个 C 语言的实现之后，各种语言就可以很方便地 bind 过去了，从官网上的信息看，目前 C, Go, Java, Javascript, Lua, .NET, Node, Perl, PHP, Python, Ruby, Scala 这些语言上都有实现。 SASS 支持两种格式的源码写法，一种叫 SASS ，另一种叫 SCSS ，区别只是前者使用缩进，后者使用大括号。（我就不明白了，为什么有人喜欢大括号，你写了大括号不也要缩进么） 2. 安装这里，使用 Node 上的实现，叫 node-sass ： 1sudo npm install -g node-sass 安装之后，除了相应的 node 模块，还会有一个命令行可执行程序，叫 node-sass ： 1node-sass a.sass 通过 --output-style 参数可以控制输出的 CSS 的格式，我喜欢用： 1node-sass --output-style compact a.sass 这样输出的 CSS ，是一行一条。（以前喜欢这种形式，是因为一行一条的格式，可以方便地在编辑器中使用列编辑作批量修改） 3. 变量, 赋值, 数据类型SASS 中使用 $ 开头来标识一个变量名，使用 : 完成赋值的操作： 1$a: 123 数据类型有以下几种： 数字 123 , 1.2 , 12px , 12%, 这些是数字类型。比较特殊的一点，可能在于， SASS 把带有 CSS 单位的标识也作为数字处理，在后面的运算符行为时，单位部分也会一并处理。 字符串 abc 或 &quot;abc&quot; 或 &#39;abc&#39; 。简单来说，单引号，双引号都可以，不要引号也可以。但是，因为 CSS 中大部分的描述都是不要引号的形式，比如 color: red ，而不是 color: &#39;red&#39; ，所以，在引号的处理上，要小心。 颜色 red , #abcd , rgb(123,255,67) , rgba(123, 255, 67, 0.5) , CSS 中表示颜色的形式，在 SASS 中作为颜色类型处理。这里注意，第一个 red ，跟字符串的形式一样的。（我猜这类标识具有混合属性吧） 列表 10px 2px 0 0 或 Helvtica, Arial, sans-serif ，以空格，或者以逗号分割的数据形式，为列表。主要对应于 CSS 中的对应形式，比如 margin: 10px 2px 0 0 ， font-family: Helvtica, Arial, sans-serif 。 同时，列表这种类型，在处理函数的参数时也有用。 映射 (k1: v1, k2: v2) ，映射其实就是一个嵌套的列表，形如 (k1 v1), (k2 v2) ，主要用于迭代的一些控制结构中。 4. 变量符号化这里的“符号化”说法，意思就是“行内求值”。简单来说，就是把变量的值，在任何地方，转换为语法结构的一部分（因为按语法规则，“这里”是不能使用变量的）。举一个例子： 1234$a cls.$a: color: red 这肯定是错误的。因为 “规则” / “选择器” 部分，是不允许使用变量的。但是你可以： 1234$a cls.#&#123;$a&#125; color: red 这样，就是正确的了，编译出来是： 1.cls &#123; color: red; &#125; 同时，还有： 1234$a: &apos;red&apos;.cls color: $a 这样写，虽然编译没有问题，但是结果： 1.cls &#123; color: &apos;red&apos;; &#125; 这是不对的。换成： 1234$a: &apos;red&apos;.cls color: #&#123;$a&#125; 就可以正确得到： 1.cls &#123; color: red; &#125; 所以， #{} 的功能，算是非常有用且强大。 5. 嵌套规则与引用CSS 简单来说，只有两部分内容，一是规则，或者说选择器。二是属性描述。DOM 本身是一个层级结构，所以我们在书写规则时，也是层级下降的方式，这样，如果直接写 CSS ，就不可避免地要写很多重复的前置规则，比如： 12.project &gt; .header &gt; .title &#123; color: red; &#125;.project &gt; .header &gt; .content &#123; color: blue; &#125; SASS 最直观的一个功能，就是可以以一种嵌套的层级形式，来处理规则的书写： 123456.project &gt; .header &gt; .title color: red &gt; .content color: blue 这样不光可以少写很多代码，而且最重要的，是容易维护。 这种嵌套的层级结构，有一个特别的功能，就是使用 &amp; 可以作为当前选择的引用，这个功能，一般用于伪类： 12345678910.project &gt; .header &gt; .title color: red &gt; a color: yellow &amp;:hover text-decoration: none 编译得到： 123.project &gt; .header &gt; .title &#123; color: red; &#125;.project &gt; .header &gt; .title &gt; a &#123; color: yellow; &#125;.project &gt; .header &gt; .title &gt; a:hover &#123; text-decoration: none; &#125; 6. 运算符, 逻辑判断, 控制结构SASS 虽然不是完整的一门编程语言，但是，运算符和控制结构的概念还是有的。 这里先说一下， SASS 中可以使用 @debug 作标准输出。 123456789$a: 1px + 1px$b: 1px * 20$c: 10px - 2px$d: 10px / 2$e: 10 + 2 - 3 + 0px$e2: 10 + 2 - 3 + 0%$e3: (10 + 2) * 3 / 100 * 100%@debug $a, $b, $c, $d, $e, $e2, $e3 四则运算时，单位需要匹配，或者，你也可以在最后再处理单位。 控制结构方面，目前有 @for, @each, @while, @if 。 @for 单纯的数字范围的迭代：@for $i from 1 through 10 @debug $i @each 对列表的迭代：@each $i in 1,2,3,4 @debug $i支持多值匹配：@each $a, $b, $c in (a, b, c), (red, 1, blue) @debug $a, $b, $c @while $i: 0@while $i &lt; 10 @debug $i $i: $i + 1 @if 这里随便把逻辑判断一起用了：$i: 0@while $i &lt; 10 @if $i == 0 @debug zero @if $i &gt; 2 @debug gtwo @else @debug ltwo @if $i != 0 @debug other $i: $i + 1 7. 函数定义先说清楚这里的函数定义，传入参数，返回值，返回值。 1234@function add($a, $b) @return $a + $b@debug add(1, 2) 函数的参数，跟 Python 一样，可以有默认值，可以有关键词参数： 默认值： 1234@function add($a, $b:3) @return $a + $b@debug add(1) 关键词参数： 1234@function add($a:2, $b:3) @return $a + $b@debug add($b:1) 8. @mixin, 宏Mixin 是官方的叫的名字， 宏 是我自己叫的，因为，这东西的行为就像“宏”一样，可以生成代码片段。 Mixin 是 SASS 中地位很重要，还特别给它了一种简写形式。 12345@mixin em color: red.header.em @include em 简写形式： 12345=em color: red.header.em +em 生成： 1.header.em &#123; color: red; &#125; Mixin 也可以带参数： 12345678=em-back($color:yellow, $font-size: 14px) color: red background-color: $color font-size: $font-size.header.true +em-back($font-size: 20px) 生成： 1.header.true &#123; color: red; background-color: yellow; font-size: 20px; &#125; 还可以直接传入代码块： 12345678=em color: red @content.header.true +em font-size: 14px 生成： 1.header.true &#123; color: red; font-size: 14px; &#125; 注意， Mixin 的结果是代码块，所以，它不光可以返回属性块，还可以连带规则块一起处理： 123456=em span color: red.header.true +em 生成： 1.header.true span &#123; color: red; &#125; 引用 &amp; 也可以照常使用： 123456789=hover &amp;:hover @content.header.true color: white +hover color: red 生成： 12.header.true &#123; color: white; &#125;.header.true:hover &#123; color: red; &#125; 配合 @at-root 和 &amp; ： 12345678910=hover @at-root &amp; @content.header.true color: white +hover color: red 生成： 12.header.true &#123; color: white; &#125;.header.true &#123; color: red; &#125; Mixin 本身是可以嵌套的： 12345678910=em color: red=hover +em @content.header.true +hover background-color: aqua 生成： 1.header.true &#123; color: red; background-color: aqua; &#125; 9. @extend 续写前面说的 @mixin 是处理抽象的可复用代码，现在说的 @extend 是处理具体的已存在的可复用代码。其实两者的机制都是 Mixin ，这里说的 “续写” 是我自己叫的一个名字，因为我实在不想叫“继承”。 9.1. 最简单情况@extend 的作用，是通过指定标识符，在当前块中引用对应的属性定义。 123456.a color: red.b @extend .a background-color: blue 生成： 12.a, .b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 这里，你也可以看成是生成了： 123.a &#123; color: red; &#125;.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 或者： 12.a &#123; color: red; &#125;.b &#123; color: red; background-color: blue; &#125; 这里的行为，可以注意一点，用 @extend 的块自己本身一定还有一条定义 ，这里的就是最前面的 .b 有自己单独的一条。如果 .b 中没有 background-color ，也可以看成是 .b 会有两条相同的，仅有 color 的属性定义。 9.2. 复合规则当然，这是最简单的情况，复杂一点的： 123456.g.a color: red.b @extend .a background-color: blue 生成的是： 12.g.a, .g.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 这里的行为，可以总结为， @extend 部分，不会更改原有的规则限制。这里就是 .a 有 .g 这个限制，那么引用 .a 的 .b ，在引用部分，也有 .g 的限制。 把 .a 换成 .g 的话： 123456.g.a color: red.b @extend .g background-color: blue 那么生成的就是： 12.g.a, .a.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 上面的例子，把 .g.a 换成 .g .a 结果相同。 这里的： 1.g.a, .a.b &#123; color: red; &#125; 也可以看成是： 1.g.a, .b.a &#123; color: red; &#125; 9.3. 伪类伪类本身是一个限定，所以，如果碰到伪类的情况，就把它看成是一个普通类限定， @extend 就只是指定了一个复合条件而已。 先看复合条件的情况： 12345.g .x.y.z color: red.m @extend .x.y 生成： 1.g .x.y.z, .g .z.m &#123; color: red; &#125; 即： 1.g .x.y.z, .g .m.z &#123; color: red; &#125; 伪类同样： 12345.g img.user:hover color: red.b @extend img:hover 把 :hover 看成 .hover 就好了： 12345.g img.user:hover, .g .user.b &#123; color: red; &#125;-&gt;.g img.user:hover, .g .b.user &#123; color: red; &#125; 不过伪类一般会这么用吧： 123456.g img.user:hover color: red.b &amp;:hover @extend img:hover 生成： 12345.g img.user:hover, .g .user.b:hover &#123; color: red; &#125;-&gt;.g img.user:hover, .g .b.user:hover &#123; color: red; &#125; 9.4. 序列规则下的使用前面的例子， @extend 所在的规则，本身都比较简单。最复杂的情况，就是 @extend 所在的规则是多重限定，并且 @extend 指定的条件是多重限定，同时，目标定义时，又有多重限定，最后，目标可能还有多个。 四个点， @extend 所在的块， @extend 本身， @extend 可能碰到的目标， @extend 可能碰到的多个目标。 当然，现实情况不会这样，太复杂了 SASS 自己也搞不定。所以， SASS 中， @extend 本身的规则，是不允许有“序列条件”的。 12345.x a color: red.header &gt; a @extend .x a 这种情况，不被允许。 @extend 本身简单了一点，但是情况还是有些伤脑筋： 12345678.x &gt; .side .m.a color: red.y .m.a background-color: yellow.header .title a @extend .m.a 当 @extend 的目标有多个时，我们一个一个来看就好了，先看 .x &gt; .side .m.a 。 前面说过， @extend 不会改变原来的限定，所以， .x &gt; .side 这个条件是不会变的。但是，这里的情况有些不一样，因为， @extend 所在的块，本身还有一个 .header .title 的前置限定条件。 那么现在的问题就是，对于 .header .title a 中的这个 a ，它有两组前置限定条件了。 这里的两组条件，其实跟前面是一回事。最开始的一条，就说了，别忘了在 @extend 所在的块本身，还会有一条定义生成。不同的是，这里 @extend 所在的块本身，会被附加限定条件。 所以，单看： 12345.x &gt; .side .m.a color: red.header .title a @extend .m.a 第一步： 目标照写， .x &gt; .side .m.a { color: red } 。 第二步： 自己照写， .header .title .x &gt; .side a { color: red } 。 第三步： 目标 -&gt; @extend， .x &gt; .side .header .title a { color: red } 。 换作最简单情况的话： 12345.em color: red.side .content @extend .em 第一步： 目标照写， .em { color: red } 。 第二步： 自己照写， .side .content { color: red } 。 第三步： 目标 -&gt; @extend， .side .content { color: red } 。 9.5. 总结总结起来，对于： 12345[PRE_A] TARGET_A color: red[PRE_B] TARGET_B @extend TARGET_A 结果就是： [PRE_A] TARGET_A { color: red } ... TARGET_B { color: red } 1... TARGET_B &#123; color: red &#125; ​ 然后放 1[PRE_A] [PRE_B] 和 1[PRE_B] [PRE_A] 两种情况，得到： ​ [PRE_A] TARGET_A { color: red } [PRE_A] [PRE_B] TARGET_B { color: red } [PRE_B] [PRE_A] TARGET_B { color: red } 看之前的第二个目标实例： 12345.y .m.a background-color: yellow.header .title a @extend .m.a 自然就是生成： 123.y .m.a &#123; background-color: yellow &#125;... a &#123; background-color: yellow &#125;... a &#123; background-color: yellow &#125; 补充上： 123.y .m.a &#123; background-color: yellow &#125;.header .title .y a &#123; background-color: yellow &#125;.y .header .title a &#123; background-color: yellow &#125; 9.6. 抽象块SASS 还真是把 @extend 搞得复杂哦。 SASS 中还有一种“抽象块”的概述，相对于“抽象类”去理解吧。就是，定义的规则块，只是用来被 @extend 的，它自己不会出现在最终的 CSS 中，这种块，使用 %name 结尾来标识： 12345.x .y a%only color: red.title div .link @extend %only 结果就是： 123.x .y a &#123; color: red; &#125;... a.link &#123; color: red; &#125;... a.link &#123; color: red; &#125; 补充： 123.x .y a &#123; color: red; &#125;.x .y .title div a.link &#123; color: red; &#125;.title div .x .y a.link &#123; color: red; &#125; 最后去掉不要的： 12.x .y .title div a.link &#123; color: red; &#125;.title div .x .y a.link &#123; color: red; &#125; 抽象块最后 a.link 的处理，跟普通 @extend 行为不一样，普通的 @extend 不会保留 a ，只有 .link 。 10. @import 引入其它文件@import ，首先有原本的功能，即可以引入一段其它的 CSS 。 同时， SASS 中的 @import 也可以引入自己的 SASS 文件，比如： 1234@import &quot;reset.sass&quot;.ok @extend .em reset.sass 中有定义 .em { color: red; } ，最后编译就可以得到： 1.em, .ok &#123; color: red; &#125; @import 的其它使用形式还有： @import &quot;a&quot;, &quot;b&quot; 引入多个文件 @import &quot;a&quot; screen 使用媒体查询 @import url(&quot;http://fonts.googleapis.com/css?family=#{$family}&quot;) 使用变量 @import 可以在规则中使用，它的行为类似单纯的宏替换，比如： 12.a1 @import &quot;a.sass&quot; 11. @media 媒体查询@media 的写法与其在 CSS 中是一样的，SASS 中， @media 的额外能力，就是你可以把它写在规则下面，编译的时候，会自动整理代码，把 @media 部分抽到最外面去： 1234.a color: red @media print color: black 会生成： 12.a &#123; color: red; &#125;@media print &#123; .a &#123; color: black; &#125; &#125;]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志组件slf4j介绍及配置详解]]></title>
    <url>%2Fposts%2F30235.html</url>
    <content type="text"><![CDATA[每一个Java程序员都知道日志对于任何一个Java应用程序尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库，如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候在你的项目中学习使用SLF4J了。 基本介绍SLF4J不同于其他日志类库，与其它日志类库有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。 如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。 总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是对于API开发者的很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物，而且Apache commons logging也已经在使用这种思想了，但SLF4J正迅速成为Java世界的日志标准。让我们再看几个使用SLF4J而不是log4j、logback或者java.util.logging的理由。 SLF4J对比Log4J，logback和java.util.Logging的优势正如我之前说的，在你的代码中使用SLF4J写日志语句的主要出发点是使得你的程序独立于任何特定的日志类库，依赖于特定类库可能需要使用不同于你已有的配置，并且导致更多维护的麻烦。除此之外，还有一个SLF4J API的特性是使得我坚持使用SLF4J而抛弃我长期间钟爱的Log4j的理由，是被称为占位符(place holder)，在代码中表示为“{}”的特性。占位符是一个非常类似于在String的format()方法中的%s，因为它会在运行时被某个提供的实际字符串所替换。这不仅降低了你代码中字符串连接次数，而且还节省了新建的String对象。通过使用SLF4J，你可以在运行时延迟字符串的建立，这意味着只有需要的String对象才被建立。而如果你已经使用log4j，那么你已经对于在if条件中使用debug语句这种变通方案十分熟悉了，但SLF4J的占位符就比这个好用得多。 这是你在Log4j中使用的方案，但这并不有趣，而且降低了代码可读性，因为它增加了不必要的繁琐重复代码(boiler-plate code)： 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " symbol: " + symbol);&#125; 另一方面，如果你使用SLF4J的话，你可以得到更简洁格式的结果，就像以下展示的一样： 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 在SLF4J，我们不需要字符串连接而且不会导致暂时不需要的字符串消耗。取而代之，我们在一个以占位符和参数传递实际值构成的模板格式下写日志信息。你可能会在想万一我有很多个参数怎么办？嗯，那么你可以选择使用变量参数版本的日志方法或者以Object数组传递。这是一个相当方便和高效方法的打日志方法。记住，在生产最终日志信息字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。 123456public void debug(String format, Object arg1, Object arg2) &#123; if (logger.isDebugEnabled()) &#123; FormattingTuple ft = MessageFormatter.format(format, arg1, arg2); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); &#125;&#125; 同时，我们应该知道打日志是对应用程序性能有着很大影响，在生产环节上我们建议只进行必要的日志记录。 使用配置maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt; 日志系统配置假设现有如下程序： 1234567891011121314import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Main &#123; private static final Logger logger = LoggerFactory.getLogger(Main.class); public static void main(String[] args) &#123; int status = 0; if (status == 0) &#123; logger.info("status:&#123;&#125;", status); &#125; else &#123; logger.info("status:&#123;&#125;", status); &#125; logger.info("end!"); &#125;&#125; 可以使用以下两种方式对日志系统的输出格式、记录级别、输出方式等进行配置。 properties文件方式log4j.properties: 12345678910log4j.rootLogger=info, ServerDailyRollingFile, stdoutlog4j.appender.ServerDailyRollingFile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.ServerDailyRollingFile.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.ServerDailyRollingFile.File=logs/notify-subscription.loglog4j.appender.ServerDailyRollingFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.ServerDailyRollingFile.layout.ConversionPattern=%d - %m%nlog4j.appender.ServerDailyRollingFile.Append=truelog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %p [%c] %m%n 输出结果为： 122016-05-12 16:08:21 INFO [club.chuxing.learn.Main] status:0 2016-05-12 16:08:21 INFO [club.chuxing.learn.Main] end! xml文件方式首先pom中添加如下依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt;&lt;/dependency&gt; logback.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt; &lt;!-- 应用名称 --&gt; &lt;property name="APP_NAME" value="logtest" /&gt; &lt;!--日志文件的保存路径,首先查找系统属性-Dlog.dir,如果存在就使用其；否则，在当前目录下创建名为logs目录做日志存放的目录 --&gt; &lt;property name="LOG_HOME" value="$&#123;log.dir:-logs&#125;/$&#123;APP_NAME&#125;" /&gt; &lt;!-- 日志输出格式 --&gt; &lt;property name="ENCODER_PATTERN" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;80&#125; - %msg%n" /&gt; &lt;contextName&gt;$&#123;APP_NAME&#125;&lt;/contextName&gt; &lt;!-- 控制台日志：输出全部日志到控制台 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;Pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/Pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件日志：输出全部日志到文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/output.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 错误日志：用于将错误日志输出到独立文件 --&gt; &lt;appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 独立输出的同步日志 --&gt; &lt;appender name="SYNC_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/sync.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name="log.sync" level="DEBUG" addtivity="true"&gt; &lt;appender-ref ref="SYNC_FILE" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value="DEBUG" /&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;appender-ref ref="ERROR_FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 输出结果为： 122016-05-12 17:08:32.105 [main] INFO club.chuxing.learn.Main - status:0 2016-05-12 17:08:32.114 [main] INFO club.chuxing.learn.Main - end! 日志系统配置说明输出级别的种类 ERROR 为严重错误 主要是程序的错误 WARN 为一般警告，比如session丢失 INFO 为一般要显示的信息，比如登录登出 DEBUG 为程序的调试信息 配置日志信息输出目的地 log4j.appender.appenderName=?? org.apache.log4j.ConsoleAppender（控制台）org.apache.log4j.FileAppender（文件）org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置日志信息的格式 log4j.appender.appenderName.layout = ?? org.apache.log4j.HTMLLayout（以HTML表格形式布局）org.apache.log4j.PatternLayout（可以灵活地指定布局模式）org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） ConsoleAppender选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。Target=System.err:默认情况下是System.out,指定输出控制台 FileAppender 选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。 RollingFileAppender 选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。MaxBackupIndex=2:指定可以产生的滚动文件的最大数。 日志信息格式中几个符号所代表的含义 -X号: X信息输出时左对齐；%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921%r: 输出自应用启动到输出该log信息耗费的毫秒数%c: 输出日志信息所属的类目，通常就是所在类的全名%t: 输出产生该日志事件的线程名%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10)%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。%%: 输出一个”%”字符%F: 输出日志消息产生时所在的文件名称%L: 输出代码中的行号%m: 输出代码中指定的消息,产生的日志具体信息%n: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行 一个示例配置文件 1234567891011121314log4j.debug=true log4j.rootLogger=DEBUG,D,Elog4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File = logs/logs.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = DEBUGlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = logs/error.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = ERRORlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 过滤器过滤器，执行一个过滤器会有返回个枚举值，即DENY，NEUTRAL，ACCEPT其中之一。返回DENY，日志将立即被抛弃不再经过其他过滤器；返回NEUTRAL，有序列表里的下个过滤器过接着处理日志；返回ACCEPT，日志会被立即处理，不再经过剩余过滤器。过滤器被添加到 中，为 添加一个或多个过滤器后，可以用任意条件对日志进行过滤。 有多个过滤器时，按照配置顺序执行。 常用的过滤器： LevelFilter： 级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。有以下子节点： :设置过滤级别 :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 ThresholdFilter： 临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。 例如：过滤掉所有低于INFO级别的日志。 EvaluatorFilter： 求值过滤器，评估、鉴别日志是否符合指定条件。有一下子节点： :鉴别器，常用的鉴别器是JaninoEventEvaluato，也是默认的鉴别器，它以任意的Java布尔值表达式作为求值条件，求值条件在配置文件解释过成功被动态编译，布尔值表达式返回true就表示符合过滤条件。evaluator有个子标签，用于配置求值条件。 求值表达式作用于当前日志，logback向求值表达式暴露日志的各种字段：Name Type Descriptionevent LoggingEvent 与记录请求相关联的原始记录事件，下面所有变量都来自event 例如，event.getMessage()返回下面”message”相同的字符串 message String 日志的原始消息 例如，设有logger mylogger，”name”的值是”AUB”，对于 mylogger.info(“Hello {}”,name); “Hello {}”就是原始消息。formatedMessage String 日志被各式话的消息， 例如，设有logger mylogger，”name”的值是”AUB”，对于 mylogger.info(“Hello {}”,name); “Hello Aub”就是格式化后的消息。logger String logger 名。 loggerContext LoggerContextVO 日志所属的logger上下文。 level int 级别对应的整数值，所以 level &gt; INFO 是正确的表达式。 timeStamp long 创建日志的时间戳。 marker Marker 与日志请求相关联的Marker对象，注意“Marker”有可能为null，所以你要确保它不能是null。 mdc Map 包含创建日志期间的MDC所有值得map。访问方法是：mdc.get(“myKey”) 。 mdc.get()返回的是Object不是String，要想调用String的方法就要强转 例如，((String) mdc.get(“k”)).contains(“val”) .MDC可能为null，调用时注意。 throwable java.lang.Throwable 如果没有异常与日志关联”throwable” 变量为 null. 不幸的是， “throwable” 不能被序列化。在远程系统上永远为null，对于与位置无关的表达式请使用下面的变量throwableProxy throwableProxy IThrowableProxy 与日志事件关联的异常代理。如果没有异常与日志事件关联，则变量”throwableProxy” 为 null. 当异常被关联到日志事件时，”throwableProxy” 在远程系统上不会为null :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：过滤掉所有日志消息中不包含“billing”字符串的日志。 参考来源： http://www.importnew.com/7450.html#comment-204549 http://www.tuicool.com/articles/6VRnui http://blog.csdn.net/linwei_1029/article/details/8844939 http://blog.csdn.net/xuanjiewu/article/details/7587586 http://blog.csdn.net/haidage/article/details/6794540]]></content>
      <categories>
        <category>SLF4J</category>
      </categories>
      <tags>
        <tag>SLF4J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web站点如何防范XSS、CSRF、SQL注入攻击]]></title>
    <url>%2Fposts%2F52946.html</url>
    <content type="text"><![CDATA[对Web服务器的攻击也可以说是形形色色、种类繁多，常见的有挂马、SQL注入、缓冲区溢出、嗅探、利用IIS等针对Webserver漏洞进行攻击。本文结合WEB TOP10漏洞中常见的SQL注入，跨站脚本攻击(XSS)，跨站请求伪造（CSRF）攻击的产生原理，介绍相应的防范方法。 XSS跨站脚本攻击**XSS跨站脚本攻击指攻击者在网页中嵌入客户端脚本(例如JavaScript)，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的，比如获取用户的Cookie，导航到恶意网站，携带木马等。 如何防止XSS跨站脚本攻击：原则：不相信用户输入的数据 将重要的cookie标记为http only，这样的话Javascript 中的document.cookie语句就不能获取到cookie了 只允许用户输入我们期望的数据。例如：年龄的textbox中，只允许用户输入数字，而数字之外的字符都过滤掉 对数据进行Html Encode 处理。&lt; 转化为 &amp;lt;、&gt; 转化为 &amp;gt;、&amp; 转化为 &amp;amp;、&#39; 转化为 &amp;#039;、&quot; 转化为 &amp;quot;、空格 转化为 &amp;nbsp; 过滤或移除特殊的Html标签。例如：&lt;script&gt;、&lt;iframe&gt;、&amp;lt; for &lt;、&amp;gt; for &gt;、&amp;quot for 过滤JavaScript 事件的标签。例如 “onclick=”、”onfocus” 等等很多浏览器都加入了安全机制来过滤XSS 注意：攻击代码不一定在中 CSRF跨站请求伪造CSRF（XSRF）尽管听起来很想XSS跨站脚本攻击，但是它于XSS完全不同。XSS是利用站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的站点。与XSS相比，CSRF攻击不大流行和难以防范，所以比XSS更具危险性。 如何防止CSRF跨站请求伪造： 对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field）。 “双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form post之前正被JavaScript代码读取，那么限制跨域规则将被应用。什么叫限制跨域规则呢？限制跨域规则就是：如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。上面那个例子的受信任域就是银行网站的某个域，而Mallory发给Bob的链接不是受信任的域。 使用Post代替Get。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。 以上三点都是正对web站点的防御手段，第4点是从用户的角度的防御手段。通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie来防止CSRF攻击。 SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 如何防止SQL注入： 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL请求到Action的映射规则]]></title>
    <url>%2Fposts%2F61440.html</url>
    <content type="text"><![CDATA[URL请求到Action的映射规则 1.URL路径映射1.1.对一个action配置多个URL映射：我们把上一篇中的HelloWorldController的index() action方法的@RequestMapping更改为@RequestMapping(value={“/index”, “/hello”}, method = {RequestMethod.GET})，这表示对该action配置了/index和/hello两个映射。运行测试，可以看到/helloworld/hello请求也成功匹配。 1.2.URL请求参数映射：这在查询的时候经常用到，比如我们根据id或编号来获取某一条记录。 在HelloWorldController添加一个getDetail的action，代码如下： 12345678@RequestMapping(value="/detail/&#123;id&#125;", method = &#123;RequestMethod.GET&#125;)public ModelAndView getDetail(@PathVariable(value="id") Integer id)&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("id", id); modelAndView.setViewName("detail"); return modelAndView;&#125; 其中value=”/detail/{id}”,中的{id}为占位符表示可以映射请求为/detail/xxxx 的URL如：/detail/123等。 方法的参数@PathVariable(value=”id”) Integer id 用于将URL中占位符所对应变量映射到参数id上，@PathVariable(value=”id”) 中value的值要和占位符/{id}大括号中的值一致。 在views中添加detail.jsp视图，用于将获取到的id值展示出来。视图内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;id&#125;&lt;/body&gt;&lt;/html&gt; 运行试，请求URL地址 http://localhost:8080/SpringMVCLesson/helloworld/detail/123 ，结果可以看到已经正确的显示了我们请求的id。 1.3.URL通配符映射：我们还可以通过通配符对URL映射进行配置，通配符有“？”和“”两个字符。其中“？”表示1个字符，“”表示匹配多个字符，“**”表示匹配0个或多个路径。 例如：12345678910“/helloworld/index?”可以匹配“/helloworld/indexA”、“/helloworld/indexB”但不能匹配“/helloworld/index”也不能匹配“/helloworld/indexAA”； “/helloworld/index*”可以匹配“/helloworld/index”、“/helloworld/indexA”、“/helloworld/indexAA” 但不能匹配“/helloworld/index/A”； “/helloworld/index/*”可以匹配“/helloworld/index/”、“/helloworld/index/A”、“/helloworld/index/AA”、“/helloworld/index/AB” 但不能匹配 “/helloworld/index”、“/helloworld/index/A/B”; “/helloworld/index/**”可以匹配“/helloworld/index/”下的多有子路径，比如：“/helloworld/index/A/B/C/D”; 如果现在有“/helloworld/index”和“/helloworld/*”，如果请求地址为“/helloworld/index”那么将如何匹配？Spring MVC会按照最长匹配优先原则（即和映射配置中哪个匹配的最多）来匹配，所以会匹配“/helloworld/index”，下面来做测试： 在HelloWorldController添加一个urlTest的action，内容如下： 1234567@RequestMapping(value="/*", method = &#123;RequestMethod.GET&#125;)public ModelAndView urlTest()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("urltest"); return modelAndView;&#125; 在views文件夹中新加一个视图urltest.jsp，为了和index.jsp做区别urltest.jsp的内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; urlTest!&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/index查看结果： 可以看出映射的是index对应的action。 请求http://localhost:8080/SpringMVCLesson/helloworld/AAA查看结果： 可以看出映射的是urlTest对应的action。 1.4.URL正则表达式映射：Spring MVC还支持正则表达式方式的映射配置，我们通过一个测试来展示： 在HelloWorldController添加一个regUrlTest的action，内容如下： 123456789@RequestMapping(value="/reg/&#123;name:\\w+&#125;-&#123;age:\\d+&#125;", method = &#123;RequestMethod.GET&#125;)public ModelAndView regUrlTest(@PathVariable(value="name") String name, @PathVariable(value="age") Integer age)&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("name", name); modelAndView.addObject("age", age); modelAndView.setViewName("regurltest"); return modelAndView;&#125; 在views文件夹中新加一个视图regurltest.jsp内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;name&#125;-$&#123;age&#125;&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/reg/Hanmeimei-18查看结果： 请求http://localhost:8080/SpringMVCLesson/helloworld/reg/Hanmeimei-Lilei查看结果（会发现找不到对应的action返回404）： 2.限制action所接受的请求方式（get或post）：之前我们在HelloWorldController的index() action方法上配置的为@RequestMapping(value=”/“, method = {RequestMethod.GET})我们把它改为@RequestMapping(value=”/“, method = {RequestMethod.POST})再次请求http://localhost:8080/SpringMVCLesson/helloworld/index试一下： 这里可以看到结果映射到了urlTest这个action，这是因为我们在urlTest上配置的为@RequestMapping(value=”/*”, method = {RequestMethod.GET})，当index这个action映射不在符合时便映射到了urlTest。 我们也可以这样配置@RequestMapping(value=”/*”, method = {RequestMethod.GET, RequestMethod.POST})表示该action可以接受get或post请求，不过更简单的是不对method做配置则默认支持所有请求方式。 3.限制action所接受请求的参数：我们可以为某个action指定映射的请求中必须包含某参数，或必须不包含某参数，或者某参数必须等于某个值，或者某参数必须不等于某个值这些限制。 3.1.指定映射请求必须包含某参数：在HelloWorldController添加一个paramsTest的action，内容如下： 123456@RequestMapping(value="/paramstest", params="example", method = &#123;RequestMethod.GET&#125;)public ModelAndView paramsTest()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("paramstest"); return modelAndView;&#125; 在view文件夹中新加一个视图paramstest.jsp内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; paramstest!&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest查看结果： 这里可以看到没有找到paramsTest这个action结果还是映射到了urlTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example查看结果： 这次可以看到请求映射到了paramsTest这个action。 3.2.指定映射请求必须不包含某参数：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”!example”, method = {RequestMethod.GET}) 重新请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example查看结果： 可以看到又没有找到paramsTest这个action而映射到了urlTest这个action。 3.3.指定映射请求中或者某参数必须等于某个值：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”example=AAA”, method = {RequestMethod.GET}) 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=BBB查看结果： 可以看到没有找到paramsTest这个action而映射到了urlTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=AAA查看结果： 这次可以看到请求映射到了paramsTest这个action。 3.4.指定映射请求中或者某参数必须不等于某个值：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”example!=AAA”, method = {RequestMethod.GET}) 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=BBB查看结果： 可以看到请求映射到了paramsTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=AAA查看结果： 可以看到没有找到paramsTest这个action而映射到了urlTest这个action。 注：当我们为params指定多个参数时如：params={“example1”, “example2”}，表示的是and关系，即两个参数限制必须同时满足。 4.限制action所接受请求头参数：同限制action所接受的请求参数一样，我们也可以为某个action指定映射的请求头中必须包含某参数，或必须不包含某参数，或者某参数必须等于某个值，或者某参数必须不等于某个值这些限制。 4.1.指定映射请求头必须包含某参数：@RequestMapping(value=”/headerTest”, headers = “example”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.2.指定映射请求头必须不包含某参数：@RequestMapping(value=”/headerTest”, headers = “!example”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.3.指定映射请求头中或者某参数必须等于某个值：@RequestMapping(value=”/headerTest”, headers = “Accept=text/html”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.4.指定映射请求头中或者某参数必须不等于某个值：@RequestMapping(value=”/headerTest”, headers = “Accept!=text/html”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 注：当我们为headers指定多个参数时如：headers={“example1”, “example2”}，表示的是and关系，即两个参数限制必须同时满足。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的职业方向]]></title>
    <url>%2Fposts%2F47386.html</url>
    <content type="text"><![CDATA[我们可能会有这样的疑问：将来就业干啥好呢？ 如果你是学计算机的，将来想进入软件和互联网行业， 恭喜， 这是个好行业， 薪水很高， 也不需靠关系， 一切靠实力说话， 不需要有个好爸爸。 坏处是， 这个行业需要极为繁重的脑力和体力劳动 , 加班也是司空见惯的事情。 接下来的问题是： 现在软件和互联网大概有哪些方向？ 看看下文的解释： 1. 首先是需求从哪里来?1.1 客户的项目如果做的是客户的项目， 需求当然是从客户那里来的，当然客户绝对是软件开发的小白（其实也不能这么绝对啦， 我也见过极少客户中很优秀的软件人才），他们很难清楚的描述自己真正的业务要求， 这时候就需要有个人隆重出场了： 业务分析师 ， 对于大公司， 业务分析师是专职的， 对于小公司，项目经理或者开发骨干也就硬着头皮上了。 业务分析师需要把需求理理清楚， 交给后面的架构人员做设计。 业务分析师如果在某个行业干久了， 就会变成业务专家， 例如你把国内各大银行的核心系统项目都做了个遍， 那你对银行业务的熟悉程度甚至可能超过银行的特定人员， 这时候你就超级值钱了， 不仅仅能分析业务， 更能够帮助银行优化业务， 你说牛不牛？ 问： 业务分析师需要懂技术吗？ 答： 最好是懂一点，你分析出来的东西是要码农们实现的， 如果不考虑现有的技术，一味地迎合用户， 肯定会被码农们骂死。 如果你是由程序员成长起来的业务专家， 技术精湛， 那就坐着数钱玩吧。 1.2 公司的产品如果你做的是产品， 例如微信， QQ, 淘宝 ， 魔兽世界，征途， 大话西游， 那需求其实是自己公司的人来定义的。 定义这个需求的现在有个时髦的职业： 产品经理。 像张小龙就是微信的超级产品经理， 史玉柱就是征途的骨灰级产品经理。 产品经理主要根据用户的心理和体验来设计产品， 让大家用的爽，好的产品经理现在非常吃香， 也属于紧缺人才。 问： 产品经理需要懂技术吗？ 答： 需要， 最好是从程序员成长起来的， 知道一个产品设计实现的难度， 要不然只顾自己爽 ， 也会被码农骂死。 2. 设计和开发2.1 架构师听起来很高大上的一个职位， 但是需要强悍的技术实力和深厚的技术积累 架构师的成长需要历练， 需要技术的广度， 和适当的深度。 设计优雅，灵活，可扩展的架构是架构师的主要工作 不能追求最新，最热的技术， 还要考虑现有团队的能力，技术的成熟度。 人员需求：★ 难度指数：★★★★★ 2.2 web后端码农后端码农主要实现业务逻辑， 提供接口给前端使用。 Java 当然是用的最多的， 但是也有别的相对小众的像Python, ruby on rails 等， 还有就是PHP，简单粗暴 中小网站常用，无论哪一个，学习起来都不是很难 这一块的人员需求是比较大的。 人员需求：★★★★★ 难度指数：★★★ 2.3 web前端码农主要是Javascript , CSS， JQuery 等， 最近几年大家重视浏览器端用户体验， 浏览器端做的越来越炫， 所以也很火 人员需求：★★★★★ 难度指数：★★★ 2.4手机端码农主要是Android, iOS , 由于移动互联网的发展， 现在很火爆， 需求量很大， 相对而言iOS的门槛高一些，程序员也少一点，不过工资高一点。 人员需求：★★★★ 难度指数：★★★★ 2.5 系统编程码农有些需求很简单， 有些需求很复杂， 需要支持海量的用户 ，海量的并发， 像淘宝的双11， 像微信的春节抢红包 需要做云计算，虚拟化，分布式处理， 支持系统水平扩展。 对于海量的数据，还需要做大数据分析，从中提取有价值的信息， 例如Hadoop。 由于需要对操作系统，数据库，服务器端系统做定制开发， 甚至自己搞一套， 小公司一般没有这样的技术能力， 主要是BAT这样的公司在搞。 人员需求不是很大， 对码农来讲， 需要在一个领域钻研的非常深， 技术稳定度比较好。 人员需求：★★ 难度指数：★★★★★ 2.6 安全互联网时代， 你的信息一不留神就有可能被偷走， 安全变的越来越重要。 所以单单实现了功能， 满足了性能还不够， 很多公司，尤其是BAT对安全非常重视。 这个方向也需要对技术钻研的很深才可以 人员需求：★★ 难度指数：★★★★★ 3. 测试这个对技术要求不太高，但也需要测试相关的知识， 能够设计测试用例， 准备测试数据， 执行测试。 现在敏捷开发流行， 对测试也要求懂开发知识， 至少能够开发一些自动化的脚本。 很多女生后来转到了测试岗位， 我想主要是女生比较细心吧。 我在IBM见过一个非常优秀的测试人员： 她不仅仅能出色完成上面说的工作， 还可以参与设计开发的讨论， 经常能从测试角度提出开发人员都没有想到的问题，极大的帮助提升了软件的质量。 4. 数据库管理员几乎所有项目都需要数据库的支持， 对于大型，超大型项目， 会有一个叫做DBA的职位。他对数据库知识极为精通，平时对数据库进行管理， 开发时能帮助开发团队设计数据库，并且找出性能瓶颈， 进行性能调优。 5. 美工/文档美工： 就是对界面进行美化了，一般是由美工先出界面原型， 大家讨论，修改，确定后美工会生成各种界面元素，像图标，按钮等。 现在对美工也有一定的技术要求， 不仅仅是画界面，还要把html模板做出来， 所以美工需要懂得 HTML, CSS, 甚至部分Javascript。 程序员拿到html模板后，往上添加业务代码即可。 文档编写人员：小项目一般是有人兼职做， 大的项目，产品会有人专职写文档， 我2003年的时候参与过上海证券交易所的项目， 看到有个专职的文档编写人员写的Word , 是在是太专业了， 那个精美啊，完全是可以直接出版的水准。 我把它copy下来，自己都想山寨一个， 照葫芦画瓢都做不出来。 6. 项目管理项目已经开始了， 业务分析师， 架构师， 开发，测试等人一群人如饿狼扑食，势必要把项目撕个粉碎。 可以这么多人怎么协作？ 如何管理？ 进度能不能按要求完成? 这就需要项目经理出马了。 项目经理，说白了就是带着大家做项目， 主要和人打交道， 需要协调各个方面的关系， 保证项目的进展顺利。 问： 项目经理需要懂技术吗？ 答： 当然需要， 最好是开发出身， 要不然你就听不懂那帮码农再说什么， 只能在表面漂浮着， 没法深入项目，别人也就不服你 ， 肯定是带不好团队的。 7. 运营如果你是在开发自己的产品， 开发完成以后， 马上就会遇到一个问题， 怎么推广？ 在互联网时代，世界是平的， 竞争异常激烈，一个好的软件，或者App, 或者网站， 缺乏运营， 你的技术再好也不行。 运营其实就是想方设法让你的产品被人知道， 被人用起来，这里边水很深，例如怎么写个软文？ 怎么在社交网络，微信，微博进行营销？ 怎么统计，分析，精准的定位？ 这方面， 2014年以前的小米绝对是典范。 雷军的7字诀：专注，极致，口碑， 快， 黎万强的《参与感》 都是经典。 好的互联网运营人才奇缺， 当然非常的吃香。 对编程不感兴趣的同学，不妨看看这个方向。说了这么多职业方向， 你会发现， 绝大多数都要求懂一定的技术， 所以我其实想想说的是：刚参加工作， 不妨先从程序员开始， 慢慢的再寻找自己感兴趣的方向。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery中的DOM操作]]></title>
    <url>%2Fposts%2F64922.html</url>
    <content type="text"><![CDATA[JQuery中的DOM操作主要对包括：建【新建】、增【添加】、删【删除】、改【修改】、查【查找】【像数据库操作】。下面的DOM操作将围绕上面的DOM树进行学习JQueryDOM操作。 一、查–查找DOM节点查找节点非常容易，使用选择器就能轻松完成各种查找工作。 例：查找元素节点p返回p内的文本内容 1$("p").text(); 例：查找元素节点p的属性返回属性名称对应的属性值 1$("p").attr("title")//返回p的属性title的值。 1、jQuery选择器：$(‘#text’)最基本的选择器，简化了js的getElementById\byClassNames，querySelectorAll()等方法。允许使用css选择器来对DOM元素进行选择。 2、子元素1$(“.parent”).children();//所有子元素的集合1 3、parent()、parents()、closest()parent()用于查找一级父元素，parents()查找所有父元素的集合，closest()查找最近的父元素例如： 123456789&lt;div&gt; &lt;ul&gt; &lt;li id=“a”&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;var test = $(“#a”);test.parent();//ultest.parents();//ul,div..一直到htmltest.closest(“div”)//div12345678910 4、find()同js的[某元素].getElementById()，在某元素里面找元素 5、nextAll()、prevAll()Ps:javaScript的对应方法 1firstChild(),lastChild,parent()…. 二、建–新建DOM节点1、创建元素节点创建元素节点并且把节点作为元素的子节点添加到DOM节点树上。先创建元素点，创建元素节点使用Jquery的工厂函数$()来完成，格式如下：$(html),该方法会根据传入的html字符串返回一个DOM对象，并将DOM对象包装成一个JQuery对象后返回。创建一个元素节点JQuery代码如下： 1$li1=$("&lt;li&gt;&lt;/li&gt;") 代码返回$li1就是一个由DOM对象包装成的JQuery对象。把新建节点添加到DOM树中JQuery代码如下： 1$("ul").append($li1); 添加后页面中只能看到元素默认的”·”,由于没有为节点添加文本所以只显示默认符号，下面创建文本节点。PS:append()方法是添加DOM节点方法详见增–添加DOM节点。 2、创建文本节点使用JQuery的工厂函数$()同样能够创建文本节点，创建文本节点的JQuery代码如下： 1$li2=$("&lt;li&gt;苹果&lt;/li&gt;"); 代码返回$li2就是一个由DOM对象包装成JQuery对象，把新建的文本节点添加到DOM树中JQuery代码如下： 1$("ul").append($li2); 添加后页面中能看到”·苹果”，右键查看页面源码发现新加的文本节点没有title属性。下面方法创建带属性的节点。 3、创建属性节点创建属性节点同元素节点、文本节点一样使用JQuery的工厂函数完成。创建属性节点的JQuery代码如下： 1$li3=$("&lt;li title='榴莲'&gt;榴莲&lt;/li&gt;"); 代码返回$li3也是一个由DOM对象包装成JQuery对象，把新建的属性节点添加到DOM树中JQuery代码如下： 1$("ul").append($li3); 添加后页面中能看到”·榴莲”，右键查看页面源码发现新加的属性节点有title=’榴莲’属性。 三、增–添加DOM节点动态新建元素不添加到文档中没有实际意义，将新建的节点插入到文档中有多个方法，如下：append()、appendTo()、prepend()、prependTo()、after()、insertAfter()、before()、insertBefore()。 1、append()方法append()方法向匹配的元素内部追加内容，方法如下： 1$("target").append(element); 例： 1$("ul").append("&lt;li title='香蕉'&gt;香蕉&lt;/li&gt;"); 该方法查找ul元素，然后向ul中添加新建的li元素。 2、appendTo()方法appendTo()方法将所有匹配的元素追加到指定的元素中，该方法是append()方法的颠倒[操作主题的颠倒并非操作结果]操作。方法如下： 1$(element).appendTo(target); 例： 1$("&lt;li title='荔枝'&gt;荔枝&lt;li&gt;").appendTo("ul"); 该方法新建元素li，然后把li添加到查找到的ul元素中。 3、prepend()方法prepend()方法将每匹配的元素内部前置要添加的元素，方法如下：$(target).prepend(element);例： 1$("ul").prepend("&lt;li title='芒果'&gt;芒果&lt;/li&gt;") 该方法将查找元素ul然后将新建的li元素作为ul子节点，且作为ul的第一个子节点插入到ul中。 4、prependTo()方法 prependTo()方法将元素添加到每一个匹配的元素内部前置，方法如下：$(element).prependTo();例： 1$("&lt;li title='西瓜’&gt;西瓜&lt;/li&gt;").prependTo("ul"); 该方法将新建的元素li插入到查找到的ul元素中作为ul的第一个子节元素。 5、after()方法after()方法向匹配的元素后面添加元素，新添加的元素做为目标元素后的紧邻的兄弟元素。方法如下： 1$(target).after(element); 例: 1$("p").after("&lt;span&gt;新加段新加段新加段新加段新加段&lt;/span&gt;"); 方法将查找节点p，然后把新建的元素添加到span节点后面做为p的兄弟节点。 6、insertAfter()方法insertAfter()方法将新建的元素插入到查找到的目标元素后，做为目标元素的兄弟节点。方法如下： 1$(element).insertAfter(target); 例: 1$("&lt;p&gt;insertAfter操作&lt;/p&gt;").insertAfter("span"); 方法将新建的p元素添加到查找到目标元素span后面，做为目标元素后面的第一个兄弟节点。 7、before()方法before()方法在每一个匹配的元素之前插入，做为匹配元素的前一个兄弟节点。方法如下: 1$(target).before(element); 例： 1$("p").before("&lt;span&gt;下面是个段落&lt;/span&gt;"); before方法查找每个元素p，将新建的span元素插入到元素p之前做为p的前一个兄弟节点。 8、insertBefore()方法insertBefore()方法将新建元素添加到目标元素前，做为目标元素的前一个兄弟节点，方法如下: 1$(element).insertBefore(target); 例: 1$("&lt;a href='#'&gt;锚&lt;/a&gt;").insertBefore("ul"); insertBefore()新建a元素，将新建的a元素添加到元素ul前，做为ul的前一个兄弟节点。 增加元素的方法前四个是添加到元素内部，后四个是添加到元素外部的操作，有这些方法可以完成任何形式的元素添加。 四、删–删除DOM节点操作如果想要删除文档中的某个元素JQuery提供了两种删除节点的方法：remove()和empty(); 1、remove()方法remove()方法删除所有匹配的元素，传入的参数用于筛选元素，该方法能删除元素中的所有子节点，当匹配的节点及后代被删除后，该方法返回值是指向被删除节点的引用，因此可以使用该引用，再使用这些被删除的元素。方法如下： 1$(element).remove(); 例: 12span=("span").remove();$span.insertAfter("ul"); 该示例中先删除所有的span元素，把删除后的元素使用$span接收，把删除后的元素添加到ul后面做为ul的兄弟节点。该操作相当于将所有的span元素以及后代元素移到ul后面。 2、empty()方法。empty()方法严格来讲并不是删除元素，该方法只是清空节点，它能清空元素中的所有子节点。方法如下: 1$(element).empty(); 例： 1$("ul li:eq(0)").empty(); 该示例使用empty方法清空ul中第一个li的文本值。只能下li标签默认符号”·“。 五、改–修改DOM节点操作 修改文档中的元素节点可以使用多种方法:复制节点、替换节点、包裹节点。 1、复制节点$(element).clone() 复制节点方法能够复制节点元素，并且能够根据参数决定是否复制节点元素的行为。方法如下: 1$(element).clone(true); 例： 1$("ul li:eq(0)").clone(true); 该方法复制ul的第一个li元素，true参数决定复制元素时也复制元素行为，当不复制行为时没有参数。 2、替换节点$(element).repalcewith()、$(element).repalceAll() 替换节点方法能够替换某个节点，有两种形式形式实现：replaceWith()和replaceAll().使用replaceWith方法使用后面的元素替换前面的元素，replaceAll方法使用前面的元素替换后面的元素，方法如下：$(oldelement).replaceWith(newelement);$(newelement).repalceAll(oldelement);例： $(“p”).replaceWith(“我要留下“);该方法使用strong元素替换p元素。 $(“替换strong“).repalceAll(“strong”);该例使用h3元素替换所有的strong元素。 3、包裹节点$(element).wrap()、$(element).wrapAll()、$(element).wrapInner() 包裹节点方法使用其他标记包裹目标元素从而改变元素的显示形式等，并且该操作不会破坏原始文档的词义。包裹节点有三种实现形式：wrap();wrapAll();wrapInner(); wrap()方法如下： 1$(dstelement).wrap(tag); 例： 1 $("p").wrap("&lt;b&gt;&lt;/b&gt;");//该示例方法使用b标签包裹所有的p元素每个元素都使用b标签包裹。 wrapAll()方法如下： 1$(dstelement).wrapAll(tag); 例： 1 $("p").wrapAll("&lt;b&gt;&lt;/b&gt;");//访示例方法使用b标签包裹所有的p元素，所有的p元素标签用一个b标签包裹。 wrapInner()方法如下： 1$(dstelement).wrapInner(tag); 例： 1 $("strong").wrapInner("&lt;b&gt;&lt;/b&gt;");//该示例使用b标签包裹每个一strong元素的子元素。 Dom元素的其他操作:属性操作、样式操作、设置和获取HTML,文本和值、遍历节点操作、Css-Dom操作。 1、属性操作attr()和removeAttr()attr()方法能够获取元素属性，也能能够设置元素属性。方法如下，当attr(para1)方法有个参数时候用于获得当前元素的para1的属性值，当attr(para1,attrValue)有两个参数时候设置当前元素的属性名为para1的属性值为attrValue;例： 12$("p").attr("title");//该示例用于获得p元素的title属性值。$("p").attr("title","//你最喜欢的水果");该示例设置p元素的title属性值为"你最喜欢的水果"; 如果一次设置多个属性值可以使用“名/值”对形式，例： 1$("p").attr(&#123;"title":"你最喜欢的水果","name":"水果"&#125;)//。该示例一次设置两个属性值。 removeAttr()方法用于删除特定的属性，方法是在参数中指定属性名。例： 1$("p").removeAttr("name");//该方法就是移除p元素的name属性。 2、样式操作addClass()、removeClass()、toggleClass()和hasClass()添加样式addClass()方法，使用该方法对目标元素添加相应的样式，方法如下： 1$(element).addClass(); 例： 1$("p").addClass("ul");//该示例设置元素p的样式为ul。 移除样式removeClass()方法，使用该方法移除目标元素的指定样式，方法如下： 1$(element).removeClass(); 例： 1$("p").removeClass("ul");//该救命去除掉p元素的ul类样式。 切换样式toggleClass()方法，使用该方法切换目标元素的样式，方法如下： 1$(element).toggleClass(); 例： 1$("p").toggleClass("ul");//该方法来回切换【添加删除实现切换】元素p的样式ul. 判断元素是否使用了样式 $(element).hasClass(),方法如下：$(element).hasClass(class);例： 1alert($("p").hasClass("ul"));//打印出p元素是否有ul样式。 PS:addClass()和attr()方法设置样式的不同，attr方法把元素的属性名对应的属性值设为方法中的参数值，addClass()则把属性值 添加到属性名对应的属性值中。例：已有元素元素样式,使用attr()和addClass()分别添加新样式。 3、设置和获取HTML【html()】,文本【text()】和值【val()】html()方法获得或设置某个元素的html元素。方法如下:$(selector).html();例: 1234567891011121314151617181920 $("p").html();该示例获得元素p的html内容。$("p").html("&lt;strong&gt;添加html内容&lt;/strong&gt;");该示例设置p的html内容为”&lt;strong&gt;添加html内容&lt;/strong&gt;“;PS：该方法可以用于XHTML文档，不能用于XML文档。text()方法获得或设置某个元素的文本值。方法如下:$(selecotr).text();例：$("p").text();该示例获得元素p的text文本内容。$("p").text("重新设置的文本内容");该示例设置元素p的text文本为"重新设置的文本内容";PS:该方法对html和XML文档都适用。val()方法获得或设置某个元素的值，如果元素值是多选则以数组形式返回，方法如下：$(selector).val();例:文本元素 &lt;input type="text" id="userName" value="请输入用户名" /&gt;$("#userName").val();获得input元素的值。$("#userName").val('响马');设置input元素的值为'响马'。val()方法的不仅能操作input，最重要的一个用途用于select【下拉列表框】、checkbox【多选框】、radio【单选框】。例：在下拉框下的多选赋值应用&lt;select id="fruits" multiple="multiple"&gt;&lt;option&gt;苹果&lt;/option&gt;&lt;option&gt;香蕉&lt;/option&gt;&lt;option&gt;西瓜&lt;/option&gt;&lt;/select&gt;$("#fruits").val(['苹果','香蕉']);该示例使select中苹果和香蕉两项被选中。 4、遍历节点操作children()、next()、prev()、siblings()和closest()children()方法用于取得匹配元素的子元素集合，只匹配子元素不考虑任何后代元素。方法如下：$(selector).children();例： 1 ("("body").children().length;//该示例获得body元素的子元素个数； next()方法用于匹配元素的下一个兄弟节点，方法如下:$(selector).next();例： 1 $("p").next().html();//该示例获得p元素的下一个兄弟节点的html内容。 prev()方法用于匹配元素的上一个兄弟节点，方法如下：$(selector).prev();例： 1 $("ul").prev().text();//该示例获得ul元素的上一个兄弟节点的文本内容。 siblings方法()用于匹配目标元素的所有兄弟元素，方法如下：$(selector).siblings();例： 1$("p").slibings();//示例获得p元素的所有兄弟节点元素。 closest()方法()用来取得最近的匹配元素，首先检查当前元素是否匹配如果匹配则直接返回，否则继续向上查找父元素中符合条件的元素返回，如果没有匹配的元素则返回空JQuery对象。 5、CSS-Dom操作css()、offset()、position()、scrollTop()和scrollLeft()css()方法用于获取、设置元素的一个或多个属性。方法如下：$(selector).css();例： 123$("p").css("color","red");//该示例用于设置元素的颜色属性为红色; $("p").css("color")//该示例用于获得元素的color样式值; $("p").css(&#123;"font-size":"30px","backgroundColor","#888888"&#125;);//该示例用于设置元素的多个样式。 offset()方法用于获取元素相对当前窗体的偏移量，其返回对象包括两个属性：top和left。方法如下：$(selector).offset() 1 var offset= $("p").offset(); var left=offset.left;var top=offset.top;//该示例用于获得元素p的偏移量。 PS:offset()只对可见元素有效。 position()方法用于获取元素于最近的个position样式属性设置为relative或者absolute的祖交节点的相对偏移量。方法如下：$(selector).position();例： 1 var postion = $("p").positon();var left=positon.left;var top=positon.top;//该示例用于获得元素p的位置。 scrollTop()和scrollLeft()方法用于获取元素的滚动条距顶端的距离和距左侧的距离。方法如下:(selector).scrollTop();(selector).scrollLeft();例： 1var scrollTop=("p").scrollTop();var scrollLeft=("p").scrollLeft();//该示例用于获得元素的滚动条的位置。 也可以添加参数将元素滚动到指定的位置。例： 1 ("textarea").scrollTop(300);("textarea").scrollLeft(300);]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端程序员该做什么]]></title>
    <url>%2Fposts%2F1360.html</url>
    <content type="text"><![CDATA[以前做Web开发的时候，根本没有前端，后端之说。 原因很简单，那个时候服务器端的代码就是一切：接受浏览器的请求，实现业务逻辑，访问数据库，用JSP生成HTML，然后发送给浏览器。 即使后来Javascript在浏览器中添加了一些AJAX的效果，那也是锦上添花，绝对不敢造次。因为页面的HTML主要还是用所谓“套模板”的方式生成：美工生成HTML模板，程序员用JSP,Veloctiy,FreeMaker等技术把动态的内容添加上去，仅此而已。 在最初的J2EE体系中，这个表示层可不仅仅是浏览器中运行的页面，还包括Java写的桌面端，只是Java在桌面端太不争气， 没有发展起来。 每个程序员都是所谓“全栈”工程师，不仅要搞定HTML, JavaScript, CSS，还要实现业务逻辑，编写访问数据库的代码。等到部署的时候，就把所有的代码打成一个WAR包，往Tomcat指定的目录一扔，测试一下没问题，收工回家！ 不差钱的公司会把程序部署到Weblogic，Websphere这样的应用服务器中，还会用上高大上的EJB。 虽然看起来生活“简单”又“惬意”，但实际上也需要实现那些多变的、不讲逻辑的业务需求，苦逼的本质并没有改变。 前后端的分离随着大家对浏览器页面的视觉和交互要求越来越高，“套模板”的方式渐渐无法满足要求，这个所谓的表示层慢慢地迁移到浏览器当中去了，一大批像Angular, ReactJS之类的框架崛起，前后端分离了！ 后端的工程师只负责提供接口和数据，专注于业务逻辑的实现，前端取到数据后在浏览器中展示，各司其职。 像Java这样的语言很适合去实现复杂的业务逻辑，尤其是一些MIS系统，行业软件如税务、电力、烟草、金融，通信等等。 所以剥离表示层，只做后端挺合适的。 但是如果仅仅是实现业务逻辑，那后端也不会需要这么多技术了，搞定SSH/SSM就行了。 后端技术互联网，尤其是移动互联网开始兴起以后，海量的用户呼啸而来，一个单机部署的小小War包肯定是撑不住了，必须得做分布式。 原来的单个Tomcat得变成Tomcat的集群，前边弄个Web服务器做请求的负载均衡，不仅如此，还得考虑状态问题，session的一致性。 业务越来越复杂，我们不得不把某些业务放到一个机器（或集群）上，把另外一部分业务放到另外一个机器（或集群）上，虽然系统的计算能力，处理能力大大增强，但是这些系统之间的通信就变成了头疼的问题，消息队列（MQ)，RPC框架（如Dubbo）应运而生，为了提高通信效率，各种序列化的工具(如Protobuf)也争先空后地问世。 单个数据库也撑不住了，那就做数据库的读写分离，如果还不行，就做分库和分表，把原有的数据库垂直地切一切，或者水平地切一切， 但不管怎么切，都会让应用程序的访问非常麻烦，因为数据要跨库做Join/排序，还需要事务，为了解决这个问题，又有各种各样“数据访问中间件”的工具和产品诞生。 为了最大程度地提高性能，缓存肯定少不了，可以在本机做缓存(如Ehcache)，也可以做分布式缓存(如Redis)，如何搞数据分片，数据迁移，失效转移，这又是一个超级大的主题了。 互联网用户喜欢上传图片和文件，还得搞一个分布式的文件系统（如FastDFS），要求高可用，高可靠。 数据量大了，搜索的需求就自然而然地浮出水面，你得弄一个支持全文索引的搜索引擎(如Elasticsearch ,Solr)出来。 林子大了，什么鸟都有，必须得考虑安全，数据的加密/解密，签名、证书，防止SQL注入，XSS/CSRF等各种攻击。 “大后端”前面提到了这么多的系统，还都是分布式的，每次上线，运维的同学说：把这么多系统协调好，把老子都累死了。 得把持续集成做好，能自动化地部署，自动化测试（其实前端也是如此），后来出现了一个革命化的技术docker， 能够让开发、测试、生成环境保持一致，系统原来只是在环境（如Ngnix, JVM,Tomcat,MySQL等）上部署代码，现在把代码和环境一并打包， 运维的工作一下子就简化了。 公司自己购买服务器比较贵，维护也很麻烦，又难于弹性地增长，那就搞点虚拟的服务器吧，硬盘、内存都可以动态扩展（反正是虚拟的）， 访问量大的时候多用点，没啥访问量了就释放一点，按需分配，很方便，这就是云计算的一个场景。 随着时间的推移，各个公司和系统收集的数据越来越多，都堆成一座大山了，难道就放在那里白白地浪费硬盘空间吗？ 有人就惊奇地发现，咦，我们利用这些数据搞点事情啊， 比如把数据好好分析一下，预测一下这个用户的购买/阅读/浏览习惯，给他推荐一点东西嘛。 可是这么多数据，用传统的方式计算好几天甚至好几个月才能出个结果，到时候黄花菜都凉了，所以也得利用分布式的技术，想办法把计算分到各个计算机去，然后再把计算结果收回来， 时势造英雄，Hadoop及其生态系统就应运而生了。 之前听说过一个大前端的概念，把移动端和网页端都归结为“前端”，我这里造个词“大后端”，把那些用户直接接触不到的、发生在服务器端的都归结进来。 怎么学？现在无论是前端还是后端，技术领域多如牛毛，都严重地细分了，所以我认为真正的全栈工程师根本不存在，因为一个人精力有限，不可能搞定这么多技术领域，太难了。 培训机构所说的“全栈”，我认为就是前后端还在拉拉扯扯，藕断丝连，没有彻底分离的时候的“全栈”工程师。 那么问题来了， 后端这么多东西，我该怎么学？ 往深度挖掘，可以成为某个技术领域的专家，如搜索方面的专家、安全方面的专家，分布式文件的专家等等，不管是哪个领域，重点都不是学会使用某个工具和框架， 而是保证你可以自己的知识和技术去搞定这个领域的顶尖问题。 往广度发展，各个技术领域都要了解，对于某种需求，能够选取合适的软件和技术架构来实现它，把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行，这也需要持续地学习和不断的经验积累。 很多人入行以后，都是靠一门语言，几个框架谋生，在这个行业摸爬滚打几年以后，会产生一些疑惑： 作为热爱技术的码农，以后的路该怎么走？ 我觉得有两个方向可供大家参考： 一个是“上天”，一个是“入地”。 上天“上天”的意思就是慢慢往上升了， 刚开始的时候就是在一些框架中做一个填空人员， 在别人的指导下实现小块的业务需求， 比如用Spring, Hibernate/MyBatis 去写税务软件的某一个模块。 后来职责扩大，自己开始负责一个或几个模块，带着别人做开发，看到的领域也越来越大， 开始向外扩展， 去学习系统的缓存是怎么设计的，数据库读写分离，主从复制是怎么做的， session是怎么管理的，搜索是怎么实现的 ，消息队列是怎么用的，怎么做到高可用性、高并发等等。 由点及面， 着眼系统整体和业务的全局，慢慢具备了设计系统架构的能力： 把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行。 经过长时间的实践、历练和经验的积累，把很多东西都研究透了，知道了各种技术的优缺点，终于迎来了质变的一天：突然发现自己具备了技术选型的能力，对于某种需求，能够选取合适的软件和技术架构来实现它。 这时候即使软件业发生了一些变化，出现了很多新技术，例如DevOps, 容器， 微服务，前后端分离，Angular, React ，CQRS 等等， 你发现稍加研究就能参透这些技术的本质， 他们要解决什么问题，有哪些最佳实践， 能否在自己的项目/产品中采用。 恭喜， 你已经成功上天了！ 注意，我说的并不是架构师，技术总监， CTO这样的title ， 而是一种能力。 那些“上天”的人知识面讲究广度，对深度并没有极致要求， 你可能并不了解一个软件的内部细节实现， 但是一定知道这个软件的特点、能力、性能和适用范围。 入地对于“入地”的人，恰恰相反，要求深度而不求广度， 要求是领域专家， 一个形象的比喻是要求一个一厘米宽的口子得有两公里深。 “入地”的人专注于某一类技术，比如说有人特别喜欢安全领域，把各种攻击、防御方法研究透彻 ， 成为了一个安全专家。 或者有人就是喜欢搜索，把搜索引擎的原理搞了个明明白白， 成了搜索专家。 很明显，“入地”要求一个人真的要对这个领域超级感兴趣，要不然就经不起诱惑，耐不住寂寞，别人都在热议云计算，大数据，人工智能，你还能静下心来研究动态字节码生成吗？ 你还能研究Tomcat的原理吗？ “入地”的领域非常多，例如安全、搜索、应用程序框架、缓存、JVM、分布式、RPC框架等等。 或者更加底层的数据库开发，Web服务器开发， 编译器开发等。 这些领域对软件的正确性、可靠性、安全性、性能要求极高，所以从事这些软件开发的人，肯定得真正地精通操作系统、网络、算法等基础知识， 这些人是真正的专家，受到大家的尊敬。 哪个更好？上天和入地哪个更好，更高级？ 其实没有贵贱之分，就看一个人的爱好了，每一条路都不容易，都需要努力的奋斗才行。 最怕的是高不成低不就，工作多年还是呆在中间，那就容易被IT的大浪拍死在沙滩上了！]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http Server, 一个差生的逆袭]]></title>
    <url>%2Fposts%2F16421.html</url>
    <content type="text"><![CDATA[我刚毕业那会儿，国家还是包分配工作的， 我的死党小明被分配到了一个叫数据库的大城市，天天都可以坐在高端大气上档次的机房里， 在那里专门执行SQL查询优化 ， 工作稳定又舒适； 隔壁宿舍的小白被送到了编译器镇，在那里专门把C源文件编译成EXE程序， 虽然累，但是技术含量非常高， 工资高，假期多。 我成绩不太好，典型的差生，四级补考了两次才过， 被发配到了一个不知道什么名字的村庄，据说要处理什么HTTP请求， 这个村庄其实就是一个破旧的电脑， 令我欣慰的是可以上网，时不时能和死党们通个信什么的。 不过辅导员说了， 我们都有光明的前途。 Http Server 1.0HTTP是个新鲜的事物， 能够激起我一点点工作的兴趣， 不至于沉沦下去。 一上班，操作系统老大扔给我一大堆文档： “这是HTTP协议， 两天看完！” 我这样的英文水平， 这几十页的英文HTTP协议我不吃不喝不睡两天也看不完， 死猪不怕开水烫，慢慢磨吧。 两个星期以后， 我终于大概明白了这HTTP是怎么回事： 无非是有些电脑上的浏览器向我这个破电脑发送一个预先定义好的文本（Http request）, 然后我这边处理一下（通常是从硬盘上取一个后缀名是html的文件）， 然后再把这个文件通过文本方式发回去（http response）， 就这么简单。 唯一麻烦的实现， 我得请操作系统给我建立Http层下面的TCP连接通道， 因为所有的文本数据都得通过这些TCP通道接收和发送， 这个通道是用socket建立的。 弄明白了原理，我很快就搞出了第一版程序， 这个程序长这个样子： 看看， 这些socket, bind, listen , accept… 都是操作系统老大提供的接口， 我能做的也就是把他们组装起来： 先在80端口监听， 然后进入无限循环，如果有连接请求来了，就接受(accept)，创建新的socket, 最后才可以通过这个socket来接收，发送http数据。 老大给我的程序起了个名称， Http Server, 版本1.0 。 这个名字听起来挺高端的， 我喜欢。 我兴冲冲的拿来实验， 程序启动了， 在80端口“蹲守”， 过了一会儿就有连接请求了， 赶紧Accept ,建立新的socket, 成功 ！ 接下来就需要从socket 中读取Http Request了。 可是这个receive 调用好慢， 我足足等了100毫秒还没有响应 ！ 我被阻塞(block)住了！ 操作系统老大说： “别急啊， 我也在等着从网卡那里读数据，读完以后就会复制给你。 ” 我乐的清闲， 可以休息一下。 可是操作系统老大说：“别介啊， 后边还有很多浏览器要发起连接， 你不能在这儿歇着啊。” 我说不歇着怎么办？ receive调用在你这里阻塞着， 我除了加入阻塞队列， 让出CPU让别人用还能干什么？ 老大说： “唉， 大学里没听说过多进程吗？ 你现在很明显是单进程， 一旦阻塞就完蛋了， 想办法用下多进程， 每个进程处理一个请求！ ” 老大教训的是， 我忘了多进程并发编程了。 Http 2.0 ：多进程多进程的思路非常简单，当accept连接以后，对于这个新的socket ， 不在主进程里处理， 而是新创建子进程来接管。 这样主进程就不会阻塞在receive 上， 可以继续接受新的连接了。 我改写了代码， 把Http server 升级为V2.0， 这次运行顺畅了很多， 能并发的处理很多连接了。 这个时候Web 刚刚兴起， 我这个Http Server 访问的人还不多， 每分钟也就那么几十个连接发过来，我轻松应对。 由于是新鲜事物， 我还有资本给搞数据库的小明和做编译的小白吹吹牛， 告诉他们我可是网络高手。 没过几年, Web迅速发展， 我所在的破旧机器也不行了， 换成了一个性能强悍的服务器， 也搬到了四季如春的机房里。 现在每秒中都有上百个连接请求了， 有些连接持续的时间还相当的长，所以我经常得创建成百上千的进程来处理他们，每个进程都得耗费大量的系统资源， 很明显操作系统老大已经不堪重负了。 他说： “咱们不能这么干了， 这么多进程，光是做进程切换就把我累死了。” “要不对每个Socket连接我不用进程了， 使用线程？ ” “可能好一点， 但我还是得切换线程啊， 你想想办法限制一下数量吧。” 我怎么限制？ 我只能说同一时刻，我只能支持x个连接， 其他的连接只能排队等待了。 这肯定不是一个好的办法。 Http Server 3.0 : Select模型老大说： “我们仔细合计合计， 对我来说，一个Socket连接就是一个所谓的文件描述符（File Descriptor ,简称 fd , 是个整数） , 这个fd 背后是一个简单的数据结构， 但是我们用了一个非常重量级的东西– 进程 –来表示对它的读写操作， 有点浪费啊。” 我说： “要不咱们还切换回单进程模型？ 但是又会回到老路上去， 一个receive 的阻塞就什么事都干不了了” “单进程也不是不可以， 但是我们要改变一下工作方式。” “改成什么？” 我想不透老大在卖什么关子。 “你想想你阻塞的本质原因， 还不是因为人家浏览器还没有把数据发过来， 我自然也没法给你， 而你又迫不及待的想去读， 我只好把你阻塞。 在单进程情况下， 一阻塞，别的事儿都干不了。“ “对，就是这样” “所以你接受了客户端连接以后， 不能那么着急的去读， 咱们这么办， 你的每个socket fd 都有编号， 你把这些编号告诉我， 就可以阻塞休息了 ” 我问道：“这不和以前一样吗？ 原来是调用receive 时阻塞， 现在还是阻塞” “听我说完， 我会在后台检查这些编号的socket, 如果发现这些socket 可以读写， 我会把对应的socket 做个标记， 把你唤醒去处理这些socket 的数据， 你处理完了，再把你的那些socket fd 告诉我， 再次进入阻塞，如此循环往复。” 我有点明白了： “ 这是我们俩的一种通信方式， 我告诉你我要等待什么东西， 然后阻塞， 如果事件发生了， 你就把我唤醒， 让我做事情。” “对， 关键点是你等我的通知， 我把你从阻塞状态唤醒后， 你一定要去遍历一遍所有的socket fd，看看谁有标记， 有标记的做相应处理。 我把这种方式叫做 select ” 我用select的方式改写了Http server， 抛弃了一个socket请求对于一个进程的模式， 现在我用一个进程就可以处理所有的socket了。 Http Server4.0 : epoll这种称为select的方式运行了一段时间， 效果还不错， 我只管把socket fd 告诉老大， 然后等着他通知我就行了。 有一次我无意中问老大：“我每次最多可以告诉你多少个socket fd？” “1024个” “那就是说我一个进程最多只能监控1024个socket了？ ” “是的， 你可以考虑多用几个进程啊” 这倒是一个办法， 不过”select”的方式用的多了， 我就发现了弊端， 最大的问题就是我从阻塞中恢复以后，需要遍历这1000多个socket fd， 看看有没有标志位需要处理。 实际的情况是， 很多socket 并不活跃， 在一段时间内浏览器并没有数据发过来， 这1000多个socket 可能只有那么几十个需要真正的处理， 但是我不得不查看所有的socket fd， 这挺烦人的。 难道老大不能把那些发生了变化的socket 告诉我吗？ 我把这个想法给老大说了下， 他说：“嗯， 现在访问量越来越大， select 方式已经不满足要求， 我们需要与时俱进了， 我想了一个新的方式，叫做epoll” “看到没有， 使用epoll和select 其实类似“ 老大接着说 ： ” 不同的地方是第3步和第4步， 我只会告诉你那些可以读写的socket , 你呢只需要处理这些’ready’ 的socket 就可以了“ “看来老大想的很周全， 这种方式对我来说就简单的多了。 ” 我用epoll 把Http Server 再次升级， 由于不需要遍历全部集合， 只需要处理哪些有变化的， 活跃的socket 文件描述符， 系统的处理能力有了飞跃的提升。 我的Http Server 受到了广泛的欢迎， 全世界有无数人在使用， 最后死党数据库小明也知道了， 他问我：“ 大家都说你能轻松的支持好几万的并发连接， 真是这样吗？ ” 我谦虚的说： “过奖， 其实还得做系统的优化啦。” 他说：“厉害啊，你小子走了狗屎运了啊。” 我回答： “毕业那会儿辅导员不是说过吗， 每个人都有光明的前途。” （完）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入网址到浏览器呈现发生了什么]]></title>
    <url>%2Fposts%2F37416.html</url>
    <content type="text"><![CDATA[前言这篇文章是应网友之邀所写，主要描述一下我们访问网站时， 从输入网址到最后浏览器呈现内容，中间发生了什么。 今天的文章主要专注于应用层，我拿了一个很简单的网络结构来讲。假定本机已经获取了IP地址，各种网络基础设施已经准备好了。 由于知识点太多，我肯定会漏掉部分内容，欢迎在留言中补充， 以后我会根据大家建议再写文章扩展。 准备当你在浏览器中输入网址（例如www.coder.com）并且敲了回车以后， 浏览器首先要做的事情就是获得coder.com的IP地址，具体的做法就是发送一个UDP的包给DNS服务器，DNS服务器会返回coder.com的IP, 这时候浏览器通常会把IP地址给缓存起来，这样下次访问就会加快。 比如Chrome， 你可以通过chrome://net-internals/#dns来查看。 有了服务器的IP， 浏览器就要可以发起HTTP请求了，但是HTTP Request/Response必须在TCP这个“虚拟的连接”上来发送和接收。 想要建立“虚拟的”TCP连接，TCP邮差需要知道4个东西：（本机IP, 本机端口，服务器IP, 服务器端口），现在只知道了本机IP,服务器IP， 两个端口怎么办？ 本机端口很简单，操作系统可以给浏览器随机分配一个， 服务器端口更简单，用的是一个“众所周知”的端口，HTTP服务就是80， 我们直接告诉TCP邮差就行。 经过三次握手以后，客户端和服务器端的TCP连接就建立起来了！ 终于可以发送HTTP请求了。 之所以把TCP连接画成虚线，是因为这个连接是虚拟的。 Web服务器一个HTTP GET请求经过千山万水，历经多个路由器的转发，终于到达服务器端（HTTP数据包可能被下层进行分片传输，略去不表）。 Web服务器需要着手处理了，它有三种方式来处理： 可以用一个线程来处理所有请求，同一时刻只能处理一个，这种结构易于实现，但是这样会造成严重的性能问题。 可以为每个请求分配一个进程/线程，但是当连接太多的时候，服务器端的进程/线程会耗费大量内存资源，进程/线程的切换也会让CPU不堪重负。 复用I/O的方式，很多Web服务器都采用了复用结构，例如通过epoll的方式监视所有的连接，当连接的状态发生变化（如有数据可读）， 才用一个进程/线程对那个连接进行处理，处理完以后继续监视，等待下次状态变化。 用这种方式可以用少量的进程/线程应对成千上万的连接请求。 我们使用Nginx这个非常流行的Web服务器来继续下面的故事。 对于HTTP GET请求，Nginx利用epoll的方式给读取了出来， Nginx接下来要判断，这是个静态的请求还是个动态的请求啊？ 如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。 例如Ngnix支持这么几种： 轮询：按照次序挨个向后端服务器转发 权重：给每个后端服务器指定一个权重，相当于向后端服务器转发的几率。 ip_hash： 根据ip做一个hash操作，然后找个服务器转发，这样的话同一个客户端ip总是会转发到同一个后端服务器。 fair：根据后端服务器的响应时间来分配请求，响应时间段的优先分配。 不管用哪种算法，某个后端服务器最终被选中，然后Nginx需要把HTTP Request转发给后端的Tomcat，并且把Tomcat输出的HttpResponse再转发给浏览器。 由此可见，Nginx在这种场景下，是一个代理人的角色。 应用服务器Http Request终于来到了Tomcat，这是一个由Java写的、可以处理Servlet/JSP的容器，我们的代码就运行在这个容器之中。 如同Web服务器一样， Tomcat也可能为每个请求分配一个线程去处理，即通常所说的BIO模式（Blocking I/O 模式）。 也可能使用I/O多路复用技术，仅仅使用若干线程来处理所有请求，即NIO模式。 不管用哪种方式，Http Request 都会被交给某个Servlet处理，这个Servlet又会把Http Request做转换，变成框架所使用的参数格式，然后分发给某个Controller(如果你是在用Spring)或者Action(如果你是在Struts)。 剩下的故事就比较简单了（不，对码农来说，其实是最复杂的部分），就是执行码农经常写的增删改查逻辑，在这个过程中很有可能和缓存、数据库等后端组件打交道，最终返回HTTP Response，由于细节依赖业务逻辑，略去不表。 根据我们的例子，这个HTTP Response应该是一个HTML页面。 归途Tomcat很高兴地把Http Response发给了Ngnix 。 Ngnix也很高兴地把Http Response 发给了浏览器。 发完以后TCP连接能关闭吗？ 如果使用的是HTTP1.1， 这个连接默认是keep-alive，也就是说不能关闭； 如果是HTTP1.0，要看看之前的HTTP Request Header中有没有Connetion:keep-alive，如果有，那也不能关闭。 浏览器再次工作浏览器收到了Http Response，从其中读取了HTML页面，开始准备显示这个页面。 但是这个HTML页面中可能引用了大量其他资源，例如js文件，CSS文件，图片等，这些资源也位于服务器端，并且可能位于另外一个域名下面，例如static.coder.com。 浏览器没有办法，只好一个个地下载，从使用DNS获取IP开始，之前做过的事情还要再来一遍。不同之处在于不会再有应用服务器如Tomcat的介入了。 如果需要下载的外部资源太多，浏览器会创建多个TCP连接，并行地去下载。 但是同一时间对同一域名下的请求数量也不能太多，要不然服务器访问量太大，受不了。所以浏览器要限制一下， 例如Chrome在Http1.1下只能并行地下载6个资源。 当服务器给浏览器发送JS,CSS这些文件时，会告诉浏览器这些文件什么时候过期（使用Cache-Control或者Expire），浏览器可以把文件缓存到本地，当第二次请求同样的文件时，如果不过期，直接从本地取就可以了。 如果过期了，浏览器就可以询问服务器端，文件有没有修改过？（依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not Modified），还可以使用缓存。否则的话服务器就会被最新的文件发回到浏览器。 当然如果你按了Ctrl+F5，会强制地发出GET请求，完全无视缓存。 注：在Chrome下，可以通过 chrome://view-http-cache/ 命令来查看缓存。 现在浏览器得到了三个重要的东西： HTML ，浏览器把它变成DOM Tree CSS, 浏览器把它变成CSS Rule Tree JavaScript， 它可以修改DOM Tree 浏览器会通过DOM Tree和CSS Rule Tree生成所谓“Render Tree”，计算每个元素的位置/大小，进行布局，然后调用操作系统的API进行绘制，这是一个非常复杂的过程，略去不表。 到目前为止，我们终于在浏览器中看到了www.coder.com的内容。 （完）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS Client集群环境的问题及解决方案]]></title>
    <url>%2Fposts%2F53969.html</url>
    <content type="text"><![CDATA[为了描述方便，假设有如下一个单点登录系统。一套CASServer，两套CAS Client系统。为了描述的方便，省略CAS Server调用用户系统完成登录，以及CASClient从用户系统读取用户详细信息的过程。 1 单点登录的过程为了描述方便，假设有如下一个单点登录系统。一套CASServer，两套CAS Client系统。为了描述的方便，省略CAS Server调用用户系统完成登录，以及CASClient从用户系统读取用户详细信息的过程。 1.1 多应用情况下Session信息假定有两个CAS Client应用，一个CAS Server。应用的部署，可能在不同的服务器，也可能有不同的访问IP或域名，即使是同一个浏览器，在各个应用中的Session信息也是不相同的。 浏览器中，每个应用有一个独立的JSESSIONIDCookie。某一个应用，不可能读取到浏览器在其他应用中的Cookie信息。 假定用户首先访问CAS Client 01，系统提醒用户进行一次登录；然后用户访问CAS Client2，不会再提示登录而是直接登录成功。 1.2 第一次访问CAS Client 01用户打开浏览器后第一次访问，重定向到单点登录后，会提示用户输入账号密码登录。登录成功之后，再跳转回CAS Client。 1.3 第一次访问CAS Client 02当用户浏览器已经登录系统，切换到另一个CASClient时，跟第一次访问有所不同，因为已经登录成功，就不会再提醒输入账号密码登录了。 1.4 再次访问CAS Clients当用户已经访问过CAS Client后，当用户再次访问，系统不会再跳转到CAS Server做认证。 1.5 CASClient配置为了实现前述的单点登录过程，以Java WEB项目为例，需要在 web.xml 中进行相应的配置。（为了排版，没有填写Filter的完整class名，请自行查阅补充。） 123456789101112131415161718192021222324&lt;filter&gt; &lt;filter-name&gt;CAS AuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.AuthenticationFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;*.Cas10TicketValidationFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest WrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.HttpServletRequestWrapperFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS AuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest WrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 仔细看一下配置过滤器可以发现，三个过滤器正好对应流程图中三次访问CAS Client。 Authentication Filter：负责将未登录用户跳转到登录界面 Authentication Filter：负责验证Service Ticket HttpServletRequest WrapperFilter：负责将用户信息封装到request和session中。 2 统一注销的过程2.1 不能实现统一注销会有什么问题当用户访问系统后从系统注销，如何能够从每个应用中都注销？注意前面1.4部分的描述，如果用户注销时，并没有注销CASClient 02中的会话信息，如果用户在浏览器中直接访问这个应用，因为Session存在，并不会提醒用户重新登录。 这会带来两个潜在的隐患： 用户注销user1后换账号user2重新登录，进入CAS Client 02之后，当前身份其实还是user1，并没有如用户预期一样使用user2身份。 用户user1点击注销后离开，没有关闭浏览器。这时候其他用户直接打开CAS Client 02，能够直接盗用user1的身份进行操作。 2.2基本概念：Service、TGT和STCAS已经考虑到统一注销的问题。 这里有三个重要的概念TGT、ST和Service，需要着重介绍一下，因为它们同后续统一注销的方案息息相关。 2.2.1 Service这是用户第一次访问CAS Client的URL。假设一个CAS Client应用部署在域名oa.company.com，使用HTTP协议，应用首页是index.htm。当用户第一次访问这个应用时，对应的URL地址是 http://oa.company.com/index.htm 。这个URL，对CAS Server来说，就是一个service。 当用户第一次跳转到CAS Server的时候，可以看到传了一个参数service，就是这个值。当CASServer生成Ticket重定向到CAS Client的时候，实际就是在这个service 中添加了一个参数 ticket 。 2.2.2 TGT：Ticket Grangting TicketTGT是CAS Server为每一个登录用户创建的登录令牌。在CASServer上拥有了TGT，用户就可以证明自己在CASServer成功登录过。TGT封装了SessionCookie值以及此Cookie值对应的用户信息。当HTTP请求到来时，CAS以此Cookie值为key查询缓存中有无TGT ，如果有的话，则相信用户已登录过。 2.2.3 ST：Service TicketST是CAS Server为用户签发的访问某一service的认证令牌。用户访问service时，service发现用户没有ST，浏览器会跳转到CASServer去获取ST。CAS Server发现用户有TGT，则签发一个ST，返回给用户。用户使用ST作为ticket参数去访问service，service拿ST去CAS Server验证，验证通过后，得到当前登录用户的登录名。 注意TGT和ST，是一对多的关系。一个TGT会维护一个 services 列表，每当为用户创建一个ST并认证通过后，会将这个ST添加到TGT的services列表中。这样，在CASServer端，这个services列表实际维护了一个用户登录过的所有CASClient。这就为实现统一注销打下了基础。 2.3 CAS Client的统一注销配置CAS Client，为了实现统一注销，除了第一张介绍的三个登录过程的过滤器之外，还需要添加一个统一注销过滤器。 1234567891011&lt;filter&gt; &lt;filter-name&gt;CAS Single Sign OutFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.SingleSignOutFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign OutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;listener&gt; &lt;listener-class&gt;*.SingleSignOutHttpSessionListener&lt;/listener-class&gt;&lt;/listener&gt; 2.4 CAS Server注销过程用户在浏览器中点击“注销”链接，实际浏览器会访问CASServer的注销页面。收到注销请求后，CAS Server会读取到TGT，并检查当前用户登录过的所有service，并依次发送注销请求。 2.5 CAS Client注销过程CAS Client的注销，核心代码是SingleSignOutFilter，它的关键代码 12345678910public voiddoFilter(servletRequest, servletResponse, filterChain)&#123; HttpServletRequest request =(HttpServletRequest)servletRequest; if (handler.isTokenRequest(request)) &#123; handler.recordSession(request); &#125; else if (handler.isLogoutRequest(request)) &#123; handler.destroySession(request); return; &#125; filterChain.doFilter(servletRequest, servletResponse);&#125; 其中handler是SingleSignOutHandler的实例，这个对象完成用户在CASClient端登录信息的维护和注销工作。 至此，CAS完整的登录和注销过程就完成。 2.6 思考：什么情况统一注销会失败统一注销的实现，需要CAS Server通过HttpClient访问CAS Client的service。如果这个访问过程失败，就会导致统一注销失败。列了几种情况，不详述。 开发调试阶段，使用localhost访问CAS Client。 CAS Server部署在外网，CAS Client部署在内网。 网络安全设置，不允许CASServer访问CAS Client。 3 CAS Client集群的影响前面的论述，一直假定所有的CAS Client都是单点部署，没有集群。如果集群，会有什么影响，应该如何来解决？ 3.1 Client集群对登录的影响假设使用nginx做集群前端，后面部署两台CAS Client 01的实例。我们看看对登录过程会有什么影响。 为了描述方便，CAS Client登录过程会有三次请求（对应三个过滤器），我们依次命名为Authentication Request / Validation Request / Wrapper Request。 Nginx缺省的分发规则，并不是sticky模式，同一个浏览器的请求，会按照nginx自身某种规则进行分发。我们曾经测试过，在双点集群环境下，Authentication Request和ValidationRequest会恰好被分发到两台服务器，这就会导致登录过程死循环。 出现登录死循环的原因，主要在于nginx分发时，没有使用sticky策略，也就是同一个浏览器的请求，永远分发给同一台CAS Client实例。缺省nginx的分发策略，可以根据用户IP分发，实现的是同一个IP永远分发到同一台Client，这样就能解决死循环的问题。 3.2 Client集群对注销的影响当nginx实现了sitcky转发，同一个浏览器的访问会分发到同一个Client1实例，该用户的会话信息也一直保存在Client1实例中。 当用户统一注销时，由CAS Server向Client发送注销请求，这时候nginx无法确保按当前用户进行分发，因此可能会被分发到Client2。这时候，实际效果是注销失败。 这个问题，在我们当前的环境中真实存在，还没有合理的解决方法。初步分析，大概有几个修改方向。 3.2.1 修改nginx分发策略问题存在的原因，是因为nginx在分发注销策略时，不能准确分发。如果能在这个环节进行修改，系统代码和环境，基本不用做任何修改。 这里有两种分发方法： CAS Server发送的注销请求，分发给对应的后台服务器。 CAS Server发送的注销请求，广播到所有的后台服务器。 初步结论：同架构组进行了沟通，这两种方案都很难实现，特别是广播的方案，没在网络上找到类似成功的案例。 3.2.2 集群的节点实现Session同步如果能实现集群Session的同步：同步创建、同步注销，主要在一个Client上实现了注销，其他Client也就同步注销。 这个会对Tomcat性能有影响。 3.2.3 集群节点使用redis保存会话信息即使是多个节点，它们的会话信息只有一份。一旦失效，则所有节点都失效。这只是一个设想，没有做技术调研，不知能够实现。 这有两种修改方法： 修改Tomcat的配置文件，使用redis保存Tomcat的会话信息。 修改代码而不是Tomcat，使用redis保存会话信息。 初步结论：架构组不允许修改生产环境的Tomcat，否定了第一种方法。我们只能尝试修改代码并利用redis保存会话。 3.2.4 每次请求验证用户是否注销首先，在CAS Server中实现一个接口，用于判断某一个ST对应的TGT是否还有效。 在SingleSignOutFilter中，每次访问都调用CAS Server的这个新接口，判断用户是否已经注销。如果已经注销，则立刻注销本实例中的会话信息。 这个方法是比较安全的解决办法，但每次请求都会调用CASServer接口，会对性能造成巨大影响。完全不建议用这种方案。 3.2.5 几种策略的初步调研对前面提到的几种方案做了初步调研之后： 技术实现困难，否定了方案1 性能考虑以及架构组的策略，否定方案2 架构组的策略，否定方案3中的第一种做法。 性能考虑，否定方案4。 因此，可能的做法是修改代码，使用redis保存会话信息。 4 使用redis保存会话在目前的生产环境的限制下，我们只能采用修改代码来实现redis保存会话的实现方案。 4.1 Request和Session缺省怎么实现在Tomcat缺省的实现中，Session信息都是保存在JVM中，所以不能跨JVM共享。 要想将所有的session都保存到redis中，一种能想到的简单办法是自己写一个CustomSession，将会话信息保存到这个自定义的Session中，并且利用redis等进行保存。但这样做，会带来很大的代码改动，所有涉及到session读写操作的地方可能都需要修改。 我们希望找到更优雅的解决方案，能够修改更少的代码。 4.2 WEB请求的执行过程Request 和Session什么时候创建？如何传递？ Filter的调用入口函数是doFilter，传入的主要参数是request和response。在此之前，Tomcat已经创建好request。通常情况下，业务代码不需要关心request和session等对象如何创建的问题，只需要使用即可。每个过滤器的实现，当需要继续流程的时候，只需要将得到的request和response传递给下一个filter就行。 但这仅仅是缺省做法，并不表示我们不能修改或重写一个request对象。我们想修改Session的保存位置，如果能在所有的Filter之前插入一个自定义过滤器，定义一个新的Request传递给后面的Filter，并且让后面的Filter和Servlet感受不到变化，就可以实现这个目标。 4.3 如何定制Request4.3.1 增加过滤器在所有的Filter之前，插入一个新的Filter。 HttpServletRequest可以重写吗？ 4.3.2 Tomcat的Request实现4.3.3 改写之后的Request实现在Session重写一个RedisSessionRequest，继承自HttpServletRequestWrapper，并包含原request(RequestFacade)的引用。但需要读取Form参数时，直接调用oriRequest取值。当需要拿到Session对象进行会话信息访问时，调用重载后的函数。 这样就实现了request的封装，在后续的filter和servlet中通过request获取到的session，都是放在redis中的会话数据，不再是缺省保存在JVM中的数据。 4.3.4 集群环境的session读写当nginx将同一个浏览器的请求分发给不同的Tomcat时，都会根据SessionId从redis中读取Session。因为同一个浏览器发送请求的SessionID相同，所以在不同的Tomcat实例中，会读取到同一个Session对象。 4.4 使用Spring Session实现根据前面的分析，在项目中自定义Request，就可以实现需求。Spring Session已经是一个成熟的开源实现，并且后端实现了将会话保存在redis、mongodb、jdbc等多种实现，我们没必要自己发明轮子。 Spring提供的例子代码很简洁，跟我们已经实现的业务系统稍微有点不同。在现有系统中，已经定义了bean jedisConnectionFactory，可以直接使用。 4.4.1 修改pom.xml在pom.xml文件中，添加代码 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.4.2 修改redis配置文件在项目中已经有redis配置文件spring-redis.xml，在其中添加内容 1&lt;context:annotation-config/&gt;&lt;beans:beanclass="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"/&gt; 4.4.3 修改web.xml在所有的过滤器前面添加一个新的过滤器 12345678910&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 4.5 测试实现效果集成Spring Session后，经过初步测试，能够达到预想效果。（感谢同事瑞钊的实际测试并提供截图） 4.5.1 Session信息已经保存到redis中用户登录后查看redis中的数据，可以看到这些Session信息。 4.5.2 删除redis中会话的影响用户登录后继续访问系统，不会切换到CAS登录页面。 如果手工删掉redis中的session，重新访问，可以看到需要重新做一个CAS认证的过程。 4.5.3 统一用户注销的测试后续需要部署一套生产环境的集群环境，验证统一注销的效果。 5 问题：问题在于，Cas Client中有一个实现类HashMapBackedSessionMappingStorage，这个类的作用，在于存储tiket和sessionId的映射注销的时候，cas服务器会发来一个tiket，退出过滤器需要根据这个ticket找到对应的sessionId来清除session 而HashMapBackedSessionMappingStorage是存储在Map里的，也就是内存里的，而不是session里 如果能保证nginx转发的路径是固定的，也就是一个访问者 固定访问一个tomcat，那固然没问题。所以我觉得 你这个方案测试应该是没问题的。 但是，如果这个tomcat挂掉了呢？ 靠谱的方式应该是把这个映射关系 也存在redis里。也就是自己实现一个RedisBackedSessionMappingStorage 链接：https://yq.aliyun.com/articles/49871casclient源代码下载链接：https://github.com/apereo/java-cas-client cas官网链接：https://www.apereo.org/projects/cas 上面一篇引用别人的分析方案介绍，来描述了下项目中遇到的问题，现在介绍本人怎么解决的 本人项目中用的是改造了tomcat 做的session 共享 所以客户端请求退出，服务端根据TGT查看对应的ST进行请求客户端，通过nginx负载均衡，可能对应到另一台客户端服务器，但是我们的session是存入rediscluster，任意客户端可以根据sessionid取到这个，进行删除，这样session就没了。即在客户端配置的SingleSignOutFilter，需要在HashMapBackedSessionMappingStorage进行删除存入redis的session数据，这样就可以退出了，就是这个原理来处理这个退出登录问题 代码依赖jar包spring-data-redis-1.7.4.RELEASE.jar；jedis-2.9.0.jar；fastjson-1.2.31.jar；注意jar包版本 改造的HashMapBackedSessionMappingStorage类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package org.jasig.cas.client.session;/*- agreements. See the NOTICE file distributed with this work- for additional information regarding copyright ownership.- Jasig licenses this file to you under the Apache License,- Version 2.0 (the "License"); you may not use this file- except in compliance with the License. You may obtain a- copy of the License at the following location: *- http://www.apache.org/licenses/LICENSE-2.0 *- Unless required by applicable law or agreed to in writing,- software distributed under the License is distributed on an- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY- KIND, either express or implied. See the License for the- specific language governing permissions and limitations- under the License. */import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import javax.annotation.Resource;import javax.servlet.http.HttpSession;import org.jasig.cas.client.session.SessionMappingStorage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.EnableMBeanExport;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;/**- HashMap backed implementation of SessionMappingStorage.- @author Scott Battaglia- @version Revision Date- @since 3.1 */ public final class HashMapBackedSessionMappingStorage implements SessionMappingStorage &#123; protected final transient Logger logger = LoggerFactory.getLogger(getClass()); private final static String CASCLIENT_PREFIX = "CASCLI:SESSIONID:"; private final static String CASCLIENT_MAPID_PREFIX = "CASCLI:MAPID:"; private int casTimeout=86400; private RedisTemplate redisTemplate=new RedisTemplate(); public RedisTemplate getRedisTemplate() &#123; return redisTemplate; &#125; public void setRedisTemplate(RedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public HashMapBackedSessionMappingStorage()&#123; ApplicationContext ac =new ClassPathXmlApplicationContext("classpath:schemeone/xml/spring-core.xml"); setRedisTemplate((RedisTemplate)ac.getBean("redisTemplate")); &#125; @Override public synchronized void addSessionById(String mappingId, HttpSession session) &#123; logger.debug("Adding ticket &#123;&#125;", session); try &#123; String sessionRedisKey = this.getCasSessionRedisKey(session.getId()); String mappingIdRedisKey = this.getCasMappingIdRedisKey(mappingId); this.redisTemplate.boundValueOps(sessionRedisKey).set(mappingId, casTimeout, TimeUnit.SECONDS); this.redisTemplate.boundValueOps(mappingIdRedisKey).set(session.getId(), casTimeout, TimeUnit.SECONDS); &#125; catch (final Exception e) &#123; logger.error("Failed Adding &#123;&#125;", session, e); &#125; &#125; @Override public synchronized void removeBySessionById(String sessionId) &#123; logger.debug("Attempting to remove Session=[&#123;&#125;]", sessionId); final String key =(String) this.redisTemplate.boundValueOps(this.getCasSessionRedisKey(sessionId)).get(); if (logger.isDebugEnabled()) &#123; if (key != null) &#123; logger.debug("Found mapping for session. Session Removed."); &#125; else &#123; logger.debug("No mapping for session found. Ignoring."); &#125; &#125; this.redisTemplate.delete(this.getCasMappingIdRedisKey(key)); this.redisTemplate.delete(this.getCasSessionRedisKey(sessionId)); &#125; @Override public synchronized HttpSession removeSessionByMappingId(String mappingId) &#123; //先去取sessionid final String sessionId=(String) this.redisTemplate.boundValueOps(this.getCasMappingIdRedisKey(mappingId)).get(); //final HttpSession session = (HttpSession) this.redisTemplate.boundValueOps(sessionId).get(); this.redisTemplate.delete(sessionId);// if (session != null) &#123;// removeBySessionById(session.getId());// &#125;// return session; if (sessionId != null) &#123; removeBySessionById(sessionId); &#125; return null; &#125; private String getCasSessionRedisKey( String sessionId) &#123; return CASCLIENT_PREFIX + sessionId; &#125; private String getCasMappingIdRedisKey(String mappingId) &#123; return CASCLIENT_MAPID_PREFIX + mappingId; &#125;&#125; redistemplteBean配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"xmlns:context="http://www.springframework.org/schema/context"xmlns:util="http://www.springframework.org/schema/util"xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"&gt; &lt;!-- 扫描注解Bean --&gt;&lt;context:component-scan base-package="com.hivescm" /&gt;&lt;aop:config proxy-target-class="true" /&gt;&lt;!-- 开启AOP监听 只对当前配置文件有效 --&gt;&lt;aop:aspectj-autoproxy expose-proxy="true" /&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!--&lt;value&gt;classpath:schemeone/properties/common/*.properties&lt;/value&gt; --&gt; &lt;value&gt;classpath:schemeone/properties/common/redis.cluster.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt;&lt;!-- 最大空闲数 --&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt;&lt;!-- 最大建立连接等待时间 --&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt;&lt;!-- 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个 --&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean&gt;&lt;!-- 配置文件加载 --&gt; &lt;bean id="resourcePropertySource" class="org.springframework.core.io.support.ResourcePropertySource"&gt; &lt;constructor-arg name="name" value="redis.cluster.properties"/&gt; &lt;constructor-arg name="resource" value="classpath:schemeone/properties/common/redis.cluster.properties"/&gt; &lt;/bean&gt;&lt;!-- redisCluster配置 --&gt; &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt; &lt;constructor-arg name="propertySource" ref="resourcePropertySource"/&gt; &lt;/bean&gt;&lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;constructor-arg name="clusterConfig" ref="redisClusterConfiguration"/&gt; &lt;constructor-arg name="poolConfig" ref="poolConfig"/&gt; &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt;&lt;!-- 如果不配置Serializer，那么存储的时候缺省使用String，如果用User类型存储，那么会提示错误User can't cast to String！！ --&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashValueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;/bean &gt;&lt;/beans&gt; redis.cluster.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344#redis\u4E2D\u5FC3#redis\u7684\u670D\u52A1\u5668\u5730\u5740redis.host=192.168.103.158#redis\u7684\u670D\u52A1\u7AEF\u53E3redis.port=6379#\u5BC6\u7801redis.password=#\u6700\u5927\u7A7A\u95F2\u6570redis.maxIdle=100#\u6700\u5927\u8FDE\u63A5\u6570redis.maxActive=300#\u6700\u5927\u5EFA\u7ACB\u8FDE\u63A5\u7B49\u5F85\u65F6\u95F4redis.maxWait=1000#\u5BA2\u6237\u7AEF\u8D85\u65F6\u65F6\u95F4\u5355\u4F4D\u662F\u6BEB\u79D2redis.timeout=100000redis.maxTotal=1000redis.minIdle=8#\u660E\u662F\u5426\u5728\u4ECE\u6C60\u4E2D\u53D6\u51FA\u8FDE\u63A5\u524D\u8FDB\u884C\u68C0\u9A8C,\u5982\u679C\u68C0\u9A8C\u5931\u8D25,\u5219\u4ECE\u6C60\u4E2D\u53BB\u9664\u8FDE\u63A5\u5E76\u5C1D\u8BD5\u53D6\u51FA\u53E6\u4E00\u4E2Aredis.testOnBorrow=true#sentinel#spring.redis.sentinel.node1.host=127.0.0.1#spring.redis.sentinel.node2.host=127.0.0.1#spring.redis.sentinel.node3.host=127.0.0.1#spring.redis.sentinel.node1.port=26379#spring.redis.sentinel.node2.port=26479#spring.redis.sentinel.node3.port=26579#sentinel#jediscluster#cluster1.host.port=127.0.0.1:7000#cluster2.host.port=127.0.0.1:7001#cluster3.host.port=127.0.0.1:7002#cluster4.host.port=127.0.0.1:7003#cluster5.host.port=127.0.0.1:7004#cluster6.host.port=127.0.0.1:7005#cluster7.host.port=127.0.0.1:7006#cluster8.host.port=127.0.0.1:7007#jediscluster#rediscluster#spring.redis.cluster.nodes=192.168.103.158:6379spring.redis.cluster.nodes=192.168.103.174:6379,192.168.103.174:6389,192.168.103.174:6399,192.168.103.173:6379,192.168.103.173:6389,192.168.103.173:6399spring.redis.cluster.max-redirects=3]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具类总结]]></title>
    <url>%2Fposts%2F36591.html</url>
    <content type="text"><![CDATA[Java FileUtils、StringUtils和DateUtils笔记 FileUtils我项目中用到的文件工具类 读取raw文件、file文件，drawable文件，asset文件，比如本地的json数据，本地文本等；如：String result =FileUtil.getString(context,”raw://first.json”) 读取本地的property文件，并转化为hashMap类型的数据 （simpleProperty2HashMap）； 将raw文件拷贝到指定目录（copyRawFile）； 基本文件读写操作（readFile，writeFile）； 从文件的完整路径名（路径+文件名）中提取 路径（extractFilePath）； 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名)如：d:\path\file.ext –&gt; file.ext（extractFileName） 检查指定文件的路径是否存在（pathExists） 检查制定文件是否存在（fileExists） 创建目录（makeDir） 移除字符串中的BOM前缀（removeBomHeaderIfExists） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435package com.nsu.edu.library.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.text.TextUtils;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.util.HashMap;import java.util.Iterator;import java.util.Properties;import java.util.Set;/** * Create By Anthony on 2016/1/15 * Class Note:文件工具类 * 包含内容： * 1 读取raw文件、file文件，drawable文件，asset文件，比如本地的json数据，本地文本等； * 如：String result =FileUtil.getString(context,"raw://first.json") * 2 读取本地的property文件，并转化为hashMap类型的数据（simpleProperty2HashMap）； * 3 将raw文件拷贝到指定目录（copyRawFile）； * 4 基本文件读写操作（readFile，writeFile）； * 5 从文件的完整路径名（路径+文件名）中提取 路径（extractFilePath）； * 6 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) 如：d:\path\file.ext --&gt; file.ext（extractFileName） *7 检查指定文件的路径是否存在（pathExists） *8 检查制定文件是否存在（fileExists） *9 创建目录（makeDir） *10 移除字符串中的BOM前缀（removeBomHeaderIfExists） */public class FileUtil &#123; public static final String ASSETS_PREFIX = "file://android_assets/"; public static final String ASSETS_PREFIX2 = "file://android_asset/"; public static final String ASSETS_PREFIX3 = "assets://"; public static final String ASSETS_PREFIX4 = "asset://"; public static final String RAW_PREFIX = "file://android_raw/"; public static final String RAW_PREFIX2 = "raw://"; public static final String FILE_PREFIX = "file://"; public static final String DRAWABLE_PREFIX = "drawable://"; public static InputStream getStream(Context context, String url) throws IOException &#123; String lowerUrl = url.toLowerCase(); InputStream is; if (lowerUrl.startsWith(ASSETS_PREFIX)) &#123; String assetPath = url.substring(ASSETS_PREFIX.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX2)) &#123; String assetPath = url.substring(ASSETS_PREFIX2.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX3)) &#123; String assetPath = url.substring(ASSETS_PREFIX3.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX4)) &#123; String assetPath = url.substring(ASSETS_PREFIX4.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(RAW_PREFIX)) &#123; String rawName = url.substring(RAW_PREFIX.length()); is = getRawStream(context, rawName); &#125; else if (lowerUrl.startsWith(RAW_PREFIX2)) &#123; String rawName = url.substring(RAW_PREFIX2.length()); is = getRawStream(context, rawName); &#125; else if (lowerUrl.startsWith(FILE_PREFIX)) &#123; String filePath = url.substring(FILE_PREFIX.length()); is = getFileStream(filePath); &#125; else if (lowerUrl.startsWith(DRAWABLE_PREFIX)) &#123; String drawableName = url.substring(DRAWABLE_PREFIX.length()); is = getDrawableStream(context, drawableName); &#125; else &#123; throw new IllegalArgumentException(String.format("Unsupported url: %s \n" + "Supported: \n%sxxx\n%sxxx\n%sxxx", url, ASSETS_PREFIX, RAW_PREFIX, FILE_PREFIX)); &#125; return is; &#125; private static InputStream getAssetsStream(Context context, String path) throws IOException &#123; return context.getAssets().open(path); &#125; private static InputStream getFileStream(String path) throws IOException &#123; return new FileInputStream(path); &#125; private static InputStream getRawStream(Context context, String rawName) throws IOException &#123; int id = context.getResources().getIdentifier(rawName, "raw", context.getPackageName()); if (id != 0) &#123; try &#123; return context.getResources().openRawResource(id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; throw new IOException(String.format("raw of id: %s from %s not found", id, rawName)); &#125; private static InputStream getDrawableStream(Context context, String rawName) throws IOException &#123; int id = context.getResources().getIdentifier(rawName, "drawable", context.getPackageName()); if (id != 0) &#123; BitmapDrawable drawable = (BitmapDrawable) context.getResources().getDrawable(id); Bitmap bitmap = drawable.getBitmap(); ByteArrayOutputStream os = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 0, os); return new ByteArrayInputStream(os.toByteArray()); &#125; throw new IOException(String.format("bitmap of id: %s from %s not found", id, rawName)); &#125; public static String getString(Context context, String url) throws IOException &#123; return getString(context, url, "UTF-8"); &#125; public static String getString(Context context, String url, String encoding) throws IOException &#123; String result = readStreamString(getStream(context, url), encoding); if (result.startsWith("\ufeff")) &#123; result = result.substring(1); &#125; return result; &#125; public static String readStreamString(InputStream is, String encoding) throws IOException &#123; return new String(readStream(is), encoding); &#125; public static byte[] readStream(InputStream is) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buf = new byte[1024 * 10]; int readlen; while ((readlen = is.read(buf)) &gt;= 0) &#123; baos.write(buf, 0, readlen); &#125; baos.close(); return baos.toByteArray(); &#125; public static Bitmap getDrawableBitmap(Context context, String rawName) &#123; int id = context.getResources().getIdentifier(rawName, "drawable", context.getPackageName()); if (id != 0) &#123; BitmapDrawable drawable = (BitmapDrawable) context.getResources().getDrawable(id); if (drawable != null) &#123; return drawable.getBitmap(); &#125; &#125; return null; &#125; /** * 读取Property文件 */ public static HashMap&lt;String, String&gt; simpleProperty2HashMap(Context context, String path) &#123; try &#123; InputStream is = getStream(context, path); return simpleProperty2HashMap(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new HashMap&lt;String, String&gt;(); &#125; private static HashMap&lt;String, String&gt; simpleProperty2HashMap(InputStream in) throws IOException &#123; HashMap&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;(); Properties properties = new Properties(); properties.load(in); in.close(); Set keyValue = properties.keySet(); for (Iterator it = keyValue.iterator(); it.hasNext(); ) &#123; String key = (String) it.next(); hashMap.put(key, (String) properties.get(key)); &#125; return hashMap; &#125; /** * 将raw文件拷贝到指定目录 */ public static void copyRawFile(Context ctx, String rawFileName, String to) &#123; String[] names = rawFileName.split("\\."); String toFile = to + "/" + names[0] + "." + names[1]; File file = new File(toFile); if (file.exists()) &#123; return; &#125; try &#123; InputStream is = getStream(ctx, "raw://" + names[0]); OutputStream os = new FileOutputStream(toFile); int byteCount = 0; byte[] bytes = new byte[1024]; while ((byteCount = is.read(bytes)) != -1) &#123; os.write(bytes, 0, byteCount); &#125; os.close(); is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 基本文件操作 */ public static String FILE_READING_ENCODING = "UTF-8"; public static String FILE_WRITING_ENCODING = "UTF-8"; public static String readFile(String _sFileName, String _sEncoding) throws Exception &#123; StringBuffer buffContent = null; String sLine; FileInputStream fis = null; BufferedReader buffReader = null; if (_sEncoding == null || "".equals(_sEncoding)) &#123; _sEncoding = FILE_READING_ENCODING; &#125; try &#123; fis = new FileInputStream(_sFileName); buffReader = new BufferedReader(new InputStreamReader(fis, _sEncoding)); boolean zFirstLine = "UTF-8".equalsIgnoreCase(_sEncoding); while ((sLine = buffReader.readLine()) != null) &#123; if (buffContent == null) &#123; buffContent = new StringBuffer(); &#125; else &#123; buffContent.append("\n"); &#125; if (zFirstLine) &#123; sLine = removeBomHeaderIfExists(sLine); zFirstLine = false; &#125; buffContent.append(sLine); &#125;// end while return (buffContent == null ? "" : buffContent.toString()); &#125; catch (FileNotFoundException ex) &#123; throw new Exception("要读取的文件没有找到!", ex); &#125; catch (IOException ex) &#123; throw new Exception("读取文件时错误!", ex); &#125; finally &#123; // 增加异常时资源的释放 try &#123; if (buffReader != null) buffReader.close(); if (fis != null) fis.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; public static File writeFile(InputStream is, String path, boolean isOverride) throws Exception &#123; String sPath = extractFilePath(path); if (!pathExists(sPath)) &#123; makeDir(sPath, true); &#125; if (!isOverride &amp;&amp; fileExists(path)) &#123; if(path.contains(".")) &#123; String suffix = path.substring(path.lastIndexOf(".")); String pre = path.substring(0, path.lastIndexOf(".")); path = pre + "_" + TimeUtils.getNowTime() + suffix; &#125; else &#123; path = path + "_" + TimeUtils.getNowTime(); &#125; &#125; FileOutputStream os = null; File file = null; try &#123; file = new File(path); os = new FileOutputStream(file); int byteCount = 0; byte[] bytes = new byte[1024]; while ((byteCount = is.read(bytes)) != -1) &#123; os.write(bytes, 0, byteCount); &#125; os.flush(); return file; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("写文件错误", e); &#125; finally &#123; try &#123; if (os != null) os.close(); if (is != null) is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static File writeFile(String path, String content, String encoding, boolean isOverride) throws Exception &#123; if (TextUtils.isEmpty(encoding)) &#123; encoding = FILE_WRITING_ENCODING; &#125; InputStream is = new ByteArrayInputStream(content.getBytes(encoding)); return writeFile(is, path, isOverride); &#125; /** * 从文件的完整路径名（路径+文件名）中提取 路径（包括：Drive+Directroy ) * * @param _sFilePathName * @return */ public static String extractFilePath(String _sFilePathName) &#123; int nPos = _sFilePathName.lastIndexOf('/'); if (nPos &lt; 0) &#123; nPos = _sFilePathName.lastIndexOf('\\'); &#125; return (nPos &gt;= 0 ? _sFilePathName.substring(0, nPos + 1) : ""); &#125; /** * 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) &lt;br&gt; * 如：d:\path\file.ext --&gt; file.ext * * @param _sFilePathName * @return */ public static String extractFileName(String _sFilePathName) &#123; return extractFileName(_sFilePathName, File.separator); &#125; /** * 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) &lt;br&gt; * 如：d:\path\file.ext --&gt; file.ext * * @param _sFilePathName 全文件路径名 * @param _sFileSeparator 文件分隔符 * @return */ public static String extractFileName(String _sFilePathName, String _sFileSeparator) &#123; int nPos = -1; if (_sFileSeparator == null) &#123; nPos = _sFilePathName.lastIndexOf(File.separatorChar); if (nPos &lt; 0) &#123; nPos = _sFilePathName .lastIndexOf(File.separatorChar == '/' ? '\\' : '/'); &#125; &#125; else &#123; nPos = _sFilePathName.lastIndexOf(_sFileSeparator); &#125; if (nPos &lt; 0) &#123; return _sFilePathName; &#125; return _sFilePathName.substring(nPos + 1); &#125; /** * 检查指定文件的路径是否存在 * * @param _sPathFileName 文件名称(含路径） * @return 若存在，则返回true；否则，返回false */ public static boolean pathExists(String _sPathFileName) &#123; String sPath = extractFilePath(_sPathFileName); return fileExists(sPath); &#125; public static boolean fileExists(String _sPathFileName) &#123; File file = new File(_sPathFileName); return file.exists(); &#125; /** * 创建目录 * * @param _sDir 目录名称 * @param _bCreateParentDir 如果父目录不存在，是否创建父目录 * @return */ public static boolean makeDir(String _sDir, boolean _bCreateParentDir) &#123; boolean zResult = false; File file = new File(_sDir); if (_bCreateParentDir) zResult = file.mkdirs(); // 如果父目录不存在，则创建所有必需的父目录 else zResult = file.mkdir(); // 如果父目录不存在，不做处理 if (!zResult) zResult = file.exists(); return zResult; &#125; /** * 移除字符串中的BOM前缀 * * @param _sLine 需要处理的字符串 * @return 移除BOM后的字符串. */ private static String removeBomHeaderIfExists(String _sLine) &#123; if (_sLine == null) &#123; return null; &#125; String line = _sLine; if (line.length() &gt; 0) &#123; char ch = line.charAt(0); // 使用while是因为用一些工具看到过某些文件前几个字节都是0xfffe. // 0xfeff,0xfffe是字节序的不同处理.JVM中,一般是0xfeff while ((ch == 0xfeff || ch == 0xfffe)) &#123; line = line.substring(1); if (line.length() == 0) &#123; break; &#125; ch = line.charAt(0); &#125; &#125; return line; &#125;&#125; 网上的工具类这个工具类也大同小异。其中也有很多和我上面重复的一些方法，也有上面没有的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575package com.nsu.edu.library.utils;import android.text.TextUtils;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.util.ArrayList;import java.util.List;/** * File Utils * &lt;ul&gt; * Read or write file * &lt;li&gt;&#123;@link #readFile(String, String)&#125; read file&lt;/li&gt; * &lt;li&gt;&#123;@link #readFileToList(String, String)&#125; read file to string list&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, String, boolean)&#125; write file from String&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, String)&#125; write file from String&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, List, boolean)&#125; write file from String List&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, List)&#125; write file from String List&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, InputStream)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, InputStream, boolean)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(File, InputStream)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(File, InputStream, boolean)&#125; write file&lt;/li&gt; * &lt;/ul&gt; * &lt;ul&gt; * Operate file * &lt;li&gt;&#123;@link #moveFile(File, File)&#125; or &#123;@link #moveFile(String, String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #copyFile(String, String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileExtension(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileName(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileNameWithoutExtension(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileSize(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #deleteFile(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #isFileExist(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #isFolderExist(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #makeFolders(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #makeDirs(String)&#125;&lt;/li&gt; * &lt;/ul&gt; * * @author &lt;a href="http://www.trinea.cn" target="_blank"&gt;Trinea&lt;/a&gt; 2012-5-12 */public class FileUtils &#123; public final static String FILE_EXTENSION_SEPARATOR = "."; private FileUtils() &#123; throw new AssertionError(); &#125; /** * read file * * @param filePath * @param charsetName The name of a supported &#123;@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;&#125; * @return if file not exist, return null, else return content of file * @throws RuntimeException if an error occurs while operator BufferedReader */ public static StringBuilder readFile(String filePath, String charsetName) &#123; File file = new File(filePath); StringBuilder fileContent = new StringBuilder(""); if (file == null || !file.isFile()) &#123; return null; &#125; BufferedReader reader = null; try &#123; InputStreamReader is = new InputStreamReader(new FileInputStream(file), charsetName); reader = new BufferedReader(is); String line = null; while ((line = reader.readLine()) != null) &#123; if (!fileContent.toString().equals("")) &#123; fileContent.append("\r\n"); &#125; fileContent.append(line); &#125; return fileContent; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(reader); &#125; &#125; /** * write file * * @param filePath * @param content * @param append is append, if true, write to the end of file, else clear content of file and write into it * @return return false if content is empty, true otherwise * @throws RuntimeException if an error occurs while operator FileWriter */ public static boolean writeFile(String filePath, String content, boolean append) &#123; if (StringUtils.isEmpty(content)) &#123; return false; &#125; FileWriter fileWriter = null; try &#123; makeDirs(filePath); fileWriter = new FileWriter(filePath, append); fileWriter.write(content); return true; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(fileWriter); &#125; &#125; /** * write file * * @param filePath * @param contentList * @param append is append, if true, write to the end of file, else clear content of file and write into it * @return return false if contentList is empty, true otherwise * @throws RuntimeException if an error occurs while operator FileWriter */ public static boolean writeFile(String filePath, List&lt;String&gt; contentList, boolean append) &#123; if (ListUtils.isEmpty(contentList)) &#123; return false; &#125; FileWriter fileWriter = null; try &#123; makeDirs(filePath); fileWriter = new FileWriter(filePath, append); int i = 0; for (String line : contentList) &#123; if (i++ &gt; 0) &#123; fileWriter.write("\r\n"); &#125; fileWriter.write(line); &#125; return true; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(fileWriter); &#125; &#125; /** * write file, the string will be written to the begin of the file * * @param filePath * @param content * @return */ public static boolean writeFile(String filePath, String content) &#123; return writeFile(filePath, content, false); &#125; /** * write file, the string list will be written to the begin of the file * * @param filePath * @param contentList * @return */ public static boolean writeFile(String filePath, List&lt;String&gt; contentList) &#123; return writeFile(filePath, contentList, false); &#125; /** * write file, the bytes will be written to the begin of the file * * @param filePath * @param stream * @return * @see &#123;@link #writeFile(String, InputStream, boolean)&#125; */ public static boolean writeFile(String filePath, InputStream stream) &#123; return writeFile(filePath, stream, false); &#125; /** * write file * * @param file the file to be opened for writing. * @param stream the input stream * @param append if &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file rather than the beginning * @return return true * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean writeFile(String filePath, InputStream stream, boolean append) &#123; return writeFile(filePath != null ? new File(filePath) : null, stream, append); &#125; /** * write file, the bytes will be written to the begin of the file * * @param file * @param stream * @return * @see &#123;@link #writeFile(File, InputStream, boolean)&#125; */ public static boolean writeFile(File file, InputStream stream) &#123; return writeFile(file, stream, false); &#125; /** * write file * * @param file the file to be opened for writing. * @param stream the input stream * @param append if &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file rather than the beginning * @return return true * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean writeFile(File file, InputStream stream, boolean append) &#123; OutputStream o = null; try &#123; makeDirs(file.getAbsolutePath()); o = new FileOutputStream(file, append); byte data[] = new byte[1024]; int length = -1; while ((length = stream.read(data)) != -1) &#123; o.write(data, 0, length); &#125; o.flush(); return true; &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException("FileNotFoundException occurred. ", e); &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(o); IOUtils.close(stream); &#125; &#125; /** * move file * * @param sourceFilePath * @param destFilePath */ public static void moveFile(String sourceFilePath, String destFilePath) &#123; if (TextUtils.isEmpty(sourceFilePath) || TextUtils.isEmpty(destFilePath)) &#123; throw new RuntimeException("Both sourceFilePath and destFilePath cannot be null."); &#125; moveFile(new File(sourceFilePath), new File(destFilePath)); &#125; /** * move file * * @param srcFile * @param destFile */ public static void moveFile(File srcFile, File destFile) &#123; boolean rename = srcFile.renameTo(destFile); if (!rename) &#123; copyFile(srcFile.getAbsolutePath(), destFile.getAbsolutePath()); deleteFile(srcFile.getAbsolutePath()); &#125; &#125; /** * copy file * * @param sourceFilePath * @param destFilePath * @return * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean copyFile(String sourceFilePath, String destFilePath) &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(sourceFilePath); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException("FileNotFoundException occurred. ", e); &#125; return writeFile(destFilePath, inputStream); &#125; /** * read file to string list, a element of list is a line * * @param filePath * @param charsetName The name of a supported &#123;@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;&#125; * @return if file not exist, return null, else return content of file * @throws RuntimeException if an error occurs while operator BufferedReader */ public static List&lt;String&gt; readFileToList(String filePath, String charsetName) &#123; File file = new File(filePath); List&lt;String&gt; fileContent = new ArrayList&lt;String&gt;(); if (file == null || !file.isFile()) &#123; return null; &#125; BufferedReader reader = null; try &#123; InputStreamReader is = new InputStreamReader(new FileInputStream(file), charsetName); reader = new BufferedReader(is); String line = null; while ((line = reader.readLine()) != null) &#123; fileContent.add(line); &#125; return fileContent; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(reader); &#125; &#125; /** * get file name from path, not include suffix * * &lt;pre&gt; * getFileNameWithoutExtension(null) = null * getFileNameWithoutExtension("") = "" * getFileNameWithoutExtension(" ") = " " * getFileNameWithoutExtension("abc") = "abc" * getFileNameWithoutExtension("a.mp3") = "a" * getFileNameWithoutExtension("a.b.rmvb") = "a.b" * getFileNameWithoutExtension("c:\\") = "" * getFileNameWithoutExtension("c:\\a") = "a" * getFileNameWithoutExtension("c:\\a.b") = "a" * getFileNameWithoutExtension("c:a.txt\\a") = "a" * getFileNameWithoutExtension("/home/admin") = "admin" * getFileNameWithoutExtension("/home/admin/a.txt/b.mp3") = "b" * &lt;/pre&gt; * * @param filePath * @return file name from path, not include suffix * @see */ public static String getFileNameWithoutExtension(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int extenPosi = filePath.lastIndexOf(FILE_EXTENSION_SEPARATOR); int filePosi = filePath.lastIndexOf(File.separator); if (filePosi == -1) &#123; return (extenPosi == -1 ? filePath : filePath.substring(0, extenPosi)); &#125; if (extenPosi == -1) &#123; return filePath.substring(filePosi + 1); &#125; return (filePosi &lt; extenPosi ? filePath.substring(filePosi + 1, extenPosi) : filePath.substring(filePosi + 1)); &#125; /** * get file name from path, include suffix * * &lt;pre&gt; * getFileName(null) = null * getFileName("") = "" * getFileName(" ") = " " * getFileName("a.mp3") = "a.mp3" * getFileName("a.b.rmvb") = "a.b.rmvb" * getFileName("abc") = "abc" * getFileName("c:\\") = "" * getFileName("c:\\a") = "a" * getFileName("c:\\a.b") = "a.b" * getFileName("c:a.txt\\a") = "a" * getFileName("/home/admin") = "admin" * getFileName("/home/admin/a.txt/b.mp3") = "b.mp3" * &lt;/pre&gt; * * @param filePath * @return file name from path, include suffix */ public static String getFileName(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int filePosi = filePath.lastIndexOf(File.separator); return (filePosi == -1) ? filePath : filePath.substring(filePosi + 1); &#125; /** * get folder name from path * * &lt;pre&gt; * getFolderName(null) = null * getFolderName("") = "" * getFolderName(" ") = "" * getFolderName("a.mp3") = "" * getFolderName("a.b.rmvb") = "" * getFolderName("abc") = "" * getFolderName("c:\\") = "c:" * getFolderName("c:\\a") = "c:" * getFolderName("c:\\a.b") = "c:" * getFolderName("c:a.txt\\a") = "c:a.txt" * getFolderName("c:a\\b\\c\\d.txt") = "c:a\\b\\c" * getFolderName("/home/admin") = "/home" * getFolderName("/home/admin/a.txt/b.mp3") = "/home/admin/a.txt" * &lt;/pre&gt; * * @param filePath * @return */ public static String getFolderName(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int filePosi = filePath.lastIndexOf(File.separator); return (filePosi == -1) ? "" : filePath.substring(0, filePosi); &#125; /** * get suffix of file from path * * &lt;pre&gt; * getFileExtension(null) = "" * getFileExtension("") = "" * getFileExtension(" ") = " " * getFileExtension("a.mp3") = "mp3" * getFileExtension("a.b.rmvb") = "rmvb" * getFileExtension("abc") = "" * getFileExtension("c:\\") = "" * getFileExtension("c:\\a") = "" * getFileExtension("c:\\a.b") = "b" * getFileExtension("c:a.txt\\a") = "" * getFileExtension("/home/admin") = "" * getFileExtension("/home/admin/a.txt/b") = "" * getFileExtension("/home/admin/a.txt/b.mp3") = "mp3" * &lt;/pre&gt; * * @param filePath * @return */ public static String getFileExtension(String filePath) &#123; if (StringUtils.isBlank(filePath)) &#123; return filePath; &#125; int extenPosi = filePath.lastIndexOf(FILE_EXTENSION_SEPARATOR); int filePosi = filePath.lastIndexOf(File.separator); if (extenPosi == -1) &#123; return ""; &#125; return (filePosi &gt;= extenPosi) ? "" : filePath.substring(extenPosi + 1); &#125; /** * Creates the directory named by the trailing filename of this file, including the complete directory path required * to create this directory. &lt;br/&gt; * &lt;br/&gt; * &lt;ul&gt; * &lt;strong&gt;Attentions:&lt;/strong&gt; * &lt;li&gt;makeDirs("C:\\Users\\Trinea") can only create users folder&lt;/li&gt; * &lt;li&gt;makeFolder("C:\\Users\\Trinea\\") can create Trinea folder&lt;/li&gt; * &lt;/ul&gt; * * @param filePath * @return true if the necessary directories have been created or the target directory already exists, false one of * the directories can not be created. * &lt;ul&gt; * &lt;li&gt;if &#123;@link FileUtils#getFolderName(String)&#125; return null, return false&lt;/li&gt; * &lt;li&gt;if target directory already exists, return true&lt;/li&gt; * &lt;li&gt;return &#123;@link File#makeFolder&#125;&lt;/li&gt; * &lt;/ul&gt; */ public static boolean makeDirs(String filePath) &#123; String folderName = getFolderName(filePath); if (StringUtils.isEmpty(folderName)) &#123; return false; &#125; File folder = new File(folderName); return (folder.exists() &amp;&amp; folder.isDirectory()) ? true : folder.mkdirs(); &#125; /** * @param filePath * @return * @see #makeDirs(String) */ public static boolean makeFolders(String filePath) &#123; return makeDirs(filePath); &#125; /** * Indicates if this file represents a file on the underlying file system. * * @param filePath * @return */ public static boolean isFileExist(String filePath) &#123; if (StringUtils.isBlank(filePath)) &#123; return false; &#125; File file = new File(filePath); return (file.exists() &amp;&amp; file.isFile()); &#125; /** * Indicates if this file represents a directory on the underlying file system. * * @param directoryPath * @return */ public static boolean isFolderExist(String directoryPath) &#123; if (StringUtils.isBlank(directoryPath)) &#123; return false; &#125; File dire = new File(directoryPath); return (dire.exists() &amp;&amp; dire.isDirectory()); &#125; /** * delete file or directory * &lt;ul&gt; * &lt;li&gt;if path is null or empty, return true&lt;/li&gt; * &lt;li&gt;if path not exist, return true&lt;/li&gt; * &lt;li&gt;if path exist, delete recursion. return true&lt;/li&gt; * &lt;ul&gt; * * @param path * @return */ public static boolean deleteFile(String path) &#123; if (StringUtils.isBlank(path)) &#123; return true; &#125; File file = new File(path); if (!file.exists()) &#123; return true; &#125; if (file.isFile()) &#123; return file.delete(); &#125; if (!file.isDirectory()) &#123; return false; &#125; for (File f : file.listFiles()) &#123; if (f.isFile()) &#123; f.delete(); &#125; else if (f.isDirectory()) &#123; deleteFile(f.getAbsolutePath()); &#125; &#125; return file.delete(); &#125; /** * get file size * &lt;ul&gt; * &lt;li&gt;if path is null or empty, return -1&lt;/li&gt; * &lt;li&gt;if path exist and it is a file, return file size, else return -1&lt;/li&gt; * &lt;ul&gt; * * @param path * @return returns the length of this file in bytes. returns -1 if the file does not exist. */ public static long getFileSize(String path) &#123; if (StringUtils.isBlank(path)) &#123; return -1; &#125; File file = new File(path); return (file.exists() &amp;&amp; file.isFile() ? file.length() : -1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class FileUtil&#123; private static String message; /** * 读取文本文件内容 * @param filePathAndName 带有完整绝对路径的文件名 * @param encoding 文本文件打开的编码方式 * @return 返回文本文件的内容 */ public static String readTxt(String filePathAndName,String encoding) throws IOException&#123; encoding = encoding.trim(); StringBuffer str = new StringBuffer(""); String st = ""; try&#123; FileInputStream fs = new FileInputStream(filePathAndName); InputStreamReader isr; if(encoding.equals(""))&#123; isr = new InputStreamReader(fs); &#125;else&#123; isr = new InputStreamReader(fs,encoding); &#125; BufferedReader br = new BufferedReader(isr); try&#123; String data = ""; while((data = br.readLine())!=null)&#123; str.append(data+" "); &#125; &#125;catch(Exception e)&#123; str.append(e.toString()); &#125; st = str.toString(); &#125;catch(IOException es)&#123; st = ""; &#125; return st; &#125; /** * 新建目录 * @param folderPath 目录 * @return 返回目录创建后的路径 */ public static String createFolder(String folderPath) &#123; String txt = folderPath; try &#123; java.io.File myFilePath = new java.io.File(txt); txt = folderPath; if (!myFilePath.exists()) &#123; myFilePath.mkdir(); &#125; &#125; catch (Exception e) &#123; message = "创建目录操作出错"; &#125; return txt; &#125; /** * 多级目录创建 * @param folderPath 准备要在本级目录下创建新目录的目录路径 例如 c:myf * @param paths 无限级目录参数，各级目录以单数线区分 例如 a|b|c * @return 返回创建文件后的路径 例如 c:myfac */ public static String createFolders(String folderPath, String paths)&#123; String txts = folderPath; try&#123; String txt; txts = folderPath; StringTokenizer st = new StringTokenizer(paths,"|"); for(int i=0; st.hasMoreTokens(); i++)&#123; txt = st.nextToken().trim(); if(txts.lastIndexOf("/")!=-1)&#123; txts = createFolder(txts+txt); &#125;else&#123; txts = createFolder(txts+txt+"/"); &#125; &#125; &#125;catch(Exception e)&#123; message = "创建目录操作出错！"; &#125; return txts; &#125; /** * 新建文件 * @param filePathAndName 文本文件完整绝对路径及文件名 * @param fileContent 文本文件内容 * @return */ public static void createFile(String filePathAndName, String fileContent) &#123; try &#123; String filePath = filePathAndName; filePath = filePath.toString(); File myFilePath = new File(filePath); if (!myFilePath.exists()) &#123; myFilePath.createNewFile(); &#125; FileWriter resultFile = new FileWriter(myFilePath); PrintWriter myFile = new PrintWriter(resultFile); String strContent = fileContent; myFile.println(strContent); myFile.close(); resultFile.close(); &#125; catch (Exception e) &#123; message = "创建文件操作出错"; &#125; &#125; /** * 有编码方式的文件创建 * @param filePathAndName 文本文件完整绝对路径及文件名 * @param fileContent 文本文件内容 * @param encoding 编码方式 例如 GBK 或者 UTF-8 * @return */ public static void createFile(String filePathAndName, String fileContent, String encoding) &#123; try &#123; String filePath = filePathAndName; filePath = filePath.toString(); File myFilePath = new File(filePath); if (!myFilePath.exists()) &#123; myFilePath.createNewFile(); &#125; PrintWriter myFile = new PrintWriter(myFilePath,encoding); String strContent = fileContent; myFile.println(strContent); myFile.close(); &#125; catch (Exception e) &#123; message = "创建文件操作出错"; &#125; &#125; /** * 删除文件 * @param filePathAndName 文本文件完整绝对路径及文件名 * @return Boolean 成功删除返回true遭遇异常返回false */ public static boolean delFile(String filePathAndName) &#123; boolean bea = false; try &#123; String filePath = filePathAndName; File myDelFile = new File(filePath); if(myDelFile.exists())&#123; myDelFile.delete(); bea = true; &#125;else&#123; bea = false; message = (filePathAndName+"删除文件操作出错"); &#125; &#125; catch (Exception e) &#123; message = e.toString(); &#125; return bea; &#125; /** * 删除文件夹 * @param folderPath 文件夹完整绝对路径 * @return */ public static void delFolder(String folderPath) &#123; try &#123; delAllFile(folderPath); //删除完里面所有内容 String filePath = folderPath; filePath = filePath.toString(); java.io.File myFilePath = new java.io.File(filePath); myFilePath.delete(); //删除空文件夹 &#125; catch (Exception e) &#123; message = ("删除文件夹操作出错"); &#125; &#125; /** * 删除指定文件夹下所有文件 * @param path 文件夹完整绝对路径 * @return * @return */ public static boolean delAllFile(String path) &#123; boolean bea = false; File file = new File(path); if (!file.exists()) &#123; return bea; &#125; if (!file.isDirectory()) &#123; return bea; &#125; String[] tempList = file.list(); File temp = null; for (int i = 0; i &lt; tempList.length; i++) &#123; if (path.endsWith(File.separator)) &#123; temp = new File(path + tempList[i]); &#125;else&#123; temp = new File(path + File.separator + tempList[i]); &#125; if (temp.isFile()) &#123; temp.delete(); &#125; if (temp.isDirectory()) &#123; delAllFile(path+"/"+ tempList[i]);//先删除文件夹里面的文件 delFolder(path+"/"+ tempList[i]);//再删除空文件夹 bea = true; &#125; &#125; return bea; &#125; /** * 复制单个文件 * @param oldPathFile 准备复制的文件源 * @param newPathFile 拷贝到新绝对路径带文件名 * @return */ public static void copyFile(String oldPathFile, String newPathFile) &#123; try &#123; int bytesum = 0; int byteread = 0; File oldfile = new File(oldPathFile); if (oldfile.exists()) &#123; //文件存在时 InputStream inStream = new FileInputStream(oldPathFile); //读入原文件 FileOutputStream fs = new FileOutputStream(newPathFile); byte[] buffer = new byte[1444]; while((byteread = inStream.read(buffer)) != -1)&#123; bytesum += byteread; //字节数 文件大小 System.out.println(bytesum); fs.write(buffer, 0, byteread); &#125; inStream.close(); &#125; &#125;catch (Exception e) &#123; message = ("复制单个文件操作出错"); &#125; &#125; /** * 复制整个文件夹的内容 * @param oldPath 准备拷贝的目录 * @param newPath 指定绝对路径的新目录 * @return */ public static void copyFolder(String oldPath, String newPath) &#123; try &#123; new File(newPath).mkdirs(); //如果文件夹不存在 则建立新文件夹 File a=new File(oldPath); String[] file=a.list(); File temp=null; for (int i = 0; i &lt; file.length; i++) &#123; if(oldPath.endsWith(File.separator))&#123; temp=new File(oldPath+file[i]); &#125;else&#123; temp=new File(oldPath+File.separator+file[i]); &#125; if(temp.isFile())&#123; FileInputStream input = new FileInputStream(temp); FileOutputStream output = new FileOutputStream(newPath + "/" + (temp.getName()).toString()); byte[] b = new byte[1024 * 5]; int len; while ((len = input.read(b)) != -1) &#123; output.write(b, 0, len); &#125; output.flush(); output.close(); input.close(); &#125; if(temp.isDirectory())&#123;//如果是子文件夹 copyFolder(oldPath+"/"+file[i],newPath+"/"+file[i]); &#125; &#125; &#125;catch (Exception e) &#123; message = "复制整个文件夹内容操作出错"; &#125; &#125; /** * 移动文件 * @param oldPath * @param newPath * @return */ public static void moveFile(String oldPath, String newPath) &#123; copyFile(oldPath, newPath); delFile(oldPath); &#125; /** * 移动目录 * @param oldPath * @param newPath * @return */ public static void moveFolder(String oldPath, String newPath) &#123; copyFolder(oldPath, newPath); delFolder(oldPath); &#125; /** * 得到错误信息 */ public static String getMessage()&#123; return message; &#125;&#125; StringUtils 字符串达到多长才截取 将指定的对象转换为String类型 转换字符,用于替换提交的数据中存在非法数据:”‘“ 对标题””转换为中文“”采用对应转换 替换HTML标记 标题中含有特殊字符替换 如:●▲@◎※ 主要在标题中使用 替换所有英文字母 替换所有数字 将/n转换成为回车 ,空格转为&nbsp; 清除所有&lt;&gt;标记符号 主要在搜索中显示文字内容 而不显示样式 清楚WOrd垃圾代码 判断传入的字符串如果为null则返回””,否则返回其本身 获取百分比 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676package com.xwtech.uomp.base.util;import java.io.UnsupportedEncodingException;import java.text.NumberFormat;import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.xwtech.uomp.base.action.handler.HandlerResult;import com.xwtech.uomp.base.constants.SystemCodeConstants;public class StringUtil &#123; public static final String arrTest[] = &#123;"[br]", "[/b]", "[/i]", "[/u]", "[/size]", "[/color]", "[/align]", "[/url]", "[/email]", "[/img]"&#125;; public static final String arrParam[] = &#123;"\\[br\\]", "\\[b\\](.+?)\\[/b\\]", "\\[i\\](.+?)\\[/i\\]", "\\[u\\](.+?)\\[/u\\]", "\\[size=(.+?)\\](.+?)\\[/size\\]", "\\[color=(.+?)\\](.+?)\\[/color\\]", "\\[align=(.+?)\\](.+?)\\[/align\\]", "\\[url=(.+?)\\](.+?)\\[/url\\]", "\\[email=(.+?)\\](.+?)\\[/email\\]," + "\\[img=(.+?)\\](.+?)\\[/img\\]"&#125;; public static final String arrCode[] = &#123;"&lt;br&gt;", "&lt;b&gt;$1&lt;/b&gt;", "&lt;i&gt;$1&lt;/i&gt;", "&lt;u&gt;$1&lt;/u&gt;", "&lt;font size=\"$1\"&gt;$2&lt;/font&gt;", "&lt;font color=\"$1\"&gt;$2&lt;/font&gt;", "&lt;div align=\"$1\"&gt;$2&lt;/div&gt;", "&lt;a href=\"$1\" target=\"_blank\"&gt;$2&lt;/a&gt;", "&lt;a href=\"email:$1\"&gt;$2&lt;/a&gt;", "&lt;img src=\"$1\" border=0&gt;$2&lt;/img&gt;"&#125;; public static int getInt(String content) &#123; int intContent; try &#123; intContent = Integer.parseInt(content); &#125; catch (Exception e) &#123; intContent = 0; &#125; return intContent; &#125; public static long getLong(String content) &#123; long lngContent; try &#123; lngContent = Long.parseLong(content); &#125; catch (Exception e) &#123; lngContent = 0L; &#125; return lngContent; &#125; /** 1 * @param str 原字符串 * @param length 字符串达到多长才截取 * @return */ @SuppressWarnings("static-access") public static String subStringToPoint(String str, int length, String more) &#123; String reStr = ""; if (str.length() * 2 - 1 &gt; length) &#123; int reInt = 0; if (str == null) return ""; char[] tempChar = str.toCharArray(); for (int kk = 0; (kk &lt; tempChar.length &amp;&amp; length &gt; reInt); kk++) &#123; String s1 = str.valueOf(tempChar[kk]); byte[] b = s1.getBytes(); reInt += b.length; reStr += tempChar[kk]; &#125; if (length == reInt || (length == reInt - 1)) &#123; if (!reStr.equals(str)) &#123; reStr += more; &#125; &#125; &#125; else &#123; reStr = str; &#125; return reStr; &#125; /** 2 * 将指定的对象转换为String类型 * * @param curObject 传入对象参数 * @return String */ public static String getString(Object curObject) &#123; if (null == curObject) &#123; throw new NullPointerException("The input object is null."); &#125; else &#123; return curObject.toString(); &#125; &#125; /** 3 * 转换字符,用于替换提交的数据中存在非法数据:"'" * * @param Content * @return */ public static String replaceChar(String content) &#123; String newstr = ""; newstr = content.replaceAll("\'", "''"); return newstr; &#125; /**4 * 对标题""转换为中文“”采用对应转换 * * @param Content * @return */ public static String replaceSymbol(String content) &#123; int intPlaceNum = 0; int Num = 0; String strContent = content; while (true) &#123; //判断是否还存在" intPlaceNum = strContent.indexOf("\""); if (intPlaceNum &lt; 0) &#123; break; &#125; else &#123; if (Num % 2 == 0) &#123; strContent = strContent.replaceFirst("\"", "“"); &#125; else &#123; strContent = strContent.replaceFirst("\"", "”"); &#125; Num = Num + 1; &#125; &#125; return strContent; &#125; /**5 * 替换HTML标记 * * @param Content * @return */ public static String replaceCharToHtml(String content) &#123; String strContent = content; strContent = strContent.replaceAll("&lt;", "&lt;"); strContent = strContent.replaceAll("&gt;", "&gt;"); strContent = strContent.replaceAll("\"", """); return strContent; &#125; public static String replaceHtmlToChar(String content) &#123; String strContent = content; strContent = strContent.replaceAll("&lt;", "&lt;"); strContent = strContent.replaceAll("&gt;", "&gt;"); strContent = strContent.replaceAll(""", "\""); return strContent; &#125; //数据库替换 public static String replaceCharToSql(String content) &#123; String strContent = content; strContent = strContent.replaceAll("%", "\\\\%"); return strContent; &#125; public static String toHtmlValue(String value) &#123; if (null == value) &#123; return null; &#125; char a = 0; StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; value.length(); i++) &#123; a = value.charAt(i); switch (a) &#123; // 双引号 case 34: buf.append("""); break; // &amp;号 case 38: buf.append("&amp;"); break; // 单引号 case 39: buf.append("'"); break; // 小于号 case 60: buf.append("&lt;"); break; // 大于号 case 62: buf.append("&gt;"); break; default: buf.append(a); break; &#125; &#125; return buf.toString(); &#125; /**6 * 标题中含有特殊字符替换 如:●▲@◎※ 主要在标题中使用 * * @param Content * @return */ public static String replaceSign(String content) &#123; String strContent = ""; strContent = content.replaceAll("\\*", ""); strContent = strContent.replaceAll("\\$", ""); strContent = strContent.replaceAll("\\+", ""); String arrStr[] = &#123;":", "：", "●", "▲", "■", "@", "＠", "◎", "★", "※", "＃", "〓", "＼", "§", "☆", "○", "◇", "◆", "□", "△", "＆", "＾", "￣", "＿", "♂", "♀", "Ю", "┭", "①", "「", "」", "≮", "§", "￡", "∑", "『", "』", "⊙", "∷", "Θ", "の", "↓", "↑", "Ф", "~", "Ⅱ", "∈", "┣", "┫", "╋", "┇", "┋", "→", "←", "!", "Ж", "#"&#125;; for (int i = 0; i &lt; arrStr.length; i++) &#123; if ((strContent.indexOf(arrStr[i])) &gt;= 0) &#123; strContent = strContent.replaceAll(arrStr[i], ""); &#125; &#125; return strContent; &#125; /**7 * 替换所有英文字母 * * @param Content * @return */ public static String replaceLetter(String content) &#123; String strMark = "[^[A-Za-z]+$]"; String strContent = ""; strContent = content.replaceAll(strMark, ""); return strContent; &#125; /**8 * 替换所有数字 * * @param Content * @return */ public static String replaceNumber(String content) &#123; String strMark = "[^[0-9]+$]"; String strContent = ""; strContent = content.replaceAll(strMark, ""); return strContent; &#125; /**9 * 将/n转换成为回车&lt;br&gt; ,空格转为 * * @param Content * @return */ public static String replaceBr(String content) &#123; if (content == null) &#123; return ""; &#125; String strContent = ""; // String strMark ="[/\n\r\t]"; //strContent = content.replaceAll(strMark,"&lt;br&gt;"); strContent = content.replaceAll("\n\r\t", "&lt;br&gt;"); strContent = strContent.replaceAll("\n\r", "&lt;br&gt;"); strContent = strContent.replaceAll("\r\n", "&lt;br&gt;"); strContent = strContent.replaceAll("\n", "&lt;br&gt;"); strContent = strContent.replaceAll("\r", "&lt;br&gt;"); strContent = strContent.replaceAll(" ", " "); return strContent; &#125; /**10 * 清除所有&lt;&gt;标记符号 主要在搜索中显示文字内容 而不显示样式 * * @param Content * @return */ public static String replaceMark(String content) &#123; String strContent = ""; String strMark = "&lt;\\s*[^&gt;]*&gt;"; strContent = content.trim(); strContent = strContent.replaceAll("\"", ""); strContent = strContent.replaceAll("\'", ""); //删除所有&lt;&gt;标记 strContent = strContent.replaceAll(strMark, ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll("\r", ""); strContent = strContent.replaceAll("\n", ""); strContent = strContent.replaceAll("\r\n", ""); return strContent; &#125; /**11 * 清楚WOrd垃圾代码 * * @param Content * @return */ public static String clearWord(String content) &#123; String strContent = ""; strContent = content.trim(); strContent = strContent.replaceAll("x:str", ""); //Remove Style attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) style=\"([^\"]*)\"", "&lt;$1"); //Remove all SPAN tags strContent = strContent.replaceAll("&lt;\\/?SPAN[^&gt;]*&gt;", ""); //Remove Lang attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) lang=([^ |&gt;]*)([^&gt;]*)", "&lt;$1$3"); //Remove Class attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) class=([^ |&gt;]*)([^&gt;]*)", "&lt;$1$3"); //Remove XML elements and declarations strContent = strContent.replaceAll("&lt;\\\\?\\?xml[^&gt;]*&gt;", ""); //Remove Tags with XML namespace declarations: &lt;o:p&gt;&lt;/o:p&gt; strContent = strContent.replaceAll("&lt;\\/?\\w+:[^&gt;]*&gt;", ""); return strContent; &#125; /** * 对组ID信息进行处理 转换为标准ID组 并过滤重复的信息 * * @param teamId * @return */ public static String checkTeamId(String teamId) &#123; String strTeamId = ""; String strTempId = ""; String strTemp = ""; String[] arrTeamId = teamId.split(","); for (int num = 0; num &lt; arrTeamId.length; num++) &#123; strTemp = arrTeamId[num].trim(); if ((!strTemp.equals("")) &amp;&amp; (!strTemp.equals("0"))) &#123; if ((strTempId.indexOf("," + strTemp + ",")) &gt;= 0) &#123; //表示已经保存过了 &#125; else &#123; if (strTeamId.equals("")) &#123; strTeamId = strTemp; strTempId = strTempId + "," + strTemp + ","; ; &#125; else &#123; strTeamId = strTeamId + "," + strTemp; strTempId = strTempId + strTemp + ","; &#125; &#125; &#125; &#125; return strTeamId; &#125; public static String replaceUbb(String content) &#123; String strContent = content; try &#123; for (int num = 0; num &lt; arrTest.length; num++) &#123; if ((strContent.indexOf(arrTest[num])) &gt;= 0) &#123; try &#123; strContent = strContent.replaceAll(arrParam[num], arrCode[num]); &#125; catch (Exception ex) &#123; &#125; &#125; &#125; &#125; catch (Exception e) &#123; //System.out.println("UBB CODE 错误"+e); &#125; return strContent; &#125; /**12 * 判断传入的字符串如果为null则返回"",否则返回其本身 * * @param string * @param instant * @return String */ public static String convertNull(String string, String instant) &#123; return isNull(string) ? instant : string; &#125; /** * &#123;@link #convertNull(String, String)&#125; * * @param string * @return String */ public static String convertNull(String string) &#123; return convertNull(string, ""); &#125; /** * 判断对象是否为空 * * @param obj Object * @return boolean 空返回true,非空返回false */ public static boolean isNull(Object obj) &#123; return (null == obj) ? true : false; &#125; /** * Description:判断字段空null &lt;br&gt; * * @param s * @return boolean */ public static boolean isNull(String s) &#123; if (s == null || "".equals(s.trim())) &#123; return true; &#125; return false; &#125; /**13 * 获取百分比 * * @param p1 * @param p2 * @return */ public static String percent(double p1, double p2) &#123; if (p2 == 0) &#123; return "0.00%"; &#125; String str; double p3 = p1 / p2; NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2); str = nf.format(p3); return str; &#125; /** * 字符串编码转换的实现方法 * * @param str 待转换编码的字符串 * @param oldCharset 原编码 * @param newCharset 目标编码 * @return * @throws UnsupportedEncodingException */ public static String changeCharset(String str, String oldCharset, String newCharset) &#123; try &#123; if (str != null) &#123; //用旧的字符编码解码字符串。解码可能会出现异常。 byte[] bs = str.getBytes(oldCharset); //用新的字符编码生成字符串 return new String(bs, newCharset); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); return ""; &#125; return ""; &#125; /** * 字符串编码转换的实现方法 * * @param str 待转换编码的字符串 * @param newCharset 目标编码 * @return * @throws UnsupportedEncodingException */ public String changeCharset(String str, String newCharset) &#123; try &#123; if (str != null) &#123; //用默认字符编码解码字符串。 byte[] bs = str.getBytes(); //用新的字符编码生成字符串 return new String(bs, newCharset); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return ""; &#125; /** * 解析html中的参数信息 * * @param elementStr * @return */ public static Map&lt;String, String&gt; getConfigValue(String elementStr) &#123; try &#123; elementStr = java.net.URLDecoder.decode(elementStr, "utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; int start = elementStr.indexOf("configvalue"); Map&lt;String, String&gt; map = null; //参数的键值对 if (start != -1) &#123; map = new HashMap&lt;String, String&gt;(); start = elementStr.indexOf("\"", start); int end = elementStr.lastIndexOf("||"); if (start &lt; 0 || end &lt; 0) &#123; return null; &#125; String configValue = elementStr.substring(start + 1, end); String[] values = configValue.split("\\|\\|"); for (int i = 0; i &lt; values.length; i++) &#123; String value = values[i]; if (value != null &amp;&amp; value.trim().length() &gt; 1) &#123; int de = value.indexOf("="); if (de &gt; 0) &#123; String name = value.substring(0, de); String v = value.substring(de + 1); map.put(name, v); &#125; &#125; &#125; &#125; return map; &#125; /** * 转换空值为0 * * @param str * @return */ public static String conventString(String str) &#123; return null == str || "".equals(str) ? "" + "0" : str; &#125; public static String alert(HandlerResult result, String contextPath) &#123; StringBuffer sf = new StringBuffer(); sf.append("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); sf.append("&lt;html&gt;&lt;head&gt;&lt;title&gt;信息提示&lt;/title&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/css/frame.css\" /&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/skins/dhtmlxwindows_dhx_skyblue.css\"/&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/dhtmlxwindows.css\"/&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxLayout/codebase/dhtmlxcommon.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxLayout/codebase/dhtmlxcontainer.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/dhtmlxwindows.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/jquery-1.7.1.min.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/uompDialog.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/main.js\" &gt;&lt;/script&gt;"); sf.append("&lt;/head&gt;&lt;body&gt;"); sf.append("&lt;/body&gt;&lt;/html&gt;"); sf.append("&lt;script type=\"text/javascript\"&gt;"); sf.append("$(document).ready(function()&#123;"); sf.append(" top.UOMPDialog.alert('" + result.getResMsg() + "',0,\"\""); if (SystemCodeConstants.NOT_LOGIN.equals(result.getSysCode())) &#123; sf.append(", &#123;'yes' : function()&#123;"); sf.append(" top.location.href = '").append(contextPath).append("/index.jsp'").append(";"); sf.append("&#125;&#125;"); &#125; sf.append(");"); sf.append(" &#125;);"); sf.append("&lt;/script&gt;"); return sf.toString(); &#125; public static void main(String[] args) &#123; Pattern pattern = Pattern.compile("&lt;span\\s.+?]]&lt;/span&gt;"); String str = "&lt;span configvalue=\"eid=1043||ename=%E9%9D%A2%E5%8C%85%E5%B1%91||folderId=CLBLYM||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 面包屑 ]]&lt;/span&gt;&lt;br /&gt;" + "业务名称：&lt;span configvalue=\"eid=1042||ename=%E4%B8%9A%E5%8A%A1%E5%90%8D%E7%A7%B0||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务名称 ]]&lt;/span&gt;&lt;br /&gt;" + "业务资费：&lt;span configvalue=\"eid=1041||ename=%E4%B8%9A%E5%8A%A1%E8%B5%84%E8%B4%B9||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务资费 ]]&lt;/span&gt;&lt;br /&gt;" + "业务介绍：&lt;br /&gt;" + "&lt;span configvalue=\"eid=1040||ename=%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务介绍 ]]&lt;/span&gt;&lt;br /&gt;" + "&lt;br /&gt;" + "&lt;br /&gt;" + "&lt;br /&gt;&lt;span &gt;]]&lt;/span&gt;" + "&lt;span configvalue=\"eid=1043||ename=%E9%9D%A2%E5%8C%85%E5%B1%91||folderId=CLBLYM||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 面包屑 ]]&lt;/span&gt;&lt;br /&gt;"; Matcher matcher = pattern.matcher(str); String htmlStr = ""; StringBuffer strbuff = new StringBuffer(); int i = 0; while (matcher.find()) &#123; String bm = matcher.group(); System.out.println(bm); Map map = getConfigValue(bm); if (map != null) &#123; //todo:从缓存中获取数据 if (((String) map.get("eid")).equals("1043")) &#123; String se = "【掌上营业厅】+ 1"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1042")) &#123; String se = "【掌上营业厅】+ 2"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1041")) &#123; String se = "【掌上营业厅】 + 3"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1040")) &#123; String se = "【掌上营业厅】+ 4"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1046")) &#123; String se = "【掌上营业厅】+888888888888"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; i++; &#125; &#125; matcher.appendTail(strbuff); htmlStr += strbuff.toString(); System.out.println(htmlStr + "=================" + i); &#125; /** * 方法描述：判断传入的字符串是否非空，即：字符串是否等于null、""或" "。 * 创建日期：2013-12-7下午11:39:34 * 修改日期： * 作者：zhanglu * @param: * @return:boolean */ public static boolean isNotEmpty(String str) &#123; if ((null == str) || ("".equals(str.trim()))) &#123; return false; &#125; else &#123; return true; &#125; &#125; /** * 方法描述：将传入的字符串转换成整型数据，如果转换过程中发生异常，则返回默认值：defaultValue。 * 创建日期：2013-12-7下午11:40:20 * 修改日期： * 作者：zhanglu * @param: * @return:int */ public static int convertIntoInt(String str, int defaultValue) &#123; // 定义一个返回值，假如转型过程中发生异常，则返回此默认值 int retData = defaultValue; try &#123; retData = Integer.parseInt(str.trim()); &#125; catch(NumberFormatException e) &#123; &#125; catch(Exception ex) &#123; &#125; return retData; &#125;&#125; org.apache.commons.lang.StringUtils中方法的操作对象是java.lang.String类型的对象，是JDK提供的String类型操作方法的补充，并且是null安全的(即如果输入参数String为null则不会抛出NullPointerException，而是做了相应处理，例如，如果输入为null则返回也是null等，具体可以查看源代码)。 除了构造器，StringUtils中一共有130多个方法，并且都是static的， 所以我们可以这样调用StringUtils.xxx()。 下面分别对一些常用方法做简要介绍： public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是str == null 或 str.length() == 0下面是示例： 1234567891011StringUtils.isEmpty(null) = trueStringUtils.isEmpty("") = trueStringUtils.isEmpty(" ") = falseStringUtils.isEmpty(" ") = falseStringUtils.isEmpty("bob") = falseStringUtils.isEmpty(" bob ") = false public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于!isEmpty(String str)下面是示例： 1234567891011StringUtils.isNotEmpty(null) = falseStringUtils.isNotEmpty("") = falseStringUtils.isNotEmpty(" ") = trueStringUtils.isNotEmpty(" ") = trueStringUtils.isNotEmpty("bob") = trueStringUtils.isNotEmpty(" bob ") = true public static boolean isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace)构成下面是示例： 123456789101112131415StringUtils.isBlank(null) = trueStringUtils.isBlank("") = trueStringUtils.isBlank(" ") = trueStringUtils.isBlank(" ") = trueStringUtils.isBlank("\t \n \f \r") = trueStringUtils.isBlank("\b") = falseStringUtils.isBlank("bob") = falseStringUtils.isBlank(" bob ") = false public static boolean isNotBlank(String str) 判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成，等于!isBlank(String str) 下面是示例： 123456789101112131415StringUtils.isNotBlank(null) = falseStringUtils.isNotBlank("") = falseStringUtils.isNotBlank(" ") = falseStringUtils.isNotBlank(" ") = falseStringUtils.isNotBlank("\t \n \f \r") = falseStringUtils.isNotBlank("\b") = trueStringUtils.isNotBlank("bob") = trueStringUtils.isNotBlank(" bob ") = true public static String trim(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果输入为null则返回null 下面是示例： 123456789101112131415StringUtils.trim(null) = nullStringUtils.trim("") = ""StringUtils.trim(" ") = ""StringUtils.trim(" \b \t \n \f \r ") = ""StringUtils.trim(" \n\tss \b") = "ss"StringUtils.trim(" d d dd ") = "d d dd"StringUtils.trim("dd ") = "dd"StringUtils.trim(" dd ") = "dd" public static String trimToNull(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果变为null或””，则返回null 下面是示例： 123456789101112131415StringUtils.trimToNull(null) = nullStringUtils.trimToNull("") = nullStringUtils.trimToNull(" ") = nullStringUtils.trimToNull(" \b \t \n \f \r ") = nullStringUtils.trimToNull(" \n\tss \b") = "ss"StringUtils.trimToNull(" d d dd ") = "d d dd"StringUtils.trimToNull("dd ") = "dd"StringUtils.trimToNull(" dd ") = "dd" public static String trimToEmpty(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果变为null或””，则返回”” 下面是示例： 123456789101112131415StringUtils.trimToEmpty(null) = ""StringUtils.trimToEmpty("") = ""StringUtils.trimToEmpty(" ") = ""StringUtils.trimToEmpty(" \b \t \n \f \r ") = ""StringUtils.trimToEmpty(" \n\tss \b") = "ss"StringUtils.trimToEmpty(" d d dd ") = "d d dd"StringUtils.trimToEmpty("dd ") = "dd"StringUtils.trimToEmpty(" dd ") = "dd" public static String strip(String str) 去掉字符串两端的空白符(whitespace)，如果输入为null则返回null 下面是示例(注意和trim()的区别)： 123456789101112131415StringUtils.strip(null) = nullStringUtils.strip("") = ""StringUtils.strip(" ") = ""StringUtils.strip(" \b \t \n \f \r ") = "\b"StringUtils.strip(" \n\tss \b") = "ss \b"StringUtils.strip(" d d dd ") = "d d dd"StringUtils.strip("dd ") = "dd"StringUtils.strip(" dd ") = "dd" public static String stripToNull(String str) 去掉字符串两端的空白符(whitespace)，如果变为null或””，则返回null 下面是示例(注意和trimToNull()的区别)： 123456789101112131415StringUtils.stripToNull(null) = nullStringUtils.stripToNull("") = nullStringUtils.stripToNull(" ") = nullStringUtils.stripToNull(" \b \t \n \f \r ") = "\b"StringUtils.stripToNull(" \n\tss \b") = "ss \b"StringUtils.stripToNull(" d d dd ") = "d d dd"StringUtils.stripToNull("dd ") = "dd"StringUtils.stripToNull(" dd ") = "dd" public static String stripToEmpty(String str) 去掉字符串两端的空白符(whitespace)，如果变为null或””，则返回”” 下面是示例(注意和trimToEmpty()的区别)： 123456789101112131415StringUtils.stripToNull(null) = ""StringUtils.stripToNull("") = ""StringUtils.stripToNull(" ") = ""StringUtils.stripToNull(" \b \t \n \f \r ") = "\b"StringUtils.stripToNull(" \n\tss \b") = "ss \b"StringUtils.stripToNull(" d d dd ") = "d d dd"StringUtils.stripToNull("dd ") = "dd"StringUtils.stripToNull(" dd ") = "dd" public static String strip(String str, String stripChars) 去掉str两端的在stripChars中的字符。如果str为null或等于””，则返回它本身； 如果stripChars为null或””，则返回strip(String str)。 public static String stripStart(String str, String stripChars) 和11相似，去掉str前端的在stripChars中的字符。 public static String stripEnd(String str, String stripChars) 和11相似，去掉str末端的在stripChars中的字符。 public static String[] stripAll(String[] strs) 对字符串数组中的每个字符串进行strip(String str)，然后返回。如果strs为null或strs长度为0，则返回strs本身 public static String[] stripAll(String[] strs, String stripChars) 对字符串数组中的每个字符串进行strip(String str, String stripChars)，然后返回。如果strs为null或strs长度为0，则返回strs本身 public static boolean equals(String str1, String str2) 比较两个字符串是否相等，如果两个均为空则也认为相等。 public static boolean equalsIgnoreCase(String str1, String str2) 比较两个字符串是否相等，不区分大小写，如果两个均为空则也认为相等。 public static int indexOf(String str, char searchChar) 返回字符searchChar在字符串str中第一次出现的位置。如果searchChar没有在str中出现则返回-1， 如果str为null或””，则也返回-1 public static int indexOf(String str, char searchChar, int startPos) 返回字符searchChar从startPos开始在字符串str中第一次出现的位置。如果从startPos开始searchChar没有在str中出现则返回-1， 如果str为null或””，则也返回-1 public static int indexOf(String str, String searchStr) 返回字符串searchStr在字符串str中第一次出现的位置。如果str为null或searchStr为null则返回-1， 如果searchStr为””,且str为不为null，则返回0， 如果searchStr不在str中，则返回-1 public static int ordinalIndexOf(String str, String searchStr, int ordinal) 返回字符串searchStr在字符串str中第ordinal次出现的位置。如果str=null或searchStr=null或ordinal&lt;=0则返回-1 举例(*代表任意字符串)： 1234567891011121314151617181920212223StringUtils.ordinalIndexOf(null, *, *) = -1StringUtils.ordinalIndexOf(*, null, *) = -1StringUtils.ordinalIndexOf("", "", *) = 0StringUtils.ordinalIndexOf("aabaabaa", "a", 1) = 0StringUtils.ordinalIndexOf("aabaabaa", "a", 2) = 1StringUtils.ordinalIndexOf("aabaabaa", "b", 1) = 2StringUtils.ordinalIndexOf("aabaabaa", "b", 2) = 5StringUtils.ordinalIndexOf("aabaabaa", "ab", 1) = 1StringUtils.ordinalIndexOf("aabaabaa", "ab", 2) = 4StringUtils.ordinalIndexOf("aabaabaa", "bc", 1) = -1StringUtils.ordinalIndexOf("aabaabaa", "", 1) = 0StringUtils.ordinalIndexOf("aabaabaa", "", 2) = 0 public static int indexOf(String str, String searchStr, int startPos) 返回字符串searchStr从startPos开始在字符串str中第一次出现的位置。举例(*代表任意字符串)： 123456789101112131415161718192021StringUtils.indexOf(null, *, *) = -1StringUtils.indexOf(*, null, *) = -1StringUtils.indexOf("", "", 0) = 0StringUtils.indexOf("aabaabaa", "a", 0) = 0StringUtils.indexOf("aabaabaa", "b", 0) = 2StringUtils.indexOf("aabaabaa", "ab", 0) = 1StringUtils.indexOf("aabaabaa", "b", 3) = 5StringUtils.indexOf("aabaabaa", "b", 9) = -1StringUtils.indexOf("aabaabaa", "b", -1) = 2StringUtils.indexOf("aabaabaa", "", 2) = 2StringUtils.indexOf("abc", "", 9) = 3 public static int lastIndexOf(String str, char searchChar) 基本原理同18。 public static int lastIndexOf(String str, char searchChar, int startPos) 基本原理同19。 public static int lastIndexOf(String str, String searchStr) 基本原理同20。 public static int lastIndexOf(String str, String searchStr, int startPos) 基本原理同22。 public static boolean contains(String str, char searchChar) 判断字符串str中是否包含字符searchChar。如果str为null或””，返回false； 如果searchChar不在str中，返回false。 public static boolean contains(String str, String searchStr) 判断字符串str是否包含字符串searchStr。如果str为null或searchStr为null，返回false； 如果str为””，并且searchStr为””，返回true 举例： 1234567StringUtils.contains("", "") = trueStringUtils.contains("dfg", "") = trueStringUtils.contains("dfg", "d") = trueStringUtils.contains("dfg", "gz") = false public static boolean containsIgnoreCase(String str, String searchStr) 判断字符串str是否包含字符串searchStr，不区分大小写。和28类似。 public static int indexOfAny(String str, char[] searchChars) 找出字符数组searchChars中的字符第一次出现在字符串str中的位置。如果字符数组中的字符都不在字符串中，则返回-1 如果字符串为null或””，则返回-1 举例(*表示任意)： 12345678910111213StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny("", *) = -1StringUtils.indexOfAny(*, []) = -1StringUtils.indexOfAny("asdf", ['a','f',' ']) = 0StringUtils.indexOfAny("bs df", ['a','f',' ']) = 2StringUtils.indexOfAny("bsdf", ['a','f',' ']) = 3StringUtils.indexOfAny("bbeegg", ['a','f',' ']) = -1 public static int indexOfAny(String str, String searchChars) 找出字符串searchChars中的字符第一次出现在字符串str中的位置。如果字符串searchChars中的字符都不在字符串str中，则返回-1 如果searchChars或str为null或为””，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny("", *) = -1StringUtils.indexOfAny(*, null) = -1StringUtils.indexOfAny(*, "") = -1StringUtils.indexOfAny("asdf", "af ") = 0StringUtils.indexOfAny("bs df", "af ") = 2StringUtils.indexOfAny("bsdf", "af ") = 3StringUtils.indexOfAny("bbeegg", "af ") = -1 public static int indexOfAnyBut(String str, char[] searchChars) 找出字符串str中不在字符数组searchChars中的第一个字符的位置。如果字符串中的所有字符都在字符数组中，则返回-1 如果字符串为null或””，则返回-1 举例(*表示任意)： 12345678910111213StringUtils.indexOfAnyBut(null, *) = -1StringUtils.indexOfAnyBut("", *) = -1StringUtils.indexOfAnyBut(*, []) = -1StringUtils.indexOfAnyBut("asdf", ['a','f',' ']) = 1StringUtils.indexOfAnyBut("bs df", ['a','f',' ']) = 0StringUtils.indexOfAnyBut(" aaf", ['a','f',' ']) = -1StringUtils.indexOfAnyBut("bbeegg", ['a','f',' ']) = 0 public static int indexOfAnyBut(String str, String searchChars) 找出字符串str中不在字符串searchChars中的第一个字符的位置。如果字符串str中的所有字符都在字符串searchChars中，则返回-1 如果字符串str或searchChars为null或””，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAnyBut(null, *) = -1StringUtils.indexOfAnyBut("", *) = -1StringUtils.indexOfAnyBut(*, null) = -1StringUtils.indexOfAnyBut(*, "") = -1StringUtils.indexOfAnyBut("asdf", "af ") = 1StringUtils.indexOfAnyBut("bs df", "af ") = 0StringUtils.indexOfAnyBut(" aaf", "af ") = -1StringUtils.indexOfAnyBut("bbeegg", "af ") = 0 public static boolean containsOnly(String str, char[] valid) 判断是否字符串str仅包含字符数组valid中的字符，即字符串中的字符是否都在字符数组中。如果str为null，则返回false；如果str为””，则返回true 举例(*表示任意)： 12345678910111213StringUtils.containsOnly(null, *)) = falseStringUtils.containsOnly("", *)) = trueStringUtils.containsOnly("afaf", ['a','f',' ']))= trueStringUtils.containsOnly("af a", ['a','f',' ']))= trueStringUtils.containsOnly("a", ['a','f',' '])) = trueStringUtils.containsOnly("afg", ['a','f',' '])) = falseStringUtils.containsOnly("bbeegg", [])) = false public static boolean containsOnly(String str, String validChars) 判断是否字符串str仅包含字符串validChars中的字符，即字符串str中的字符是否都在字符串validChars中。 和34类似，举例(*表示任意)： 123456789101112131415StringUtils.containsOnly(null, *) = falseStringUtils.containsOnly(*, null) = falseStringUtils.containsOnly("", "") = trueStringUtils.containsOnly("", "a") = trueStringUtils.containsOnly("afaf", "af ") = trueStringUtils.containsOnly("af a", "af ") = trueStringUtils.containsOnly("afg", "af ") = falseStringUtils.containsOnly("afg", "") = false public static boolean containsNone(String str, char[] invalidChars) 判断是否字符串str不包含字符数组invalidChars中的字符，如果含有则返回false。举例(*表示任意)： 123456789101112131415StringUtils.containsNone(null, *) = trueStringUtils.containsNone(*, []) = trueStringUtils.containsNone("", *) = trueStringUtils.containsNone("ab", []) = trueStringUtils.containsNone("b", ['a','f',' ']) = trueStringUtils.containsNone("bcd", ['a','f',' ']) = trueStringUtils.containsNone("abc", ['a','f',' ']) = falseStringUtils.containsNone(" ", ['a','f',' ']) = false public static boolean containsNone(String str, String invalidChars) 判断是否字符串str不包含字符串invalidChars中的字符，如果含有则返回false。举例(*表示任意)： 123456789101112131415StringUtils.containsNone(null, *) = trueStringUtils.containsNone(*, null) = trueStringUtils.containsNone("", *) = trueStringUtils.containsNone("ab", "") = trueStringUtils.containsNone("b", "af ") = trueStringUtils.containsNone("bcd", "af ") = trueStringUtils.containsNone("abc", "af ") = falseStringUtils.containsNone(" ", "af ") = false public static int indexOfAny(String str, String[] searchStrs) 找出字符串数组searchStrs中的字符串第一次出现在字符串str中的位置。如果数组中没有字符串在str中，则返回-1 如果数组为null或长度为0，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny(*, null) = -1StringUtils.indexOfAny(*, []) = -1StringUtils.indexOfAny("", [""]) = 0StringUtils.indexOfAny("bbeegg", ["as","df","yy"]) = -1StringUtils.indexOfAny("asdfgh", ["as","df","yy"]) = 0StringUtils.indexOfAny("dfasgh", ["as","df","yy"]) = 0StringUtils.indexOfAny("ghasdf", ["as","df","yy"]) = 2 public static int lastIndexOfAny(String str, String[] searchStrs) 找出字符串数组searchStrs中的字符串最后一次出现在字符串str中的位置。如果数组中没有字符串在str中，则返回-1 如果数组为null或长度为0，则返回-1 举例(*表示任意)： 1234567891011121314151617StringUtils.lastIndexOfAny(null, *) = -1StringUtils.lastIndexOfAny(*, null) = -1StringUtils.lastIndexOfAny(*, []) = -1StringUtils.lastIndexOfAny("", [""]) = 0StringUtils.lastIndexOfAny("bbeegg", ["as","df","yy"]) = -1StringUtils.lastIndexOfAny("asdfgh", ["as","df","yy"]) = 2StringUtils.lastIndexOfAny("dfghjk", ["as","df","yy"]) = 0StringUtils.lastIndexOfAny("ghasdf", ["as","df","yy"]) = 4StringUtils.lastIndexOfAny("ghasdf", ["as","df",""]) = 6 public static String substring(String str, int start) 得到字符串str的子串。如果start小于0，位置是从后往前数的第|start|个 如果str为null或””，则返回它本身 举例(*表示任意)： 1234567891011121314151617StringUtils.substring(null, *) = nullStringUtils.substring("", *) = ""StringUtils.substring("asdf", 0)) = "asdf"StringUtils.substring("asdf", 1)) = "sdf"StringUtils.substring("asdf", 3)) = "f"StringUtils.substring("asdf",) = ""StringUtils.substring("asdf", -1)) = "f"StringUtils.substring("asdf", -3)) = "sdf"StringUtils.substring("asdf", -8)) = "asdf" public static String substring(String str, int start, int end) 得到字符串str的子串。如果start小于0，位置是从后往前数的第|start|个， 如果end小于0，位置是从后往前数的第|end|个， 如果str为null或””，则返回它本身 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substring(null, *, *) = nullStringUtils.substring("", * , *) = "";StringUtils.substring("asdf", 0, 2) = "as"StringUtils.substring("asdf", 0, -1) = "asd"StringUtils.substring("asdf", 2, -1) = "d"StringUtils.substring("asdf", 2, -2) = ""StringUtils.substring("asdf", 3, 2) = ""StringUtils.substring("asdf", 1, = "sdf"StringUtils.substring("asdf", -1, -3) = ""StringUtils.substring("asdf", -3, -1) = "sd"StringUtils.substring("asdf", -8, 5) = "asdf" public static String left(String str, int len) 得到字符串str从左边数len长度的子串。如果str为null或为””，则返回它本身 如果len小于0，则返回”” 举例(*表示任意)： 1234567891011StringUtils.left(null, *) = nullStringUtils.left(*, -ve) = ""StringUtils.left("", *) = ""StringUtils.left("asdf", 0) = ""StringUtils.left("asdf", 2) = "as"StringUtils.left("asdf", = "asdf" public static String right(String str, int len) 得到字符串str从右边数len长度的子串。如果str为null或为””，则返回它本身 如果len小于0，则返回”” 举例(*表示任意)： 1234567891011StringUtils.right(null, *) = nullStringUtils.right(*, -ve) = ""StringUtils.right("", *) = ""StringUtils.right("asdf", 0) = ""StringUtils.right("asdf", 2) = "df"StringUtils.right("asdf", = "asdf" public static String mid(String str, int pos, int len) 得到字符串str从pos开始len长度的子串。如果str为null或为””，则返回它本身 如果len小于0或pos大于srt的长度，则返回”” 如果pos小于0，则pos设为0 举例(*表示任意)： 123456789101112131415StringUtils.mid(null, *, *) = nullStringUtils.mid("", *, *) = ""StringUtils.mid(*, *, -ve) = ""StringUtils.mid("asdf", 0, 4)) = "asdf"StringUtils.mid("asdf", 2, 2)) = "df"StringUtils.mid("asdf", 2, 5)) = "df"StringUtils.mid("asdf", -2, 1)) = "a"StringUtils.mid("asdf", 0, -1)) = "" public static String substringBefore(String str, String separator) 得到字符串str的在字符串separator出现前的字串，且separator不包括在内。如果str为null或为””，则返回它本身 如果separator为null，则返回str本身 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringBefore(null, *) = nullStringUtils.substringBefore("", *) = ""StringUtils.substringBefore("asdfg", null)) = "asdfg"StringUtils.substringBefore("asdfg", "a")) = ""StringUtils.substringBefore("asdfg", "sd")) = "a"StringUtils.substringBefore("asdfsag", "sa")) = "asdf"StringUtils.substringBefore("asdfg", "h")) = "asdfg"StringUtils.substringBefore("asdfg", "")) = ""StringUtils.substringBefore("asdfg", "dfgh")) = "asdfg"StringUtils.substringBefore("asdfg", "dfg")) = "as"StringUtils.substringBefore("abbbabbba", "bb")) = "a" public static String substringAfter(String str, String separator) 得到字符串str的在字符串separator出现后的字串，且separator不包括在内。如果str为null或为””，则返回它本身 如果separator为null，则返回”” 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringAfter(null, *) = nullStringUtils.substringAfter("", *) = ""StringUtils.substringAfter(*, null) = ""StringUtils.substringAfter("asdfg", "a")) = "sdfg"StringUtils.substringAfter("asdfg", "sd")) = "fg"StringUtils.substringAfter("asdfsag", "sa")) = "g"StringUtils.substringAfter("asdfg", "h")) = ""StringUtils.substringAfter("asdfg", "")) = "asdfg"StringUtils.substringAfter("asdfg", "dfgh")) = ""StringUtils.substringAfter("asdfg", "dfg")) = ""StringUtils.substringAfter("abbbabbba", "bb"))= "babbba" public static String substringBeforeLast(String str, String separator) 和45类似，得到字符串str的在字符串separator最后一次出现前的字串。这里不再举例。 public static String substringAfterLast(String str, String separator) 和46类似，得到字符串str的在字符串separator最后一次出现后的字串。这里不再举例。 public static String substringBetween(String str, String tag) 得到str中的在两个字符串tag中间的字符串，即str中的tag所夹的串。如果str为null或tag为null，返回null 举例(*表示任意)： 1234567891011121314151617StringUtils.substringBetween(null, *) = nullStringUtils.substringBetween(*, null) = nullStringUtils.substringBetween("", "") = ""StringUtils.substringBetween("", "a")) = nullStringUtils.substringBetween("asdfdf", "df")) = ""StringUtils.substringBetween("asdfas", "as")) = "df"StringUtils.substringBetween("dfasdfasdfas", "df")) = "as"StringUtils.substringBetween("dfasdfasdfas", "as")) = "df"StringUtils.substringBetween("dfasdfasgdf", "df")) = "as" public static String substringBetween(String str, String open, String close) 得到str中的在两个字符串open和close中间的字符串，即open和close所夹的串。如果str为null或open为null或close为null，返回null 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringBetween(null, *, *) = nullStringUtils.substringBetween(*, null, *) = nullStringUtils.substringBetween(*, *, null) = nullStringUtils.substringBetween("", "", "") = ""StringUtils.substringBetween("", "", "]") = nullStringUtils.substringBetween("", "[", "]") = nullStringUtils.substringBetween("[]", "[","]")) = ""StringUtils.substringBetween("a[sd]f", "[","]")) = "sd"StringUtils.substringBetween("a[sd]f[gh]", "[","]")) = "sd"StringUtils.substringBetween("a[sd]f", "]","[")) = nullStringUtils.substringBetween("a[sd]f", "","")) = "" public static String[] substringsBetween(String str, String open, String close) 得到str中的在两个字符串open和close中间的字符串，即open和close所夹的串，把所有符合的结果放在数组中返回。 和50类似，但是返回了所有的结果(50只返回了第一个匹配的结果)。 这里不再举例。 public static String[] split(String str) 把字符串拆分成一个字符串数组，用空白符(whitespace)作为分隔符。Whitespace是这样定义的 {@link Character#isWhitespace(char)} 如果字符串为null，返回null 如果字符串为””，返回空数组{} 举例(*表示任意)： 12345678910111213141516171819StringUtils.split(null) = nullStringUtils.split("") = &#123;&#125;StringUtils.split("as df yy")) = &#123;"as","df","yy"&#125;StringUtils.split(" as df yy ")) = &#123;"as","df","yy"&#125;StringUtils.split("as\ndf\ryy")) = &#123;"as","df","yy"&#125;StringUtils.split("as\tdf\fyy")) = &#123;"as","df","yy"&#125;StringUtils.split("as df \fyy")) = &#123;"as","df","yy"&#125;StringUtils.split("as\t \r df \f \n yy")) = &#123;"as","df","yy"&#125;StringUtils.split("as")) = &#123;"as"&#125;StringUtils.split(" as ")) = &#123;"as"&#125; public static String[] split(String str, char separatorChar) 把字符串拆分成一个字符串数组，用指定的字符separatorChar作为分隔符。如果字符串为null，返回null 如果字符串为””，返回空数组{} 举例(*表示任意)： 1234567891011121314151617StringUtils.split(null, *) = nullStringUtils.split("", *) = &#123;&#125;StringUtils.split("as df yy",' ')) = &#123;"as","df","yy"&#125; StringUtils.split(" as df yy ",' ')) = &#123;"as","df","yy"&#125; StringUtils.split("asodfoyy",'o')) = &#123;"as","df","yy"&#125; StringUtils.split("as.df.yy",'.')) = &#123;"as","df","yy"&#125; StringUtils.split("as\ndf\nyy",'\n'))= &#123;"as","df","yy"&#125; StringUtils.split("as",' ')) = &#123;"as"&#125; StringUtils.split(" as ",' ')) = &#123;"as"&#125; public static String[] split(String str, String separatorChars) 把字符串拆分成一个字符串数组，用指定的字符串separatorChars作为分隔符。如果字符串str为null，返回null 如果字符串str为””，返回空数组{} 如果separatorChars为null，则默认为空白符 和53类似。 举例(*表示任意)： 12345StringUtils.split("as \rdf \t yy",null)) = &#123;"as","df","yy"&#125;StringUtils.split("as\ndf\fyy",null)) = &#123;"as","df","yy"&#125;StringUtils.split("as","")) = &#123;"as"&#125; public static String[] split(String str, String separatorChars, int max) 把字符串拆分成一个字符串数组，用指定的字符串separatorChars作为分隔符，数组的最大长度为max。 如果字符串str为null，返回null 如果字符串str为””，返回空数组{} 如果separatorChars为null，则默认为空白符 如果max小于等于0，认为是没有限制 举例(*表示任意)： 12345678910111213141516171819StringUtils.split(null, *, *) = nullStringUtils.split("", *, *) = &#123;&#125;StringUtils.split("as df yy",null,0)) = &#123;"as","df","yy"&#125;StringUtils.split("as df yy"," ",0)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",-1)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",4)) = &#123;"as","df","yy"&#125;StringUtils.split("as-!-df-!-yy","-!-",0)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",2)) = &#123;"as","df.yy"&#125;StringUtils.split("as","",0)) = &#123;"as"&#125;StringUtils.split("as","",2)) = &#123;"as"&#125; public static String[] splitByWholeSeparator(String str, String separator) 个人认为和54功能一样。区别有待发掘。 public static String[] splitByWholeSeparator( String str, String separator, int max ) 个人认为和55功能一样。区别有待发掘。 public static String[] splitPreserveAllTokens(String str) 把字符串str拆分成一个数组，用空白符(whitespace)作为分隔符，保留所有的标识，包括相邻分隔符产生的空的标识。它可作为StringTokenizer的一个替代。 Whitespace是这样定义的{@link Character#isWhitespace(char)}。 举例(*表示任意)： 12345678910111213StringUtils.splitPreserveAllTokens(null)) = nullStringUtils.splitPreserveAllTokens("")) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\ndf\rgh\fjk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\tdf gh jk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as df gh")) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(" as df ")) = &#123;"","as","","","df","",""&#125; public static String[] splitPreserveAllTokens(String str, char separatorChar) 和58类似，只是分隔符为字符separatorChar。举例(*表示任意)： 12345678910111213StringUtils.splitPreserveAllTokens(null, *) = nullStringUtils.splitPreserveAllTokens("", *) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk",' ')) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as.df.gh.jk",'.')) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as..df.gh",'.')) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(",as,,,df,,",',')) = &#123;"","as","","","df","",""&#125;StringUtils.splitPreserveAllTokens("as.df.gh",',')) = &#123;"as.df.gh"&#125; public static String[] splitPreserveAllTokens(String str, String separatorChars) 和59类似，只是分隔符为字符串separatorChars。举例(*表示任意)： 12345678910111213141516171819StringUtils.splitPreserveAllTokens(null, *) = nullStringUtils.splitPreserveAllTokens("", *) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk",null)) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\ndf\rgh\fjk",null))= &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as df gh jk"," ")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as.df.gh.jk",".")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as..df.gh",".")) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(",as,,,df,,",",")) = &#123;"","as","","","df","",""&#125;StringUtils.splitPreserveAllTokens("as.df.gh",",")) = &#123;"as.df.gh"&#125;StringUtils.splitPreserveAllTokens("as.df.gh","")) = &#123;"as.df.gh"&#125; public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) 和上面几个类似，只是指定了数组的最大长度。如果max为0或负数，则认为没有限制。 这里不再举例。 public static String join(Object[] array) 把数组中的元素连接成一个字符串返回。举例(*表示任意)： 123456789StringUtils.join(null) = nullStringUtils.join(&#123;&#125;) = ""StringUtils.join(&#123;"as","df","gh","jk"&#125;)) = "asdfghjk"StringUtils.join(&#123;"as","","df","gh"&#125;)) = "asdfgh"StringUtils.join(&#123;"","as","","","df","",""&#125;)) = "asdf" public static String join(Object[] array, char separator) 把数组中的元素连接成一个字符串返回，把分隔符separator也加上。举例(*表示任意)： 12345678910111213141516171819StringUtils.join(null, *) = nullStringUtils.join(&#123;&#125;, *) = ""StringUtils.join(&#123;null&#125;, *) = ""StringUtils.join(&#123;"as","df","gh","jk"&#125;,' ')) = "as df gh jk"StringUtils.join(&#123;"as","df","gh","jk"&#125;,'.')) = "as.df.gh.jk"StringUtils.join(&#123;"as","","df","gh"&#125;,'.')) = "as..df.gh"StringUtils.join(&#123;"","as","","","df","",""&#125;,','))= ",as,,,df,,"StringUtils.join(&#123;"","as","","","df","",""&#125;,' '))= " as df "StringUtils.join(&#123;"as.df.gh"&#125;,'.')) = "as.df.gh"StringUtils.join(&#123;"as.df.gh"&#125;,' ')) = "as.df.gh" public static String join(Object[] array, char separator, int startIndex, int endIndex) 把数组中的元素连接成一个字符串返回，把分隔符separator也加上。连接的开始位置为startIndex，结束位置为endIndex。 这里不再举例。 public static String join(Object[] array, String separator) 与63类似，这里不再举例。 public static String join(Object[] array, String separator, int startIndex, int endIndex) 与64类似，这里不再举例。 public static String deleteWhitespace(String str) 删除字符串中的所有空白符(whitespace)，空白符是这样定义的{@link Character#isWhitespace(char)}。举例(*表示任意)： 12345678910111213StringUtils.deleteWhitespace(null) = nullStringUtils.deleteWhitespace("") = ""StringUtils.deleteWhitespace("asd")) = "asd",StringUtils.deleteWhitespace("as df")) = "asdf"StringUtils.deleteWhitespace("as\n\r\f\tdf")) = "asdf"StringUtils.deleteWhitespace("as\bdf")) = "as\bdf"StringUtils.deleteWhitespace(" as df ")) = "asdf" public static String removeStart(String str, String remove) 如果字符串str是以字符串remove开始，则去掉这个开始，然后返回，否则返回原来的串。举例(*表示任意)： 12345678910111213StringUtils.removeStart(null, *) = nullStringUtils.removeStart("", *) = ""StringUtils.removeStart(*, null) = *StringUtils.removeStart("asdf","")) = "asdf"StringUtils.removeStart("asdf","as")) = "df"StringUtils.removeStart("asdf","df")) = "asdf"StringUtils.removeStart("asdf","gh")) = "asdf" public static String removeEnd(String str, String remove) 如果字符串str是以字符串remove结尾，则去掉这个结尾，然后返回，否则返回原来的串。这里不再举例。 public static String remove(String str, String remove) 去掉字符串str中所有包含remove的部分，然后返回。这里不再举例。 public static String remove(String str, char remove) 去掉字符串str中所有包含remove的部分，然后返回。 这里不再举例。 public static String replaceOnce(String text, String repl, String with) 在字符串text中用with代替repl，仅一次。这里不再举例。 public static String replace(String text, String repl, String with) 在字符串text中用with代替repl，替换所有。这里不再举例。 public static String replace(String text, String repl, String with, int max) 在字符串text中用with代替repl，max为最大替换次数。如果max小于0，则替换所有。 这里不再举例。 public static String replaceChars(String str, char searchChar, char replaceChar) 在字符串str中用字符replaceChar代替所有字符searchChar，如果字符串为null或””，则返回它本身。 这里不再举例。 public static String replaceChars(String str, String searchChars, String replaceChars) 用replaceChars代替str中的searchChars。replaceChars的长度应该和searchChars的长度相等， 如果replaceChars的长度大于searchChars的长度，超过长度的字符将被忽略， 如果replaceChars的长度小于searchChars的长度，超过长度的字符将被删除。 举例(*表示任意)： 1234567891011121314151617181920212223StringUtils.replaceChars(null, *, *) = nullStringUtils.replaceChars("", *, *) = ""StringUtils.replaceChars("asdf", null, *) = "asdf"StringUtils.replaceChars("asdf", "", *) = "asdf"StringUtils.replaceChars("asdf","s",null)) = "adf"StringUtils.replaceChars("asdf","s","")) = "adf"StringUtils.replaceChars("asdsfsg","s","y")) = "aydyfyg"StringUtils.replaceChars("asdf","sd","yy")) = "ayyf"StringUtils.replaceChars("asdf","sd","yyy")) = "ayyf"StringUtils.replaceChars("asssdf","s","yyy")) = "ayyydf"StringUtils.replaceChars("asdf","sd","y")) = "ayf"StringUtils.replaceChars("assssddddf","sd","y"))= "ayyyyf" public static String overlay(String str, String overlay, int start, int end) 用字符串overlay覆盖字符串str从start到end之间的串。如果str为null，则返回null 如果start或end小于0，则设为0 如果start大于end，则两者交换 如果start或end大于str的长度，则认为等于str的长度 举例(*表示任意)： 123456789101112131415161718192021StringUtils.overlay(null, *, *, *) = nullStringUtils.overlay("","as",0,0)) = "as"StringUtils.overlay("asdfgh","qq",2,5)) = "asqqh"StringUtils.overlay("asdfgh","qq",5,2)) = "asqqh"StringUtils.overlay("asdfgh","qq",-1,3)) = "qqfgh"StringUtils.overlay("asdfgh","qq",-1,-3)) = "qqasdfgh"StringUtils.overlay("asdfgh","qq",7,10)) = "asdfghqq"StringUtils.overlay("asdfgh","qq",0,8)) = "qq"StringUtils.overlay("asdfgh","qq",2,8)) = "asqq"StringUtils.overlay("asdfgh",null,2,5)) = "ash"StringUtils.overlay("asdfgh","",2,5)) = "ash" public static String chop(String str) 去掉字符串str的最后一个字符。如果字符串以”\r\n”结尾，则去掉它们。 这里不再举例。 public static String repeat(String str, int repeat) 重复字符串repeat次，组合成一个新串返回。如果字符串str为null或””，则返回它本身 如果repeat小于0，则返回”” 举例(*表示任意)： 123456789StringUtils.repeat(null, *) = nullStringUtils.repeat("", *) = ""StringUtils.repeat("a", 3) = "aaa"StringUtils.repeat("ab", 2) = "abab"StringUtils.repeat("a", -2) = "" public static String rightPad(String str, int size) 如果str为null，则返回null如果字符串长度小于size，则在右边补空格使其长度等于size，然后返回 如果字符串长度大于等于size，则返回它本身 这里不再举例。 public static String rightPad(String str, int size, char padChar) 和80类似，只是补的字符为padChar。这里不再举例。 public static String rightPad(String str, int size, String padStr) 和80类似，只是补的是字符串padStr。举例(*表示任意)： 123456789101112131415161718192021StringUtils.rightPad(null, *, *) = nullStringUtils.rightPad("",0,"")) = ""StringUtils.rightPad("",3,"")) = " "StringUtils.rightPad("",3,"a")) = "aaa"StringUtils.rightPad("",2,"as")) = "as"StringUtils.rightPad("as",-1,"df")) = "as"StringUtils.rightPad("as",0,"df")) = "as"StringUtils.rightPad("as",3,"df")) = "asd"StringUtils.rightPad("as",8,"df")) = "asdfdfdf"StringUtils.rightPad("as",5,null)) = "as "StringUtils.rightPad("as",5,"")) = "as " public static String leftPad(String str, int size) 和80类似，只是补左边。这里不再举例。 public static String leftPad(String str, int size, char padChar) 和81类似。这里不再举例。 public static String leftPad(String str, int size, String padStr) 和82类似。这里不再举例。 public static String center(String str, int size) 产生一个字符串返回，该字符串长度等于size，str位于新串的中心，其他位置补空格。如果str为null，则返回null 如果size小于str的长度，则返回str本身 举例(*表示任意)： 123456789101112131415StringUtils.center(null, *) = nullStringUtils.center("",1)) = " "StringUtils.center("",2)) = " "StringUtils.center("as",-1)) = "as"StringUtils.center("as",2)) = "as"StringUtils.center("as",3)) = "as "StringUtils.center("as",4)) = " as "StringUtils.center("as",10)) = " as " public static String center(String str, int size, char padChar) 和86类似，只是其他位置补padChar。这里不再举例。 public static String center(String str, int size, String padStr) 和86类似，只是其他位置补padStr。这里不再举例。 public static String swapCase(String str) 把字符串中的字符大写转换为小写，小写转换为大写。举例： 1234567StringUtils.swapCase(null) = nullStringUtils.swapCase("") = ""StringUtils.swapCase("Hello Boys")) = "hELLO bOYS"StringUtils.swapCase("I am 11")) = "i AM 11" public static int countMatches(String str, String sub) 计算字符串sub在字符串str中出现的次数。如果str为null或””，则返回0 举例(*表示任意)： 12345678910111213StringUtils.countMatches(null, *) = 0StringUtils.countMatches("", *) = 0StringUtils.countMatches("asdf","as")) = 1StringUtils.countMatches("asdfas","as")) = 2StringUtils.countMatches("dfgh","as")) = 0StringUtils.countMatches("as","")) = 0StringUtils.countMatches("as",null)) = 0 DateUtilDateUtil类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652package com.util;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;public class DateUtil &#123; /** * 获取SimpleDateFormat * @param parttern 日期格式 * @return SimpleDateFormat对象 * @throws RuntimeException 异常：非法日期格式 */ private static SimpleDateFormat getDateFormat(String parttern) throws RuntimeException &#123; return new SimpleDateFormat(parttern); &#125; /** * 获取日期中的某数值。如获取月份 * @param date 日期 * @param dateType 日期格式 * @return 数值 */ private static int getInteger(Date date, int dateType) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); return calendar.get(dateType); &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期字符串 * @param dateType 类型 * @param amount 数值 * @return 计算后日期字符串 */ private static String addInteger(String date, int dateType, int amount) &#123; String dateString = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); myDate = addInteger(myDate, dateType, amount); dateString = DateToString(myDate, dateStyle); &#125; return dateString; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期 * @param dateType 类型 * @param amount 数值 * @return 计算后日期 */ private static Date addInteger(Date date, int dateType, int amount) &#123; Date myDate = null; if (date != null) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(dateType, amount); myDate = calendar.getTime(); &#125; return myDate; &#125; /** * 获取精确的日期 * @param timestamps 时间long集合 * @return 日期 */ private static Date getAccurateDate(List&lt;Long&gt; timestamps) &#123; Date date = null; long timestamp = 0; Map&lt;Long, long[]&gt; map = new HashMap&lt;Long, long[]&gt;(); List&lt;Long&gt; absoluteValues = new ArrayList&lt;Long&gt;(); if (timestamps != null &amp;&amp; timestamps.size() &gt; 0) &#123; if (timestamps.size() &gt; 1) &#123; for (int i = 0; i &lt; timestamps.size(); i++) &#123; for (int j = i + 1; j &lt; timestamps.size(); j++) &#123; long absoluteValue = Math.abs(timestamps.get(i) - timestamps.get(j)); absoluteValues.add(absoluteValue); long[] timestampTmp = &#123; timestamps.get(i), timestamps.get(j) &#125;; map.put(absoluteValue, timestampTmp); &#125; &#125; // 有可能有相等的情况。如2012-11和2012-11-01。时间戳是相等的 long minAbsoluteValue = -1; if (!absoluteValues.isEmpty()) &#123; // 如果timestamps的size为2，这是差值只有一个，因此要给默认值 minAbsoluteValue = absoluteValues.get(0); &#125; for (int i = 0; i &lt; absoluteValues.size(); i++) &#123; for (int j = i + 1; j &lt; absoluteValues.size(); j++) &#123; if (absoluteValues.get(i) &gt; absoluteValues.get(j)) &#123; minAbsoluteValue = absoluteValues.get(j); &#125; else &#123; minAbsoluteValue = absoluteValues.get(i); &#125; &#125; &#125; if (minAbsoluteValue != -1) &#123; long[] timestampsLastTmp = map.get(minAbsoluteValue); if (absoluteValues.size() &gt; 1) &#123; timestamp = Math.max(timestampsLastTmp[0], timestampsLastTmp[1]); &#125; else if (absoluteValues.size() == 1) &#123; // 当timestamps的size为2，需要与当前时间作为参照 long dateOne = timestampsLastTmp[0]; long dateTwo = timestampsLastTmp[1]; if ((Math.abs(dateOne - dateTwo)) &lt; 100000000000L) &#123; timestamp = Math.max(timestampsLastTmp[0], timestampsLastTmp[1]); &#125; else &#123; long now = new Date().getTime(); if (Math.abs(dateOne - now) &lt;= Math.abs(dateTwo - now)) &#123; timestamp = dateOne; &#125; else &#123; timestamp = dateTwo; &#125; &#125; &#125; &#125; &#125; else &#123; timestamp = timestamps.get(0); &#125; &#125; if (timestamp != 0) &#123; date = new Date(timestamp); &#125; return date; &#125; /** * 判断字符串是否为日期字符串 * @param date 日期字符串 * @return true or false */ public static boolean isDate(String date) &#123; boolean isDate = false; if (date != null) &#123; if (StringToDate(date) != null) &#123; isDate = true; &#125; &#125; return isDate; &#125; /** * 获取日期字符串的日期风格。失敗返回null。 * @param date 日期字符串 * @return 日期风格 */ public static DateStyle getDateStyle(String date) &#123; DateStyle dateStyle = null; Map&lt;Long, DateStyle&gt; map = new HashMap&lt;Long, DateStyle&gt;(); List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; Date dateTmp = StringToDate(date, style.getValue()); if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); map.put(dateTmp.getTime(), style); &#125; &#125; dateStyle = map.get(getAccurateDate(timestamps).getTime()); return dateStyle; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static Date StringToDate(String date) &#123; DateStyle dateStyle = null; return StringToDate(date, dateStyle); &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param parttern 日期格式 * @return 日期 */ public static Date StringToDate(String date, String parttern) &#123; Date myDate = null; if (date != null) &#123; try &#123; myDate = getDateFormat(parttern).parse(date); &#125; catch (Exception e) &#123; &#125; &#125; return myDate; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param dateStyle 日期风格 * @return 日期 */ public static Date StringToDate(String date, DateStyle dateStyle) &#123; Date myDate = null; if (dateStyle == null) &#123; List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; Date dateTmp = StringToDate(date, style.getValue()); if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); &#125; &#125; myDate = getAccurateDate(timestamps); &#125; else &#123; myDate = StringToDate(date, dateStyle.getValue()); &#125; return myDate; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param parttern 日期格式 * @return 日期字符串 */ public static String DateToString(Date date, String parttern) &#123; String dateString = null; if (date != null) &#123; try &#123; dateString = getDateFormat(parttern).format(date); &#125; catch (Exception e) &#123; &#125; &#125; return dateString; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param dateStyle 日期风格 * @return 日期字符串 */ public static String DateToString(Date date, DateStyle dateStyle) &#123; String dateString = null; if (dateStyle != null) &#123; dateString = DateToString(date, dateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param parttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String parttern) &#123; return StringToString(date, null, parttern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param dateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle dateStyle) &#123; return StringToString(date, null, dateStyle); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddParttern 旧日期格式 * @param newParttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String olddParttern, String newParttern) &#123; String dateString = null; if (olddParttern == null) &#123; DateStyle style = getDateStyle(date); if (style != null) &#123; Date myDate = StringToDate(date, style.getValue()); dateString = DateToString(myDate, newParttern); &#125; &#125; else &#123; Date myDate = StringToDate(date, olddParttern); dateString = DateToString(myDate, newParttern); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, DateStyle newDateStyle) &#123; String dateString = null; if (olddDteStyle == null) &#123; DateStyle style = getDateStyle(date); dateString = StringToString(date, style.getValue(), newDateStyle.getValue()); &#125; else &#123; dateString = StringToString(date, olddDteStyle.getValue(), newDateStyle.getValue()); &#125; return dateString; &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期字符串 */ public static String addYear(String date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期 */ public static Date addYear(Date date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加月份后的日期字符串 */ public static String addMonth(String date, int yearAmount) &#123; return addInteger(date, Calendar.MONTH, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加月份后的日期 */ public static Date addMonth(Date date, int yearAmount) &#123; return addInteger(date, Calendar.MONTH, yearAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期字符串 */ public static String addDay(String date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期 */ public static Date addDay(Date date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加小时后的日期字符串 */ public static String addHour(String date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加小时后的日期 */ public static Date addHour(Date date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期字符串 */ public static String addMinute(String date, int hourAmount) &#123; return addInteger(date, Calendar.MINUTE, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期 */ public static Date addMinute(Date date, int hourAmount) &#123; return addInteger(date, Calendar.MINUTE, hourAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期字符串 */ public static String addSecond(String date, int hourAmount) &#123; return addInteger(date, Calendar.SECOND, hourAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期 */ public static Date addSecond(Date date, int hourAmount) &#123; return addInteger(date, Calendar.SECOND, hourAmount); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期字符串 * @return 年份 */ public static int getYear(String date) &#123; return getYear(StringToDate(date)); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期 * @return 年份 */ public static int getYear(Date date) &#123; return getInteger(date, Calendar.YEAR); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期字符串 * @return 月份 */ public static int getMonth(String date) &#123; return getMonth(StringToDate(date)); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期 * @return 月份 */ public static int getMonth(Date date) &#123; return getInteger(date, Calendar.MONTH); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期字符串 * @return 天 */ public static int getDay(String date) &#123; return getDay(StringToDate(date)); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期 * @return 天 */ public static int getDay(Date date) &#123; return getInteger(date, Calendar.DATE); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期字符串 * @return 小时 */ public static int getHour(String date) &#123; return getHour(StringToDate(date)); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期 * @return 小时 */ public static int getHour(Date date) &#123; return getInteger(date, Calendar.HOUR_OF_DAY); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期字符串 * @return 分钟 */ public static int getMinute(String date) &#123; return getMinute(StringToDate(date)); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期 * @return 分钟 */ public static int getMinute(Date date) &#123; return getInteger(date, Calendar.MINUTE); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期字符串 * @return 秒钟 */ public static int getSecond(String date) &#123; return getSecond(StringToDate(date)); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期 * @return 秒钟 */ public static int getSecond(Date date) &#123; return getInteger(date, Calendar.SECOND); &#125; /** * 获取日期 。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static String getDate(String date) &#123; return StringToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期 * @return 日期 */ public static String getDate(Date date) &#123; return DateToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期字符串 * @return 时间 */ public static String getTime(String date) &#123; return StringToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期 * @return 时间 */ public static String getTime(Date date) &#123; return DateToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期字符串 * @return 星期 */ public static Week getWeek(String date) &#123; Week week = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); week = getWeek(myDate); &#125; return week; &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期 * @return 星期 */ public static Week getWeek(Date date) &#123; Week week = null; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int weekNumber = calendar.get(Calendar.DAY_OF_WEEK) - 1; switch (weekNumber) &#123; case 0: week = Week.SUNDAY; break; case 1: week = Week.MONDAY; break; case 2: week = Week.TUESDAY; break; case 3: week = Week.WEDNESDAY; break; case 4: week = Week.THURSDAY; break; case 5: week = Week.FRIDAY; break; case 6: week = Week.SATURDAY; break; &#125; return week; &#125; /** * 获取两个日期相差的天数 * @param date 日期字符串 * @param otherDate 另一个日期字符串 * @return 相差天数 */ public static int getIntervalDays(String date, String otherDate) &#123; return getIntervalDays(StringToDate(date), StringToDate(otherDate)); &#125; /** * @param date 日期 * @param otherDate 另一个日期 * @return 相差天数 */ public static int getIntervalDays(Date date, Date otherDate) &#123; date = DateUtil.StringToDate(DateUtil.getDate(date)); long time = Math.abs(date.getTime() - otherDate.getTime()); return (int)time/(24 * 60 * 60 * 1000); &#125;&#125; DateStyle类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.util;public enum DateStyle &#123; MM_DD("MM-dd"), YYYY_MM("yyyy-MM"), YYYY_MM_DD("yyyy-MM-dd"), MM_DD_HH_MM("MM-dd HH:mm"), MM_DD_HH_MM_SS("MM-dd HH:mm:ss"), YYYY_MM_DD_HH_MM("yyyy-MM-dd HH:mm"), YYYY_MM_DD_HH_MM_SS("yyyy-MM-dd HH:mm:ss"), MM_DD_EN("MM/dd"), YYYY_MM_EN("yyyy/MM"), YYYY_MM_DD_EN("yyyy/MM/dd"), MM_DD_HH_MM_EN("MM/dd HH:mm"), MM_DD_HH_MM_SS_EN("MM/dd HH:mm:ss"), YYYY_MM_DD_HH_MM_EN("yyyy/MM/dd HH:mm"), YYYY_MM_DD_HH_MM_SS_EN("yyyy/MM/dd HH:mm:ss"), MM_DD_CN("MM月dd日"), YYYY_MM_CN("yyyy年MM月"), YYYY_MM_DD_CN("yyyy年MM月dd日"), MM_DD_HH_MM_CN("MM月dd日 HH:mm"), MM_DD_HH_MM_SS_CN("MM月dd日 HH:mm:ss"), YYYY_MM_DD_HH_MM_CN("yyyy年MM月dd日 HH:mm"), YYYY_MM_DD_HH_MM_SS_CN("yyyy年MM月dd日 HH:mm:ss"), HH_MM("HH:mm"), HH_MM_SS("HH:mm:ss"); private String value; DateStyle(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; Week类1234567891011121314151617181920212223242526272829303132333435363738394041package com.util;public enum Week &#123; MONDAY("星期一", "Monday", "Mon.", 1), TUESDAY("星期二", "Tuesday", "Tues.", 2), WEDNESDAY("星期三", "Wednesday", "Wed.", 3), THURSDAY("星期四", "Thursday", "Thur.", 4), FRIDAY("星期五", "Friday", "Fri.", 5), SATURDAY("星期六", "Saturday", "Sat.", 6), SUNDAY("星期日", "Sunday", "Sun.", 7); String name_cn; String name_en; String name_enShort; int number; Week(String name_cn, String name_en, String name_enShort, int number) &#123; this.name_cn = name_cn; this.name_en = name_en; this.name_enShort = name_enShort; this.number = number; &#125; public String getChineseName() &#123; return name_cn; &#125; public String getName() &#123; return name_en; &#125; public String getShortName() &#123; return name_enShort; &#125; public int getNumber() &#123; return number; &#125;&#125; DateUtils优化版： 修正当字符串日期风格为MM-dd或yyyy-MM时，若日期太大或太小后，识别日期错误。 修正识别日期算法（getAccurateDate）bug。 修正计算日期天数差（getIntervalDays）bug。 优化DateUtil处理日期的速度。 优化日期风格（DateStyle）识别方式。 DateUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687package com.itkt.mtravel.hotel.util;import java.text.ParsePosition;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;public class DateUtil &#123; private static final ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;(); private static final Object object = new Object(); /** * 获取SimpleDateFormat * @param pattern 日期格式 * @return SimpleDateFormat对象 * @throws RuntimeException 异常：非法日期格式 */ private static SimpleDateFormat getDateFormat(String pattern) throws RuntimeException &#123; SimpleDateFormat dateFormat = threadLocal.get(); if (dateFormat == null) &#123; synchronized (object) &#123; if (dateFormat == null) &#123; dateFormat = new SimpleDateFormat(pattern); dateFormat.setLenient(false); threadLocal.set(dateFormat); &#125; &#125; &#125; dateFormat.applyPattern(pattern); return dateFormat; &#125; /** * 获取日期中的某数值。如获取月份 * @param date 日期 * @param dateType 日期格式 * @return 数值 */ private static int getInteger(Date date, int dateType) &#123; int num = 0; Calendar calendar = Calendar.getInstance(); if (date != null) &#123; calendar.setTime(date); num = calendar.get(dateType); &#125; return num; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期字符串 * @param dateType 类型 * @param amount 数值 * @return 计算后日期字符串 */ private static String addInteger(String date, int dateType, int amount) &#123; String dateString = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); myDate = addInteger(myDate, dateType, amount); dateString = DateToString(myDate, dateStyle); &#125; return dateString; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期 * @param dateType 类型 * @param amount 数值 * @return 计算后日期 */ private static Date addInteger(Date date, int dateType, int amount) &#123; Date myDate = null; if (date != null) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(dateType, amount); myDate = calendar.getTime(); &#125; return myDate; &#125; /** * 获取精确的日期 * @param timestamps 时间long集合 * @return 日期 */ private static Date getAccurateDate(List&lt;Long&gt; timestamps) &#123; Date date = null; long timestamp = 0; Map&lt;Long, long[]&gt; map = new HashMap&lt;Long, long[]&gt;(); List&lt;Long&gt; absoluteValues = new ArrayList&lt;Long&gt;(); if (timestamps != null &amp;&amp; timestamps.size() &gt; 0) &#123; if (timestamps.size() &gt; 1) &#123; for (int i = 0; i &lt; timestamps.size(); i++) &#123; for (int j = i + 1; j &lt; timestamps.size(); j++) &#123; long absoluteValue = Math.abs(timestamps.get(i) - timestamps.get(j)); absoluteValues.add(absoluteValue); long[] timestampTmp = &#123; timestamps.get(i), timestamps.get(j) &#125;; map.put(absoluteValue, timestampTmp); &#125; &#125; // 有可能有相等的情况。如2012-11和2012-11-01。时间戳是相等的。此时minAbsoluteValue为0 // 因此不能将minAbsoluteValue取默认值0 long minAbsoluteValue = -1; if (!absoluteValues.isEmpty()) &#123; minAbsoluteValue = absoluteValues.get(0); for (int i = 1; i &lt; absoluteValues.size(); i++) &#123; if (minAbsoluteValue &gt; absoluteValues.get(i)) &#123; minAbsoluteValue = absoluteValues.get(i); &#125; &#125; &#125; if (minAbsoluteValue != -1) &#123; long[] timestampsLastTmp = map.get(minAbsoluteValue); long dateOne = timestampsLastTmp[0]; long dateTwo = timestampsLastTmp[1]; if (absoluteValues.size() &gt; 1) &#123; timestamp = Math.abs(dateOne) &gt; Math.abs(dateTwo) ? dateOne : dateTwo; &#125; &#125; &#125; else &#123; timestamp = timestamps.get(0); &#125; &#125; if (timestamp != 0) &#123; date = new Date(timestamp); &#125; return date; &#125; /** * 判断字符串是否为日期字符串 * @param date 日期字符串 * @return true or false */ public static boolean isDate(String date) &#123; boolean isDate = false; if (date != null) &#123; if (getDateStyle(date) != null) &#123; isDate = true; &#125; &#125; return isDate; &#125; /** * 获取日期字符串的日期风格。失敗返回null。 * @param date 日期字符串 * @return 日期风格 */ public static DateStyle getDateStyle(String date) &#123; DateStyle dateStyle = null; Map&lt;Long, DateStyle&gt; map = new HashMap&lt;Long, DateStyle&gt;(); List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; if (style.isShowOnly()) &#123; continue; &#125; Date dateTmp = null; if (date != null) &#123; try &#123; ParsePosition pos = new ParsePosition(0); dateTmp = getDateFormat(style.getValue()).parse(date, pos); if (pos.getIndex() != date.length()) &#123; dateTmp = null; &#125; &#125; catch (Exception e) &#123; &#125; &#125; if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); map.put(dateTmp.getTime(), style); &#125; &#125; Date accurateDate = getAccurateDate(timestamps); if (accurateDate != null) &#123; dateStyle = map.get(accurateDate.getTime()); &#125; return dateStyle; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static Date StringToDate(String date) &#123; DateStyle dateStyle = getDateStyle(date); return StringToDate(date, dateStyle); &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param pattern 日期格式 * @return 日期 */ public static Date StringToDate(String date, String pattern) &#123; Date myDate = null; if (date != null) &#123; try &#123; myDate = getDateFormat(pattern).parse(date); &#125; catch (Exception e) &#123; &#125; &#125; return myDate; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param dateStyle 日期风格 * @return 日期 */ public static Date StringToDate(String date, DateStyle dateStyle) &#123; Date myDate = null; if (dateStyle != null) &#123; myDate = StringToDate(date, dateStyle.getValue()); &#125; return myDate; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param pattern 日期格式 * @return 日期字符串 */ public static String DateToString(Date date, String pattern) &#123; String dateString = null; if (date != null) &#123; try &#123; dateString = getDateFormat(pattern).format(date); &#125; catch (Exception e) &#123; &#125; &#125; return dateString; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param dateStyle 日期风格 * @return 日期字符串 */ public static String DateToString(Date date, DateStyle dateStyle) &#123; String dateString = null; if (dateStyle != null) &#123; dateString = DateToString(date, dateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param newPattern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String newPattern) &#123; DateStyle oldDateStyle = getDateStyle(date); return StringToString(date, oldDateStyle, newPattern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle newDateStyle) &#123; DateStyle oldDateStyle = getDateStyle(date); return StringToString(date, oldDateStyle, newDateStyle); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddPattern 旧日期格式 * @param newPattern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String olddPattern, String newPattern) &#123; return DateToString(StringToDate(date, olddPattern), newPattern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newParttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, String newParttern) &#123; String dateString = null; if (olddDteStyle != null) &#123; dateString = StringToString(date, olddDteStyle.getValue(), newParttern); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddPattern 旧日期格式 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, String olddPattern, DateStyle newDateStyle) &#123; String dateString = null; if (newDateStyle != null) &#123; dateString = StringToString(date, olddPattern, newDateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, DateStyle newDateStyle) &#123; String dateString = null; if (olddDteStyle != null &amp;&amp; newDateStyle != null) &#123; dateString = StringToString(date, olddDteStyle.getValue(), newDateStyle.getValue()); &#125; return dateString; &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期字符串 */ public static String addYear(String date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期 */ public static Date addYear(Date date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param monthAmount 增加数量。可为负数 * @return 增加月份后的日期字符串 */ public static String addMonth(String date, int monthAmount) &#123; return addInteger(date, Calendar.MONTH, monthAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param monthAmount 增加数量。可为负数 * @return 增加月份后的日期 */ public static Date addMonth(Date date, int monthAmount) &#123; return addInteger(date, Calendar.MONTH, monthAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期字符串 */ public static String addDay(String date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期 */ public static Date addDay(Date date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期字符串 * @param hourAmount 增加数量。可为负数 * @return 增加小时后的日期字符串 */ public static String addHour(String date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期 * @param hourAmount 增加数量。可为负数 * @return 增加小时后的日期 */ public static Date addHour(Date date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期字符串 * @param minuteAmount 增加数量。可为负数 * @return 增加分钟后的日期字符串 */ public static String addMinute(String date, int minuteAmount) &#123; return addInteger(date, Calendar.MINUTE, minuteAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期 */ public static Date addMinute(Date date, int minuteAmount) &#123; return addInteger(date, Calendar.MINUTE, minuteAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期字符串 */ public static String addSecond(String date, int secondAmount) &#123; return addInteger(date, Calendar.SECOND, secondAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期 */ public static Date addSecond(Date date, int secondAmount) &#123; return addInteger(date, Calendar.SECOND, secondAmount); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期字符串 * @return 年份 */ public static int getYear(String date) &#123; return getYear(StringToDate(date)); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期 * @return 年份 */ public static int getYear(Date date) &#123; return getInteger(date, Calendar.YEAR); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期字符串 * @return 月份 */ public static int getMonth(String date) &#123; return getMonth(StringToDate(date)); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期 * @return 月份 */ public static int getMonth(Date date) &#123; return getInteger(date, Calendar.MONTH) + 1; &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期字符串 * @return 天 */ public static int getDay(String date) &#123; return getDay(StringToDate(date)); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期 * @return 天 */ public static int getDay(Date date) &#123; return getInteger(date, Calendar.DATE); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期字符串 * @return 小时 */ public static int getHour(String date) &#123; return getHour(StringToDate(date)); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期 * @return 小时 */ public static int getHour(Date date) &#123; return getInteger(date, Calendar.HOUR_OF_DAY); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期字符串 * @return 分钟 */ public static int getMinute(String date) &#123; return getMinute(StringToDate(date)); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期 * @return 分钟 */ public static int getMinute(Date date) &#123; return getInteger(date, Calendar.MINUTE); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期字符串 * @return 秒钟 */ public static int getSecond(String date) &#123; return getSecond(StringToDate(date)); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期 * @return 秒钟 */ public static int getSecond(Date date) &#123; return getInteger(date, Calendar.SECOND); &#125; /** * 获取日期 。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static String getDate(String date) &#123; return StringToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期 * @return 日期 */ public static String getDate(Date date) &#123; return DateToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期字符串 * @return 时间 */ public static String getTime(String date) &#123; return StringToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期 * @return 时间 */ public static String getTime(Date date) &#123; return DateToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期字符串 * @return 星期 */ public static Week getWeek(String date) &#123; Week week = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); week = getWeek(myDate); &#125; return week; &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期 * @return 星期 */ public static Week getWeek(Date date) &#123; Week week = null; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int weekNumber = calendar.get(Calendar.DAY_OF_WEEK) - 1; switch (weekNumber) &#123; case 0: week = Week.SUNDAY; break; case 1: week = Week.MONDAY; break; case 2: week = Week.TUESDAY; break; case 3: week = Week.WEDNESDAY; break; case 4: week = Week.THURSDAY; break; case 5: week = Week.FRIDAY; break; case 6: week = Week.SATURDAY; break; &#125; return week; &#125; /** * 获取两个日期相差的天数 * @param date 日期字符串 * @param otherDate 另一个日期字符串 * @return 相差天数。如果失败则返回-1 */ public static int getIntervalDays(String date, String otherDate) &#123; return getIntervalDays(StringToDate(date), StringToDate(otherDate)); &#125; /** * @param date 日期 * @param otherDate 另一个日期 * @return 相差天数。如果失败则返回-1 */ public static int getIntervalDays(Date date, Date otherDate) &#123; int num = -1; Date dateTmp = DateUtil.StringToDate(DateUtil.getDate(date), DateStyle.YYYY_MM_DD); Date otherDateTmp = DateUtil.StringToDate(DateUtil.getDate(otherDate), DateStyle.YYYY_MM_DD); if (dateTmp != null &amp;&amp; otherDateTmp != null) &#123; long time = Math.abs(dateTmp.getTime() - otherDateTmp.getTime()); num = (int) (time / (24 * 60 * 60 * 1000)); &#125; return num; &#125;&#125; DateStyle类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itkt.mtravel.hotel.util;public enum DateStyle &#123; YYYY_MM("yyyy-MM", false), YYYY_MM_DD("yyyy-MM-dd", false), YYYY_MM_DD_HH_MM("yyyy-MM-dd HH:mm", false), YYYY_MM_DD_HH_MM_SS("yyyy-MM-dd HH:mm:ss", false), YYYY_MM_EN("yyyy/MM", false), YYYY_MM_DD_EN("yyyy/MM/dd", false), YYYY_MM_DD_HH_MM_EN("yyyy/MM/dd HH:mm", false), YYYY_MM_DD_HH_MM_SS_EN("yyyy/MM/dd HH:mm:ss", false), YYYY_MM_CN("yyyy年MM月", false), YYYY_MM_DD_CN("yyyy年MM月dd日", false), YYYY_MM_DD_HH_MM_CN("yyyy年MM月dd日 HH:mm", false), YYYY_MM_DD_HH_MM_SS_CN("yyyy年MM月dd日 HH:mm:ss", false), HH_MM("HH:mm", true), HH_MM_SS("HH:mm:ss", true), MM_DD("MM-dd", true), MM_DD_HH_MM("MM-dd HH:mm", true), MM_DD_HH_MM_SS("MM-dd HH:mm:ss", true), MM_DD_EN("MM/dd", true), MM_DD_HH_MM_EN("MM/dd HH:mm", true), MM_DD_HH_MM_SS_EN("MM/dd HH:mm:ss", true), MM_DD_CN("MM月dd日", true), MM_DD_HH_MM_CN("MM月dd日 HH:mm", true), MM_DD_HH_MM_SS_CN("MM月dd日 HH:mm:ss", true); private String value; private boolean isShowOnly; DateStyle(String value, boolean isShowOnly) &#123; this.value = value; this.isShowOnly = isShowOnly; &#125; public String getValue() &#123; return value; &#125; public boolean isShowOnly() &#123; return isShowOnly; &#125;&#125; Week类1234567891011121314151617181920212223242526272829303132333435363738394041package com.util;public enum Week &#123; MONDAY("星期一", "Monday", "Mon.", 1), TUESDAY("星期二", "Tuesday", "Tues.", 2), WEDNESDAY("星期三", "Wednesday", "Wed.", 3), THURSDAY("星期四", "Thursday", "Thur.", 4), FRIDAY("星期五", "Friday", "Fri.", 5), SATURDAY("星期六", "Saturday", "Sat.", 6), SUNDAY("星期日", "Sunday", "Sun.", 7); String name_cn; String name_en; String name_enShort; int number; Week(String name_cn, String name_en, String name_enShort, int number) &#123; this.name_cn = name_cn; this.name_en = name_en; this.name_enShort = name_enShort; this.number = number; &#125; public String getChineseName() &#123; return name_cn; &#125; public String getName() &#123; return name_en; &#125; public String getShortName() &#123; return name_enShort; &#125; public int getNumber() &#123; return number; &#125;&#125; 添加日期风格（DateStyle）时需要注意的事项： 不允许复的日期风格。例如：yyyy-MM-dd和yyyy-M-d，表现出的风格是相同的。只有当两个日期风格含有不同的字符时，才会看成是不相同的日期风格。例如：yyyy-MM-dd和yyyy-M-d EEE。当含有重复的日期风格时，可以通过isShowOnly=true来区分，isShowOnly=true表示该风格只是“格式化Date类型的日期”用，而不用作“自动判断String类型的日期”。 日期必须含有完整年份信息。例如：MM-dd。没有年份的话，判断MM-dd是不准确的，因为无法识别出闰年（2-29）。其实MM-dd等类似的风格，我们日常习惯上，将其看作是“今年的M月d日”，而SimpleDateFormat中的parse方法中默认的年份为1970年。 添加顺序为：由简到繁。目的在于2012-12和2012-12-1是等价的，虽然日期风格不一样，但默认会看成是一样的且以DateStyle匹配到的最后一个为主。因此最好将详细的日期风格写在后面。 优化版本三该版本是一次较大的升级，农历相比公历复杂太多（真佩服古人的智慧），虽然有规律，但涉及到的取舍、近似的感念太多，况且本身的概念就已经很多了，我在网上也是查阅了很多的资料，虽然找到一些计算的方法，但都有些计算缺陷，后来才终于找到“寿天星文历”：一个十分精准的万年历。虽然它的功能十分强大，但相对的涉及到的计算也很多，逻辑和思路都相当的复杂了，维护成本很大，有时候项目中并不一定要用到这么强大的农历，因此该版本目前仅提供了农历的一些基本功能，在下一版本中，我会引入“寿天星文历”，以适合更多的大众需求。 源码： DateUtil类新加入代码： 1234567891011121314151617/** * 获取简单农历对象 * @param date 日期字符串 * @return 简单农历对象 */public static SimpleLunarCalendar getSimpleLunarCalendar(String date) &#123; return new SimpleLunarCalendar(DateUtil.StringToDate(date));&#125;/** * 获取简单农历对象 * @param date 日期 * @return 简单农历对象 */public static SimpleLunarCalendar getSimpleLunarCalendar(Date date) &#123; return new SimpleLunarCalendar(date);&#125; SimpleLunarCalendar类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344package com.util;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;public class SimpleLunarCalendar &#123; /** 最小时间1900-1-31*/ private final static long minTimeInMillis = -2206425952001L; /** 最大时间2099-12-31 */ private final static long maxTimeInMillis = 4102416000000L; /** * 农历年数据表(1900-2099年)&lt;br&gt; * &lt;br&gt; * 每个农历年用16进制来表示，解析时转为2进制&lt;br&gt; * 前12位分别表示12个农历月份的大小月，1是大月，0是小月&lt;br&gt; * 最后4位表示闰月，转为十进制后即为闰月值，例如0110，则为闰6月 */ private final static int[] lunarInfo = &#123; 0x4bd8, 0x4ae0, 0xa570, 0x54d5, 0xd260, 0xd950, 0x5554, 0x56af, 0x9ad0, 0x55d2, 0x4ae0, 0xa5b6, 0xa4d0, 0xd250, 0xd295, 0xb54f, 0xd6a0, 0xada2, 0x95b0, 0x4977, 0x497f, 0xa4b0, 0xb4b5, 0x6a50, 0x6d40, 0xab54, 0x2b6f, 0x9570, 0x52f2, 0x4970, 0x6566, 0xd4a0, 0xea50, 0x6a95, 0x5adf, 0x2b60, 0x86e3, 0x92ef, 0xc8d7, 0xc95f, 0xd4a0, 0xd8a6, 0xb55f, 0x56a0, 0xa5b4, 0x25df, 0x92d0, 0xd2b2, 0xa950, 0xb557, 0x6ca0, 0xb550, 0x5355, 0x4daf, 0xa5b0, 0x4573, 0x52bf, 0xa9a8, 0xe950, 0x6aa0, 0xaea6, 0xab50, 0x4b60, 0xaae4, 0xa570, 0x5260, 0xf263, 0xd950, 0x5b57, 0x56a0, 0x96d0, 0x4dd5, 0x4ad0, 0xa4d0, 0xd4d4, 0xd250, 0xd558, 0xb540, 0xb6a0, 0x95a6, 0x95bf, 0x49b0, 0xa974, 0xa4b0, 0xb27a, 0x6a50, 0x6d40, 0xaf46, 0xab60, 0x9570, 0x4af5, 0x4970, 0x64b0, 0x74a3, 0xea50, 0x6b58, 0x5ac0, 0xab60, 0x96d5, 0x92e0, 0xc960, 0xd954, 0xd4a0, 0xda50, 0x7552, 0x56a0, 0xabb7, 0x25d0, 0x92d0, 0xcab5, 0xa950, 0xb4a0, 0xbaa4, 0xad50, 0x55d9, 0x4ba0, 0xa5b0, 0x5176, 0x52bf, 0xa930, 0x7954, 0x6aa0, 0xad50, 0x5b52, 0x4b60, 0xa6e6, 0xa4e0, 0xd260, 0xea65, 0xd530, 0x5aa0, 0x76a3, 0x96d0, 0x4afb, 0x4ad0, 0xa4d0, 0xd0b6, 0xd25f, 0xd520, 0xdd45, 0xb5a0, 0x56d0, 0x55b2, 0x49b0, 0xa577, 0xa4b0, 0xaa50, 0xb255, 0x6d2f, 0xada0, 0x4b63, 0x937f, 0x49f8, 0x4970, 0x64b0, 0x68a6, 0xea5f, 0x6b20, 0xa6c4, 0xaaef, 0x92e0, 0xd2e3, 0xc960, 0xd557, 0xd4a0, 0xda50, 0x5d55, 0x56a0, 0xa6d0, 0x55d4, 0x52d0, 0xa9b8, 0xa950, 0xb4a0, 0xb6a6, 0xad50, 0x55a0, 0xaba4, 0xa5b0, 0x52b0, 0xb273, 0x6930, 0x7337, 0x6aa0, 0xad50, 0x4b55, 0x4b6f, 0xa570, 0x54e4, 0xd260, 0xe968, 0xd520, 0xdaa0, 0x6aa6, 0x56df, 0x4ae0, 0xa9d4, 0xa4d0, 0xd150, 0xf252, 0xd520 &#125;; /** 十二生肖 */ private final static String[] Animals = &#123; "鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡", "狗", "猪" &#125;; /** 农历中文字符串一 */ private final static String[] lunarString1 = &#123; "零", "一", "二", "三", "四", "五", "六", "七", "八", "九" &#125;; /** 农历中文字符串二 */ private final static String[] lunarString2 = &#123; "初", "十", "廿", "卅", "正", "腊", "冬", "闰" &#125;; /** 农历年 */ private int lunarYear; /** 农历月 */ private int lunarMonth; /** 农历日 */ private int lunarDay; /** 是否是闰月 */ private boolean isLeap; /** 是否是闰年 */ private boolean isLeapYear; /** 某农历月的最大天数 */ private int maxDayInMonth = 29; /** * 通过 TimeInMillis 构建农历信息 * @param TimeInMillis */ public SimpleLunarCalendar(long TimeInMillis) &#123; this.init(TimeInMillis); &#125; /** * 通过 Date 对象构建农历信息 * @param date 指定日期对象 */ public SimpleLunarCalendar(Date date) &#123; if (date == null) date = new Date(); this.init(date.getTime()); &#125; /** * 农历初始化 * @param timeInMillis 时间毫秒数 */ private void init(long timeInMillis) &#123; if (timeInMillis &gt; minTimeInMillis &amp;&amp; timeInMillis &lt; maxTimeInMillis) &#123; // 以农历为1900年正月一日的1900-1-31作为起始日期 Calendar baseDate = new GregorianCalendar(1900, 0, 31); // 距离起始日期间隔的总天数 long offset = (timeInMillis - baseDate.getTimeInMillis()) / 86400000; // 默认农历年为1900年，且由此开始推算农历年份 this.lunarYear = 1900; int daysInLunarYear = SimpleLunarCalendar.getLunarYearDays(this.lunarYear); // 递减每个农历年的总天数，确定农历年份 while (this.lunarYear &lt; 2100 &amp;&amp; offset &gt;= daysInLunarYear) &#123; offset -= daysInLunarYear; daysInLunarYear = SimpleLunarCalendar.getLunarYearDays(++this.lunarYear); &#125; // 获取该农历年的闰月月份 int leapMonth = SimpleLunarCalendar.getLunarLeapMonth(this.lunarYear); // 没有闰月则不是闰年 this.isLeapYear = leapMonth &gt; 0; // 默认农历月为正月，且由此开始推荐农历月 int lunarMonth = 1; // 是否递减农历月 boolean isDecrease = true; boolean isLeap = false; int daysInLunarMonth = 0; // 递减每个农历月的总天数，确定农历月份 while (lunarMonth &lt; 13 &amp;&amp; offset &gt; 0) &#123; if (isLeap &amp;&amp; !isDecrease) &#123; // 该农历年闰月的总天数 daysInLunarMonth = SimpleLunarCalendar.getLunarLeapDays(this.lunarYear); isDecrease = true; &#125; else &#123; // 该农历年正常农历月份的天数 daysInLunarMonth = SimpleLunarCalendar.getLunarMonthDays(this.lunarYear, lunarMonth); &#125; if (offset &lt; daysInLunarMonth) &#123; break; &#125; offset -= daysInLunarMonth; // 如果农历月是闰月，则不递增农历月份 if (leapMonth == lunarMonth &amp;&amp; isLeap == false) &#123; isDecrease = false; isLeap = true; &#125; else &#123; lunarMonth++; &#125; &#125; // 如果daysInLunarMonth为0则说明默认农历月即为返回的农历月 this.maxDayInMonth = daysInLunarMonth != 0 ? daysInLunarMonth : SimpleLunarCalendar.getLunarMonthDays(this.lunarYear, lunarMonth); this.lunarMonth = lunarMonth; this.isLeap = (lunarMonth == leapMonth &amp;&amp; isLeap); this.lunarDay = (int) offset + 1; &#125; &#125; /** * 获取某农历年的总天数 * @param lunarYear 农历年份 * @return 该农历年的总天数 */ private static int getLunarYearDays(int lunarYear) &#123; // 按小月计算,农历年最少有12 * 29 = 348天 int daysInLunarYear = 348; // 遍历前12位 for (int i = 0x8000; i &gt; 0x8; i &gt;&gt;= 1) &#123; // 每个大月累加一天 daysInLunarYear += ((SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; i) != 0) ? 1 : 0; &#125; // 加上闰月天数 daysInLunarYear += SimpleLunarCalendar.getLunarLeapDays(lunarYear); return daysInLunarYear; &#125; /** * 获取某农历年闰月的总天数 * @param lunarYear 农历年份 * @return 该农历年闰月的总天数，没有闰月返回0 */ private static int getLunarLeapDays(int lunarYear) &#123; // 下一年最后4bit为1111,返回30(大月) // 下一年最后4bit不为1111,返回29(小月) // 若该年没有闰月,返回0 return SimpleLunarCalendar.getLunarLeapMonth(lunarYear) &gt; 0 ? ((SimpleLunarCalendar.lunarInfo[lunarYear - 1899] &amp; 0xf) == 0xf ? 30 : 29) : 0; &#125; /** * 获取某农历年闰月月份 * @param lunarYear 农历年份 * @return 该农历年闰月的月份，没有闰月返回0 */ private static int getLunarLeapMonth(int lunarYear) &#123; // 匹配后4位 int leapMonth = SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; 0xf; // 若最后4位全为1或全为0,表示没闰 leapMonth = (leapMonth == 0xf ? 0 : leapMonth); return leapMonth; &#125; /** * 获取某农历年某农历月份的总天数 * @param lunarYear 农历年份 * @param lunarMonth 农历月份 * @return 该农历年该农历月的总天数 */ private static int getLunarMonthDays(int lunarYear, int lunarMonth) &#123; // 匹配前12位代表的相应农历月份的大小月，大月30天，小月29天 int daysInLunarMonth = ((SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; (0x10000 &gt;&gt; lunarMonth)) != 0) ? 30 : 29; return daysInLunarMonth; &#125; /** * 返回指定数字的农历年份表示字符串 * @param lunarYear 农历年份(数字,0为甲子) * @return 农历年份字符串 */ private static String getLunarYearString(int lunarYear) &#123; String lunarYearString = ""; String year = String.valueOf(lunarYear); for (int i = 0; i &lt; year.length(); i++) &#123; char yearChar = year.charAt(i); int index = Integer.parseInt(String.valueOf(yearChar)); lunarYearString += lunarString1[index]; &#125; return lunarYearString; &#125; /** * 返回指定数字的农历月份表示字符串 * @param lunarMonth 农历月份(数字) * @return 农历月份字符串 (例:正) */ private static String getLunarMonthString(int lunarMonth) &#123; String lunarMonthString = ""; if (lunarMonth == 1) &#123; lunarMonthString = SimpleLunarCalendar.lunarString2[4]; &#125; else &#123; if (lunarMonth &gt; 9) lunarMonthString += SimpleLunarCalendar.lunarString2[1]; if (lunarMonth % 10 &gt; 0) lunarMonthString += SimpleLunarCalendar.lunarString1[lunarMonth % 10]; &#125; return lunarMonthString; &#125; /** * 返回指定数字的农历日表示字符串 * @param lunarDay 农历日(数字) * @return 农历日字符串 (例: 廿一) */ private static String getLunarDayString(int lunarDay) &#123; if (lunarDay &lt; 1 || lunarDay &gt; 30) return ""; int i1 = lunarDay / 10; int i2 = lunarDay % 10; String c1 = SimpleLunarCalendar.lunarString2[i1]; String c2 = SimpleLunarCalendar.lunarString1[i2]; if (lunarDay &lt; 11) c1 = SimpleLunarCalendar.lunarString2[0]; if (i2 == 0) c2 = SimpleLunarCalendar.lunarString2[1]; return c1 + c2; &#125; /** * 取农历年生肖 * @return 农历年生肖(例:龙) */ public String getAnimalString() &#123; if (lunarYear == 0) return null; return SimpleLunarCalendar.Animals[(this.lunarYear - 4) % 12]; &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getDayString() &#123; if (lunarDay == 0) return null; return SimpleLunarCalendar.getLunarDayString(this.lunarDay); &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getMonthString() &#123; if (lunarMonth == 0) return null; return (this.isLeap() ? "闰" : "") + SimpleLunarCalendar.getLunarMonthString(this.lunarMonth); &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getYearString() &#123; if (lunarYear == 0) return null; return SimpleLunarCalendar.getLunarYearString(this.lunarYear); &#125; /** * 返回农历表示字符串 * @return 农历字符串(例:甲子年正月初三) */ public String getDateString() &#123; if (lunarYear == 0) return null; return this.getYearString() + "年" + this.getMonthString() + "月" + this.getDayString() + "日"; &#125; /** * 农历年是否是闰月 * @return 农历年是否是闰月 */ public boolean isLeap() &#123; return isLeap; &#125; /** * 农历年是否是闰年 * @return 农历年是否是闰年 */ public boolean isLeapYear() &#123; return isLeapYear; &#125; /** * 当前农历月是否是大月 * @return 当前农历月是大月 */ public boolean isBigMonth() &#123; return this.getMaxDayInMonth() &gt; 29; &#125; /** * 当前农历月有多少天 * @return 天数 */ public int getMaxDayInMonth() &#123; if (lunarYear == 0) return 0; return this.maxDayInMonth; &#125; /** * 农历日期 * @return 农历日期 */ public int getDay() &#123; return lunarDay; &#125; /** * 农历月份 * @return 农历月份 */ public int getMonth() &#123; return lunarMonth; &#125; /** * 农历年份 * @return 农历年份 */ public int getYear() &#123; return lunarYear; &#125;&#125; 说明：该农历核心算法是从网上寻找而来，但我进行了完善，适用的年份为：1900年——2099年，我去掉了不精准的部分（如天干地支），目前该简单农历只能满足显示阴历信息，适合需要较为简单的用户适用。另外若想支持的年限范围更广，则需要修改lunarInfo（农历年数据表），并做适当的调整（默认农历年）即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate框架技术]]></title>
    <url>%2Fposts%2F37268.html</url>
    <content type="text"><![CDATA[Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 hibernate框架的搭建Hibernate框架的概述 Hibernate框架的概述 Hibernate称为 Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 记住：Hibernate是一个持久层的ORM框架！ 什么是ORM（对象关系映射） ORM映射：Object Relational Mapping O：面向对象领域的Object（JavaBean对象） R：关系数据库领域的Relational（表的结构） M：映射Mapping（XML的配置文件） 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 Hibernate优点 优点 Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 技术分析之Hibernate框架的快速入门第一步：下载Hibernate5的运行环境 下载相应的jar包等 http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 解压后对目录结构有一定的了解 第二步：创建表结构 建表语句如下 123456789101112131415Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_user_id` bigint(32) DEFAULT NULL COMMENT '负责人id', `cust_create_id` bigint(32) DEFAULT NULL COMMENT '创建人id', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_linkman` varchar(64) DEFAULT NULL COMMENT '联系人', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 第三步：搭建Hibernate的开发环境 创建WEB工程，引入Hibernate开发所需要的jar包 MySQL的驱动jar包 Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） 日志jar包（资料/jar包/log4j/所有jar包） 第四步：编写JavaBean实体类 Customer类的代码如下： 12345678910111213public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 &#125; 第五步：创建类与表结构的映射 在JavaBean所在的包下创建映射的配置文件 默认的命名规则为：实体类名.hbm.xml 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） 123&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 如果不能上网，编写配置文件是没有提示的，需要自己来配置 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd –&gt; window –&gt; preferences –&gt; 搜索xml –&gt; 选择xml catalog –&gt; 点击add –&gt; 现在URI –&gt; 粘贴复制的地址 –&gt; 选择location，选择本地的DTD的路径 编写映射的配置文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.xujingyang.hibernate.Customer" table="cst_customer"&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="cust_name" column="cust_name"&gt;&lt;/property&gt; &lt;property name="cust_user_id" column="cust_user_id"&gt;&lt;/property&gt; &lt;property name="cust_create_id" column="cust_create_id"&gt;&lt;/property&gt; &lt;property name="cust_source" column="cust_source"&gt;&lt;/property&gt; &lt;property name="cust_industry" column="cust_industry"&gt;&lt;/property&gt; &lt;property name="cust_level" column="cust_level"&gt;&lt;/property&gt; &lt;property name="cust_linkman" column="cust_linkman "&gt;&lt;/property&gt; &lt;property name="cust_phone" column="cust_phone"&gt;&lt;/property&gt; &lt;property name="cust_mobile" column="cust_mobile"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 第六步：编写Hibernate核心的配置文件 在src目录下，创建名称为hibernate.cfg.xml的配置文件 在XML中引入DTD约束 123&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） 具体的配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; --&gt; &lt;!-- * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource="com/itheima/domain/Customer.hbm.xml"/&gt; --&gt; &lt;mapping resource="com/xujingyang/hibernate/Customer.hbm.xml"/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 回忆：快速入门 下载Hibernate框架的开发包 编写数据库和表结构 创建WEB的项目，导入了开发的jar包 MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 编写JavaBean，以后不使用基本数据类型，使用包装类 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 编写hibernate的核心的配置文件，里面的内容是固定的 编写代码，使用的类和方法 第七步：编写Hibernate入门代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241import java.util.List ;import org.hibernate.Query ;import org.hibernate.SQLQuery ;import org.hibernate.Session ;import org.hibernate.SessionFactory ;import org.hibernate.Transaction ;import org.hibernate.cfg.Configuration ;import org.junit.Test ;import com.xujingyang.hibernate.Customer ;import com.xujingyang.utils.HibernateUtil ;public class TestHibernate &#123; @Test public void testAddofUtils() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Customer c = new Customer() ; c.setCust_name("hehe") ; session.save(c) ; transaction.commit() ; session.close() ; &#125; /** * 添加数据 */ @Test public void testSave() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = new Customer() ; c.setCust_name("小明") ; // 保存用户 session.save(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 根据id查询数据,只能查询一条 */ @Test public void testGet() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 编写操作代码 Customer customer = session.get(Customer.class, 94L) ; System.out.println(customer) ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 更新数据 */ @Test public void testUpdate() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = session.get(Customer.class, 94L) ; c.setCust_mobile("12324343545") ; session.update(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** *更新或添加,存在就更新,不存在就添加 */ @Test public void testSaveOrUpdate() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 // Customer c=session.get(Customer.class, 94L); Customer c = new Customer() ; c.setCust_name("小红2") ; c.setCust_mobile("22324343545") ; session.saveOrUpdate(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 删除数据 */ @Test public void testDel() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = session.get(Customer.class, 94L) ; session.delete(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 查询多条数据 */ @Test public void testGetList() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 按sql语句查找,并制定类型 SQLQuery sqlQuery = session.createSQLQuery("select * from cst_customer").addEntity( Customer.class) ; List&lt;Customer&gt; list = sqlQuery.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** *所有数据 */ @Test public void testGetAllList() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 按sql语句查找,并制定类型 Query query = session.createQuery("from Customer") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; // Customer c=session.get(Customer.class, 94L); Customer c = new Customer() ; c.setCust_name("小红2") ; c.setCust_mobile("22324343545") ; session.saveOrUpdate(c) ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; &#125; 第八步：编写Hibernate的SessionFactory工具类1234567891011121314151617package com.xujingyang.utils ;import org.hibernate.Session ;import org.hibernate.SessionFactory ;import org.hibernate.cfg.Configuration ;public class HibernateUtil &#123; private static SessionFactory sessionFactory = null ; static &#123; sessionFactory = new Configuration().configure().buildSessionFactory() ; &#125; public static Session getSession() &#123; return sessionFactory.openSession() ; &#125;&#125; 技术分析之：Hibernate常用的配置文件Hibernate配置文件之映射配置文件 映射文件，即Stu.hbm.xml的配置文件 标签 – 用来将类与数据库表建立映射关系 name – 类的全路径 table – 表名.(类名与表名一致,那么table属性也可以省略) catalog – 数据库的名称，基本上都会省略不写 标签 – 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 name – 类中属性名 column – 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) length – 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 – 用来将类中的普通属性与表中的字段建立映射. name – 类中属性名 column – 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) length – 数据长度 type – 数据类型（一般都不需要编写，如果写需要按着规则来编写） Hibernate的数据类型 type=”string” Java的数据类型 type=”java.lang.String” 数据库字段的数据类型 Hibernate配置文件之核心配置文件 核心配置文件的两种方式 第一种方式是属性文件的形式，即properties的配置文件 hibernate.properties hibernate.connection.driver_class=com.mysql.jdbc.Driver 缺点 不能加载映射的配置文件，需要手动编写代码去加载 第二种方式是XML文件的形式，开发基本都会选择这种方式 hibernate.cfg.xml com.mysql.jdbc.Driver 优点 格式比较清晰 编写有提示 可以在该配置文件中加载映射的配置文件（最主要的） 关于hibernate.cfg.xml的配置文件方式 必须有的配置 数据库连接信息: hibernate.connection.driver_class – 连接数据库驱动程序 hibernate.connection.url – 连接数据库URL hibernate.connection.username – 数据库用户名 hibernate.connection.password – 数据库密码 方言: hibernate.dialect – 操作数据库方言 可选的配置 hibernate.show_sql – 显示SQL hibernate.format_sql – 格式化SQL hibernate.hbm2ddl.auto – 通过映射转成DDL语句 create – 每次都会创建一个新的表.—测试的时候 create-drop – 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.—测试的时候 update – 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. validate – 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. 加载映射 如果XML方式： 技术分析之Hibernate常用的接口和类Configuration类和作用 Configuration类 Configuration对象用于配置并且启动Hibernate。 Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 Configuration类的其他应用（了解） 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 但是需要自己手动加载映射文件 例如：config.addResource(“cn/itcast/domain/Student.hbm.xml”); 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 SessionFactory：重要 是工厂类，是生成Session对象的工厂类 SessionFactory类的特点 由Configuration通过加载配置文件创建该对象。 SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 预定义SQL语句 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 常见的SQL语句是增删改查（通过主键来查询） 这样做的目的是效率更高 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 总结 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 Session接口 概述 Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 Session是线程不安全的 所有持久化对象必须在 session 的管理下才可以进行持久化操作 Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 持久化类与 Session 关联起来后就具有了持久化的能力 特点 不是线程安全的。应避免多个线程使用同一个Session实例 Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 常用的方法 save(obj) delete(obj) get(Class,id) update(obj) saveOrUpdate(obj) – 保存或者修改（如果没有数据，保存数据。如果有，修改数据） createQuery() – HQL语句的查询的方式 Transaction接口 Transaction是事务的接口 常用的方法 commit() – 提交事务 rollback() – 回滚事务 特点 Hibernate框架默认情况下事务不自动提交.需要手动提交事务 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 Hibernate特点 Hibernate持久化对象的状态 Hibernate的一级缓存 Hibernate操作持久化对象的方法 Hibernate的基本查询 Hibernate的持久化类什么是持久化类 持久化类:就是一个Java类（咱们编写的JavaBean），这个Java类与表建立了映射关系就可以成为是持久化类。 持久化类 = JavaBean + xxx.hbm.xml 持久化类的编写规则 提供一个无参数 public访问控制符的构造器 – 底层需要进行反射. 提供一个标识属性，映射数据表主键字段 – 唯一标识OID.数据库中通过主键.Java对象通过地址确定对象.持久化类通过唯一标识OID确定记录 所有属性提供public访问控制符的 set或者get 方法 标识属性应尽量使用基本数据类型的包装类型 区分自然主键和代理主键 创建表的时候 自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号.(唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式） 代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段.用这个字段作为主键.代理主键.（开发中推荐使用这种方式） 创建表的时候尽量使用代理主键创建表 主键的生成策略 increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制. Hibernate中提供的一种增长机制. 先进行查询 :select max(id) from user; 再进行插入 :获得最大值+1作为新的记录的主键. 问题:不能在集群环境下或者有并发访问的情况下使用. identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制. 底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长. sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式. Oracle数据库底层没有自动增长,想自动增长需要使用序列. uuid:适用于char,varchar类型的作为主键. 使用随机的字符串作为主键. native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long) 如果底层使用的MySQL数据库:相当于identity. 如果底层使用Oracle数据库:相当于sequence. assigned:主键的生成不用Hibernate管理了.必须手动设置主键. Hibernate持久化对象的状态持久化对象的状态 Hibernate的持久化类 持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类. 持久化类 = Java类 + hbm的配置文件 Hibernate的持久化类的状态 Hibernate为了管理持久化类：将持久化类分成了三个状态 瞬时态:Transient Object 没有持久化标识OID, 没有被纳入到Session对象的管理. 持久态:Persistent Object 有持久化标识OID,已经被纳入到Session对象的管理. 脱管态:Detached Object 有持久化标识OID,没有被纳入到Session对象的管理.Hibernate持久化对象的状态的转换 瞬时态 – 没有持久化标识OID, 没有被纳入到Session对象的管理 获得瞬时态的对象 User user = new User() 瞬时态对象转换持久态 save()/saveOrUpdate(); 瞬时态对象转换成脱管态 user.setId(1) 持久态 – 有持久化标识OID,已经被纳入到Session对象的管理 获得持久态的对象 get()/load(); 持久态转换成瞬时态对象 delete(); — 比较有争议的，进入特殊的状态(删除态:Hibernate中不建议使用的) 持久态对象转成脱管态对象 session的close()/evict()/clear(); 脱管态 – 有持久化标识OID,没有被纳入到Session对象的管理 获得托管态对象:不建议直接获得脱管态的对象. User user = new User(); user.setId(1); 脱管态对象转换成持久态对象 update();/saveOrUpdate()/lock(); 脱管态对象转换成瞬时态对象 user.setId(null); 注意：持久态对象有自动更新数据库的能力!!! Hibernate的一级缓存Session对象的一级缓存（重点） 什么是缓存？ 其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！ Hibernate框架提供了两种缓存 一级缓存 – 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存. 二级缓存 – 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存. Session对象的缓存概述 Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着 内存中包含Session实例 –&gt; Session的缓存（一些集合） –&gt; 集合中包含的是缓存对象！ 证明一级缓存的存在，编写查询的代码即可证明 在同一个Session对象中两次查询，可以证明使用了缓存 Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ 使用get方法查询User对象 然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。 利用快照机制来完成的（SnapShot） 控制Session的一级缓存（了解） 学习Session接口中与一级缓存相关的方法 Session.clear() – 清空缓存。 Session.evict(Object entity) – 从一级缓存中清除指定的实体对象。 Session.flush() – 刷出缓存Hibernate中的事务与并发事务相关的概念 什么是事务 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！ 事务的特性 原子性 – 事务不可分割. 一致性 – 事务执行的前后数据的完整性保持一致. 隔离性 – 一个事务执行的过程中,不应该受到其他的事务的干扰. 持久性 – 事务一旦提交,数据就永久保持到数据库中. 如果不考虑隔离性:引发一些读的问题 脏读 – 一个事务读到了另一个事务未提交的数据. 不可重复读 – 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致. 虚读 – 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 通过设置数据库的隔离级别来解决上述读的问题 未提交读:以上的读的问题都有可能发生. 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. 串行化:以上读的情况都可以避免. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置 通过：hibernate.connection.isolation = 4 来配置 取值 1—Read uncommitted isolation 2—Read committed isolation 4—Repeatable read isolation 8—Serializable isolation丢失更新的问题 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 A事务和B事务同时获取到一条数据，同时再做修改 如果A事务修改完成后，提交了事务 B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 解决方案有两种 悲观锁 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 只有当A事务提交后，锁释放了，其他事务才能操作该条记录 乐观锁 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1. 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 使用Hibernate框架解决丢失更新的问题 悲观锁 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 乐观锁 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法 2.在映射的配置文件中，提供标签即可。 绑定本地的Session 之前在讲JavaWEB的事务的时候，需要在业务层使用Connection来开启事务， 一种是通过参数的方式传递下去 另一种是把Connection绑定到ThreadLocal对象中 现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式 需要在hibernate.cfg.xml的配置文件中提供配置 1&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; * 重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。 123public static Session getCurrentSession()&#123; return factory.getCurrentSession(); &#125; * 注意：想使用getCurrentSession()方法，必须要先配置才能使用。 Hibernate框架的查询方式Query查询接口 具体的查询代码如下 1234567891011121314151617// 1.查询所有记录 Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); System.out.println(list); // 2.条件查询: Query query = session.createQuery("from Customer where name = ?"); query.setString(0, "李健"); List&lt;Customer&gt; list = query.list(); System.out.println(list); // 3.条件查询: Query query = session.createQuery("from Customer where name = :aaa and age = :bbb"); query.setString("aaa", "李健"); query.setInteger("bbb", 38); List&lt;Customer&gt; list = query.list(); System.out.println(list); Criteria查询接口（做条件查询非常合适） 具体的查询代码如下 1234567891011121314151617// 1.查询所有记录 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); // 2.条件查询 Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("name", "李健")); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); // 3.条件查询 Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("name", "李健")); criteria.add(Restrictions.eq("age", 38)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.xujingyang.hibernate ;import java.util.List ;import org.hibernate.Criteria ;import org.hibernate.Query ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.hibernate.criterion.Criterion ;import org.hibernate.criterion.Restrictions ;import org.junit.Test ;import com.xujingyang.domain.User ;import com.xujingyang.utils.HibernateUtil ;public class Test1 &#123; @Test public void testSave1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setAge(18) ; session.update(user) ; // session.clear();//清除缓存 // session.evict(user);//从一级缓存中删除指定的对象 // session.flush();//输出缓存 transaction.commit() ; &#125; @Test public void testSave2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setAge(11) ; session.update(user) ; transaction.commit() ; &#125; @Test public void testSave3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setMoney(12) ; session.update(user) ; User u = new User() ; u.setName("小红") ; u.setMoney(12) ; session.saveOrUpdate(u) ; transaction.commit() ; &#125; /** * 演示事务 */ @Test public void testSave4() &#123; Session session = null ; Transaction transaction = null ; try &#123; session = HibernateUtil.getThreadLocalSession() ; transaction = session.beginTransaction() ; add1() ; // int i = 1 / 0 ; add2() ; transaction.commit() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; transaction.rollback() ; &#125; &#125; public void add1() &#123; Session session = HibernateUtil.getThreadLocalSession() ; User user = session.get(User.class, 1) ; user.setMoney(0) ; session.update(user) ; &#125; public void add2() &#123; Session session = HibernateUtil.getThreadLocalSession() ; User u = session.get(User.class, 2) ; u.setName("小红") ; u.setMoney(24) ; &#125; /** * HQL按条件查询 */ @Test public void testQuery1() &#123; Session session = HibernateUtil.getSession() ; Query query = session.createQuery("from User where name=?") ; query.setString(0, "小明") ; List list = query.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; /** * HQL按条件查询 */ @Test public void testQuery2() &#123; Session session = HibernateUtil.getSession() ; Query query = session.createQuery("from User where name=:name") ; query.setString("name", "小明") ; List list = query.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; @Test public void testQuery3() &#123; Session session = HibernateUtil.getSession() ; Criteria criteria = session.createCriteria(User.class) ; List list = criteria.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; @Test public void testQuery4() &#123; Session session = HibernateUtil.getSession() ; Criteria criteria = session.createCriteria(User.class) ; criteria.add(Restrictions.gt("money", 0)) ; List list = criteria.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125;&#125; hibernate之关联关系映射案例：完成CRM的联系人的保存操作需求分析 因为客户和联系人是一对多的关系，在有客户的情况下，完成联系人的添加保存操作技术分析之Hibernate的关联关系映射之一对多映射（重点） 实现过程 JavaWEB中一对多的设计及其建表原则 先导入SQL的建表语句 创建数据库：create database hibernate_03; 编写客户和联系人的JavaBean程序（注意一对多的编写规则） 客户的JavaBean如下 123456789101112131415public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;(); &#125; * 联系人的JavaBean如下 1234567891011121314public class Linkman &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer; &#125; 编写客户和联系人的映射配置文件（注意一对多的配置编写） 客户的映射配置文件如下 12345678910111213141516171819&lt;class name="com.xujingyang.domain.Customer" table="cst_customer"&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="cust_name" column="cust_name"/&gt; &lt;property name="cust_user_id" column="cust_user_id"/&gt; &lt;property name="cust_create_id" column="cust_create_id"/&gt; &lt;property name="cust_source" column="cust_source"/&gt; &lt;property name="cust_industry" column="cust_industry"/&gt; &lt;property name="cust_level" column="cust_level"/&gt; &lt;property name="cust_linkman" column="cust_linkman"/&gt; &lt;property name="cust_phone" column="cust_phone"/&gt; &lt;property name="cust_mobile" column="cust_mobile"/&gt; &lt;set name="linkmans"&gt; &lt;key column="lkm_cust_id"/&gt; &lt;one-to-many class="com.xujingyang.domain.Linkman"/&gt; &lt;/set&gt; &lt;/class&gt; * 联系人的映射配置文件如下 123456789101112131415&lt;class name="com.xujingyang.domain.Linkman" table="cst_linkman"&gt; &lt;id name="lkm_id" column="lkm_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="lkm_name" column="lkm_name"/&gt; &lt;property name="lkm_gender" column="lkm_gender"/&gt; &lt;property name="lkm_phone" column="lkm_phone"/&gt; &lt;property name="lkm_mobile" column="lkm_mobile"/&gt; &lt;property name="lkm_email" column="lkm_email"/&gt; &lt;property name="lkm_qq" column="lkm_qq"/&gt; &lt;property name="lkm_position" column="lkm_position"/&gt; &lt;property name="lkm_memo" column="lkm_memo"/&gt; &lt;many-to-one name="customer" class="com.xujingyang.domain.Customer" column="lkm_cust_id"/&gt; &lt;/class&gt; 技术分析之保存客户和联系人的数据 进行双向关联进行数据的保存 技术分析之级联保存 测试：如果现在代码只插入其中的一方的数据 如果只保存其中的一方的数据，那么程序会抛出异常。 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ 级联保存是方向性 级联保存效果 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ 使用cascade=”save-update” 技术分析之级联删除 先来给大家在数据库中演示含有外键的删除客户功能，那么SQL语句是会报出错误的 例如：1delete from customers where cid = 1; 如果使用Hibernate框架直接删除客户的时候，测试发现是可以删除的 上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的 1* &lt;many-to-one cascade=&quot;delete&quot; /&gt; 技术分析之级联的取值（cascade的取值）和孤儿删除 需要大家掌握的取值如下 none – 不使用级联 save-update – 级联保存或更新 delete – 级联删除 delete-orphan – 孤儿删除.(注意：只能应用在一对多关系) all – 除了delete-orphan的所有情况.（包含save-update delete） all-delete-orphan – 包含了delete-orphan的所有情况.（包含save-update delete delete-orphan） 孤儿删除（孤子删除），只有在一对多的环境下才有孤儿删除 在一对多的关系中,可以将一的一方认为是父方.将多的一方认为是子方.孤儿删除:在解除了父子关系的时候.将子方记录就直接删除。 1* &lt;many-to-one cascade=&quot;delete-orphan&quot; /&gt; 技术分析之让某一方放弃外键的维护，为多对多做准备 先测试双方都维护外键的时候，会产生多余的SQL语句。 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的SQL语句。 产生的原因：session的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的SQL语句。 如果不想产生多余的SQL语句，那么需要一方来放弃外键的维护！ 在标签上配置一个inverse=”true”.true:放弃.false:不放弃.默认值是false 1&lt;inverse=&quot;true&quot;&gt; 技术分析之cascade和inverse的区别 cascade用来级联操作（保存、修改和删除） inverse用来维护外键的 Hibernate的关联关系映射之多对多映射技术分析之多对多的建表原则 JavaWEB的多对多 技术分析之多对多JavaBean的编写 编写用户和角色的JavaBean 用户的JavaBean代码如下 123456789public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); &#125; * 角色的JavaBean代码如下 1234567public class Role &#123; private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); &#125; 用户和角色的映射配置文件如下 用户的映射配置文件如下 1234567891011121314&lt;class name="com.xujingyang.domain.User" table="sys_user"&gt; &lt;id name="user_id" column="user_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="user_code" column="user_code"/&gt; &lt;property name="user_name" column="user_name"/&gt; &lt;property name="user_password" column="user_password"/&gt; &lt;property name="user_state" column="user_state"/&gt; &lt;set name="roles" table="sys_user_role"&gt; &lt;key column="user_id"/&gt; &lt;many-to-many class="com.xujingyang.domain.Role" column="role_id"/&gt; &lt;/set&gt; &lt;/class&gt; * 角色的映射配置文件如下 123456789101112&lt;class name="com.xujingyang.domain.Role" table="sys_role"&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="role_name" column="role_name"/&gt; &lt;property name="role_memo" column="role_memo"/&gt; &lt;set name="users" table="sys_user_role"&gt; &lt;key column="role_id"/&gt; &lt;many-to-many class="com.xujingyang.domain.User" column="user_id"/&gt; &lt;/set&gt; &lt;/class&gt; 多对多进行双向关联的时候:必须有一方去放弃外键维护权 技术分析之多对多的级联保存 级联保存 1&lt;set cascade=&quot;save-update&quot;&gt; 级联删除（在多对多中是很少使用的） 级联删除 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.xujingyang.test ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.junit.Test ;import com.xujingyang.demo.Customer ;import com.xujingyang.demo.LinkMan ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月16日 */public class TestDemo &#123; /** * 双向添加 */ @Test public void Demo1() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = new Customer() ; customer.setCust_name("小明") ; LinkMan lMan1 = new LinkMan() ; lMan1.setLkm_name("小小明1") ; LinkMan lMan2 = new LinkMan() ; lMan2.setLkm_name("小小明2") ; customer.getLinkmans().add(lMan1) ; customer.getLinkmans().add(lMan2) ; lMan1.setCustomer(customer) ; lMan2.setCustomer(customer) ; session.save(customer) ; session.save(lMan1) ; session.save(lMan2) ; transaction.commit() ; &#125; /** * 级联添加, 客户配置中添加cascade="all"此时还维护外建,会执行两次重复的sql语句 , * 添加 inverse="true"时,表明客户表不维护外键,不会重复执行 */ @Test public void Demo2() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = new Customer() ; customer.setCust_name("小明") ; LinkMan lMan1 = new LinkMan() ; lMan1.setLkm_name("小小明1") ; LinkMan lMan2 = new LinkMan() ; lMan2.setLkm_name("小小明2") ; customer.getLinkmans().add(lMan1) ; customer.getLinkmans().add(lMan2) ; session.save(customer) ; transaction.commit() ; &#125; /** * 普通删除,此时会把关联的外建表的列对应的外建置为null * 不添加任何的delete * 删除客户的时候 删除联系人： * 需要在Customer.hbm.xml中set标签上配置cascade="delete" * 删除联系人 同时删除 客户： * 需要在LinkMan.hbm.xml中many-to-one标签上配置cascade="delete" */ @Test public void Demo3() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = session.get(Customer.class, 1L) ; session.delete(customer) ; transaction.commit() ; &#125; /** * 孤儿删除, &lt;set cascade="delete-orphan" /&gt;,跟我解除关系,就把你删了 * 不添加时,只是解除关系,外建置为null */ @Test public void Demo4() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = session.get(Customer.class, 1L) ; LinkMan linkMan = session.get(LinkMan.class, 1L) ; customer.getLinkmans().remove(linkMan) ; transaction.commit() ; &#125;&#125; hibernate之各种查询 Hibernate的查询方式 Hibernate的查询策略 案例：使用Hibernate完成查询所有联系人功能需求分析 完成所有的联系人的查询 技术分析之Hibernate框架的查询方式 唯一标识OID的检索方式 session.get(对象.class,OID) 对象的导航的方式 HQL的检索方式 Hibernate Query Language – Hibernate的查询语言 QBC的检索方式 Query By Criteria – 条件查询 SQL检索方式（了解） 本地的SQL检索 技术分析之HQL的查询方式概述 HQL的介绍 HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 HQL与SQL的关系 HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. HQL 查询语句中的主体是域模型中的类及类的属性 SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段 技术分析之HQL的查询演示 HQL基本的查询格式 支持方法链的编程，即直接调用list()方法 简单的代码如下 1session.createQuery("from Customer").list(); 使用别名的方式 可以使用别名的方式 12session.createQuery("from Customer c").list();session.createQuery("select c from Customer c").list(); 排序查询 排序查询和SQL语句中的排序的语法是一样的 升序 1session.createQuery("from Customer order by cust_id").list(); * 降序 1session.createQuery("from Customer order by cust_id desc").list(); 分页查询 Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页 两个方法如下 setFirstResult(a) – 从哪条记录开始，如果查询是从第一条开启，值是0 setMaxResults(b) – 每页查询的记录条数 演示代码如下 1List&lt;LinkMan&gt; list = session.createQuery("from LinkMan").setFirstResult(0).setMaxResults().list(); 带条件的查询 setParameter(“?号的位置，默认从0开始”,”参数的值”); 不用考虑参数的具体类型 按位置绑定参数的条件查询（指定下标值，默认从0开始） 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） 例如代码如下 1234567Query query = session.createQuery("from Linkman where lkm_name like ? order by lkm_id desc"); query.setFirstResult(0).setMaxResults(3); query.setParameter(0, "%熊%"); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; HQL的投影查询 投影查询就是想查询某一字段的值或者某几个字段的值 投影查询的案例 如果查询多个字段，例如下面这种方式 1234List&lt;Object[]&gt; list = session.createQuery("select c.cust_name,c.cust_level from Customer c").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; * 如果查询两个字段，也可以把这两个字段封装到对象中 * 先在持久化类中提供对应字段的构造方法 * 使用下面这种HQL语句的方式 1234List&lt;Customer&gt; list = session.createQuery("select new Customer(c.cust_name,c.cust_level) from Customer c").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; 技术分析之聚合函数查询 获取总的记录数 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery("select count(c) from Customer c").list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 获取某一列数据的和 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery("select sum(c.cust_id) from Customer c").list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之QBC检索方式 QBC：Query By Criteria 按条件进行查询 简单查询，使用的是Criteria接口 1234List&lt;Customer&gt; list = session.createCriteria(Customer.class).list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; 排序查询 需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象 具体代码如下： 12345678910Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 分页查询 QBC的分页查询也是使用两个方法 setFirstResult(); setMaxResults(); 代码如下; 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); criteria.setFirstResult(0); criteria.setMaxResults(3); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 条件查询 （Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件） * 条件查询使用Criteria接口的add方法，用来传入条件。 * 使用Restrictions的添加条件的方法，来添加条件，例如： * Restrictions.eq -- 相等 * Restrictions.gt -- 大于号 * Restrictions.ge -- 大于等于 * Restrictions.lt -- 小于 * Restrictions.le -- 小于等于 * Restrictions.between -- 在之间 * Restrictions.like -- 模糊查询 * Restrictions.in -- 范围 * Restrictions.and -- 并且 * Restrictions.or -- 或者 * 测试代码如下 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); // 设置查询条件 criteria.add(Restrictions.or(Restrictions.eq("lkm_gender", "男"), Restrictions.gt("lkm_id", 3L))); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 聚合函数查询 （Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询） * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法 * 具体的代码如下 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); criteria.setProjection(Projections.rowCount()); List&lt;Number&gt; list = criteria.list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之离线条件查询 离线条件查询使用的是DetachedCriteria接口进行查询，离线条件查询对象在创建的时候，不需要使用Session对象，只是在查询的时候使用Session对象即可。 创建离线条件查询对象 1DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 具体的代码如下 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); // 设置查询条件 criteria.add(Restrictions.eq("lkm_gender", "男")); // 查询数据 List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 技术分析之SQL查询方式（了解） 基本语法 123456789Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery("select * from cst_linkman where lkm_gender = ?"); sqlQuery.setParameter(0,"男"); sqlQuery.addEntity(Linkman.class); List&lt;Linkman&gt; list = sqlQuery.list(); System.out.println(list); tr.commit(); 技术分析之HQL多表查询 多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。 * 内连接查询 * 显示内连接 1select * from customers c inner join orders o on c.cid = o.cno; * 隐式内连接 1select * from customers c,orders o where c.cid = o.cno; * 外连接查询 * 左外连接 1select * from customers c left join orders o on c.cid = o.cno; * 右外连接 1select * from customers c right join orders o on c.cid = o.cno; HQL的多表查询 迫切和非迫切： 非迫切返回结果是Object[] 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。 内连接查询 内连接使用 inner join ，默认返回的是Object数组 1234567Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery("from Customer c inner join c.linkmans").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tr.commit(); * 迫切内连接:inner join fetch ，返回的是实体对象 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer c inner join fetch c.linkmans").list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) &#123; System.out.println(customer); &#125; tr.commit(); 左外连接查询 左外连接: 封装成List 迫切左外连接 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer c left join fetch c.linkmans").list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) &#123; System.out.println(customer); &#125; tr.commit(); 案例一代码实现 案例二：对查询功能优化需求分析 对Hibernate框架的查询进行优化 技术分析之延迟加载 延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式 类级别的延迟加载 Session对象的load方法默认就是延迟加载 1Customer c = session.load(Customer.class, 1L); 没有发送SQL语句，当使用该对象的属性时，才发送SQL语句 * 使类级别的延迟加载失效 * 在&lt;class&gt;标签上配置lazy=”false” 1Hibernate.initialize(Object proxy); 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载） 默认是延迟加载 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 1L); System.out.println("============="); System.out.println(c.getLinkmans().size()); tr.commit(); 技术分析之Hibernate框架的查询策略 查询策略： 使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!! Hibernate框架的检索策略解决的问题 查询的时机 12Customer c1 = (Customer) session.get(Customer.class, 1); System.out.println(c1.getLinkmans().size()); * lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！ * 查询的语句形式 1234List&lt;Customer&gt; list = session.createQuery("from Customer").list(); for(Customer c : list)&#123; System.out.println(c.getLinkmans()); &#125; * fetch属性就可以解决查询语句的形式的问题！！ 技术分析之在set标签上配置策略 在标签上使用fetch和lazy属性 fetch的取值 – 控制SQL语句生成的格式 select – 默认值.发送查询语句 join – 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了 subselect – 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试) lazy的取值 – 查找关联对象的时候是否采用延迟! true – 默认.延迟 false – 不延迟 extra – 及其懒惰 set标签上的默认值是fetch=”select”和lazy=”true” 总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。 技术分析之在man-to-one标签上配置策略 在标签上使用fetch和lazy属性 fetch的取值 – 控制SQL的格式. select – 默认。发送基本select语句查询 join – 发送迫切左外连接查询 lazy的取值 – 控制加载关联对象是否采用延迟. false – 不采用延迟加载. proxy – 默认值.代理.现在是否采用延迟. 由另一端的上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载). 如果class上lazy=”false”.proxy的值就是false(不采用延迟.) 在标签上的默认值是fetch=”select”和proxy 代码实现 TestHQLDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.xujingyang.test ;import java.util.List ;import org.hibernate.Query ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.junit.Test ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月19日 */public class TestHQLDemo &#123; /** * 排序查询 */ @Test public void demo1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer order by cust_id desc") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 检索查询 */ @Test public void demo2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; // Query query = session.createQuery("from Customer where cust_id=?") ; // query.setLong(0, 2L); Query query = session.createQuery("from Customer where cust_id=2") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 分页查询 */ @Test public void demo3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer") ; query.setFirstResult(0) ;// 从第几条记录开始 query.setMaxResults(2) ;// 每页显示几条数据 List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 统计查询 */ @Test public void demo4() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("select count(1) from Customer") ; List list = query.list() ; System.out.println(list.get(0)) ; transaction.commit() ; &#125; /** * 投影查询 */ @Test public void demo5() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("select cust_id from Customer") ; List list = query.list() ; for (Object object : list) &#123; System.err.println(object) ; &#125; transaction.commit() ; &#125; /** * 连接查询 */ @Test public void demo6() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c inner join fetch c.linkmans ") ; List&lt;Object []&gt; list = query.list() ; for (Object [] objects : list) &#123; for (Object object : objects) &#123; System.out.println(object) ; &#125; &#125; transaction.commit() ; &#125; /** * 迫切内连接 */ @Test public void demo7() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c inner join fetch c.linkmans ") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 外连接 */ @Test public void demo8() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c left join fetch c.linkmans ") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; &#125; TestQBCDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.xujingyang.test ;import java.util.List ;import org.hibernate.Criteria ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.hibernate.criterion.DetachedCriteria ;import org.hibernate.criterion.Order ;import org.hibernate.criterion.Projection ;import org.hibernate.criterion.Projections ;import org.hibernate.criterion.Restrictions ;import org.junit.Test ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月19日 */public class TestQBCDemo &#123; /** * 基本查询 */ @Test public void demo1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 条件查询 */ @Test public void demo2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; // criteria.add(Restrictions.gt("cust_id", 3L)); criteria.add(Restrictions.between("cust_id", 3L, 4L)) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 分页查询 */ @Test public void demo3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; criteria.setFirstResult(0) ; criteria.setMaxResults(2) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 排序查询 */ @Test public void demo4() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; criteria.addOrder(Order.desc("cust_id")) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 统计查询 */ @Test public void demo5() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; // criteria.setProjection(Projections.id()); criteria.setProjection(Projections.sum("cust_id")) ; List list = criteria.list() ; for (Object obj : list) &#123; System.out.println(obj) ; &#125; transaction.commit() ; &#125; /** * 离线条件查询:DetachedCriteria(SSH整合经常使用.). * * 可以脱离session设置参数. */ @Test public void demo6() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class) ; detachedCriteria.add(Restrictions.gt("cust_id", 3L)) ; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; List list = detachedCriteria.getExecutableCriteria(session).list() ; for (Object obj : list) &#123; System.out.println(obj) ; &#125; transaction.commit() ; &#125; &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术重点回顾]]></title>
    <url>%2Fposts%2F44393.html</url>
    <content type="text"><![CDATA[Java技术重点回顾 JavaI/O Java中和I/O操作相关的内容，I/O也是编程语言的一个基础特性，Java中的I/O分为两种类型，一种是顺序读取，一种是随机读取。 我们先来看顺序读取，有两种方式可以进行顺序读取，一种是InputStream/OutputStream，它是针对字节进行操作的输入输出流；另外一种是Reader/Writer，它是针对字符进行操作的输入输出流。 InputStream的结构 FileInputStream：操作文件，经常和BufferedInputStream一起使用 PipedInputStream：可用于线程间通信 ObjectInputStream：可用于对象序列化 ByteArrayInputStream：用于处理字节数组的输入 LineNumberInputStream：可输出当前行数，并且可以在程序中进行修改 OutputStream的结构PrintStream：提供了类似print和println的接口去输出数据 下面我们来看如何使用Stream的方式来操作输入输出 使用InputStream读取文件1234567891011121314151617181920212223242526使用FileInputStream读取文件信息public static byte[] readFileByFileInputStream(File file) throws IOException&#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); FileInputStream fis = null; try &#123; fis = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer, 0, buffer.length)) != -1) &#123; output.write(buffer, 0, bytesRead); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file.getAbsoluteFile()); &#125; finally &#123; if (fis !=null) fis.close(); if (output !=null) output.close(); &#125; return output.toByteArray();&#125; 使用BufferedInputStream读取文件12345678910111213141516171819202122232425262728public static byte[] readFileByBufferedInputStream(File file) throws Exception&#123; FileInputStream fis = null; BufferedInputStream bis = null; ByteArrayOutputStream output = new ByteArrayOutputStream(); try &#123; fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = bis.read(buffer, 0, buffer.length)) != -1) &#123; output.write(buffer, 0, bytesRead); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (bis != null) bis.close(); if (output != null) output.close(); &#125; return output.toByteArray();&#125; 使用OutputStream复制文件1234567891011121314151617181920212223242526public static void copyFileByFileOutputStream(File file) throws IOException&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(file); fos = new FileOutputStream(file.getName() + ".bak"); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer,0,buffer.length)) != -1) &#123; fos.write(buffer, 0, bytesRead); &#125; fos.flush(); &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (fos != null) fos.close(); &#125;&#125; 使用BufferedOutputStream复制文件123456789101112131415161718192021222324252627282930313233public static void copyFilebyBufferedOutputStream(File file)throws IOException&#123; FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; try &#123; fis = new FileInputStream(file); bis = new BufferedInputStream(fis); fos = new FileOutputStream(file.getName() + ".bak"); bos = new BufferedOutputStream(fos); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = bis.read(buffer, 0, buffer.length)) != -1) &#123; bos.write(buffer, 0, bytesRead); &#125; bos.flush(); &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (bis != null) bis.close(); if (fos != null) fos.close(); if (bos != null) bos.close(); &#125;&#125; 这里的代码对异常的处理非常不完整，稍后我们会给出完整严谨的代码。 Reader的结构这里的Reader基本上和InputStream能够对应上。 Writer的结构下面我们来看一些使用Reader或者Writer的例子 使用Reader读取文件内容 123456789101112131415161718192021222324public static String readFile(String file)throws IOException&#123; BufferedReader br = null; StringBuffer sb = new StringBuffer(); try &#123; br = new BufferedReader(new FileReader(file)); String line = null; while((line = br.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file); &#125; finally &#123; if (br != null) br.close(); &#125; return sb.toString();&#125; 使用Writer复制文件123456789101112131415161718192021222324public static void copyFile(String file) throws IOException&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader(file)); bw = new BufferedWriter(new FileWriter(file + ".bak")); String line = null; while((line = br.readLine())!= null) &#123; bw.write(line); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file); &#125; finally &#123; if (br != null) br.close(); if (bw != null) bw.close(); &#125;&#125; 下面我们来看如何对文件进行随机访问，Java中主要使用RandomAccessFile来对文件进行随机操作。 创建一个大小固定的文件1234567public static void createFile(String file, int size) throws IOException&#123; File temp = new File(file); RandomAccessFile raf = new RandomAccessFile(temp, "rw"); raf.setLength(size); raf.close();&#125; 向文件中随机写入数据1234567public static void writeFile(String file, byte[] content, int startPos, int contentLength) throws IOException&#123; RandomAccessFile raf = new RandomAccessFile(new File(file), "rw"); raf.seek(startPos); raf.write(content, 0, contentLength); raf.close();&#125; 接下里，我们来看一些其他的常用操作 移动文件12345678public static boolean moveFile(String sourceFile, String destFile)&#123; File source = new File(sourceFile); if (!source.exists()) throw new RuntimeException("source file does not exist."); File dest = new File(destFile); if (!(new File(dest.getPath()).exists())) new File(dest.getParent()).mkdirs(); return source.renameTo(dest);&#125; 复制文件123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copyFile(String sourceFile, String destFile) throws IOException&#123; File source = new File(sourceFile); if (!source.exists()) throw new RuntimeException("File does not exist."); if (!source.isFile()) throw new RuntimeException("It is not file."); if (!source.canRead()) throw new RuntimeException("File cound not be read."); File dest = new File(destFile); if (dest.exists()) &#123; if (dest.isDirectory()) throw new RuntimeException("Destination is a folder."); else &#123; dest.delete(); &#125; &#125; else &#123; File parentFolder = new File(dest.getParent()); if (!parentFolder.exists()) parentFolder.mkdirs(); if (!parentFolder.canWrite()) throw new RuntimeException("Destination can not be written."); &#125; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(source); fos = new FileOutputStream(dest); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer, 0, buffer.length)) != -1) &#123; fos.write(buffer, 0, bytesRead); &#125; fos.flush(); &#125; catch(IOException ex) &#123; System.out.println("Error occurs during copying " + sourceFile); &#125; finally &#123; if (fis != null) fis.close(); if (fos != null) fos.close(); &#125;&#125; 复制文件夹12345678910111213141516171819202122232425262728public static void copyDir(String sourceDir, String destDir) throws IOException&#123; File source = new File(sourceDir); if (!source.exists()) throw new RuntimeException("Source does not exist."); if (!source.canRead()) throw new RuntimeException("Source could not be read."); File dest = new File(destDir); if (!dest.exists()) dest.mkdirs(); File[] arrFiles = source.listFiles(); for(int i = 0; i &lt; arrFiles.length; i++) &#123; if (arrFiles[i].isFile()) &#123; BufferedReader reader = new BufferedReader(new FileReader(arrFiles[i])); BufferedWriter writer = new BufferedWriter(new FileWriter(destDir + "/" + arrFiles[i].getName())); String line = null; while((line = reader.readLine()) != null) writer.write(line); writer.flush(); reader.close(); writer.close(); &#125; else &#123; copyDir(sourceDir + "/" + arrFiles[i].getName(), destDir + "/" + arrFiles[i].getName()); &#125; &#125;&#125; 删除文件夹123456789101112131415161718192021public static void del(String filePath)&#123; File file = new File(filePath); if (file == null || !file.exists()) return; if (file.isFile()) &#123; file.delete(); &#125; else &#123; File[] arrFiles = file.listFiles(); if (arrFiles.length &gt; 0) &#123; for(int i = 0; i &lt; arrFiles.length; i++) &#123; del(arrFiles[i].getAbsolutePath()); &#125; &#125; file.delete(); &#125;&#125; 获取文件夹大小1234567891011121314151617public static long getFolderSize(String dir)&#123; long size = 0; File file = new File(dir); if (!file.exists()) throw new RuntimeException("dir does not exist."); if (file.isFile()) return file.length(); else &#123; String[] arrFileName = file.list(); for (int i = 0; i &lt; arrFileName.length; i++) &#123; size += getFolderSize(dir + "/" + arrFileName[i]); &#125; &#125; return size;&#125; 将大文件切分成多个小文件123456789101112131415161718192021222324252627282930313233343536public static void splitFile(String filePath, long unit) throws IOException&#123; File file = new File(filePath); if (!file.exists()) throw new RuntimeException("file does not exist."); long size = file.length(); if (unit &gt;= size) return; int count = size % unit == 0 ? (int)(size/unit) : (int)(size/unit) + 1; String newFile = null; FileOutputStream fos = null; FileInputStream fis =null; byte[] buffer = new byte[(int)unit]; fis = new FileInputStream(file); long startPos = 0; String countFile = filePath + "_Count"; PrintWriter writer = new PrintWriter(new FileWriter( new File(countFile))); writer.println(filePath + "\t" + size); for (int i = 1; i &lt;= count; i++) &#123; newFile = filePath + "_" + i; startPos = (i - 1) * unit; System.out.println("Creating " + newFile); fos = new FileOutputStream(new File(newFile)); int bytesRead = fis.read(buffer, 0, buffer.length); if (bytesRead != -1) &#123; fos.write(buffer, 0, bytesRead); writer.println(newFile + "\t" + startPos + "\t" + bytesRead); &#125; fos.flush(); fos.close(); System.out.println("StartPos:" + i*unit + "; EndPos:" + (i*unit + bytesRead)); &#125; writer.flush(); writer.close(); fis.close();&#125; 将多个小文件合并成一个大文件1234567891011121314151617181920212223242526public static void linkFiles(String countFile) throws IOException&#123; File file = new File(countFile); if (!file.exists()) throw new RuntimeException("Count file does not exist."); BufferedReader reader = new BufferedReader(new FileReader(file)); String line = reader.readLine(); String newFile = line.split("\t")[0]; long size = Long.parseLong(line.split("\t")[1]); RandomAccessFile raf = new RandomAccessFile(newFile, "rw"); raf.setLength(size); FileInputStream fis = null; byte[] buffer = null; while((line = reader.readLine()) != null) &#123; String[] arrInfo = line.split("\t"); fis = new FileInputStream(new File(arrInfo[0])); buffer = new byte[Integer.parseInt(arrInfo[2])]; long startPos = Long.parseLong(arrInfo[1]); fis.read(buffer, 0, Integer.parseInt(arrInfo[2])); raf.seek(startPos); raf.write(buffer, 0, Integer.parseInt(arrInfo[2])); fis.close(); &#125; raf.close();&#125; 执行外部命令1234567891011121314151617181920212223public static void execExternalCommand(String command, String argument)&#123; Process process = null; try &#123; process = Runtime.getRuntime().exec(command + " " + argument); InputStream is = process.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line = null; while((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (process != null) process.destroy(); &#125;&#125; Java网络通信Java实现网络通信，包括TCP通信、UDP通信、多播以及NIO。 TCP连接TCP的基础是Socket，在TCP连接中，我们会使用ServerSocket和Socket，当客户端和服务器建立连接以后，剩下的基本就是对I/O的控制了。 我们先来看一个简单的TCP通信，它分为客户端和服务器端。 客户端代码如下： 简单的TCP客户端1234567891011121314151617181920212223242526272829303132333435363738import java.net.*;import java.io.*;public class SimpleTcpClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = null; BufferedReader br = null; PrintWriter pw = null; BufferedReader brTemp = null; try &#123; socket = new Socket(InetAddress.getLocalHost(), 5678); br = new BufferedReader(new InputStreamReader(socket.getInputStream())); pw = new PrintWriter(socket.getOutputStream()); brTemp = new BufferedReader(new InputStreamReader(System.in)); while(true) &#123; String line = brTemp.readLine(); pw.println(line); pw.flush(); if (line.equals("end")) break; System.out.println(br.readLine()); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (socket != null) socket.close(); if (br != null) br.close(); if (brTemp != null) brTemp.close(); if (pw != null) pw.close(); &#125; &#125;&#125; 服务器端代码如下： 简单版本TCP服务器端12345678910111213141516171819202122232425262728293031323334353637import java.net.*;import java.io.*;public class SimpleTcpServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = null; Socket client = null; BufferedReader br = null; PrintWriter pw = null; try &#123; server = new ServerSocket(5678); client = server.accept(); br = new BufferedReader(new InputStreamReader(client.getInputStream())); pw = new PrintWriter(client.getOutputStream()); while(true) &#123; String line = br.readLine(); pw.println("Response:" + line); pw.flush(); if (line.equals("end")) break; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (server != null) server.close(); if (client != null) client.close(); if (br != null) br.close(); if (pw != null) pw.close(); &#125; &#125;&#125; 这里的服务器的功能非常简单，它接收客户端发来的消息，然后将消息“原封不动”的返回给客户端。当客户端发送“end”时，通信结束。 上面的代码基本上勾勒了TCP通信过程中，客户端和服务器端的主要框架，我们可以发现，上述的代码中，服务器端在任何时刻，都只能处理来自客户端的一个请求，它是串行处理的，不能并行，这和我们印象里的服务器处理方式不太相同，我们可以为服务器添加多线程，当一个客户端的请求进入后，我们就创建一个线程，来处理对应的请求。 改善后的服务器端代码如下： 多线程版本的TCP服务器端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.net.*;import java.io.*;public class SmartTcpServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(5678); while(true) &#123; Socket client = server.accept(); Thread thread = new ServerThread(client); thread.start(); &#125; &#125;&#125;class ServerThread extends Thread&#123; private Socket socket = null; public ServerThread(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; BufferedReader br = null; PrintWriter pw = null; try &#123; br = new BufferedReader(new InputStreamReader(socket.getInputStream())); pw = new PrintWriter(socket.getOutputStream()); while(true) &#123; String line = br.readLine(); pw.println("Response:" + line); pw.flush(); if (line.equals("end")) break; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (socket != null) try &#123; socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; if (br != null) try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (pw != null) pw.close(); &#125; &#125;&#125; 修改后的服务器端，就可以同时处理来自客户端的多个请求了。 在编程的过程中，我们会有“资源”的概念，例如数据库连接就是一个典型的资源，为了提升性能，我们通常不会直接销毁数据库连接，而是使用数据库连接池的方式来对多个数据库连接进行管理，已实现重用的目的。对于Socket连接来说，它也是一种资源，当我们的程序需要大量的Socket连接时，如果每个连接都需要重新建立，那么将会是一件非常没有效率的做法。 和数据库连接池类似，我们也可以设计TCP连接池，这里的思路是我们用一个数组来维持多个Socket连接，另外一个状态数组来描述每个Socket连接是否正在使用，当程序需要Socket连接时，我们遍历状态数组，取出第一个没被使用的Socket连接，如果所有连接都在使用，抛出异常。这是一种很直观简单的“调度策略”，在很多开源或者商业的框架中（Apache/Tomcat），都会有类似的“资源池”。 TCP连接池的代码如下： 一个简单的TCP连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.net.*;import java.io.*;public class TcpConnectionPool &#123; private InetAddress address = null; private int port; private Socket[] arrSockets = null; private boolean[] arrStatus = null; private int count; public TcpConnectionPool(InetAddress address, int port, int count) &#123; this.address = address; this.port = port; this .count = count; arrSockets = new Socket[count]; arrStatus = new boolean[count]; init(); &#125; private void init() &#123; try &#123; for (int i = 0; i &lt; count; i++) &#123; arrSockets[i] = new Socket(address.getHostAddress(), port); arrStatus[i] = false; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125; public Socket getConnection() &#123; if (arrSockets == null) init(); int i = 0; for(i = 0; i &lt; count; i++) &#123; if (arrStatus[i] == false) &#123; arrStatus[i] = true; break; &#125; &#125; if (i == count) throw new RuntimeException("have no connection availiable for now."); return arrSockets[i]; &#125; public void releaseConnection(Socket socket) &#123; if (arrSockets == null) init(); for (int i = 0; i &lt; count; i++) &#123; if (arrSockets[i] == socket) &#123; arrStatus[i] = false; break; &#125; &#125; &#125; public void reBuild() &#123; init(); &#125; public void destory() &#123; if (arrSockets == null) return; for(int i = 0; i &lt; count; i++) &#123; try &#123; arrSockets[i].close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); continue; &#125; &#125; &#125;&#125; UDP连接UDP是一种和TCP不同的连接方式，它通常应用在对实时性要求很高，对准确定要求不高的场合，例如在线视频。UDP会有“丢包”的情况发生，在TCP中，如果Server没有启动，Client发消息时，会报出异常，但对UDP来说，不会产生任何异常。 UDP通信使用的两个类时DatagramSocket和DatagramPacket，后者存放了通信的内容。 下面是一个简单的UDP通信例子，同TCP一样，也分为Client和Server两部分，Client端代码如下： UDP通信客户端123456789101112131415161718192021222324252627282930import java.net.*;import java.io.*;public class UdpClient &#123; public static void main(String[] args) &#123; try &#123; InetAddress host = InetAddress.getLocalHost(); int port = 5678; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); while(true) &#123; String line = br.readLine(); byte[] message = line.getBytes(); DatagramPacket packet = new DatagramPacket(message, message.length, host, port); DatagramSocket socket = new DatagramSocket(); socket.send(packet); socket.close(); if (line.equals("end")) break; &#125; br.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; Server端代码如下： UDP通信服务器端1234567891011121314151617181920212223242526272829import java.net.*;import java.io.*;public class UdpServer &#123; public static void main(String[] args) &#123; try &#123; int port = 5678; DatagramSocket dsSocket = new DatagramSocket(port); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while(true) &#123; dsSocket.receive(packet); String message = new String(buffer, 0, packet.getLength()); System.out.println(packet.getAddress().getHostName() + ":" + message); if (message.equals("end")) break; packet.setLength(buffer.length); &#125; dsSocket.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; 这里，我们也假设和TCP一样，当Client发出“end”消息时，认为通信结束，但其实这样的设计不是必要的，Client端可以随时断开，并不需要关心Server端状态。 多播（Multicast）多播采用和UDP类似的方式，它会使用D类IP地址和标准的UDP端口号，D类IP地址是指224.0.0.0到239.255.255.255之间的地址，不包括224.0.0.0。 多播会使用到的类是MulticastSocket，它有两个方法需要关注：joinGroup和leaveGroup。 下面是一个多播的例子，Client端代码如下： 多播通信客户端12345678910111213141516171819202122232425262728import java.net.*;import java.io.*;public class MulticastClient &#123; public static void main(String[] args) &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; InetAddress address = InetAddress.getByName("230.0.0.1"); int port = 5678; while(true) &#123; String line = br.readLine(); byte[] message = line.getBytes(); DatagramPacket packet = new DatagramPacket(message, message.length, address, port); MulticastSocket multicastSocket = new MulticastSocket(); multicastSocket.send(packet); if (line.equals("end")) break; &#125; br.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; 服务器端代码如下： 多播通信服务器端123456789101112131415161718192021222324252627282930import java.net.*;import java.io.*;public class MulticastServer &#123; public static void main(String[] args) &#123; int port = 5678; try &#123; MulticastSocket multicastSocket = new MulticastSocket(port); InetAddress address = InetAddress.getByName("230.0.0.1"); multicastSocket.joinGroup(address); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while(true) &#123; multicastSocket.receive(packet); String message = new String(buffer, packet.getLength()); System.out.println(packet.getAddress().getHostName() + ":" + message); if (message.equals("end")) break; packet.setLength(buffer.length); &#125; multicastSocket.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; NIO（New IO）NIO是JDK1.4引入的一套新的IO API，它在缓冲区管理、网络通信、文件存取以及字符集操作方面有了新的设计。对于网络通信来说，NIO使用了缓冲区和通道的概念。 下面是一个NIO的例子，和我们上面提到的代码风格有很大的不同。 NIO例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;import java.nio.*;import java.nio.channels.*;import java.nio.charset.*;import java.net.*;public class NewIOSample &#123; public static void main(String[] args) &#123; String host="127.0.0.1"; int port = 5678; SocketChannel channel = null; try &#123; InetSocketAddress address = new InetSocketAddress(host,port); Charset charset = Charset.forName("UTF-8"); CharsetDecoder decoder = charset.newDecoder(); CharsetEncoder encoder = charset.newEncoder(); ByteBuffer buffer = ByteBuffer.allocate(1024); CharBuffer charBuffer = CharBuffer.allocate(1024); channel = SocketChannel.open(); channel.connect(address); String request = "GET / \r\n\r\n"; channel.write(encoder.encode(CharBuffer.wrap(request))); while((channel.read(buffer)) != -1) &#123; buffer.flip(); decoder.decode(buffer, charBuffer, false); charBuffer.flip(); System.out.println(charBuffer); buffer.clear(); charBuffer.clear(); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (channel != null) try &#123; channel.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 上述代码会试图访问一个本地的网址，然后将其内容打印出来。 Java多线程多线程是一个复杂的话题，包含了很多内容，文章主要关注线程的基本属性、如何创建线程、线程的状态切换以及线程通信，我们把线程同步的话题留到下一篇文章中。 线程是操作系统运行的基本单位，它被封装在进程中，一个进程可以包含多个线程。即使我们不手动创造线程，进程也会有一个默认的线程在运行。 对于JVM来说，当我们编写一个单线程的程序去运行时，JVM中也是有至少两个线程在运行，一个是我们创建的程序，一个是垃圾回收。 线程基本信息我们可以通过Thread.currentThread()方法获取当前线程的一些信息，并对其进行修改。 我们来看以下代码： 查看并修改当前线程的属性123456789101112131415161718String name = Thread.currentThread().getName(); int priority = Thread.currentThread().getPriority(); String groupName = Thread.currentThread().getThreadGroup().getName(); boolean isDaemon = Thread.currentThread().isDaemon(); System.out.println("Thread Name:" + name); System.out.println("Priority:" + priority); System.out.println("Group Name:" + groupName); System.out.println("IsDaemon:" + isDaemon); Thread.currentThread().setName("Test"); Thread.currentThread().setPriority(Thread.MAX_PRIORITY); name = Thread.currentThread().getName(); priority = Thread.currentThread().getPriority(); groupName = Thread.currentThread().getThreadGroup().getName(); isDaemon = Thread.currentThread().isDaemon(); System.out.println("Thread Name:" + name); System.out.println("Priority:" + priority); 其中列出的属性说明如下： GroupName，每个线程都会默认在一个线程组里，我们也可以显式的创建线程组，一个线程组中也可以包含子线程组，这样线程和线程组，就构成了一个树状结构。 Name，每个线程都会有一个名字，如果不显式指定，那么名字的规则是“Thread-xxx”。 Priority，每个线程都会有自己的优先级，JVM对优先级的处理方式是“抢占式”的。当JVM发现优先级高的线程时，马上运行该线程；对于多个优先级相等的线程，JVM对其进行轮询处理。Java的线程优先级从1到10，默认是5，Thread类定义了2个常量：MIN_PRIORITY和MAX_PRIORITY来表示最高和最低优先级。 我们可以看下面的代码，它定义了两个不同优先级的线程： 线程优先级示例1234567891011121314151617181920212223242526272829public static void priorityTest()&#123; Thread thread1 = new Thread("low") &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("Thread 1 is running."); &#125; &#125; &#125;; Thread thread2 = new Thread("high") &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("Thread 2 is running."); &#125; &#125; &#125;; thread1.setPriority(Thread.MIN_PRIORITY); thread2.setPriority(Thread.MAX_PRIORITY); thread1.start(); thread2.start();&#125; 从运行结果可以看出，是高优先级线程运行完成后，低优先级线程才运行。isDaemon，这个属性用来控制父子线程的关系，如果设置为true，当父线程结束后，其下所有子线程也结束，反之，子线程的生命周期不受父线程影响。 我们来看下面的例子： IsDaemon 示例123456789101112131415161718192021222324public static void daemonTest()&#123; Thread thread1 = new Thread("daemon") &#123; public void run() &#123; Thread subThread = new Thread("sub") &#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println("Sub Thread Running " + i); &#125; &#125; &#125;; subThread.setDaemon(true); subThread.start(); System.out.println("Main Thread end."); &#125; &#125;; thread1.start();&#125; 上面代码的运行结果，在和删除subThread.setDaemon(true);后对比，可以发现后者运行过程中子线程会完成执行后再结束，而前者中，子线程很快就结束了。 如何创建线程上面的内容，都是演示默认线程中的一些信息，那么应该如何创建线程呢？在Java中，我们有3种方式可以用来创建线程。 Java中的线程要么继承Thread类，要么实现Runnable接口，我们一一道来。 使用内部类来创建线程我们可以使用内部类的方式来创建线程，过程是声明一个Thread类型的变量，并重写run方法。示例代码如下： 123456789101112131415public static void createThreadByNestClass()&#123; Thread thread = new Thread() &#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125; &#125;; thread.start();&#125; 继承Thread以创建线程我们可以从Thread中派生一个类，重写其run方法，这种方式和上面相似。示例代码如下： 123456789101112131415161718class MyThread extends Thread&#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125;&#125;public static void createThreadBySubClass()&#123; MyThread thread = new MyThread(); thread.start();&#125; 实现Runnable接口以创建线程我们可以定义一个类，使其实现Runnable接口，然后将该类的实例作为构建Thread变量构造函数的参数。示例代码如下： 12345678910111213141516171819class MyRunnable implements Runnable&#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125;&#125;public static void createThreadByRunnable()&#123; MyRunnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start();&#125; 上述3种方式都可以创建线程，而且从示例代码上看，线程执行的功能是一样的，那么这三种创建方式有什么不同呢？ 这涉及到Java中多线程的运行模式，对于Java来说，多线程在运行时，有“多对象多线程”和“单对象多线程”的区别： 多对象多线程，程序在运行过程中创建多个线程对象，每个对象上运行一个线程。 单对象多线程，程序在运行过程中创建一个线程对象，在其上运行多个线程。 显然，从线程同步和调度的角度来看，多对象多线程要简单一些。上述3种线程创建方式，前两种都属于“多对象多线程”，第三种既可以使用“多对象多线程”，也可以使用“单对象单线程”。 我们来看下面的示例代码，里面会用到Object.notify方法，这个方法会唤醒对象上的一个线程；而Object.notifyAll方法，则会唤醒对象上的所有线程。 notify示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class NotifySample &#123; public static void main(String[] args) throws InterruptedException &#123; notifyTest(); notifyTest2(); notifyTest3(); &#125; private static void notifyTest() throws InterruptedException &#123; MyThread[] arrThreads = new MyThread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrThreads[i] = new MyThread(); arrThreads[i].id = i; arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); for (int i = 0; i &lt; arrThreads.length; i++) &#123; synchronized(arrThreads[i]) &#123; arrThreads[i].notify(); &#125; &#125; &#125; private static void notifyTest2() throws InterruptedException &#123; MyRunner[] arrMyRunners = new MyRunner[3]; Thread[] arrThreads = new Thread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrMyRunners[i] = new MyRunner(); arrMyRunners[i].id = i; arrThreads[i] = new Thread(arrMyRunners[i]); arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); for (int i = 0; i &lt; arrMyRunners.length; i++) &#123; synchronized(arrMyRunners[i]) &#123; arrMyRunners[i].notify(); &#125; &#125; &#125; private static void notifyTest3() throws InterruptedException &#123; MyRunner runner = new MyRunner(); Thread[] arrThreads = new Thread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrThreads[i] = new Thread(runner); arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); synchronized(runner) &#123; runner.notifyAll(); &#125; &#125;&#125;class MyThread extends Thread&#123; public int id = 0; public void run() &#123; System.out.println("第" + id + "个线程准备休眠5分钟。"); try &#123; synchronized(this) &#123; this.wait(5*60*1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println("第" + id + "个线程被唤醒。"); &#125;&#125;class MyRunner implements Runnable&#123; public int id = 0; public void run() &#123; System.out.println("第" + id + "个线程准备休眠5分钟。"); try &#123; synchronized(this) &#123; this.wait(5*60*1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println("第" + id + "个线程被唤醒。"); &#125; &#125; 示例代码中，notifyTest()和notifyTest2()是“多对象多线程”，尽管notifyTest2()中的线程实现了Runnable接口，但是它里面定义Thread数组时，每个元素都使用了一个新的Runnable实例。notifyTest3()属于“单对象多线程”，因为我们只定义了一个Runnable实例，所有的线程都会使用这个实例。 notifyAll方法适用于“单对象多线程”的情景，因为notify方法只会随机唤醒对象上的一个线程。 线程的状态切换对于线程来讲，从我们创建它一直到线程运行结束，在这个过程中，线程的状态可能是这样的： 创建：已经有Thread实例了， 但是CPU还有为其分配资源和时间片。 就绪：线程已经获得了运行所需的所有资源，只等CPU进行时间调度。 运行：线程位于当前CPU时间片中，正在执行相关逻辑。 休眠：一般是调用Thread.sleep后的状态，这时线程依然持有运行所需的各种资源，但是不会被CPU调度。 挂起：一般是调用Thread.suspend后的状态，和休眠类似，CPU不会调度该线程，不同的是，这种状态下，线程会释放所有资源。 死亡：线程运行结束或者调用了Thread.stop方法。 下面我们来演示如何进行线程状态切换，首先我们会用到下面方法： Thread()或者Thread(Runnable)：构造线程。 Thread.start：启动线程。 Thread.sleep：将线程切换至休眠状态。 Thread.interrupt：中断线程的执行。 Thread.join：等待某线程结束。 Thread.yield：剥夺线程在CPU上的执行时间片，等待下一次调度。 Object.wait：将Object上所有线程锁定，直到notify方法才继续运行。 Object.notify：随机唤醒Object上的1个线程。 Object.notifyAll：唤醒Object上的所有线程。 下面，就是演示时间啦！！！ 线程等待与唤醒这里主要使用Object.wait和Object.notify方法，请参见上面的notify实例。需要注意的是，wait和notify都必须针对同一个对象，当我们使用实现Runnable接口的方式来创建线程时，应该是在Runnable对象而非Thread对象上使用这两个方法。 线程的休眠与唤醒Thread.sleep实例线程在休眠过程中，我们可以使用Thread.interrupt将其唤醒，这时线程会抛出InterruptedException。 Thread.sleep实例1234567891011121314151617181920212223242526272829303132public class SleepSample &#123; public static void main(String[] args) throws InterruptedException &#123; sleepTest(); &#125; private static void sleepTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; System.out.println("线程 " + Thread.currentThread().getName() + "将要休眠5分钟。"); try &#123; Thread.sleep(5*60*1000); &#125; catch(InterruptedException ex) &#123; System.out.println("线程 " + Thread.currentThread().getName() + "休眠被中断。"); &#125; System.out.println("线程 " + Thread.currentThread().getName() + "休眠结束。"); &#125; &#125;; thread.setDaemon(true); thread.start(); Thread.sleep(500); thread.interrupt(); &#125;&#125; 线程的终止虽然有Thread.stop方法，但该方法是不被推荐使用的，我们可以利用上面休眠与唤醒的机制，让线程在处理IterruptedException时，结束线程。 Thread.interrupt示例12345678910111213141516171819202122232425262728293031public class StopThreadSample &#123; public static void main(String[] args) throws InterruptedException &#123; stopTest(); &#125; private static void stopTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; System.out.println("线程运行中。"); try &#123; Thread.sleep(1*60*1000); &#125; catch(InterruptedException ex) &#123; System.out.println("线程中断，结束线程"); return; &#125; System.out.println("线程正常结束。"); &#125; &#125;; thread.start(); Thread.sleep(500); thread.interrupt(); &#125;&#125; 线程的同步等待当我们在主线程中创建了10个子线程，然后我们期望10个子线程全部结束后，主线程在执行接下来的逻辑，这时，就该Thread.join登场了。 Thread.join示例12345678910111213141516171819202122232425262728293031323334public class JoinSample &#123; public static void main(String[] args) throws InterruptedException &#123; joinTest(); &#125; private static void joinTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; try &#123; for(int i = 0; i &lt; 5; i++) &#123; System.out.println("线程在运行。"); Thread.sleep(1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); Thread.sleep(1000); thread.join(); System.out.println("主线程正常结束。"); &#125;&#125; 我们可以试着将thread.join();注释或者删除，再次运行程序，就可以发现不同了。 线程间通信我们知道，一个进程下面的所有线程是共享内存空间的，那么我们如何在不同的线程之间传递消息呢？在回顾 Java I/O时，我们谈到了PipedStream和PipedReader，这里，就是它们发挥作用的地方了。 下面的两个示例，功能完全一样，不同的是一个使用Stream，一个使用Reader/Writer。 PipeInputStream/PipedOutpueStream 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void communicationTest() throws IOException, InterruptedException&#123; final PipedOutputStream pos = new PipedOutputStream(); final PipedInputStream pis = new PipedInputStream(pos); Thread thread1 = new Thread() &#123; public void run() &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; while(true) &#123; String message = br.readLine(); pos.write(message.getBytes()); if (message.equals("end")) break; &#125; br.close(); pos.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; byte[] buffer = new byte[1024]; int bytesRead = 0; try &#123; while((bytesRead = pis.read(buffer, 0, buffer.length)) != -1) &#123; System.out.println(new String(buffer)); if (new String(buffer).equals("end")) break; buffer = null; buffer = new byte[1024]; &#125; pis.close(); buffer = null; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; PipedReader/PipedWriter 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private static void communicationTest2() throws InterruptedException, IOException&#123; final PipedWriter pw = new PipedWriter(); final PipedReader pr = new PipedReader(pw); final BufferedWriter bw = new BufferedWriter(pw); final BufferedReader br = new BufferedReader(pr); Thread thread1 = new Thread() &#123; public void run() &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; while(true) &#123; String message = br.readLine(); bw.write(message); bw.newLine(); bw.flush(); if (message.equals("end")) break; &#125; br.close(); pw.close(); bw.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; String line = null; try &#123; while((line = br.readLine()) != null) &#123; System.out.println(line); if (line.equals("end")) break; &#125; br.close(); pr.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; Java多线程同步线程同步话题。这是比多线程更复杂，稍不留意，我们就会“掉到坑里”，而且和单线程程序不同，多线程的错误是否每次都出现，也是不固定的，这给调试也带来了很大的挑战。 我们首先阐述什么是同步，不同步有什么问题，然后讨论可以采取哪些措施控制同步，接下来我们会仿照回顾网络通信时那样，构建一个服务器端的“线程池”，JDK为我们提供了一个很大的concurrent工具包，最后我们会对里面的内容进行探索。 为什么要线程同步？说到线程同步，大部分情况下，我们是在针对“单对象多线程”的情况进行讨论，一般会将其分成两部分，一部分是关于“共享变量”，一部分关于“执行步骤”。 共享变量当我们在线程对象（Runnable）中定义了全局变量，run方法会修改该变量时，如果有多个线程同时使用该线程对象，那么就会造成全局变量的值被同时修改，造成错误。我们来看下面的代码： 共享变量造成同步问题12345678910111213141516171819202122232425262728293031323334class MyRunner implements Runnable&#123; public int sum = 0; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + sum); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest() throws InterruptedException&#123; MyRunner runner = new MyRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 这个示例中，线程用来计算1到100的和是多少，我们知道正确结果是5050（好像是高斯小时候玩过这个？），但是上述程序返回的结果是10100，原因是两个线程同时对sum进行操作。 执行步骤我们在多个线程运行时，可能需要某些操作合在一起作为“原子操作”，即在这些操作可以看做是“单线程”的，例如我们可能希望输出结果的样子是这样的： 1234561 线程1：步骤12 线程1：步骤23 线程1：步骤34 线程2：步骤15 线程2：步骤26 线程2：步骤3 如果同步控制不好，出来的样子可能是这样的： 123456线程1：步骤1线程2：步骤1线程1：步骤2线程2：步骤2线程1：步骤3线程2：步骤3 这里我们也给出一个示例代码： 执行步骤混乱带来的同步问题123456789101112131415161718192021222324252627282930313233class MyNonSyncRunner implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for(int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " Running step " + i); try &#123; Thread.sleep(50); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void syncTest() throws InterruptedException&#123; MyNonSyncRunner runner = new MyNonSyncRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 如何控制线程同步既然线程同步有上述问题，那么我们应该如何去解决呢？针对不同原因造成的同步问题，我们可以采取不同的策略。 控制共享变量我们可以采取3种方式来控制共享变量。 将“单对象多线程”修改成“多对象多线程” 上文提及，同步问题一般发生在“单对象多线程”的场景中，那么最简单的处理方式就是将运行模型修改成“多对象多线程”的样子，针对上面示例中的同步问题，修改后的代码如下： 解决共享变量问题方案一1234567891011private static void sharedVaribleTest2() throws InterruptedException&#123; Thread thread1 = new Thread(new MyRunner()); Thread thread2 = new Thread(new MyRunner()); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们可以看到，上述代码中两个线程使用了两个不同的Runnable实例，它们在运行过程中，就不会去访问同一个全局变量。 将“全局变量”降级为“局部变量”既然是共享变量造成的问题，那么我们可以将共享变量改为“不共享”，即将其修改为局部变量。这样也可以解决问题，同样针对上面的示例，这种解决方式的代码如下： 解决共享变量问题方案二123456789101112131415161718192021222324252627282930313233class MyRunner2 implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + sum); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest3() throws InterruptedException&#123; MyRunner2 runner = new MyRunner2(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们可以看出，sum变量已经由全局变量变为run方法内部的局部变量了。 使用ThreadLocal机制ThreadLocal是JDK引入的一种机制，它用于解决线程间共享变量，使用ThreadLocal声明的变量，即使在线程中属于全局变量，针对每个线程来讲，这个变量也是独立的。 我们可以用这种方式来改造上面的代码，如下所示： 解决共享变量问题方案三1234567891011121314151617181920212223242526272829303132333435363738394041class MyRunner3 implements Runnable&#123; public ThreadLocal&lt;Integer&gt; tl = new ThreadLocal&lt;Integer&gt;(); public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for (int i = 0; i &lt;= 100; i++) &#123; if (tl.get() == null) &#123; tl.set(new Integer(0)); &#125; int sum = ((Integer)tl.get()).intValue(); sum+= i; tl.set(new Integer(sum)); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + ((Integer)tl.get()).intValue()); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest4() throws InterruptedException&#123; MyRunner3 runner = new MyRunner3(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 综上三种方案，第一种方案会降低多线程执行的效率，因此，我们推荐使用第二种或者第三种方案。 控制执行步骤说到执行步骤，我们可以使用synchronized关键字来解决它。 执行步骤问题解决方案123456789101112131415161718192021222324252627282930313233343536class MySyncRunner implements Runnable&#123; public void run() &#123; synchronized(this) &#123; System.out.println(Thread.currentThread().getName() + " Start."); for(int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " Running step " + i); try &#123; Thread.sleep(50); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;&#125;private static void syncTest2() throws InterruptedException&#123; MySyncRunner runner = new MySyncRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 在线程同步的话题上，synchronized是一个非常重要的关键字。它的原理和数据库中事务锁的原理类似。我们在使用过程中，应该尽量缩减synchronized覆盖的范围,原因有二： 被它覆盖的范围是串行的，效率低； 容易产生死锁。 我们来看下面的示例： synchronized示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private static void syncTest3() throws InterruptedException&#123; final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Thread thread1 = new Thread() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); Random r = new Random(100); synchronized(list) &#123; for (int i = 0; i &lt; 5; i++) &#123; list.add(new Integer(r.nextInt())); &#125; System.out.println("The size of list is " + list.size()); &#125; try &#123; Thread.sleep(500); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); Random r = new Random(100); synchronized(list) &#123; for (int i = 0; i &lt; 5; i++) &#123; list.add(new Integer(r.nextInt())); &#125; System.out.println("The size of list is " + list.size()); &#125; try &#123; Thread.sleep(500); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;; thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们应该把需要同步的内容集中在一起，尽量不包含其他不相关的、消耗大量资源的操作，示例中线程休眠的操作显然不应该包括在里面。 构造线程池我们在Java网络通信中，已经构建了一个Socket连接池，这里我们在此基础上，构建一个线程池，完成基本的启动、休眠、唤醒、停止操作。 基本思路还是以数组的形式保持一系列线程，通过Socket通信，客户端向服务器端发送命令，当服务器端接收到命令后，根据收到的命令对线程数组中的线程进行操作。 Socket客户端的代码保持不变，依然采用构建Socket连接池时的代码，我们主要针对服务器端进行改造。 首先，我们需要定义一个线程对象，它用来执行我们的业务操作，这里简化起见，只让线程进行休眠。 定义线程对象12345678910111213141516171819202122232425262728293031323334353637383940enum ThreadStatus&#123; Initial, Running, Sleeping, Stopped&#125;enum ThreadTask&#123; Start, Stop, Sleep, Wakeup&#125;class MyThread extends Thread&#123; public ThreadStatus status = ThreadStatus.Initial; public ThreadTask task; public void run() &#123; status = ThreadStatus.Running; while(true) &#123; try &#123; Thread.sleep(3000); if (status == ThreadStatus.Sleeping) &#123; System.out.println(Thread.currentThread().getName() + " 进入休眠状态。"); this.wait(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + " 运行过程中出现错误。"); status = ThreadStatus.Stopped; &#125; &#125; &#125;&#125; 然后，我们需要定义一个线程管理器，它用来对线程池中的线程进行管理，代码如下： 定义线程池管理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyThreadManager&#123; public static void manageThread(MyThread[] threads, ThreadTask task) &#123; for (int i = 0; i &lt; threads.length; i++) &#123; synchronized(threads[i]) &#123; manageThread(threads[i], task); &#125; &#125; System.out.println(getThreadStatus(threads)); &#125; public static void manageThread(MyThread thread, ThreadTask task) &#123; if (task == ThreadTask.Start) &#123; if (thread.status == ThreadStatus.Running) &#123; return; &#125; if (thread.status == ThreadStatus.Stopped) &#123; thread = new MyThread(); &#125; thread.status = ThreadStatus.Running; thread.start(); &#125; else if (task == ThreadTask.Stop) &#123; if (thread.status != ThreadStatus.Stopped) &#123; thread.interrupt(); thread.status = ThreadStatus.Stopped; &#125; &#125; else if (task == ThreadTask.Sleep) &#123; thread.status = ThreadStatus.Sleeping; &#125; else if (task == ThreadTask.Wakeup) &#123; thread.notify(); thread.status = ThreadStatus.Running; &#125; &#125; public static String getThreadStatus(MyThread[] threads) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; threads.length; i++) &#123; sb.append(threads[i].getName() + "的状态：" + threads[i].status).append("\r\n"); &#125; return sb.toString(); &#125;&#125; 最后，是我们的服务器端，它不断接受客户端的请求，每收到一个连接请求，服务器端会新开一个线程，来处理后续客户端发来的各种操作指令。 定义服务器端线程池对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MyThreadPool &#123; public static void main(String[] args) throws IOException &#123; MyThreadPool pool = new MyThreadPool(5); &#125; private int threadCount; private MyThread[] threads = null; public MyThreadPool(int count) throws IOException &#123; this.threadCount = count; threads = new MyThread[count]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); threads[i].start(); &#125; Init(); &#125; private void Init() throws IOException &#123; ServerSocket serverSocket = new ServerSocket(5678); while(true) &#123; final Socket socket = serverSocket.accept(); Thread thread = new Thread() &#123; public void run() &#123; try &#123; System.out.println("检测到一个新的Socket连接。"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); String line = null; while((line = br.readLine()) != null) &#123; System.out.println(line); if (line.equals("Count")) &#123; System.out.println("线程池中有5个线程"); &#125; else if (line.equals("Status")) &#123; String status = MyThreadManager.getThreadStatus(threads); System.out.println(status); &#125; else if (line.equals("StartAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Start); &#125; else if (line.equals("StopAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Stop); &#125; else if (line.equals("SleepAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Sleep); &#125; else if (line.equals("WakeupAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Wakeup); &#125; else if (line.equals("End")) &#123; break; &#125; else &#123; System.out.println("Command:" + line); &#125; ps.println("OK"); ps.flush(); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread.start(); &#125; &#125;&#125; 探索JDK中的concurrent工具包为了简化开发人员在进行多线程开发时的工作量，并减少程序中的bug，JDK提供了一套concurrent工具包，我们可以用它来方便的开发多线程程序。 线程池 我们在上面实现了一个非常“简陋”的线程池，concurrent工具包中也提供了线程池，而且使用非常方便。 concurrent工具包中的线程池分为3类：ScheduledThreadPool、FixedThreadPool和CachedThreadPool。 首先我们来定义一个Runnable的对象 定义Runnable对象12345678910111213141516171819class MyRunner implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + "运行开始"); for(int i = 0; i &lt; 1; i++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "正在运行"); Thread.sleep(200); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "运行结束"); &#125;&#125; 可以看出，它的功能非常简单，只是输出了线程的执行过程。 ScheduledThreadPool这和我们平时使用的ScheduledTask比较类似，或者说很像Timer，它可以使得一个线程在指定的一段时间内开始运行，并且在间隔另外一段时间后再次运行，直到线程池关闭。 ScheduledThreadPool示例123456789101112131415161718192021ScheduledThreadPool示例private static void scheduledThreadPoolTest()&#123; final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3); MyRunner runner = new MyRunner(); final ScheduledFuture&lt;?&gt; handler1 = scheduler.scheduleAtFixedRate(runner, 1, 10, TimeUnit.SECONDS); final ScheduledFuture&lt;?&gt; handler2 = scheduler.scheduleWithFixedDelay(runner, 2, 10, TimeUnit.SECONDS); scheduler.schedule(new Runnable() &#123; public void run() &#123; handler1.cancel(true); handler2.cancel(true); scheduler.shutdown(); &#125; &#125;, 30, TimeUnit.SECONDS );&#125; FixedThreadPool这是一个指定容量的线程池，即我们可以指定在同一时间，线程池中最多有多个线程在运行，超出的线程，需要等线程池中有空闲线程时，才能有机会运行。 FixedThreadPool示例12345678910private static void fixedThreadPoolTest()&#123; ExecutorService exec = Executors.newFixedThreadPool(3); for(int i = 0; i &lt; 5; i++) &#123; MyRunner runner = new MyRunner(); exec.execute(runner); &#125; exec.shutdown();&#125; 注意它的输出结果： 123456789101112131415pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行开始pool-1-thread-3正在运行pool-1-thread-1运行结束pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行结束pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行结束pool-1-thread-1运行结束pool-1-thread-2运行结束 可以看到从始至终，最多有3个线程在同时运行。 CachedThreadPool这是另外一种线程池，它不需要指定容量，只要有需要，它就会创建新的线程。 它的使用方式和FixedThreadPool非常像，来看下面的代码： CachedThreadPool示例1234567891011private static void cachedThreadPoolTest()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++) &#123; MyRunner runner = new MyRunner(); exec.execute(runner); &#125; exec.shutdown();&#125; 它的执行结果如下： 123456789101112131415pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行开始pool-1-thread-3正在运行pool-1-thread-4运行开始pool-1-thread-4正在运行pool-1-thread-5运行开始pool-1-thread-5正在运行pool-1-thread-1运行结束pool-1-thread-2运行结束pool-1-thread-3运行结束pool-1-thread-4运行结束pool-1-thread-5运行结束 可以看到，它创建了5个线程。 处理线程返回值在有些情况下，我们需要使用线程的返回值，在上述的所有代码中，线程这是执行了某些操作，没有任何返回值。 如何做到这一点呢？我们可以使用JDK中的Callable和CompletionService，前者返回单个线程的结果，后者返回一组线程的结果。 返回单个线程的结果 还是直接看代码吧： Callable示例1234567891011121314private static void callableTest() throws InterruptedException, ExecutionException&#123; ExecutorService exec = Executors.newFixedThreadPool(1); Callable&lt;String&gt; call = new Callable&lt;String&gt;() &#123; public String call() &#123; return "Hello World."; &#125; &#125;; Future&lt;String&gt; result = exec.submit(call); System.out.println("线程的返回值是" + result.get()); exec.shutdown();&#125; 线程的返回值是Hello World. 返回线程池中每个线程的结果 这里需要使用CompletionService，代码如下： CompletionService示例123456789101112131415161718192021222324private static void completionServiceTest() throws InterruptedException, ExecutionException&#123; ExecutorService exec = Executors.newFixedThreadPool(10); CompletionService&lt;String&gt; service = new ExecutorCompletionService&lt;String&gt;(exec); for (int i = 0; i &lt; 10; i++) &#123; Callable&lt;String&gt; call = new Callable&lt;String&gt;() &#123; public String call() throws InterruptedException &#123; return Thread.currentThread().getName(); &#125; &#125;; service.submit(call); &#125; Thread.sleep(1000); for(int i = 0; i &lt; 10; i++) &#123; Future&lt;String&gt; result = service.take(); System.out.println("线程的返回值是" + result.get()); &#125; exec.shutdown();&#125; 执行结果如下： 12345678910线程的返回值是pool-2-thread-1线程的返回值是pool-2-thread-2线程的返回值是pool-2-thread-3线程的返回值是pool-2-thread-5线程的返回值是pool-2-thread-4线程的返回值是pool-2-thread-6线程的返回值是pool-2-thread-8线程的返回值是pool-2-thread-7线程的返回值是pool-2-thread-9线程的返回值是pool-2-thread-10 实现生产者-消费者模型对于生产者-消费者模型来说，我们应该都不会陌生，通常我们都会使用某种数据结构来实现它。在concurrent工具包中，我们可以使用BlockingQueue来实现生产者-消费者模型，如下： BlockingQueue示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class BlockingQueueSample &#123; public static void main(String[] args) &#123; blockingQueueTest(); &#125; private static void blockingQueueTest() &#123; final BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;(); final int maxSleepTimeForSetter = 10; final int maxSleepTimerForGetter = 10; Runnable setter = new Runnable() &#123; public void run() &#123; Random r = new Random(); while(true) &#123; int value = r.nextInt(100); try &#123; queue.put(new Integer(value)); System.out.println(Thread.currentThread().getName() + &quot;---向队列中插入值&quot; + value); Thread.sleep(r.nextInt(maxSleepTimeForSetter) * 1000); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable getter = new Runnable() &#123; public void run() &#123; Random r = new Random(); while(true) &#123; try &#123; if (queue.size() == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;---队列为空&quot;); &#125; else &#123; int value = queue.take().intValue(); System.out.println(Thread.currentThread().getName() + &quot;---从队列中获取值&quot; + value); &#125; Thread.sleep(r.nextInt(maxSleepTimerForGetter) * 1000); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;; ExecutorService exec = Executors.newFixedThreadPool(2); exec.execute(setter); exec.execute(getter); &#125;&#125; 我们定义了两个线程，一个线程向Queue中添加数据，一个线程从Queue中取数据。我们可以通过控制maxSleepTimeForSetter和maxSleepTimerForGetter的值，来使得程序得出不同的结果。 可能的执行结果如下： 123456789101112131415161718pool-1-thread-1---向队列中插入值88pool-1-thread-2---从队列中获取值88pool-1-thread-1---向队列中插入值75pool-1-thread-2---从队列中获取值75pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-1---向队列中插入值50pool-1-thread-2---从队列中获取值50pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-1---向队列中插入值51pool-1-thread-1---向队列中插入值92pool-1-thread-2---从队列中获取值51pool-1-thread-2---从队列中获取值92 因为Queue中的值和Thread的休眠时间都是随机的，所以执行结果也不是固定的。 使用信号量来控制线程JDK提供了Semaphore来实现“信号量”的功能，它提供了两个方法分别用于获取和释放信号量：acquire和release，示例代码如下： SemaPhore示例1234567891011121314151617181920212223242526272829private static void semaphoreTest()&#123; ExecutorService exec = Executors.newFixedThreadPool(10); final Semaphore semp = new Semaphore(2); for (int i = 0; i &lt; 10; i++) &#123; Runnable runner = new Runnable() &#123; public void run() &#123; try &#123; semp.acquire(); System.out.println(new Date() + " " + Thread.currentThread().getName() + "正在执行。"); Thread.sleep(5000); semp.release(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; exec.execute(runner); &#125; exec.shutdown();&#125; 执行结果如下： 12345678910Tue May 07 11:22:11 CST 2013 pool-1-thread-1正在执行。Tue May 07 11:22:11 CST 2013 pool-1-thread-2正在执行。Tue May 07 11:22:17 CST 2013 pool-1-thread-3正在执行。Tue May 07 11:22:17 CST 2013 pool-1-thread-4正在执行。Tue May 07 11:22:22 CST 2013 pool-1-thread-5正在执行。Tue May 07 11:22:22 CST 2013 pool-1-thread-6正在执行。Tue May 07 11:22:27 CST 2013 pool-1-thread-7正在执行。Tue May 07 11:22:27 CST 2013 pool-1-thread-8正在执行。Tue May 07 11:22:32 CST 2013 pool-1-thread-10正在执行。Tue May 07 11:22:32 CST 2013 pool-1-thread-9正在执行。 可以看出，尽管线程池中创建了10个线程，但是同时运行的，只有2个线程。 控制线程池中所有线程的执行步骤在前面，我们已经提到，可以用synchronized关键字来控制单个线程中的执行步骤，那么如果我们想要对线程池中的所有线程的执行步骤进行控制的话，应该如何实现呢？ 我们有两种方式，一种是使用CyclicBarrier，一种是使用CountDownLatch。 CyclicBarrier使用了类似于Object.wait的机制，它的构造函数中需要接收一个整型数字，用来说明它需要控制的线程数目，当在线程的run方法中调用它的await方法时，它会保证所有的线程都执行到这一步，才会继续执行后面的步骤。 示例代码如下： CyclicBarrier示例1234567891011121314151617181920212223242526272829303132333435363738class MyRunner2 implements Runnable&#123; private CyclicBarrier barrier = null; public MyRunner2(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public void run() &#123; Random r = new Random(); try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(r.nextInt(10) * 1000); System.out.println(new Date() + "--" + Thread.currentThread().getName() + "--第" + (i + 1) + "次等待。"); barrier.await(); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;private static void cyclicBarrierTest()&#123; CyclicBarrier barrier = new CyclicBarrier(3); ExecutorService exec = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 3; i++) &#123; exec.execute(new MyRunner2(barrier)); &#125; exec.shutdown();&#125; 执行结果如下： 123456789Tue May 07 11:31:20 CST 2013--pool-1-thread-2--第1次等待。Tue May 07 11:31:21 CST 2013--pool-1-thread-3--第1次等待。Tue May 07 11:31:24 CST 2013--pool-1-thread-1--第1次等待。Tue May 07 11:31:24 CST 2013--pool-1-thread-1--第2次等待。Tue May 07 11:31:26 CST 2013--pool-1-thread-3--第2次等待。Tue May 07 11:31:30 CST 2013--pool-1-thread-2--第2次等待。Tue May 07 11:31:32 CST 2013--pool-1-thread-1--第3次等待。Tue May 07 11:31:33 CST 2013--pool-1-thread-3--第3次等待。Tue May 07 11:31:33 CST 2013--pool-1-thread-2--第3次等待。 可以看出，thread-2到第1次等待点时，一直等到thread-1到达后才继续执行。 CountDownLatch则是采取类似”倒计时计数器”的机制来控制线程池中的线程，它有CountDown和Await两个方法。示例代码如下： CountDownLatch示例123456789101112131415161718192021222324252627282930313233343536private static void countdownLatchTest() throws InterruptedException&#123; final CountDownLatch begin = new CountDownLatch(1); final CountDownLatch end = new CountDownLatch(5); ExecutorService exec = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 5; i++) &#123; Runnable runner = new Runnable() &#123; public void run() &#123; Random r = new Random(); try &#123; begin.await(); System.out.println(Thread.currentThread().getName() + "运行开始"); Thread.sleep(r.nextInt(10)*1000); System.out.println(Thread.currentThread().getName() + "运行结束"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; end.countDown(); &#125; &#125; &#125;; exec.execute(runner); &#125; begin.countDown(); end.await(); System.out.println(Thread.currentThread().getName() + "运行结束"); exec.shutdown();&#125; 执行结果如下： 1234567891011pool-1-thread-1运行开始pool-1-thread-5运行开始pool-1-thread-2运行开始pool-1-thread-3运行开始pool-1-thread-4运行开始pool-1-thread-2运行结束pool-1-thread-1运行结束pool-1-thread-3运行结束pool-1-thread-5运行结束pool-1-thread-4运行结束main运行结束 Java集合Java中的集合（Collection）。集合是编程语言中基础的一部分，Java自JDK早期，就引入了Java Collection Framework。设计JCF的那个人，后来还写了一本书，叫《Effective Java》。 Java中的集合主要集中在2部分，一部分是java.util包中，一部分是java.util.concurrent中，后者是在前者的基础上，定义了一些实现了同步功能的集合。 这篇文章主要关注java.util下的各种集合对象。Java中的集合对象可以粗略的分为3类：List、Set和Map。 完整清晰版图片请参见：http://files.cnblogs.com/wing011203/java_collection_structure.zip，解压缩后就可以看到未经缩放的版本。 Collection概述Java集合中的List和Set都从Collection出来，它是一个学习集合很不错的入口，它包含了集合中通常需要有的操作： 添加元素：add/addAll 清空集合：clear 删除元素：remove/removeAll 判断集合中是否包含某元素：contains/containsAll 判断集合是否为空：isEmpty 计算集合中元素的个数：size 将集合转换为数组：toArray 获取迭代器：iterator 我们来看一个简单的例子，下面的代码会返回一个集合，集合中的元素是随机生成的整数： 1234567891011private static Collection initCollection()&#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; collection.add(new Integer(r.nextInt(100))); &#125; return collection;&#125; 在对集合进行操作的过程中，遍历是一个经常使用的操作，我们可以使用两种方式对集合进行遍历： 使用迭代器对集合进行遍历。正如上面描述Collection接口时所说，所有集合都会有一个迭代器，我们可以用它来遍历集合。 123456789private static void accessCollectionByIterator(Collection&lt;Integer&gt; collection)&#123; Iterator&lt;Integer&gt; iterator = collection.iterator(); System.out.println("The value in the list:"); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; 使用foreach遍历集合。 12345678private static void accessCollectionByFor(Collection&lt;Integer&gt; collection)&#123; System.out.println("The value in the list:"); for(Integer value : collection) &#123; System.out.println(value); &#125;&#125; List Java中的List是对数组的有效扩展，它是这样一种结构，如果不使用泛型，它可以容纳任何类型的元素，如果使用泛型，那么它只能容纳泛型指定的类型的元素。和数组相比，List的容量是可以动态扩展的。 List中的元素是可以重复的，里面的元素是“有序”的，这里的“有序”，并不是排序的意思，而是说我们可以对某个元素在集合中的位置进行指定。 List中常用的集合对象包括：ArrayList、Vector和LinkedList，其中前两者是基于数组来进行存储，后者是基于链表进行存储。其中Vector是线程安全的，其余两个不是线程安全的。 List中是可以包括null的，即使是使用了泛型。 ArrayList可能是我们平时用到的最多的集合对象了，在上述的示例代码中，我们也是使用它来实例化一个Collection对象，在此不再赘述。 Vector Vector的示例如下，首先我们看如何生成和输出Vector： 1234567891011private static void vectorTest1()&#123; List&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); for (int i = 0 ; i &lt; 5; i++) &#123; list.add(new Integer(100)); &#125; list.add(null); System.out.println("size of vector is " + list.size()); System.out.println(list);&#125; 它的元素中，既包括了重复元素，也包括了null，输出结果如下： 12size of vector is 6[100, 100, 100, 100, 100, null] 下面的示例，演示了Vector中的一些常用方法： 12345678910111213141516171819202122private static void vectorTest2()&#123; Vector&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 10; i++) &#123; list.add(new Integer(r.nextInt(100))); &#125; System.out.println("size of vector is " + list.size()); System.out.println(list); System.out.println(list.firstElement()); System.out.println(list.lastElement()); System.out.println(list.subList(3, 8)); List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for(int i = 4; i &lt; 7; i++) &#123; temp.add(list.get(i)); &#125; list.retainAll(temp); System.out.println("size of vector is " + list.size()); System.out.println(list);&#125; 它的输出结果如下： 1234567size of vector is 10[39, 41, 20, 9, 29, 32, 54, 12, 94, 82]3982[9, 29, 32, 54, 12]size of vector is 3[29, 32, 54] LinkedList LinkedList使用链表来存储数据，它的示例代码如下： 12345678910111213141516171819202122232425private static void linkedListTest1()&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 10; i++) &#123; list.add(new Integer(r.nextInt(100))); &#125; list.add(null); System.out.println("size of linked list is " + list.size()); System.out.println(list); System.out.println(list.element()); System.out.println(list.getFirst()); System.out.println(list.getLast()); System.out.println(list.peek()); System.out.println(list.peekFirst()); System.out.println(list.peekLast()); System.out.println(list.poll()); System.out.println(list.pollFirst()); System.out.println(list.pollLast()); System.out.println(list.pop()); list.push(new Integer(100)); System.out.println("size of linked list is " + list.size()); System.out.println(list);&#125; 这里列出了LinkedList常用的各个方法，从方法名可以看出，LinkedList也可以用来实现栈和队列。 输出结果如下： 12345678910size of linked list is 11[17, 21, 5, 84, 19, 57, 68, 26, 27, 47, null]17null17null21nullsize of linked list is 8[100, 84, 19, 57, 68, 26, 27, 47] Set Set 和List类似，都是用来存储单个元素，单个元素的数量不确定。但Set不能包含重复元素，如果向Set中插入两个相同元素，那么后一个元素不会被插入。 Set可以大致分为两类：不排序Set和排序Set，不排序Set包括HashSet和LinkedHashSet，排序Set主要指TreeSet。其中HashSet和LinkedHashSet可以包含null。 HashSet HashSet是由Hash表支持的一种集合，它不是线程安全的。 我们来看下面的示例，它和Vector的第一个示例基本上是相同的： 12345678910111213private static void hashSetTest1()&#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; 3; i++) &#123; set.add(new Integer(100)); &#125; set.add(null); System.out.println("size of set is " + set.size()); System.out.println(set);&#125; 这里，HashSet中没有包含重复元素，但包含了null，和Vector不同，这里的输出结果如下： 12size of set is 2[null, 100] 对于HashSet是如何判断两个元素是否是重复的，我们可以深入考察一下。Object中也定义了equals方法，对于HashSet中的元素，它是根据equals方法来判断元素是否相等的，为了证明这一点，我们可以定义个“不正常”的类型： 123456789101112131415161718192021222324class MyInteger&#123; private Integer value; public MyInteger(Integer value) &#123; this.value = value; &#125; public String toString() &#123; return String.valueOf(value); &#125; public int hashCode() &#123; return 1; &#125; public boolean equals(Object obj) &#123; return false; &#125;&#125; 可以看到，对于MyInteger来说，对于任意两个实例，我们都认为它是不相等的。 下面是对应的测试方法： 123456789101112private static void hashSetTest2()&#123; Set&lt;MyInteger&gt; set = new HashSet&lt;MyInteger&gt;(); for (int i = 0; i &lt; 3; i++) &#123; set.add(new MyInteger(100)); &#125; System.out.println("size of set is " + set.size()); System.out.println(set);&#125; 它的输出结果如下： 12size of set is 3[100, 100, 100] 可以看到，现在HashSet里有“重复”元素了，但对于MyInteger来说，它们不是“相同”的。 TreeSetTreeSet是支持排序的一种Set，它的父接口是SortedSet。 我们首先来看一下TreeSet都有哪些基本操作： 1234567891011121314151617181920private static void treeSetTest1()&#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; set.add(new Integer(r.nextInt(100))); &#125; System.out.println(set); System.out.println(set.first()); System.out.println(set.last()); System.out.println(set.descendingSet()); System.out.println(set.headSet(new Integer(50))); System.out.println(set.tailSet(new Integer(50))); System.out.println(set.subSet(30, 60)); System.out.println(set.floor(50)); System.out.println(set.ceiling(50));&#125; 它的输出结果如下： 123456789[8, 42, 48, 49, 53]853[53, 49, 48, 42, 8][8, 42, 48, 49][53][42, 48, 49, 53]4953 TreeSet中的元素，一般都实现了Comparable接口，默认情况下，对于Integer来说，SortedList是采用升序来存储的，我们也可以自定义Compare方式，例如以降序的方式来存储。 下面，我们首先重新定义Integer： 定义MyInteger2对象123456789101112131415161718192021222324252627282930class MyInteger2 implements Comparable&#123; public int value; public MyInteger2(int value) &#123; this.value = value; &#125; public int compareTo(Object arg0) &#123; MyInteger2 temp = (MyInteger2)arg0; if (temp == null) return -1; if (temp.value &gt; this.value) &#123; return 1; &#125; else if (temp.value &lt; this.value) &#123; return -1; &#125; return 0; &#125; public boolean equals(Object obj)&#123; return compareTo(obj) == 0; &#125; public String toString()&#123; return String.valueOf(value); &#125;&#125; 下面是测试代码： 12345678910111213141516private static void treeSetTest2()&#123; TreeSet&lt;Integer&gt; set1 = new TreeSet&lt;Integer&gt;(); TreeSet&lt;MyInteger2&gt; set2 = new TreeSet&lt;MyInteger2&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; int value = r.nextInt(100); set1.add(new Integer(value)); set2.add(new MyInteger2(value)); &#125; System.out.println("Set1 as below:"); System.out.println(set1); System.out.println("Set2 as below:"); System.out.println(set2);&#125; 代码的运行结果如我们所预期的那样，如下所示： 1234Set1 as below:[13, 41, 42, 45, 61]Set2 as below:[61, 45, 42, 41, 13] Map Map中存储的是“键值对”，和Set类似，Java中的Map也有两种：排序的和不排序的，不排序的包括HashMap、Hashtable和LinkedHashMap，排序的包括TreeMap。 非排序Map HashMap和Hashtable都是采取Hash表的方式进行存储，HashMap不是线程安全的，Hashtable是线程安全的，我们可以把HashMap看做是“简化”版的Hashtable。 HashMap是可以存储null的，无论是对Key还是对Value。Hashtable是不可以存储null的。 无论HashMap还是Hashtable，我们观察它的构造函数，就会发现它可以有两个参数：initialCapacity和loadFactor，默认情况下，initialCapacity等于16，loadFactor等于0.75。这和Hash表中可以存放的元素数目有关系，当元素数目超过initialCapacity*loadFactor时，会触发rehash方法，对hash表进行扩容。如果我们需要向其中插入过多元素，需要适当调整这两个参数。 我们首先来看HashMap的示例： 12345678910111213private static void hashMapTest1()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(new Integer(1), "a"); map.put(new Integer(2), "b"); map.put(new Integer(3), "c"); System.out.println(map); System.out.println(map.entrySet()); System.out.println(map.keySet()); System.out.println(map.values());&#125; 这会输出HashMap里的元素信息，如下所示。 1234&#123;1=a, 2=b, 3=c&#125;[1=a, 2=b, 3=c][1, 2, 3][a, b, c] 下面的示例是对null的演示： 1234567891011121314private static void hashMapTest2()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(null, null); map.put(null, null); map.put(new Integer(4), null); map.put(new Integer(5), null); System.out.println(map); System.out.println(map.entrySet()); System.out.println(map.keySet()); System.out.println(map.values());&#125; 执行结果如下： 1234&#123;null=null, 4=null, 5=null&#125;[null=null, 4=null, 5=null][null, 4, 5][null, null, null] 接下来我们演示Hashtable，和上述两个示例基本上完全一样（代码不再展开）： Hashtable示例12345678910111213141516171819202122232425262728private static void hashTableTest1()&#123; Map&lt;Integer,String&gt; table = new Hashtable&lt;Integer, String&gt;(); table.put(new Integer(1), "a"); table.put(new Integer(2), "b"); table.put(new Integer(3), "c"); System.out.println(table); System.out.println(table.entrySet()); System.out.println(table.keySet()); System.out.println(table.values());&#125;private static void hashTableTest2()&#123; Map&lt;Integer,String&gt; table = new Hashtable&lt;Integer, String&gt;(); table.put(null, null); table.put(null, null); table.put(new Integer(4), null); table.put(new Integer(5), null); System.out.println(table); System.out.println(table.entrySet()); System.out.println(table.keySet()); System.out.println(table.values());&#125; 执行结果如下： 12345678&#123;3=c, 2=b, 1=a&#125;[3=c, 2=b, 1=a][3, 2, 1][c, b, a]Exception in thread &quot;main&quot; java.lang.NullPointerException at java.util.Hashtable.put(Unknown Source) at sample.collections.MapSample.hashTableTest2(MapSample.java:61) at sample.collections.MapSample.main(MapSample.java:11) 可以很清楚的看到，当我们试图将null插入到hashtable中时，报出了空指针异常。 排序Map排序Map主要是指TreeMap，它对元素增、删、查操作时的时间复杂度都是O（log（n））。它不是线程安全的。 它的特点和TreeSet非常像，这里不再赘述。 Java序列化对象序列化。 首先，我们来讨论一下什么是序列化以及序列化的原理；然后给出一个简单的示例来演示序列化和反序列化；有时有些信息是不应该被序列化的，我们应该如何控制；我们如何去自定义序列化内容；最后我们讨论一下在继承结构的场景中，序列化需要注意哪些内容。 序列化概述 序列化，简单来讲，就是以“流”的方式来保存对象，至于保存的目标地址，可以是文件，可以是数据库，也可以是网络，即通过网络将对象从一个节点传递到另一个节点。 我们知道在Java的I/O结构中，有ObjectOutputStream和ObjectInputStream，它们可以实现将对象输出为二进制流，并从二进制流中获取对象，那为什么还需要序列化呢？这需要从Java变量的存储结构谈起，我们知道对Java来说，基础类型存储在栈上，复杂类型（引用类型）存储在堆中，对于基础类型来说，上述的操作时可行的，但对复杂类型来说，上述操作过程中，可能会产生重复的对象，造成错误。 而序列化的工作流程如下： 1. 输出流保存的对象都有一个唯一的序列号。 2. 个对象需要保存时，先对其序列号进行检查。 3. 当保存的对象中已包含该序列号时，不需要再次保存，否则，进入正常保存的流程。 正是通过序列号的机制，序列化才可以完整准确的保存对象的各个状态。 序列化保存的是对象中的各个属性的值，而不是方法或者方法签名之类的信息。对于方法或者方法签名，只要JVM能够找到正确的ClassLoader，那么就可以invoke方法。 序列化不会保存类的静态变量，因为静态变量是作用于类型，而序列化作用于对象。 简单的序列化示例 序列化的完整过程包括两部分： 1. 使用ObjectOutputStream将对象保存为二进制流，这一步叫做“序列化”。 2. 使用ObjectInputStream将二进制流转换成对象，这一步叫做“反序列化”。 下面我们来演示一个简单的示例，首先定义一个Person对象，它包含name和age两个信息。 定义Person对象1234567891011121314151617181920212223class Person implements Serializable&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 然后是两个公共方法，用来完成读、写对象的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void writeObject(Object obj, String filePath)&#123; try &#123; FileOutputStream fos = new FileOutputStream(filePath); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.flush(); fos.flush(); os.close(); fos.close(); System.out.println("序列化成功。"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125;private static Object readObject(String filePath)&#123; try &#123; FileInputStream fis = new FileInputStream(filePath); ObjectInputStream is = new ObjectInputStream(fis); Object temp = is.readObject(); fis.close(); is.close(); if (temp != null) &#123; System.out.println("反序列化成功。"); return temp; &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; return null;&#125; 这里，我们将对象保存的二进制流输出到磁盘文件中。 接下来，我们首先来看“序列化”的方法： 12345678private static void serializeTest1()&#123; Person person = new Person(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); writeObject(person, "d:\\temp\\test\\person.obj");&#125; 我们定义了一个Person实例，然后将其保存到d:\temp\test\person.obj中。 最后，是“反序列化”的方法： 123456789private static void deserializeTest1()&#123; Person temp = (Person)readObject("d:\\temp\\test\\person.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 它从d:\temp\test\person.obj中读取对象，然后进行输出。 上述两个方法的执行结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:30 可以看出，读取的对象和保存的对象是完全一致的。 隐藏非序列化信息 有时，我们的业务对象中会包含很多属性，而有些属性是比较隐私的，例如年龄、银行卡号等，这些信息是不太适合进行序列化的，特别是在需要通过网络来传输对象信息时，这些敏感信息很容易被窃取。 Java使用transient关键字来处理这种情况，针对那些敏感的属性，我们只需使用该关键字进行修饰，那么在序列化时，对应的属性值就不会被保存。 我们还是看一个实例，这次我们定义一个新的Person2，其中age信息是我们不希望序列化的： 12345678910111213141516171819202122class Person2 implements Serializable&#123; private String name; private transient int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 注意age的声明语句： 1private transient int age; 下面是“序列化”和“反序列化”的方法： 123456789101112131415161718private static void serializeTest2()&#123; Person2 person = new Person2(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); writeObject(person, "d:\\temp\\test\\person2.obj");&#125;private static void deserializeTest2()&#123; Person2 temp = (Person2)readObject("d:\\temp\\test\\person2.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 它的输出结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:0 可以看到经过反序列化的对象，age的信息变成了Integer的默认值0。 自定义序列化过程 我们可以对序列化的过程进行定制，进行更细粒度的控制。 思路是在业务模型中添加readObject和writeObject方法。下面看一个实例，我们新建一个类型，叫Person3： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person3 implements Serializable&#123; private String name; private transient int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; private void writeObject(ObjectOutputStream os) &#123; try &#123; os.defaultWriteObject(); os.writeObject(this.age); System.out.println(this); System.out.println("序列化成功。"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private void readObject(ObjectInputStream is) &#123; try &#123; is.defaultReadObject(); this.setAge(((Integer)is.readObject()).intValue() - 1); System.out.println("反序列化成功。"); System.out.println(this); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 请注意观察readObject和writeObject方法，它们都是private的，接受的参数是ObjectStream，然后在方法体内调用了defaultReadObject或者defaultWriteObject方法。 这里age同样是transient的，但是在保存对象的过程中，我们单独对其进行了保存，在读取时，我们将age信息读取出来，并进行了减1处理。 下面是测试方法： 1234567891011121314151617181920212223242526272829303132333435private static void serializeTest3()&#123; Person3 person = new Person3(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); try &#123; FileOutputStream fos = new FileOutputStream("d:\\temp\\test\\person3.obj"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(person); fos.close(); os.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125;private static void deserializeTest3()&#123; try &#123; FileInputStream fis = new FileInputStream("d:\\temp\\test\\person3.obj"); ObjectInputStream is = new ObjectInputStream(fis); is.readObject(); fis.close(); is.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125; 输出结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:29 可以看到，经过反序列化得到的对象，其age属性已经减1。 探讨serialVersionUID 在上文中，我们描述序列化原理时，曾经提及每个对象都会有一个唯一的序列号，这个序列号，就是serialVersionUID。 当我们的对象实现Serializable接口时，该接口可以为我们生成serialVersionUID。 有两种方式来生成serialVersionUID，一种是固定值：1L，一种是经过JVM计算，不同的JVM采取的计算算法可能不同。 下面就是两个serialVersionUID的示例： 12private static final long serialVersionUID = 1L;private static final long serialVersionUID = -2380764581294638541L; 第一行是采用固定值生成的；第二行是JVM经过计算得出的。 那么serialVersionUID还有其他用途吗？ 我们可以使用它来控制版本兼容。如果采用JVM生成的方式，我们可以看到，当我们业务对象的代码保持不变时，多次生成的serialVersionUID也是不变的，当我们对属性进行修改时，重新生成的serialVersionUID会发生变化，当我们对方法进行修改时，serialVersionUID不变。这也从另一个侧面说明，序列化是作用于对象属性上的。 当我们先定义了业务对象，然后对其示例进行了“序列化”，这时根据业务需求，我们修改了业务对象，那么之前“序列化”后的内容还能经过“反序列化”返回到系统中吗？这取决于业务对象是否定义了serialVersionUID，如果定义了，那么是可以返回的，如果没有定义，会抛出异常。 来看下面的示例，定义新的类型Person4： 1234567891011121314151617181920212223class Person4 implements Serializable&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; private void xxx()&#123;&#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 然后运行下面的方法： 12345678private static void serializeTest4()&#123; Person4 person = new Person4(); person.setName("Zhang San"); person.setAge(30); writeObject(person, "d:\\temp\\test\\person4.obj");&#125; 接下来修改Person4，追加address属性： 123456789101112131415161718192021222324252627282930class Person4 implements Serializable&#123; private String name; private int age; private String address; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; private void xxx()&#123;&#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getAddress() &#123; return address; &#125;&#125; 然后运行“反序列化”方法： 123456789private static void deserializeTest4()&#123; Person4 temp = (Person4)readObject("d:\\temp\\test\\person4.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 12345678910java.io.InvalidClassException: sample.serialization.Person4; local class incompatible: stream classdesc serialVersionUID = -2380764581294638541, local class serialVersionUID = -473458100724786987 at java.io.ObjectStreamClass.initNonProxy(Unknown Source) at java.io.ObjectInputStream.readNonProxyDesc(Unknown Source) at java.io.ObjectInputStream.readClassDesc(Unknown Source) at java.io.ObjectInputStream.readOrdinaryObject(Unknown Source) at java.io.ObjectInputStream.readObject0(Unknown Source) at java.io.ObjectInputStream.readObject(Unknown Source) at sample.serialization.Sample.readObject(Sample.java:158) at sample.serialization.Sample.deserializeTest4(Sample.java:105) at sample.serialization.Sample.main(Sample.java:16) 但是当我们在Person4中添加serialVersionUID后，再次执行上述各步骤，得出的运行结果如下： 12反序列化成功。Name:Zhang San; Age:30 有继承结构的序列化 业务对象会产生继承，这在管理系统中是经常看到的，如果我们有下面的业务对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person5&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; public Person5(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;class Employee extends Person5 implements Serializable&#123; public Employee(String name, int age) &#123; super(name, age); &#125; private String companyName; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyName() &#123; return companyName; &#125; public String toString() &#123; return "Name:" + super.getName() + "; Age:" + super.getAge() + "; Company:" + this.companyName; &#125;&#125; Employee继承在Person5，Employee实现了Serializable接口，Person5没有实现，那么运行下面的方法： 1234567891011121314151617private static void serializeTest5()&#123; Employee emp = new Employee("Zhang San", 30); emp.setCompanyName("XXX"); writeObject(emp, "d:\\temp\\test\\employee.obj");&#125;private static void deserializeTest5()&#123; Employee temp = (Employee)readObject("d:\\temp\\test\\employee.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 会正常运行吗？事实上不会，它会抛出如下异常： 123456789java.io.InvalidClassException: sample.serialization.Employee; no valid constructor at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(Unknown Source) at java.io.ObjectStreamClass.checkDeserialize(Unknown Source) at java.io.ObjectInputStream.readOrdinaryObject(Unknown Source) at java.io.ObjectInputStream.readObject0(Unknown Source) at java.io.ObjectInputStream.readObject(Unknown Source) at sample.serialization.Sample.readObject(Sample.java:158) at sample.serialization.Sample.deserializeTest5(Sample.java:123) at sample.serialization.Sample.main(Sample.java:18) 原因：在有继承层次的业务对象，进行序列化时，如果父类没有实现Serializable接口，那么父类必须提供默认构造函数。 我们为Person5添加如下默认构造函数： 12345public Person5() &#123; this.name = "Test"; this.age = 1; &#125; 再次运行上述代码，结果如下： 1234Name:Zhang San; Age:30; Company:XXX序列化成功。反序列化成功。Name:Test; Age:1; Company:XXX 可以看到，反序列化后的结果，父类中的属性，已经被父类构造函数中的赋值代替了！ 因此，我们推荐在有继承层次的业务对象进行序列化时，父类也应该实现Serializable接口。我们对Person5进行修改，使其实现Serializable接口，执行结果如下： 1234Name:Zhang San; Age:30; Company:XXX序列化成功。反序列化成功。Name:Zhang San; Age:30; Company:XXX 这正是我们期望的结果。 Java反射关注反射及其相关话题。 反射可以帮助我们查看指定类型中的信息、创建类型的实例，调用类型的方法。我们平时使用框架，例如Spring、EJB、Hibernate等都大量的使用了反射技术。 反射简单示例 下面来演示反射相关的基本操作 首先是基础代码，我们定义一个接口及其实现，作为我们反射操作的目标： 1234567891011121314151617181920212223interface HelloWorldService&#123; void sayHello(String name);&#125;class MyHelloWorld implements HelloWorldService&#123; public String name; public void sayHello(String name) &#123; System.out.println("Hello " + name + "."); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 获取方法及字段信息 下面的代码会输出给定类型中的方法和字段的声明信息： 12345678910111213141516private static void printClassTypeInfo(String type) throws ClassNotFoundException&#123; Class classType = Class.forName(type); Method[] methods = classType.getDeclaredMethods(); System.out.println("Methods info as below:"); for(Method method : methods) &#123; System.out.println(method.toGenericString()); &#125; Field[] fields = classType.getFields(); System.out.println("Fields info as below:"); for (Field field : fields) &#123; System.out.println(field.toGenericString()); &#125;&#125; 在使用反射时，我们一般会使用java.lang.reflect包中的内容。 然后我们调用下面的代码： 1printClassTypeInfo(&quot;sample.reflection.MyHelloWorld&quot;); 输出结果如下： 123456Methods info as below:public void sample.reflection.MyHelloWorld.sayHello(java.lang.String)public java.lang.String sample.reflection.MyHelloWorld.getName()public void sample.reflection.MyHelloWorld.setName(java.lang.String)Fields info as below:public java.lang.String sample.reflection.MyHelloWorld.name 实例化对象 我们可以使用class.netInstance的方式来创建一个对象，代码如下： 123456private static void createInstanceTest() throws ClassNotFoundException, InstantiationException, IllegalAccessException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); hello.sayHello("Zhang San");&#125; 输出结果： 1Hello Zhang San. 调用对象的方法 我们可以通过方法的名称以及参数类型构建一个Method实例，然后调用Method的invoke方法，来触发方法。 示例代码如下： 1234567private static void invokeMethodTest() throws InstantiationException, IllegalAccessException, ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); Method method = classType.getMethod("sayHello", new Class[]&#123;String.class&#125;); method.invoke(hello, new Object[]&#123;"Zhang San"&#125;);&#125; 输出结果同上。 修改字段的值 和C#不同，Java中一般使用setxxx和getxxx显示为属性赋值，因此Java中并没有Property类型，而是有Field类型。 我们可以对Field的值进行修改，代码如下： 123456789private static void setFieldTest() throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); System.out.println("name is " + hello.name); Field field = classType.getField("name"); field.set(hello, "Zhang San"); System.out.println("name is " + hello.name);&#125; 执行结果如下： 12name is nullname is Zhang San 可以看出，我们成功的修改了name的值。 Annotation探索 一开始我们提到，反射是很多技术的基础，Annotation就是这样的，我们可以把Annotation看做是C#中的Attribute，它可以对类型、方法、属性、字段、方法参数等信息进行修饰。我们可以使用“@+Annotation名”的方式来使用Annotation。 Annotation基本操作 来看下面的代码，我们定义了基于Type、Method、Parameter和Field上面的Annotation示例： 1234567891011121314151617181920212223242526272829303132@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@interface ClassAnnotation&#123; public String value();&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@interface MethodAnnotation&#123; public String methodName(); public String returnType();&#125;@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@Documented@interface ParameterAnnotation&#123; public String value();&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documented@interface FieldAnnotation&#123; public String value();&#125; 接着，我们定义了一个MyClass类型，使用了上述的Annotation： 123456789101112131415161718@ClassAnnotation("这是作用在类型上的Annotation")class MyClass&#123; @MethodAnnotation(methodName="printInfo", returnType="void") public void printInfo(String info) &#123; System.out.println(info); &#125; @MethodAnnotation(methodName="printError", returnType="void") public void printError(@ParameterAnnotation("这是作用在参数上的Annotation")String error) &#123; System.err.println(error); &#125; @FieldAnnotation("这是作用在字段上的Annotation") public int count;&#125; 对于使用了Annotation，我们可以获取其中的信息，下面两种方式都可以获取Annotation，第一种方式是通过反射遍历类型及其方法、字段，一一读取Annotation信息；第二种方式是读取指定类型的Annotation： 读取Annotation方式一1234567891011121314151617181920212223242526272829303132333435363738private static void annotationTest1()&#123; MyClass temp = new MyClass(); Annotation[] annotations = temp.getClass().getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; Method[] methods = temp.getClass().getDeclaredMethods(); for(Method method : methods) &#123; annotations = method.getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; Annotation[][] paraAnnotations = method.getParameterAnnotations(); for(int i = 0; i &lt; paraAnnotations.length; i++) &#123; for (Annotation a : paraAnnotations[i]) &#123; System.out.println(a.toString()); &#125; &#125; &#125; Field[] fields = temp.getClass().getFields(); for (Field field : fields) &#123; annotations = field.getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; &#125;&#125; 读取Annotation方式二12345678910111213141516171819202122232425262728293031323334private static void annotationTest2() throws ClassNotFoundException&#123; Class classType = Class.forName("sample.reflection.annotation.MyClass"); boolean flag = classType.isAnnotationPresent(ClassAnnotation.class); if (flag) &#123; ClassAnnotation annotation = (ClassAnnotation) classType.getAnnotation(ClassAnnotation.class); System.out.println(annotation.toString()); &#125; Method[] methods = classType.getMethods(); for(Method method : methods) &#123; if (method.isAnnotationPresent(MethodAnnotation.class)) &#123; System.out.println(((MethodAnnotation)method.getAnnotation(MethodAnnotation.class)).toString()); &#125; Annotation[][] paraAnnotations = method.getParameterAnnotations(); for(int i = 0; i &lt; paraAnnotations.length; i++) &#123; for (Annotation a : paraAnnotations[i]) &#123; System.out.println(a.toString()); &#125; &#125; &#125; Field[] fields = classType.getFields(); for (Field field:fields) &#123; if (field.isAnnotationPresent(FieldAnnotation.class)) &#123; System.out.println(((FieldAnnotation)field.getAnnotation(FieldAnnotation.class)).toString()); &#125; &#125;&#125; 上述两个方法的输出都是一样的，如下： 12345@sample.reflection.annotation.ClassAnnotation(value=这是作用在类型上的Annotation)@sample.reflection.annotation.MethodAnnotation(methodName=printInfo, returnType=void)@sample.reflection.annotation.MethodAnnotation(methodName=printError, returnType=void)@sample.reflection.annotation.ParameterAnnotation(value=这是作用在参数上的Annotation)@sample.reflection.annotation.FieldAnnotation(value=这是作用在字段上的Annotation) 在WebService中使用Annotation 上述代码看上去可能有些枯燥，不能显示出Annotation的威力，那么我们接下来看WebService，在WebService中，我们可以使用WebMethod、WebParam等Annotation来声明方法或者参数。 接下来，我们来实现一个非常简单的Web服务： 1234567891011121314151617181920212223@WebService(targetNamespace="http://test", serviceName="HelloService")public class HelloServiceProvider&#123; @WebResult(name="HelloString") @WebMethod public String sayHello(@WebParam(name="userName") String name) &#123; return "Hello " + name; &#125; @Oneway @WebMethod(action="userLogin", operationName="userLogin") public void login() &#123; System.out.println("User has logged on."); &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new HelloServicePublisher()); thread.start(); &#125;&#125; 然后定义一个Publisher： 1234567class HelloServicePublisher implements Runnable&#123; public void run() &#123; Endpoint.publish("http://localhost:8888/test/HelloService", new HelloServiceProvider()); &#125;&#125; 在命令行中，我们定位到源代码路径，执行下面的命令： 1wsgen -cp . HelloServiceProvider wsgen位于JDK的bin目录中。 然后我们启动HelloServiceProvider，在浏览器中输入如下地址：http://localhost:8888/test/HelloService，可以看到如下信息： 点击WSDL链接，可以看到： 1&lt;!-- Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --&gt;&lt;!-- Generated by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --&gt;&lt;definitions targetNamespace="http://test" name="HelloService"&gt;&lt;types&gt;&lt;xsd:schema&gt;&lt;xsd:import namespace="http://test" schemaLocation="http://localhost:8888/test/HelloService?xsd=1"/&gt;&lt;/xsd:schema&gt;&lt;/types&gt;&lt;message name="sayHello"&gt;&lt;part name="parameters" element="tns:sayHello"/&gt;&lt;/message&gt;&lt;message name="sayHelloResponse"&gt;&lt;part name="parameters" element="tns:sayHelloResponse"/&gt;&lt;/message&gt;&lt;message name="userLogin"&gt;&lt;part name="parameters" element="tns:userLogin"/&gt;&lt;/message&gt;&lt;portType name="HelloServiceProvider"&gt;&lt;operation name="sayHello"&gt;&lt;input wsam:Action="http://test/HelloServiceProvider/sayHelloRequest" message="tns:sayHello"/&gt;&lt;output wsam:Action="http://test/HelloServiceProvider/sayHelloResponse" message="tns:sayHelloResponse"/&gt;&lt;/operation&gt;&lt;operation name="userLogin"&gt;&lt;input wsam:Action="userLogin" message="tns:userLogin"/&gt;&lt;/operation&gt;&lt;/portType&gt;&lt;binding name="HelloServiceProviderPortBinding" type="tns:HelloServiceProvider"&gt;&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;&lt;operation name="sayHello"&gt;&lt;soap:operation soapAction=""/&gt;&lt;input&gt;&lt;soap:body use="literal"/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body use="literal"/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;operation name="userLogin"&gt;&lt;soap:operation soapAction="userLogin"/&gt;&lt;input&gt;&lt;soap:body use="literal"/&gt;&lt;/input&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name="HelloService"&gt;&lt;port name="HelloServiceProviderPort" binding="tns:HelloServiceProviderPortBinding"&gt;&lt;soap:address location="http://localhost:8888/test/HelloService"/&gt;&lt;/port&gt;&lt;/service&gt;&lt;/definitions&gt; JDK中自带了Web服务器，我们不需要把上述代码部署到其他服务器中。 动态代理机制 Spring中一大特色是AOP，面向方面编程也是框架设计一个趋势。对于业务中的共通操作，诸如记录日志、维护事务等，如果和业务逻辑纠缠在一起，会造成代码职责不清，后续维护困难等问题。利用AOP，我们可以很好的分离共通操作和业务操作。 下面我们来实现一个简单的AOP框架，要实现这样一个框架，需要3部分： InvocationHandler，来触发方法； Interceptor，来定义拦截器； DynamicProxy，来动态创建代理对象。 首先我们看Interptor的定义： 1234567interface AOPInterceptor&#123; public void before(Method method, Object[] args); public void after(Method method, Object[] args); public void afterThrowing(Method method, Object[] args); public void afterFinally(Method method, Object[] args);&#125; 接下来是InvocationHandler： 12345678910111213141516171819202122232425262728293031class DynamicProxyInvocationHandler implements InvocationHandler&#123; private Object target; private AOPInterceptor interceptor; public DynamicProxyInvocationHandler(Object target, AOPInterceptor interceptor) &#123; this.target = target; this.interceptor = interceptor; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; interceptor.before(method, args); Object returnValue = method.invoke(target, args); interceptor.after(method, args); return returnValue; &#125; catch(Throwable t) &#123; interceptor.afterThrowing(method, args); throw t; &#125; finally &#123; interceptor.afterFinally(method, args); &#125; &#125;&#125; 最后是DynamicProxy： 12345678class DynamicProxyFactoryImpl implements DynamicProxyFactory&#123; public &lt;T&gt; T createProxy(Class&lt;T&gt; clazz, T target, AOPInterceptor interceptor) &#123; InvocationHandler handler = new DynamicProxyInvocationHandler(target, interceptor); return (T)Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[] &#123;clazz&#125;, handler); &#125;&#125; 至此，我们构建了一个”简易“的AOP拦截器。下面我们来创建一些测试代码。 首先是实现AOPInterceptor接口： 12345678910111213141516171819class MyInterceptor implements AOPInterceptor&#123; public void after(Method method, Object[] args) &#123; System.out.println("方法执行结束。"); &#125; public void afterFinally(Method method, Object[] args) &#123; System.out.println("方法体Finally执行结束。"); &#125; public void afterThrowing(Method method, Object[] args) &#123; System.out.println("方法抛出异常。"); &#125; public void before(Method method, Object[] args) &#123; System.out.println("方法开始执行"); &#125;&#125; 然后利用本文一开始定义的HelloWorldService，来完成测试，需要在MyHello的sayHello方法最后，追加一行代码： 1throw new RuntimeException(); 接着是测试代码： 12345678private static void test()&#123; MyInterceptor interceptor = new MyInterceptor(); HelloWorldService hello = new MyHelloWorld(); DynamicProxyFactory factory = new DynamicProxyFactoryImpl(); HelloWorldService proxy = factory.createProxy(HelloWorldService.class, hello, interceptor); proxy.sayHello("Zhang San");&#125; 最终，执行结果如下： 123456789101112131415方法开始执行Hello Zhang San.方法抛出异常。方法体Finally执行结束。Exception in thread &quot;main&quot; java.lang.reflect.UndeclaredThrowableException at sample.reflection.dynamicproxy.$Proxy0.sayHello(Unknown Source) at sample.reflection.dynamicproxy.Sample.test(Sample.java:18) at sample.reflection.dynamicproxy.Sample.main(Sample.java:9)Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at sample.reflection.dynamicproxy.DynamicProxyInvocationHandler.invoke(Sample.java:60) ... 3 more 可以看出，我们已经在业务执行的前、后、异常抛出后以及finally执行后进行了拦截，达到了我们期望的效果。 Java一些基础概念地址下载：http://zangweiren.iteye.com/blog/241218 在看上述文章的时候，随手写了一些测试代码，以便加深理解。这也就是这篇文章的来源了。 类的初始化顺序 在Java中，类里面可能包含：静态变量，静态初始化块，成员变量，初始化块，构造函数。在类之间可能存在着继承关系，那么当我们实例化一个对象时，上述各部分的加载顺序是怎样的？ 首先来看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Parent&#123; public static StaticVarible staticVarible= new StaticVarible("父类-静态变量1"); public StaticVarible instVarible= new StaticVarible("父类-成员变量1"); static &#123; System.out.println("父类-静态块"); &#125; &#123; System.out.println("父类-初始化块"); &#125; public static StaticVarible staticVarible2= new StaticVarible("父类-静态变量2"); public StaticVarible instVarible2= new StaticVarible("父类-成员变量2"); public Parent() &#123; System.out.println("父类-实例构造函数"); &#125;&#125;class Child extends Parent&#123; public static StaticVarible staticVarible= new StaticVarible("子类-静态变量1"); public StaticVarible instVarible= new StaticVarible("子类-成员变量1"); static &#123; System.out.println("子类-静态块"); &#125; public Child() &#123; System.out.println("子类-实例构造函数"); &#125; &#123; System.out.println("子类-初始化块"); &#125; public static StaticVarible staticVarible2= new StaticVarible("子类-静态变量2"); public StaticVarible instVarible2= new StaticVarible("子类-成员变量2"); &#125;class StaticVarible&#123; public StaticVarible(String info) &#123; System.out.println(info); &#125;&#125; 然后执行下面的语句： 1Child child = new Child(); 输出结果如下： 1234567891011121314父类-静态变量1父类-静态块父类-静态变量2子类-静态变量1子类-静态块子类-静态变量2父类-成员变量1父类-初始化块父类-成员变量2父类-实例构造函数子类-成员变量1子类-初始化块子类-成员变量2子类-实例构造函数 结论 从上述结果可以看出，在实例化一个对象时，各部分的加载顺序如下： 父类静态成员/父类静态初始化块 -&gt; 子类静态成员/子类静态初始化块 -&gt; 父类成员变量/父类初始化块 -&gt; 父类构造函数 -&gt; 子类成员变量/子类初始化块 -&gt; 子类构造函数 和String相关的一些事儿 首先，我们聊一聊Java中堆和栈的事儿。 栈：存放基本类型，包括char/byte/short/int/long/float/double/boolean 堆：存放引用类型，同时一般会在栈中保留一个指向它的指针，垃圾回收判断一个对象是否可以回收，就是判断栈中是否有指针指向堆中的对象。 String作为一种特殊的数据类型，它不完全等同于基本类型，也不是全部的引用类型，许多面试题都有它的身影。 String类型变量的存储结构 String的存储结构分为两部分，我们以String a = “abc”;为例，描述String类型的存储方式： 1. 在栈中创建一个char数组，值分为是’a’，’b’，’c’。 2. 在堆中创建一个String对象。 Java中的字符串池 为了节省空间和资源，JVM会维护一个字符串池，或者说会缓存一部分曾经出现过的字符串。 例如下面的代码：12String v1 = &quot;ab&quot;;String v2 = &quot;ab&quot;; 实际上，v1==v2，因为JVM在v1声明后，已经对“ab”进行了缓存。 那么JVM对字符串进行缓存的依据是什么？我们来看下面的代码，非常有意思： 123456789101112131415161718192021222324252627282930313233public class StringTest &#123; public static final String constValue = "ab"; public static final String staticValue; static &#123; staticValue="ab"; &#125; public static void main(String[] args) &#123; String v1 = "ab"; String v2 = "ab"; System.out.println("v1 == v2 : " + (v1 == v2)); String v3 = new String("ab"); System.out.println("v1 == v3 : " + (v1 == v3)); String v4 = "abcd"; String v5 = "ab" + "cd"; System.out.println("v4 == v5 : " + (v4 == v5)); String v6 = v1 + "cd"; System.out.println("v4 == v6 : " + (v4 == v6)); String v7 = constValue + "cd"; System.out.println("v4 == v7 : " + (v4 == v7)); String v8 = staticValue + "cd"; System.out.println("v4 == v8 : " + (v4 == v8)); String v9 = v4.intern(); System.out.println("v4 == v9 :" + (v4 == v9)); String v10 = new String(new char[]&#123;'a','b','c','d'&#125;); String v11 = v10.intern(); System.out.println("v4 == v11 :" + (v4 == v11)); System.out.println("v10 == v11 :" + (v10 == v11)); &#125;&#125; 请注意它的输出结果： 123456789v1 == v2 : truev1 == v3 : falsev4 == v5 : truev4 == v6 : falsev4 == v7 : truev4 == v8 : falsev4 == v9 :truev4 == v11 :truev10 == v11 :false 我们会发现，并不是所有的判断都返回true，这似乎和我们上面的说法有矛盾了。其实不然，因为 结论 1. JVM只能缓存那些在编译时可以确定的常量，而非运行时常量。 上述代码中的constValue属于编译时常量，而staticValue则属于运行时常量。 2. 通过使用 new方式创建出来的字符串，JVM缓存的方式是不一样的。 所以上述代码中，v1不等同于v3。 String的这种设计属于享元模式吗？ 这个话题比较有意思，大部分讲设计模式的文章，在谈到享元时，一般就会拿String来做例子，但它属于享元模式吗？ 字符串与享元的关系，大家可以参考下面的文章：http://www.cnblogs.com/winter-cn/archive/2012/01/21/2328388.html 字符串的反转输出 这种情况下，一般会将字符串看做是字符数组，然后利用反转数组的方式来反转字符串。 眼花缭乱的方法调用有继承关系结构中的方法调用 继承是面向对象设计中的常见方式，它可以有效的实现”代码复用“，同时子类也有重写父类方法的自由，这就对到底是调用父类方法还是子类方法带来了麻烦。 来看下面的代码： 123456789101112131415161718192021222324252627282930public class PropertyTest &#123; public static void main(String[] args) &#123; ParentDef v1 = new ParentDef(); ParentDef v2 = new ChildDef(); ChildDef v3 = new ChildDef(); System.out.println("=====v1====="); System.out.println("staticValue:" + v1.staticValue); System.out.println("value:" + v1.value); System.out.println("=====v2====="); System.out.println("staticValue:" + v2.staticValue); System.out.println("value:" + v2.value); System.out.println("=====v3====="); System.out.println("staticValue:" + v3.staticValue); System.out.println("value:" + v3.value); &#125;&#125;class ParentDef&#123; public static final String staticValue = "父类静态变量"; public String value = "父类实例变量";&#125;class ChildDef extends ParentDef&#123; public static final String staticValue = "子类静态变量"; public String value = "子类实例变量";&#125; 输出结果如下： 123456789=====v1=====staticValue:父类静态变量value:父类实例变量=====v2=====staticValue:父类静态变量value:父类实例变量=====v3=====staticValue:子类静态变量value:子类实例变量 结论对于调用父类方法还是子类方法，只与变量的声明类型有关系，与实例化的类型没有关系。 到底是值传递还是引用传递 对于这个话题，我的观点是值传递，因为传递的都是存储在栈中的内容，无论是基本类型的值，还是指向堆中对象的指针，都是值而非引用。并且在值传递的过程中，JVM会将值复制一份，然后将复制后的值传递给调用方法。 按照这种方式，我们来看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ParamTest &#123; public void change(int value) &#123; value = 10; &#125; public void change(Value value) &#123; Value temp = new Value(); temp.value = 10; value = temp; &#125; public void add(int value) &#123; value += 10; &#125; public void add(Value value) &#123; value.value += 10; &#125; public static void main(String[] args) &#123; ParamTest test = new ParamTest(); Value value = new Value(); int v = 0; System.out.println("v:" + v); System.out.println("value.value:" + value.value); System.out.println("=====change====="); test.change(v); test.change(value); System.out.println("v:" + v); System.out.println("value.value:" + value.value); value = new Value(); v = 0; System.out.println("=====add====="); test.add(v); test.add(value); System.out.println("v:" + v); System.out.println("value.value:" + value.value); &#125;&#125;class Value&#123; public int value;&#125; 它的输出结果： 12345678v:0value.value:0=====change=====v:0value.value:0=====add=====v:0value.value:10 我们看到，在调用change方法时，即使我们传递进去的是指向对象的指针，但最终对象的属性也没有变，这是因为在change方法体内，我们新建了一个对象，然后将”复制过的指向原对象的指针“指向了“新对象”，并且对新对象的属性进行了调整。但是“复制前的指向原对象的指针”依然是指向“原对象”，并且属性没有任何变化。 final/finally/finalize的区别 final可以修饰类、成员变量、方法以及方法参数。使用final修饰的类是不可以被继承的，使用final修饰的方法是不可以被重写的，使用final修饰的变量，只能被赋值一次。 使用final声明变量的赋值时机： 1. 定义声明时赋值 2. 初始化块或静态初始化块中 3. 构造函数 来看下面的代码： 1234567891011121314151617181920212223class FinalTest&#123; public static final String staticValue1 = "静态变量1"; public static final String staticValue2; static &#123; staticValue2 = "静态变量2"; &#125; public final String value1 = "实例变量1"; public final String value2; public final String value3; &#123; value2 = "实例变量2"; &#125; public FinalTest() &#123; value3 = "实例变量3"; &#125;&#125; finally一般是和try…catch放在一起使用，主要用来释放一些资源。 我们来看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class FinallyTest &#123; public static void main(String[] args) &#123; finallyTest1(); finallyTest2(); finallyTest3(); &#125; private static String finallyTest1() &#123; try &#123; throw new RuntimeException(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; try &#123; System.out.println("Hello World"); return "Hello World"; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; return null; &#125; private static void finallyTest2() &#123; int i = 0; for (i = 0; i &lt; 3; i++) &#123; try &#123; if (i == 2) break; System.out.println(i); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; &#125; &#125; private static Test finallyTest3() &#123; try &#123; return new Test(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; &#125;&#125; 执行结果如下： 12345678910111213java.lang.RuntimeException at sample.interview.FinallyTest.finallyTest1(FinallyTest.java:16) at sample.interview.FinallyTest.main(FinallyTest.java:7)Finally语句被执行Hello WorldFinally语句被执行0Finally语句被执行1Finally语句被执行Finally语句被执行Test实例被创建Finally语句被执行 注意在循环的过程中，对于某一次循环，即使调用了break或者continue，finally也会执行。 finalize则主要用于释放资源，在调用GC方法时，该方法就会被调用。 来看下面的示例： 1234567891011121314class FinalizeTest&#123; protected void finalize() &#123; System.out.println("finalize方法被调用"); &#125; public static void main(String[] args) &#123; FinalizeTest test = new FinalizeTest(); test = null; Runtime.getRuntime().gc(); &#125;&#125; 执行结果如下： 1finalize方法被调用 关于基本类型的一些事儿 基本类型供分为9种，包括byte/short/int/long/float/double/boolean/void，每种基本类型都对应一个“包装类”，其他一些基本信息如下： 基本类型：byte 二进制位数：8 包装类：java.lang.Byte 最小值：Byte.MIN_VALUE=-128 最大值：Byte.MAX_VALUE=127 基本类型：short 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 最大值：Short.MAX_VALUE=32767 基本类型：int 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE=-2147483648 最大值：Integer.MAX_VALUE=2147483647 基本类型：long 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 最大值：Long.MAX_VALUE=9223372036854775807 基本类型：float 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 基本类型：double 二进制位数：64 包装类：java.lang.Double 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 基本类型：char 二进制位数：16 包装类：java.lang.Character 最小值：Character.MIN_VALUE=0 最大值：Character.MAX_VALUE=65535 关于基本类型的一些结论（来自《Java面试解惑》）未带有字符后缀标识的整数默认为int类型；未带有字符后缀标识的浮点数默认为double类型。如果一个整数的值超出了int类型能够表示的范围，则必须增加后缀“L”（不区分大小写，建议用大写，因为小写的L与阿拉伯数字1很容易混淆），表示为long型。带有“F”（不区分大小写）后缀的整数和浮点数都是float类型的；带有“D”（不区分大小写）后缀的整数和浮点数都是double类型的。编译器会在编译期对byte、short、int、long、float、double、char型变量的值进行检查，如果超出了它们的取值范围就会报错。int型值可以赋给所有数值类型的变量；long型值可以赋给long、float、double类型的变量；float型值可以赋给float、double类型的变量；double型值只能赋给double类型变量。 关于基本类型之间的转换 下面的转换是无损精度的转换： byte-&gt;shortshort-&gt;intchar-&gt;intint-&gt;longfloat-&gt;double 下面的转换是会损失精度的： int-&gt;floatlong-&gt;floatlong-&gt;double 除此之外的转换，是非法的。 和日期相关的一些事儿 Java中，有两个类和日期相关，一个是Date，一个是Calendar。我们来看下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; test1(); test2(); test3(); &#125; private static void test1() throws ParseException &#123; Date date = new Date(); System.out.println(date); DateFormat sf = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(sf.format(date)); String formatString = "2013-05-12"; System.out.println(sf.parse(formatString)); &#125; private static void test2() &#123; Date date = new Date(); System.out.println("Year:" + date.getYear()); System.out.println("Month:" + date.getMonth()); System.out.println("Day:" + date.getDate()); System.out.println("Hour:" + date.getHours()); System.out.println("Minute:" + date.getMinutes()); System.out.println("Second:" + date.getSeconds()); System.out.println("DayOfWeek:" + date.getDay()); &#125; private static void test3() &#123; Calendar c = Calendar.getInstance(); System.out.println(c.getTime()); System.out.println(c.getTimeZone()); System.out.println("Year:" + c.get(Calendar.YEAR)); System.out.println("Month:" + c.get(Calendar.MONTH)); System.out.println("Day:" + c.get(Calendar.DATE)); System.out.println("Hour:" + c.get(Calendar.HOUR)); System.out.println("HourOfDay:" + c.get(Calendar.HOUR_OF_DAY)); System.out.println("Minute:" + c.get(Calendar.MINUTE)); System.out.println("Second:" + c.get(Calendar.SECOND)); System.out.println("DayOfWeek:" + c.get(Calendar.DAY_OF_WEEK)); System.out.println("DayOfMonth:" + c.get(Calendar.DAY_OF_MONTH)); System.out.println("DayOfYear:" + c.get(Calendar.DAY_OF_YEAR)); &#125;&#125; 输出结果如下： 12345678910111213141516171819202122Sat May 11 13:44:34 CST 20132013-05-11Sun May 12 00:00:00 CST 2013Year:113Month:4Day:11Hour:13Minute:44Second:35DayOfWeek:6Sat May 11 13:44:35 CST 2013sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null]Year:2013Month:4Day:11Hour:1HourOfDay:13Minute:44Second:35DayOfWeek:7DayOfMonth:11DayOfYear:131 需要注意的是，Date中的getxxx方法已经变成deprecated了，因此我们尽量使用calendar.get方法来获取日期的细节信息。 另外，注意DateFormat，它不仅可以对日期的输出进行格式化，而且可以逆向操作，将符合Format的字符串转换为日期类型。 Java的JDBCJDBC相关的话题。 概述 尽管在实际开发过程中，我们一般使用ORM框架来代替传统的JDBC，例如Hibernate或者iBatis，但JDBC是Java用来实现数据访问的基础，掌握它对于我们理解Java的数据操作流程很有帮助。 JDBC的全称是Java Database Connectivity。 JDBC对数据库进行操作的流程： 连接数据库 发送数据请求，即传统的CRUD指令 返回操作结果集 JDBC中常用的对象包括： ConnectionManager Connection Statement CallableStatement PreparedStatement ResultSet SavePoint 一个简单JDBC示例 我们来看下面一个简单的示例，它使用JDK自带的Derby数据库，创建一张表，插入一些记录，然后将记录返回： 1234567891011121314151617181920212223242526272829303132333435private static void test1() throws SQLException&#123; String driver = "org.apache.derby.jdbc.EmbeddedDriver"; String dbURL = "jdbc:derby:EmbeddedDB;create=true"; Connection con = null; Statement st = null; try &#123; Class.forName(driver); con = DriverManager.getConnection(dbURL); st = con.createStatement(); st.execute("create table foo(ID INT NOT NULL, NAME VARCHAR(30))"); st.executeUpdate("insert into foo(ID,NAME) values(1, 'Zhang San')"); ResultSet rs = st.executeQuery("select ID,NAME from foo"); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID=" + id + "; NAME=" + name); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 如何建立数据库连接 上面的示例代码中，建立数据库连接的部分如下： 12345String driver = &quot;org.apache.derby.jdbc.EmbeddedDriver&quot;;String dbURL = &quot;jdbc:derby:EmbeddedDB;create=true&quot;;Class.forName(driver);con = DriverManager.getConnection(dbURL); 建立数据库连接的过程，可以分为两步： 1. 加载数据库驱动，即上文中的driver以及Class.forName(dirver) 2. 定位数据库连接字符串， 即dbURL以及DriverManager.getConnection(dbURL) 不同的数据库，对应的dirver和dbURL不同，但加载驱动和建立连接的方式是相同的，即只需要修改上面driver和dbURL的值就可以了。 自动加载数据库驱动 如果我们每次建立连接时，都要使用Class.forName(…)来手动加载数据库驱动，这样会很麻烦，我们可以通过配置文件的方式，来保存数据库驱动的信息。 我们可以在classpath中，即编译出来的.class的存放路径，添加如下文件： 1META-INF\services\java.sql.Driver 对应的内容就是JDBC驱动的全路径，也就是上面driver变量的值： 1org.apache.derby.jdbc.EmbeddedDriver 接下来，我们在程序中，就不需要再显示的用Class.forName(…)来加载驱动了，它会被自动加载进来，当我们的数据库发生变化时，只需要修改这个文件就可以了，例如当我们的数据库由Derby变为MySQL时，只需要将上述的配置修改为： 1com.mysql.jdbc.Driver 但是，需要注意一点，这里只是配置了JDBC驱动的全路径，并没有包含jar文件的信息，因此，我们还是需要将包含该驱动的jar文件手动的放置到程序的classpath中。 JDBC中的基本操作 对于数据库操作来说，CRUD操作应该是最常见的操作了， 即我们常说的增、删、查、改。 JDBC是使用Statement和ResultSet来完成这些操作的。 如何实现CRUD 下面是JDBC实现基本的CRUD示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static void insertTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.execute("insert into user(ID,NAME) values(1, 'Zhang San')"); st.execute("insert into user(ID,NAME) values(2, 'Li Si')"); st.execute("insert into user(ID,NAME) values(3, 'Wang Wu')"); System.out.println("=====insert test====="); showUser(st); st.close(); con.close();&#125;private static void deleteTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.execute("delete from user where ID=3"); System.out.println("=====delete test====="); showUser(st); st.close(); con.close();&#125;private static void updateTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.executeUpdate("update user set NAME='TEST' where ID=2"); System.out.println("=====update test====="); showUser(st); st.close(); con.close();&#125;private static void showUser(Statement st) throws SQLException&#123; ResultSet rs = st.executeQuery("select ID, NAME from user"); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close();&#125; 我们顺序调用上面的测试方法： 123insertTest();deleteTest();updateTest(); 执行结果如下： 12345678910=====insert test=====ID:1; NAME=Zhang SanID:2; NAME=Li SiID:3; NAME=Wang Wu=====delete test=====ID:1; NAME=Zhang SanID:2; NAME=Li Si=====update test=====ID:1; NAME=Zhang SanID:2; NAME=TEST 上面代码中的showUser方法会把user表中的所有记录打印出来。 如何调用存储过程 存储过程是做数据库开发时经常使用的技术，它可以通过节省编译时间的方式来提升系统性能，我们这里的示例使用MySQL数据库。 如何调用不带参数的存储过程 假设我们现在有一个简单的存储过程，它只是返回user表中的所有记录，存储过程如下： 1234CREATE DEFINER=`root`@`localhost` PROCEDURE `GetUser`()BEGINselect ID,NAME from user;END 我们可以使用CallableStatement来调用存储过程： 调用存储过程示例一 1234567891011121314151617private static void execStoredProcedureTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); CallableStatement cst = con.prepareCall("call GetUser()"); ResultSet rs = cst.executeQuery(); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close(); cst.close(); con.close();&#125; 它的执行结果如下： 12ID:1; NAME=Zhang SanID:2; NAME=TEST 如何调用带参数的存储过程 MySQL的存储过程中的参数分为三种：in/out/inout，我们可以把in看做入力参数，out看做出力参数，JDBC对这两种类型的参数设置方式不同： in， JDBC使用类似于cst.set(1, 10)的方式来设置 out，JDBC使用类似于cst.registerOutParameter(2, Types.VARCHAR);的方式来设置 我们来看一个in参数的示例，假设我们希望返回ID为特定值的user信息，存储过程如下： 123456CREATE DEFINER=`root`@`localhost` PROCEDURE `GetUserByID`(in id int)BEGINset @sqlstr=concat('select * from user where ID=', id);prepare psmt from @sqlstr;execute psmt;END Java的调用代码如下： JDBC调用存储过程示例二 1234567891011121314151617private static void execStoredProcedureTest2(int id) throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); CallableStatement cst = con.prepareCall("call GetUserByID(?)"); cst.setInt(1, id); ResultSet rs = cst.executeQuery(); while(rs.next()) &#123; String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close(); cst.close(); con.close();&#125; 我们执行下面的语句： 1execStoredProcedureTest2(1); 结果如下： 1ID:1; NAME=Zhang San 对于out类型的参数，调用方式类似，不再赘述。 获取数据库以及结果集的metadata信息 在JDBC中，我们不仅能够对数据进行操作，我们还能获取数据库以及结果集的元数据信息，例如数据库的名称、驱动信息、表信息；结果集的列信息等。 获取数据库的metadata信息 我们可以通过connection.getMetaData方法来获取数据库的元数据信息，它的类型是DatabaseMetaData。 获取数据库的元数据信息 1234567891011121314151617181920private static void test1() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/mysql"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); DatabaseMetaData dbmd = con.getMetaData(); System.out.println("数据库：" + dbmd.getDatabaseProductName() + " " + dbmd.getDatabaseProductVersion()); System.out.println("驱动程序：" + dbmd.getDriverName() + " " + dbmd.getDriverVersion()); ResultSet rs = dbmd.getTables(null, null, null, null); System.out.println(String.format("|%-26s|%-9s|%-9s|%-9s|", "表名称","表类别","表类型","表模式")); while(rs.next()) &#123; System.out.println(String.format("|%-25s|%-10s|%-10s|%-10s|", rs.getString("TABLE_NAME"),rs.getString("TABLE_CAT"), rs.getString("TABLE_TYPE"), rs.getString("TABLE_SCHEM"))); &#125;&#125; 这里我们使用的数据库是MySQL中自带的默认数据库：mysql，它会记录整个数据库服务器中的一些信息。上述代码执行结果如下： 12345678数据库：MySQL 5.5.28驱动程序：MySQL-AB JDBC Driver mysql-connector-java-5.0.4 ( $Date: 2006-10-19 17:47:48 +0200 (Thu, 19 Oct 2006) $, $Revision: 5908 $ )|表名称 |表类别 |表类型 |表模式 ||columns_priv |mysql |TABLE |null ||db |mysql |TABLE |null ||event |mysql |TABLE |null ||func |mysql |TABLE |null |。。。 由于mysql中表比较多，上述结果只截取了一部分。 获取结果集的元数据信息 我们可以通过使用resultset.getMetaData方法来获取结果集的元数据信息，它的类型是ResultSetMetaData。 获取结果集的元数据信息 12345678910111213private static void test2() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); ResultSet rs = st.executeQuery("select ID, NAME from user"); ResultSetMetaData rsmd = rs.getMetaData(); for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) &#123; System.out.println("Column Name:" + rsmd.getColumnName(i) + "; Column Type:" + rsmd.getColumnTypeName(i)); &#125;&#125; 它的执行结果如下： 12Column Name:ID; Column Type:INTEGER UNSIGNEDColumn Name:NAME; Column Type:VARCHAR 可以看到，它返回类结果集中每一列的名称和类型。 基于ResultSet的操作 当我们需要对数据库进行修改时，除了上述通过Statement完成操作外，我们也可以借助ResultSet来完成。 需要注意的是，在这种情况下，我们定义Statement时，需要添加参数。 Statement构造函数可以包含3个参数： resultSetType，它的取值包括：ResultSet.TYPE_FORWARD_ONLY、ResultSet.TYPE_SCROLL_INSENSITIVE 或 ResultSet.TYPE_SCROLL_SENSITIVE，默认情况下，该参数的值是ResultSet.TYPE_FORWARD_ONLY。 resultSetConcurrency，它的取值包括：ResultSet.CONCUR_READ_ONLY 或 ResultSet.CONCUR_UPDATABLE，默认情况下，该参数的值是ResultSet.CONCUR_READ_ONLY。 resultSetHoldability，它的取值包括：ResultSet.HOLD_CURSORS_OVER_COMMIT 或 ResultSet.CLOSE_CURSORS_AT_COMMIT。 为了使得ResultSet能够对数据进行操作我们需要： 将resultSetType设置为ResultSet.TYPE_SCROLL_SENSITIVE。 将resultSetConcurrency设置为ResultSet.CONCUR_UPDATABLE。 在通过ResultSet对数据进行调整的过程中，下面方法可能会被调用： resultset.last() resultset.first() resultset.moveToInsertRow() resultset.absolute() resultset.setxxx() resultset.updateRow() resultset.insertRow() 下面是一个通过ResultSet对数据进行增、删、改的示例： 通过ResultSet对数据进行增、删、改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private static void getResultCount() throws SQLException&#123; System.out.println("=====Result Count====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT); ResultSet rs = st.executeQuery("select * from user"); rs.last(); System.out.println("返回结果的条数："+ rs.getRow()); rs.first(); rs.close(); st.close(); con.close();&#125;private static void insertDataToResultSet() throws SQLException&#123; System.out.println("=====Insert====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = st.executeQuery("select ID,NAME from user"); rs.moveToInsertRow(); rs.updateInt(1, 4); rs.updateString(2, "Xiao Ming"); rs.insertRow(); showUser(st); rs.close(); st.close(); con.close();&#125;private static void updateDataToResultSet() throws SQLException&#123; System.out.println("=====Update====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = st.executeQuery("select * from user"); rs.last(); int count = rs.getRow(); rs.first(); rs.absolute(count); rs.updateString(2, "Xiao Qiang"); rs.updateRow(); showUser(st); rs.close(); st.close(); con.close();&#125;private static void delDataFromResultSet() throws SQLException&#123; System.out.println("=====Delete====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE, ResultSet.CLOSE_CURSORS_AT_COMMIT); ResultSet rs = st.executeQuery("select * from user"); rs.last(); int count = rs.getRow(); rs.first(); rs.absolute(count); rs.deleteRow(); showUser(st); rs.close(); st.close(); con.close();&#125; 分别调用上述方法： 12341 getResultCount();2 insertDataToResultSet();3 updateDataToResultSet();4 delDataFromResultSet(); 执行结果如下： 12345678910111213=====Result Count=====返回结果的条数：2=====Insert=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:4; NAME=Xiao Ming=====Update=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:4; NAME=Xiao Qiang=====Delete=====ID:1; NAME=Zhang SanID:2; NAME=TEST 可以看到我们对ID为4的记录进行了插入、更新和删除操作。 预处理以及批处理 预处理和批处理都是用来提升系统性能的方式，一种是利用数据库的缓存机制，一种是利用数据库一次执行多条语句的方式。 预处理 数据库服务器接收到Statement后，一般会解析Statement、分析是否有语法错误、定制最优的执行计划，这个过程可能会降低系统的性能。一般的数据库服务器都这对这种情况，设计了缓存机制，当数据库接收到指令时，如果缓存中已经存在，那么就不再解析，而是直接运行。 这里相同的指令是指sql语句完全一样，包括大小写。 JDBC使用PreparedStatement来完成预处理： 12345678910111213private static void test1() throws SQLException&#123; System.out.println("=====Insert a single record by PreparedStatement====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); PreparedStatement pst = con.prepareStatement("insert into user(id,name) values(?,?)"); pst.setInt(1, 5); pst.setString(2, "Lei Feng"); pst.executeUpdate(); showUser(pst); pst.close(); con.close();&#125; 执行结果如下： 1234=====Insert a single record by PreparedStatement=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei Feng 批处理 批处理是利用数据库一次执行多条语句的机制来提升性能，这样可以避免多次建立连接带来的性能损失。 批处理使用Statement的addBatch来添加指令，使用executeBatch方法来一次执行多条指令： 1234567891011121314private static void test2() throws SQLException&#123; System.out.println("=====Insert multiple records by Statement &amp; Batch====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.addBatch("insert into user(id,name) values(6,'Xiao Zhang')"); st.addBatch("insert into user(id,name) values(7,'Xiao Liu')"); st.addBatch("insert into user(id,name) values(8,'Xiao Zhao')"); st.executeBatch(); showUser(st); st.close(); con.close();&#125; 执行结果如下： 1234567=====Insert multiple records by Statement &amp; Batch=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:6; NAME=Xiao ZhangID:7; NAME=Xiao LiuID:8; NAME=Xiao Zhao 预处理和批处理相结合 我们可以把预处理和批处理结合起来，利用数据库的缓存机制，一次执行多条语句： 1234567891011121314151617181920private static void test3() throws SQLException&#123; System.out.println("=====Insert multiple records by PreparedStatement &amp; Batch====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); PreparedStatement pst = con.prepareStatement("insert into user(id,name) values(?,?)"); pst.setInt(1, 9); pst.setString(2, "Xiao Zhang"); pst.addBatch(); pst.setInt(1, 10); pst.setString(2, "Xiao Liu"); pst.addBatch(); pst.setInt(1, 11); pst.setString(2, "Xiao Zhao"); pst.addBatch(); pst.executeBatch(); showUser(pst); pst.close(); con.close();&#125; 执行结果如下： 1234567=====Insert multiple records by PreparedStatement &amp; Batch=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:9; NAME=Xiao ZhangID:10; NAME=Xiao LiuID:11; NAME=Xiao Zhao 数据库事务 谈到数据库开发，事务是一个不可回避的话题，JDBC默认情况下，是每一步都自动提交的，我们可以通过设置connection.setAutoCommit(false)的方式来强制关闭自动提交，然后通过connection.commit()和connection.rollback()来实现事务提交和回滚。 简单的数据库事务 下面是一个简单的数据库事务的示例： 12345678910111213141516171819202122232425private static void transactionTest1() throws SQLException&#123; System.out.println("=====Simple Transaction test====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); try &#123; con.setAutoCommit(false); st.executeUpdate("insert into user(id,name) values(12, 'Xiao Li')"); con.commit(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); con.rollback(); &#125; finally &#123; con.setAutoCommit(true); showUser(st); if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 连续执行上述方法两次，我们可以得出下面的结果： 1234567891011121314151617181920=====Simple Transaction test=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:12; NAME=Xiao Li=====Simple Transaction test=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:12; NAME=Xiao Licom.mysql.jdbc.exceptions.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;12&apos; for key &apos;PRIMARY&apos; at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:931) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:2870) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1573) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1665) at com.mysql.jdbc.Connection.execSQL(Connection.java:3170) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1316) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1235) at sample.jdbc.mysql.ResultSetSample.transactionTest1(ResultSetSample.java:154) at sample.jdbc.mysql.ResultSetSample.main(ResultSetSample.java:17) 可以看到，第一次调用时，操作成功，事务提交，向user表中插入了一条记录；第二次调用时，发生主键冲突异常，事务回滚。 带有SavePoint的事务 当我们的事务操作中包含多个处理，但我们有时希望一些操作完成后可以先提交，这样可以避免整个事务的回滚。JDBC使用SavePoint来实现这一点。 123456789101112131415161718192021222324252627282930private static void transactionTest2() throws SQLException&#123; System.out.println("=====Simple Transaction test====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); Savepoint svpt = null; try &#123; con.setAutoCommit(false); st.executeUpdate("insert into user(id,name) values(13, 'Xiao Li')"); st.executeUpdate("insert into user(id,name) values(14, 'Xiao Wang')"); svpt = con.setSavepoint("roll back to here"); st.executeUpdate("insert into user(id,name) values(15, 'Xiao Zhao')"); st.executeUpdate("insert into user(id,name) values(13, 'Xiao Li')"); con.commit(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); con.rollback(svpt); &#125; finally &#123; con.setAutoCommit(true); showUser(st); if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 执行结果如下： 12345678910111213141516=====Simple Transaction test=====com.mysql.jdbc.exceptions.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;13&apos; for key &apos;PRIMARY&apos; at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:931) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:2870) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1573) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1665) at com.mysql.jdbc.Connection.execSQL(Connection.java:3170) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1316) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1235) at sample.jdbc.mysql.ResultSetSample.transactionTest2(ResultSetSample.java:185) at sample.jdbc.mysql.ResultSetSample.main(ResultSetSample.java:18)ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:13; NAME=Xiao LiID:14; NAME=Xiao Wang 可以看到最终事务报出了主键冲突异常，事务回滚，但是依然向数据库中插入了ID为13和14的记录。 另外，在确定SavePoint后，ID为15的记录并没有被插入，它是通过事务进行了回滚。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我36岁了，除了收费啥都不会]]></title>
    <url>%2Fposts%2F38019.html</url>
    <content type="text"><![CDATA[我身边就有很多追求所谓稳定工作的人：干着没有挑战性的工作，拿着没有竞争力的薪水，但他们滋润而且满足。作者说，追求稳定，你只能在稳定中死去。你怎么看？ 河北唐山市地方政府为人民办了一件好事，把地方的各个路桥收费站取消了，这种收费站很多人头疼已久，莫名奇妙地收费不说，还是造成道路拥堵的源头，好好的公路，隔段时间就要被迫停下交费，市有市界，县有县界，实际上已经成为大家出行的一个阻碍，对于从事交通运输业的人来说，更是阻碍发展的一大杀手。 之所以搞运输越来越不赚钱，就是因为这些拦路虎的存在，把本来就微薄的利润降到了最低。 所以，取消路桥收费站这事可谓大快人心，但是有些人却不满意了，这些人就是收费站的工作人员。网上流传的一个视频里显示，这些收费人员围住了领导要一个说法，在人社局已经按照《劳动法》给予经济补偿的情况下，要求政府解决工作。 而且其中一位姐姐振振有词，“我今年36了，我的青春都交给收费了，我现在啥也不会，也没人喜欢我们，我也学不了什么东西了。” 这样的言辞听起来令人瞠目结舌，不知道这位只有36岁的员工大姐，哪来的自信，在这个任何人都可能被随时淘汰的时代，敢说自己除了收费啥也不会，而且也学不会了。 对她，我们只能怒其不争，哀其不幸，可怜之人必有可恨之处。这位收费员大姐工资不高，工作技能也没有，认知范围也有限，固然有可悲之处。 但是同时我们也要看到，有多少高薪高知高技能的职场人，在30多岁的时候，也同样会遭遇工作危机，本来高枕无忧的生活一下子跌入谷底，有些甚至万劫不复。比如前不久跳楼的中兴程序员，比如华为清理的35岁员工，比如高盛那些被AI取代的交易员。 所有稳定工作都是高风险职业追求稳定，你只能在稳定中死去 很多人以为的稳定，其实根本不是稳定。 收费站的收费员这种工作，不要看不起眼，薪资也不高，但是，很多人不知道的是，有很多人，为了这样一份工作，甘愿花上十几万甚至几十万元，去疏通关系，走后门来获取这样一个职位。 为什么？就是因为在他们看来，清闲事少，稳定。但是这种稳定不叫稳定，这叫偷懒，叫一成不变的混日子。希望不用付出太多努力就能获得长期可持续的、足够维持舒适生活的收入。 这种稳定，如果能叫做稳定的话，只能叫稳定地受穷，在贫困中慢慢地温水煮青蛙。可以想见，对这些收费员而言，20年前的时候，当她们青春年少，2000-3000元的工作，还能让他们维持相对还算体面的生活，他们所说的，青春交给收费站，其实就是蹉跎青春，浪费时间在一个单调重复的工作上，心安理得地混日子。 所有稳定的工作都有一个特点，缺乏高强度的竞争。那么其另一面就是，市场也绝不会给你有竞争力的薪酬，你的薪资不与能力挂钩。 但是20年过去了，即使不发生任何结构性的变化，在别人的行业随着业绩节节攀升的时候，你的薪资还是雷打不动，单是这二十年间，物价的上涨已经把你的稳定变得一无是处，所以，你所谓的稳定不过是稳定地受穷。 稳定就是躺在舒适区当年，我曾经也有一个获得稳定工作的机会。刚毕业时，我们能去的最好的公司都是发电厂、设计院。那时候，我已经拿到一个发电厂的offer，但最后犹豫再三还是拒绝了，那个公司的人事非常惊讶，他说，“从来没有人在拿到offer后拒绝我们”。 确实，那是一个理想的职业，薪酬高，休息时间多，福利多，公司基本都是校友，面试我的人就连未来公司篮球队的位置都给我了，连业余时间都包办，可以说除了老婆不发啥都发。 但在最后签约的那个晚上我却犹豫了，只要想想稳定在一个地方，几乎放弃与外界的接触，交往的都是一个系统内的人，我就不寒而栗，最终在HR的不解中放弃了那个工作。 不是所有的稳定都是受穷，但是如同华为的程序员，中兴的工程师们，外企的中层们一样，稳定的最大问题在于形成了一个舒适区，而通常只有极少数意志坚韧的家伙，可以突破舒适区。 呆在舒适区没有什么不对，实际上，所有人都乐于呆在舒适区，但是，不幸的是，我们处于有史以来变动最快的时代。 工业革命之前的古人，在他们有生之年甚至祖孙几代之间，他们生活的世界可能从来不会发生变化，所以木匠的儿子是木匠，木匠的孙子还是木匠，木匠的孙子可以完全使用跟爷爷一样的手艺谋生。 而第一次工业革命到第二次工业革命之间经历了100年，第二次工业革命到第三次工业革命之间有50年。在第三次工业革命之前，一个人如果足够幸运，他的工作经验，还能够支撑他完整地度过一个平稳的30年。 但是，我们已经没有这样的幸运了，或者说，我们比古人更幸运了，我们的寿命足够长，而世界的变化足够大。在我们的一生中，我们甚至要经历最少两次的重大改变，而这种改变，任何一次抓住机会都意味着巨大的财富和成功，但同时，也意味着，任何一次跟不上时代，都意味着你要被历史的车轮狠狠碾轧。 这是一个对年轻人非常友好的时代，同时，这是一个对老年人和中年人非常残酷的时代。 所有的老板都如女人一样，喜欢体力好耐操的小奶狗，等你的精力、体力大不如前，等你的经验落后，等你的知识更新速度比不上年轻人，危机也就随之而来。 真正的稳定不是来自外界，而是把命运把握在自己手里在这样的时代，没有人可以说自己学不会了，可以不学习，不学习的唯一结果就是被其他人抛弃。 真正的稳定不是来自外界的施舍，不是来自于体制的庇护，而是来自于自身，把命运把握在自己手里才是稳定。 任何一个行业，任何一个职业与人一样，都有他的生老病死。 新华字典上有句话，“张华考上了北京大学；李萍进了中等技术学校；我在百货公司当售货员：我们都有光明的前途。” 我父亲曾经是当地百货大楼的副经理，那时候的百货大楼，员工守则贴在柜台上，其中第一条就是：不准殴打顾客。 那时候的售货员，是人人羡慕的职业，殴打顾客的事，是常有发生的，我父亲主要的工作之一是给柜员做思想工作，让他们承认打人有错。 就是在这种背景之下，我父亲一直在坚持学习财务和打字，很早就放弃了这种工作，找到一个机会调入了政府。当时的政府干部，待遇远远比不上售货员，当时的所有人都觉得他疯了。 但没有几年，当他在政府开始站稳脚跟，百货公司转入市场竞争，曾经那些趾高气昂不可一世的同事一下子从天之骄子变成了市场的弃儿。 真正的稳定是你在风暴之前就未雨绸缪，抓住机会学习，野蛮生长，而不是说燕雀处堂不知大厦之将倾，在你最好的年华，满足于优越感和舒适区。 在这个时代，你的工作会背叛你，你的行业会背叛你，你的专业会背叛你，唯一不能背叛你的，是你的认知和你的能力。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Assert断言工具类使用]]></title>
    <url>%2Fposts%2F11911.html</url>
    <content type="text"><![CDATA[Web 应用在接受表单提交的数据后都需要对其进行合法性检查，如果表单数据不合法，请求将被驳回。类似的，当我们在编写类的方法时，也常常需要对方法入参进行合法性检查，如果入参不符合要求，方法将通过抛出异常的方式拒绝后续处理。org.springframework.util.Assert Assert断言工具类，通常用于数据合法性检查. 平时做判断123if (message== null || message.equls("")) &#123; throw new IllegalArgumentException("输入信息错误!"); &#125; 用Assert工具类简化：1Assert.hasText((message, "输入信息错误!"); Assert 类的常用断言方法：123456Assert.notNull(Object object, "object is required") - 对象非空 Assert.isTrue(Object object, "object must be true") - 对象必须为true Assert.notEmpty(Collection collection, "collection must not be empty") - 集合非空 Assert.hasLength(String text, "text must be specified") - 字符不为null且字符长度不为0 Assert.hasText(String text, "text must not be empty") - text 不为null且必须至少包含一个非空格的字符 Assert.isInstanceOf(Class clazz, Object obj, "clazz must be of type [clazz]") - obj必须能被正确造型成为clazz 指定的类 举一个例子：有一个根据文件名获取输入流的方法：InputStream getData(String file)，为了使方法能够成功执行，必须保证 file 入参不能为 null 或空白字符，否则根本无须进行后继的处理。这时方法的编写者通常会在方法体的最前面编写一段对入参进行检测的代码，如下所示： 123456public InputStream getData(String file) &#123; if (file == null || file.length() == 0|| file.replaceAll("\\s", "").length() == 0) &#123; throw new IllegalArgumentException("file入参不是有效的文件地址"); &#125; … &#125; 类似以上检测方法入参的代码是非常常见，但是在每个方法中都使用手工编写检测逻辑的方式并不是一个好主意。阅读 Spring 源码，您会发现 Spring 采用一个 org.springframework.util.Assert 通用类完成这一任务。 Assert 翻译为中文为“断言”，使用过 JUnit的读者都熟知这个概念，它断定某一个实际的运行值和预期想一样，否则就抛出异常。Spring对方法入参的检测借用了这个概念，其提供的 Assert 类拥有众多按规则对方法入参进行断言的方法，可以满足大部分方法入参检测的要求。这些断言方法在入参不满足要求时就会抛出 IllegalArgumentException。下面，我们来认识一下 Assert 类中的常用断言方法： Spring Assert的所有方法：断言方法 说明 notNull(Object object) 当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； isTrue(boolean expression) / isTrue(boolean expression, String message) 当 expression 不为 true 抛出异常； notEmpty(Collection collection) / notEmpty(Collection collection, String message) 当集合未包含元素时抛出异常。notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； hasLength(String text) / hasLength(String text, String message) 当 text 为 null 或长度为 0 时抛出异常； hasText(String text) / hasText(String text, String message) text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message) 如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message) subType 必须可以按类型匹配于 superType，否则将抛出异常； 使用 Assert 断言类可以简化方法入参检测的代码，如 InputStream getData(String file) 在应用 Assert 断言类后，其代码可以简化为以下的形式： 12345public InputStream getData(String file)&#123; Assert.hasText(file,"file入参不是有效的文件地址"); ① 使用 Spring 断言类进行方法入参检测 … &#125; 只记录这么多，具体自己去找Spring的工具类（import org.springframework.util.Assert） 查阅API http://www.apihome.cn/api/spring/Assert.html]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS单点登录（二）]]></title>
    <url>%2Fposts%2F54220.html</url>
    <content type="text"><![CDATA[Cas的全称是Centeral Authentication Service，是对单点登录SSO（Single Sign On）的一种实现。其由Cas Server和Cas Client两部分组成，Cas Server是核心，而Cas Client通常就对应于我们的应用。一个Cas Server可以对应于多个Cas Client。它允许我们在一个Client进行登录以后无需再让用户输入用户名和密码进行认证即可访问其它Client应用。 CAS简介Cas Server的主要作用是通过发行和验证Ticket（票）来对用户进行认证和授权访问Client应用，用于认证的凭证信息都是由Cas Server管理的。而Cas Client就对应于我们真正的应用，当然其中会使用到Cas相关的类，用于与Cas Server进行交互。官网有两张图最能体现Cas的架构和原理。 如你所见，在第一次访问应用app1时，由于没有登录会直接跳转到Cas Server去进行登录认证，此时将附带查询参数service在Cas Server的登录地址上，表示登录成功后将要跳转的地址。此时Cas Server检查到没有之前成功登录后生成的SSO Session信息，那么就会引导用户到登录页面进行登录。用户输入信息提交登录请求，Cas Server认证成功后将生成对应的SSO Session，以及名为CASTGC的cookie，该cookie包含用来确定用户SSO Session的Ticket Granting Ticket（TGT）。之后会生成一个Service Ticket（ST），并将以ticket作为查询参数名，以该ST作为查询参数值跳转到登录时service对应的URL。如： http(s)://domain/app1?ticket=ST-2-59fS6KxvmykibRXyoPJE 之后的操作对用户来说都是透明的，即不可见的。app1之后将以service和ticket作为查询参数请求Cas Server对service进行验证，验证通过后Cas Server将返回当前用户的用户名等信息。app1就会给当前用户生成其自身的Session，以后该用户以该Session都可以成功的访问app1，而不需要再去请求Cas Server进行认证。当该用户再去访问app2的时候，由于其在app2上没有对应的Session信息，将会跳转到Cas Server的登录地址，Cas Server此时发现其包含名为CASTGC的cookie，将获取其中包含的TGT来获取对应的SSO Session，然后会将用户重定向到app2对应的地址，以Service Ticket作为查询参数。之后app2会向Cas Server发送请求校验该Service Ticket，校验成功后app2将建立该用户对应的Session信息，以后该用户以该Session就可以自由的访问app2了。 综上所述，我们知道，各系统之间的单点登录是通过Cas Server生成的SSO Session来交流的，而用户与实际的应用系统进行交互的时候，各应用系统将建立单独的Session，以满足用户与该系统的交互需求。 （注：本文是基于cas 3.5.2所写） 部署Cas ServerCas应用都需要有一个Cas Server。Cas Server是基于Java Servlet实现的，其要求部署在Servlet2.4以上版本的Web容器中。在此笔者将其部署到tomcat7中。Cas Server是要求使用https协议进行访问的，所以如果你的Web容器没有开启https通道，则需先开启。 开启tomcat7的https通道官方文档在这里http://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html。简单来说具体步骤如下： 利用Java的keytool工具创建一个keystore文件，该文件保存了服务端的证书和私钥。打开命令窗口敲入如下命令： 1%JAVA_HOME%\bin\keytool -genkey -alias tomcat -keyalg RSA 根据提示输入密码等信息，笔者选择的是“password”，该密码稍后将用于配置tomcat。 打开tomcat安装目录conf/server.xml文件，将如下语句的注释打开，并加上属性keystorePass，密码为我们在建立keystore时设立的密码。这样我们就可以使用https来访问tomcat了。默认其会到${user.home}/.keystore寻找keystore文件，我们之前建立的keystore文件默认就在这个位置。 1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystorePass="password"/&gt; 部署Cas Server从官网下载的cas server中会含有一个cas server对应的war包，对应路径为cas-server-3.5.2\modules\cas-server-webapp-3.5.2.war，我们可以把该war包重命名为cas.war，然后丢到tomcat的webapps目录下。之后我们就可以启动tomcat，然后访问https://localhost:8443/cas/login就可以看到Cas的登录页面了。 这些UI如果不想用，都是可以进行修改，自定义的。敲入用户名和密码就可以进行登录了。默认使用的AuthenticationHandler的处理逻辑是，只要用户名和密码一致就可以登录成功。 Cas Server中各配置文件介绍 Cas Server中所有的配置文件都是放在WEB-INF目录及其子目录下的。 在WEB-INF/classes下的配置文件有： cas-theme-default.properties：该文件存放的是css文件的路径，用户可以在这里指定使用的css文件为自定义的css文件，也可以更改配置文件中对应的css文件已更改默认的样式。 系列messages_*.properties：国际化支持对应的资源文件。 default_views.properties和protocol_views.properties：Cas Server中使用到的视图配置文件，用于定义对应视图的处理类及其文件路径。 log4j.xml：log4j的配置文件。 在WEB-INF根目录下的配置文件有： web.xml：这个文件就是大伙熟悉的web.xml文件。 cas-servlet.xml：该文件是Cas Server使用到的Spring MVC的配置文件，里面定义了一些Controller及View相关的内容。 cas.properties：该文件是Cas Server配置的主要文件。与Spring相关的所有配置使用的外部属性都定义在这个文件中。 deployerConfigContext.xml：该文件是专为Cas Server部署人员抽取出来的一个文件，其中的内容通常都是Cas Server部署人员需要进行更改的内容。 login-webflow.xml：登录使用到的Spring Web Flow配置文件。 restlet-servlet.xml：使用到的Restful API的相关配置。 WEB-INF/spring-configuration：该目录中存放的是Cas Server加载的Spring相关的配置文件。 WEB-INF/unused-spring-configuration：该目录中存放的是没有用到，但是有需要时可以将它们copy到spring-configuration目录下的文件。 在WEB-INF/spring-configuration目录下的配置文件是Cas Server中使用到的所有与Spring相关的配置文件，具体有： applicationContext.xml：该文件中定义了主要使用的bean，通常不需要修改。 argumentExtractorsConfiguration.xml：该文件中定义了需要使用的协议，默认只有CAS和SAML是可用的。 log4jConfiguration.xml：log4j初始化对应的配置。 propertyFileConfigure.xml：用于指定外部属性文件的位置，默认指定的就是前面提到的cas.properties文件。 securityContext.xml：这是Cas Server中使用到的Spring Security相关内容的配置文件，默认不需要进行修改。 ticketExpirationPolicies.xml：用于指定TicketGranting Ticket和Service Ticket的过期策略，一般不需要修改。 ticketGrantingTicketCookieGenerator.xml：TicketGranting Ticket对应的CookieGenerator的配置。 ticketRegistry.xml：DefaultTicketRegistry对应的配置。 uniqueIdGenerators.xml：唯一主键生成相关的配置。 warnCookieGenerator.xml：用于生成警告的CookieGenerator对应配置。 Cas（04）——更改认证方式在Cas Server的WEB-INF目录下有一个deployerConfigContext.xml文件，该文件是基于Spring的配置文件，里面存放的内容常常是部署人员需要修改的内容。其中认证方式也是定义在这个文件中的，id为authenticationManager的bean的authenticationHandlers即定义了需要使用的AuthenticationHandler列表。默认使用了两个AuthenticationHandler，第一个是用来确保当前使用的是https协议的HttpBasedServiceCredentialsAuthenticationHandler，第二个是我们需要改的，其简单认证用户名与密码相等的SimpleTestUsernamePasswordAuthenticationHandler。我们只需要更改这里的SimpleTestUsernamePasswordAuthenticationHandler就行了。Cas中已经为我们提供了不少AuthenticationHandler的实现，包括基于数据库认证的实现，当然用户也可以实现自己的AuthenticationHandler。下面将以使用数据库进行认证为例讲解如何更改认证方式。 Cas的各个模块都是基于Maven开发的，Cas Server也不例外。所以官方推荐我们使用Maven的War覆盖机制来修改Cas Server的配置文件。Maven的War覆盖机制是指当一个package类型为war的Maven项目A中引入了一个package类型为war的项目B作为依赖时，最终项目A打包的war包中不仅会包含项目A的内容，还会包含项目B的内容，且相同位置的文件项目A中的会覆盖项目B中的，即当项目A和项目B在WEB-INF下都拥有一个web.xml文件时，最终生成的war包中将使用项目A在WEB-INF下的web.xml文件；而当项目A在WEB-INF下没有web.xml文件，而项目B在WEB-INF下拥有web.xml文件时最终生成的war包中将使用项目B在WEB-INF下的web.xml文件。所以如果我们要修改Cas Server的配置文件，我们可以建立一个自己的基于Maven的Web项目，然后引入Cas Server作为依赖，并在自己的项目中建立对应的deployerConfigContext.xml文件。下面来看详细步骤。 建立基于Maven的Web项目，取名为myCasServer。 打开pom.xml文件，删除默认的依赖项，添加如下内容。 12345678910111213141516171819202122232425262728&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;warName&gt;cas&lt;/warName&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-webapp&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;cas.version&gt;3.5.2&lt;/cas.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;ja-sig&lt;/id&gt; &lt;url&gt;http://oss.sonatype.org/content/repositories/releases/ &lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 删除myCasServer项目中src/main/webapp下的index.jsp文件和src/main/webapp/WEB-INF下的web.xml文件，因为在cas-server-webapp中都存在对应的文件，不删除的话打包后的结果将是myCasServer中的覆盖cas-server-webapp中的。如果这个时候使用Maven进行打包的话你将得到一个和cas-server-webapp一模一样的war包。 使用数据库进行认证的话还需要添加对应的依赖，打开myCasServer的pom.xml文件，添加如下依赖。 123456&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 将cas-server-webapp/WEB-INF下的deployerConfigContext.xml文件copy到myCasServer的src/main/webapp/WEB-INF目录下。 基于数据库的AuthenticationHandler有多种，这里以QueryDatabaseAuthenticationHandler为例。QueryDatabaseAuthenticationHandler需要配置两个参数，dataSource和sql。dataSource就是数据源，表示从哪个数据源进行查询。sql是对应的查询语句，其会接收username作为参数，然后查询出对应的密码，之后QueryDatabaseAuthenticationHandler会将查询出来的密码与用户提交的密码进行匹配。所以这里我们打开复制到myCasServer中的deployerConfigContext.xml文件，找到id为authenticationManager的bean的authenticationHandlers属性定义，将最后一个AuthenticationHandler替换成我们想要的QueryDatabaseAuthenticationHandler。 替换前： 12345678&lt;property name="authenticationHandlers"&gt; &lt;list&gt; &lt;beanclass="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" /&gt; &lt;bean class="org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler"/&gt; &lt;/list&gt; &lt;/property&gt; 替换后： 12345678910&lt;property name="authenticationHandlers"&gt; &lt;list&gt; &lt;beanclass="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" /&gt; &lt;beanclass="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="sql" value="select password from t_user where username = ?"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; 像dataSource的定义及其需要使用到的依赖包我就不贴了，比较常用。 打包以后生成的war包中使用的AuthenticationHandler就会是我们在myCasServer的src/main/webapp/WEB-INF目录下的deployerConfigContext.xml文件中定义的QueryDatabaseAuthenticationHandler了。以后需要修改Cas Server中的其它内容也可以依照此种方式进行修改。 修改Cas Server的其它配置修改host.namehost.name是定义在cas.properties文件中的一个属性。该属性将被定义在uniqueIdGenerators.xml文件中的各种UniqueTicketIdGenerator用来生成TGT、ST等ticket。默认在生成这些ticket时会将host.name作为对应ticket的后缀。host.name的设置在集群环境下将非常有用，其值对于每个节点来说都必须是唯一的，这样在整个集群环境下生成出的各种ticket也必定是唯一的。当然，如果只是在单机环境下使用，我们也可以不修改它。 修改SSO Session的超时策略SSO Session的超时策略是由TicketGrantingTicketExpirationPolicy来描述的，其定义在ticketExpirationPolicies.xml文件中的。以下是其定义： 1234&lt;!-- Provides both idle and hard timeouts, for instance 2 hour sliding window with an 8 hour max lifetime --&gt; &lt;bean id="grantingTicketExpirationPolicy"class="org.jasig.cas.ticket.support.TicketGrantingTicketExpirationPolicy" p:maxTimeToLiveInSeconds="$&#123;tgt.maxTimeToLiveInSeconds:28800&#125;" p:timeToKillInSeconds="$&#123;tgt.timeToKillInSeconds:7200&#125;"/&gt; 我们可以看到它需要指定两个参数，maxTimeToLiveInSeconds和timeToKillInSeconds，它们的单位都是秒。其中timeToKillInSeconds表示用户在多久不进行操作的情况下将超时，maxTimeToLiveInSeconds表示SSO Session的最大有效时间，从生成到指定时间后就将超时。timeToKillInSeconds默认是7200秒，即2小时；maxTimeToLiveInSeconds默认是28800秒，即8小时。用户如果需要修改的话可以之前介绍的Maven War覆盖的方式在ticketExpirationPolicies.xml文件中修改，也可以在cas.properties文件中通过对应的属性进行修改。 修改允许管理service的角色有的时候我们需要查看或管理Cas Server端的service注册情况。这就需要我们在cas.properties文件中指定用户访问service管理页面需要的角色，这是通过cas.securityContext.serviceProperties.adminRoles来指定的，默认是ROLE_ADMIN。之后我们就可以通过访问“/services/manage.html”来对Cas Server上注册的service进行管理了。在访问该URL时可能会出现国际化时某信息在zh_CN中找不到的问题，解决方法可以将对应的信息在messages_zh_CN.properties中加上，或者将messages_en.properties文件copy一份重命名为messages.properties，英文版本的messages相对而言应该是比较全的。Cas Server的权限控制也是基于Spring Security的，其主要配置文件是WEB-INF/spring目录下的securityContext.xml文件，关于权限相关的内容可以在这里查找。 修改logout后的重定向默认情况下，Cas客户端应用通过Cas Server的logout登出后是会展示Cas Server的默认登出结果页面的。如果用户希望在Cas Server登出后能够跳转到自己的应用来，则可以在访问Cas Server的logout时通过参数service传递登出后需要跳转的地址。有一点需要注意的是指定的service需要是在Cas Server注册过的，我们可以通过访问Cas Server的“/services/manage.html”对service进行管理，包括增、删、改、查等。另外我们还需要启用Cas Server在logout后的重定向功能，该功能默认是不启用的。通过去掉cas.properties文件中属性cas.logout.followServiceRedirects=false前面的注释，并修改其值为true可以启用logout后的重定向了。 禁用logout后的回调默认情况下在通过访问Cas Server的logout进行登出后Cas Server将依次回调其中注册的各个Cas Client应用，以进行单点登出。如果用户不希望Cas Server在logout后回调Cas Client应用，则可以通过设置cas.properties文件中的slo.callbacks.disabled=true来禁用其回调。 修改service ticket的超时时间service ticket的默认有效时间是10秒。通常来说这已经足够了，因为从Cas Server生成service ticket返回给Cas client应用，到Cas client应用发送service ticket到Cas Server进行验证这个过程10秒已经足够。这也是为什么如果我们使用debug追踪Cas应用的认证过程时经常会失败的原因，因为追踪的时候service ticket已经过了10秒的有效期了。如果用户需要修改它可以通过cas .properties文件中的st.timeToKillInSeconds属性进行修改。 基于数据库的认证Cas Server自身已经为我们实现了几种基于JDBC的AuthenticationHandler实现，但它们不包含在Cas Server的核心包里面，而是包含在cas-server-support-jdbc中，如果我们要使用Cas Server已经实现好的基于JDBC的AuthenticationHandler，我们必须先将cas-server-support-jdbc对应的jar包、相关数据库的驱动，以及所需要使用的数据源实现等jar包加入Cas Server的类路径中。如果是基于Maven的war覆盖机制来修改Cas Server的配置文件，则我们可以在自己的Maven项目的依赖中加入如下项（对应的驱动就没贴出来了）。 123456&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; Cas Server默认已经实现好的基于JDBC的AuthenticationHandler有三个，它们都继承自AbstractJdbcUsernamePasswordAuthenticationHandler，而且在认证过程中都需要一个DataSource。下面来对它们做一个简要的介绍。 BindModeSearchDatabaseAuthenticationHandlerBindModeSearchDatabaseAuthenticationHandler将试图以传入的用户名和密码从配置的DataSource中建立一个连接，如果连接成功，则表示认证成功，否则就是认证失败。以下是BindModeSearchDatabaseAuthenticationHandler源码的一段主要代码，通过它我们可以明显的看清其逻辑： 1234567891011121314protected final boolean authenticateUsernamePasswordInternal( final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String username = credentials.getUsername(); final String password = credentials.getPassword(); try &#123; final Connection c = this.getDataSource() .getConnection(username, password); DataSourceUtils.releaseConnection(c, this.getDataSource()); returntrue; &#125; catch (final SQLException e) &#123; returnfalse; &#125; &#125; 当然，这种实现也需要你的DataSource支持getConnection(user,password)才行，否则将返回false。dbcp的BasicDataSource的不支持的，而c3p0的ComboPooledDataSource支持。 以下是一个使用BindModeSearchDatabaseAuthenticationHandler的配置示例： 1234567891011121314&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.BindModeSearchDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; QueryDatabaseAuthenticationHandler使用QueryDatabaseAuthenticationHandler需要我们指定一个SQL，该SQL将接收一个用户名作为查询条件，然后返回对应的密码。该SQL将被QueryDatabaseAuthenticationHandler用来通过传入的用户名查询对应的密码，如果存在则将查询的密码与查询出来的密码进行匹配，匹配结果将作为认证结果。如果对应的用户名不存在也将返回false。 以下是QueryDatabaseAuthenticationHandler的一段主要代码： 1234567891011121314151617181920212223protected final boolean authenticateUsernamePasswordInternal(finalUsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. returnfalse; &#125; &#125; 上面的逻辑非常明显。此外，如你所见，QueryDatabaseAuthenticationHandler使用的用户名会经过PrincipalNameTransformer进行转换，而密码会经过PasswordEncoder进行编码。Cas Server中基于JDBC的AuthenticationHandler实现中使用到的PrincipalNameTransformer默认是不进行任何转换的NoOpPrincipalNameTransformer，而默认使用的PasswordEncoder也是不会经过任何编码的PlainTextPasswordEncoder。当然了，cas-server-jdbc-support对它们也有另外两种支持，即PrefixSuffixPrincipalNameTransformer和DefaultPasswordEncoder。 PrefixSuffixPrincipalNameTransformerPrefixSuffixPrincipalNameTransformer的作用很明显，如其名称所描述的那样，其在转换时会将用户名加上指定的前缀和后缀。所以用户在使用的时候需要指定prefix和suffix两个属性，默认是空。 DefaultPasswordEncoderDefaultPasswordEncoder底层使用的是标准Java类库中的MessageDigest进行加密的，其支持MD5、SHA等加密算法。在使用时需要通过构造参数encodingAlgorithm来指定使用的加密算法，可以使用characterEncoding属性注入来指定获取字节时使用的编码，不指定则使用默认编码。以下是DefaultPasswordEncoder的源码，其展示了DefaultPasswordEncoder的加密逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final class DefaultPasswordEncoder implements PasswordEncoder &#123; privatestaticfinalchar[] HEX_DIGITS = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8','9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; @NotNull privatefinal String encodingAlgorithm; private String characterEncoding; public DefaultPasswordEncoder(final String encodingAlgorithm) &#123; this.encodingAlgorithm = encodingAlgorithm; &#125; public String encode(final String password) &#123; if (password == null) &#123; returnnull; &#125; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(this.encodingAlgorithm); if (StringUtils.hasText(this.characterEncoding)) &#123; messageDigest.update(password.getBytes(this.characterEncoding)); &#125; else &#123; messageDigest.update(password.getBytes()); &#125; finalbyte[] digest = messageDigest.digest(); return getFormattedText(digest); &#125; catch (final NoSuchAlgorithmException e) &#123; thrownew SecurityException(e); &#125; catch (final UnsupportedEncodingException e) &#123; thrownew RuntimeException(e); &#125; &#125; /** * Takes the raw bytes from the digest and formats them correct. * @param bytes the raw bytes from the digest. * @return the formatted bytes. */ private String getFormattedText(byte[] bytes) &#123; final StringBuilder buf = new StringBuilder(bytes.length * 2); for (int j = 0; j &lt; bytes.length; j++) &#123; buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; 4) &amp; 0x0f]); buf.append(HEX_DIGITS[bytes[j] &amp; 0x0f]); &#125; return buf.toString(); &#125; publicfinalvoid setCharacterEncoding(final String characterEncoding) &#123; this.characterEncoding = characterEncoding; &#125;&#125; 如果在认证时需要使用DefaultPasswordEncoder，则需要确保数据库中保存的密码的加密方式和DefaultPasswordEncoder的加密算法及逻辑是一致的。如果这些都不能满足你的需求，则用户可以实现自己的PrincipalNameTransformer和PasswordEncoder。 以下是一个配置使用QueryDatabaseAuthenticationHandler进行认证，且使用DefaultPasswordEncoder对密码进行MD5加密的示例： 123456789101112131415161718192021222324&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="passwordEncoder" ref="passwordEncoder"/&gt; &lt;property name="sql" value="select password from t_user where username = ?"/&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; &lt;bean id="passwordEncoder"class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"&gt; &lt;constructor-arg value="MD5"/&gt;&lt;!-- 加密算法 --&gt; &lt;/bean&gt; SearchModeSearchDatabaseAuthenticationHandlerSearchModeSearchDatabaseAuthenticationHandler的主要逻辑是将传入的用户名和密码作为条件从指定的表中进行查询，如果对应记录存在则表示认证通过。使用该AuthenticationHandler时需要我们指定查询时使用的表名（tableUsers）、用户名对应的字段名（fieldUser）和密码对应的字段名（fieldPassword）。此外，还可以选择性的使用PrincipalNameTransformer和PasswordEncoder。以下是SearchModeSearchDatabaseAuthenticationHandler源码中的一段主要代码： 123456789101112131415161718192021222324252627282930private static final String SQL_PREFIX = "Select count('x') from "; @NotNull private String fieldUser; @NotNull private String fieldPassword; @NotNull private String tableUsers; private String sql; protectedfinalboolean authenticateUsernamePasswordInternal(finalUsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String transformedUsername = getPrincipalNameTransformer().transform(credentials.getUsername()); final String encyptedPassword = getPasswordEncoder().encode(credentials.getPassword()); finalint count = getJdbcTemplate().queryForInt(this.sql, transformedUsername, encyptedPassword); return count &gt; 0; &#125; publicvoid afterPropertiesSet() throws Exception &#123; this.sql = SQL_PREFIX + this.tableUsers + " Where " + this.fieldUser + " = ? And " + this.fieldPassword + " = ?"; &#125; 以下是一个使用SearchModeSearchDatabaseAuthenticationHandler的配置示例： 123456789101112131415161718192021222324252627282930313233&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.SearchModeSearchDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="passwordEncoder" ref="passwordEncoder"/&gt; &lt;property name="tableUsers" value="t_user"/&gt;&lt;!-- 指定从哪个用户表查询用户信息 --&gt; &lt;property name="fieldUser" value="username"/&gt;&lt;!-- 指定用户名在用户表对应的字段名 --&gt; &lt;property name="fieldPassword" value="password"/&gt;&lt;!-- 指定密码在用户表对应的字段名 --&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; 至此，cas-server-support-jdbc中支持JDBC的三个AuthenticationHandler就讲完了。如果用户觉得它们都不能满足你的要求，则还可以选择使用自己实现的AuthenticationHandler。至于其它认证方式，请参考官方文档。 建立使用Cas进行单点登录的应用根据之前的描述我们知道，Cas由两部分组成，Cas Server和Cas Client。Cas Server是Cas自己的服务端，而Cas Client是Cas客户端，其需要与我们自己的应用进行集成。 加入cas-client-core-xxx.jar到classpath在我们下载的Cas Client压缩包的modules目录下可以找到一个名为cas-client-core-xxx.jar的jar文件，首先需要将该jar包加入我们应用的类路径下，笔者这里使用的是cas-client-core-3.1.11.jar。如果用户的应用是使用Maven构造的，则可以在应用的pom.xml文件中加入如下依赖。 1234567&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.1.11&lt;/version&gt; &lt;/dependency&gt; 配置Filter然后需要我们在应用的web.xml文件中配置四个Filter，这四个Filter必须按照固定的顺序来进行配置，而且它们必须配置在应用的其它Filter之前。它们的先后顺序要求如下： AuthenticationFilter TicketValidationFilter HttpServletRequestWrapperFilter AssertionThreadLocalFilter 这些Filter有的必须指定某些参数，有的可以指定某些参数，这些参数可以通过context-param来指定，也可以通过init-param来指定。Cas Client默认会先从init-param取，没取到则从context-param取，所以当init-param和context-param都指定了某个参数时，init-param指定的将拥有更高的优先级。所以当多个Filter需要共用一个参数时，我们可以把它定义为context-param。 AuthenticationFilterAuthenticationFilter用来拦截所有的请求，用以判断用户是否需要通过Cas Server进行认证，如果需要则将跳转到Cas Server的登录页面。如果不需要进行登录认证，则请求会继续往下执行。 AuthenticationFilter有两个用户必须指定的参数，一个是用来指定Cas Server登录地址的casServerLoginUrl，另一个是用来指定认证成功后需要跳转地址的serverName或service。service和serverName只需要指定一个就可以了。当两者都指定了，参数service将具有更高的优先级，即将以service指定的参数值为准。service和serverName的区别在于service指定的是一个确定的URL，认证成功后就会确切的跳转到service指定的URL；而serverName则是用来指定主机名，其格式为{protocol}:{hostName}:{port}，如：https://localhost:8443，当指定的是serverName时，AuthenticationFilter将会把它附加上当前请求的URI，以及对应的查询参数来构造一个确定的URL，如指定serverName为“http://localhost”，而当前请求的URI为“/app”，查询参数为“a=b&amp;b=c”，则对应认证成功后的跳转地址将为“http://localhost/app?a=b&amp;b=c”。 除了上述必须指定的参数外，AuthenticationFilter还可以指定如下可选参数： renew：当指定renew为true时，在请Cas Server时将带上参数“renew=true”，默认为false。 gateway：指定gateway为true时，在请求Cas Server时将带上参数“gateway=true”，默认为false。 artifactParameterName：指定ticket对应的请求参数名称，默认为ticket。 serviceParameterName：指定service对应的请求参数名称，默认为service。 如下是一个配置AuthenticationFilter的示例，serverName由于在接下来配置的Filter中还要用，所以利用context-param将其配置为一个公用的参数。“elim”对应我的电脑名。 123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://elim:8080&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; TicketValidationFilter在请求通过AuthenticationFilter的认证之后，如果请求中携带了参数ticket则将会由TicketValidationFilter来对携带的ticket进行校验。TicketValidationFilter只是对验证ticket的这一类Filter的统称，其并不对应Cas Client中的一个具体类型。Cas Client中有多种验证ticket的Filter，都继承自AbstractTicketValidationFilter，它们的验证逻辑都是一致的，都有AbstractTicketValidationFilter实现，所不同的是使用的TicketValidator不一样。笔者这里将以Cas10TicketValidationFilter为例，其它还有Cas20ProxyReceivingTicketValidationFilter和Saml11TicketValidationFilter。 12345678910111213&lt;filter&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas10TicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 必须指定的参数： casServerUrlPrefix：用来指定Cas Server对应URL地址的前缀，如上面示例的“https://elim:8443/cas”。 serverName或service：语义跟前面介绍的一致。 可选参数： redirectAfterValidation ：表示是否验证通过后重新跳转到该URL，但是不带参数ticket，默认为true。 useSession ：在验证ticket成功后会生成一个Assertion对象，如果useSession为true，则会将该对象存放到Session中。如果为false，则要求每次请求都需要携带ticket进行验证，显然useSession为false跟redirectAfterValidation为true是冲突的。默认为true。 exceptionOnValidationFailure ：表示ticket验证失败后是否需要抛出异常，默认为true。 renew：当值为true时将发送“renew=true”到Cas Server，默认为false。 HttpServletRequestWrapperFilterHttpServletRequestWrapperFilter用于将每一个请求对应的HttpServletRequest封装为其内部定义的CasHttpServletRequestWrapper，该封装类将利用之前保存在Session或request中的Assertion对象重写HttpServletRequest的getUserPrincipal()、getRemoteUser()和isUserInRole()方法。这样在我们的应用中就可以非常方便的从HttpServletRequest中获取到用户的相关信息。以下是一个配置HttpServletRequestWrapperFilter的示例： 123456789&lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; AssertionThreadLocalFilterAssertionThreadLocalFilter是为了方便用户在应用的其它地方获取Assertion对象，其会将当前的Assertion对象存放到当前的线程变量中，那么以后用户在程序的任何地方都可以从线程变量中获取当前Assertion，无需再从Session或request中进行解析。该线程变量是由AssertionHolder持有的，我们在获取当前的Assertion时也只需要通过AssertionHolder的getAssertion()方法获取即可，如： 1Assertion assertion = AssertionHolder.getAssertion(); 像AssertionThreadLocalFilter这种设计理念是非常好的，实际应用中使用的也比较多，Spring Security中也有用到这种理念。为了便于大家了解，特贴出AssertionHolder的源码如下： 123456789101112131415161718192021222324252627282930public class AssertionHolder &#123; /** * ThreadLocal to hold the Assertion for Threads to access. */ private static final ThreadLocal threadLocal = new ThreadLocal(); /** * Retrieve the assertion from the ThreadLocal. */ public static Assertion getAssertion() &#123; return (Assertion) threadLocal.get(); &#125; /** * Add the Assertion to the ThreadLocal. */ public static void setAssertion(final Assertion assertion) &#123; threadLocal.set(assertion); &#125; /** * Clear the ThreadLocal. */ public static void clear() &#123; threadLocal.set(null); &#125;&#125; 以下是配置AssertionThreadLocalFilter的示例： 123456789101112131415&lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 基于Spring的Filter配置使用Cas单点登录的应用需要我们在应用的web.xml文件中配置上述介绍的四个Filter，但如果用户的应用是使用Spring开发的，则我们可以只在web.xml文件中配置四个Spring的DelegatingFilterProxy用来代理需要配置的四个Filter，对应的Filter名称对应我们需要代理的Spring ApplicationContext中bean的名称，此时我们需要将对应的Filter配置为Spring ApplicationContext中的一个bean对象。所以此时对应的web.xml文件的定义应该是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 而对应的Filter应该都以对应的名称定义为Spring ApplicationContext中的一个bean。 12345678910111213141516171819&lt;bean name="casAuthenticationFilter" class="org.jasig.cas.client.authentication.AuthenticationFilter" p:casServerLoginUrl="https://elim:8443/cas/login" p:renew="false" p:gateway="false" p:serverName="http://elim:8080" /&gt; &lt;bean name="casTicketValidationFilter" class="org.jasig.cas.client.validation.Cas10TicketValidationFilter" p:serverName="http://elim:8080" p:redirectAfterValidation="true"&gt; &lt;property name="ticketValidator"&gt; &lt;bean class="org.jasig.cas.client.validation.Cas10TicketValidator"&gt; &lt;!-- 对应于casServerUrlPrefix --&gt; &lt;constructor-arg index="0" value="https://elim:8443/cas" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="casHttpServletRequestWrapperFilter"class="org.jasig.cas.client.util.HttpServletRequestWrapperFilter"/&gt; &lt;bean id="casAssertionThreadLocalFilter"class="org.jasig.cas.client.util.AssertionThreadLocalFilter"/&gt; 添加证书到信任库在ticket验证成功后，还需要验证证书，这需要我们将之前建立的证书导出并添加到当前JRE的证书信任库中，否则将验证失败。JRE在寻找证书时将根据当前使用的host来寻找，且会用该host匹配之前创建证书时指定的用户名称，如果匹配则表示找到。这也就意味着我们在创建证书时指定的用户名称需要是我们的host。我的机器名称为“elim”，我就把它作为我的host，那么对应的证书应该这样创建。 1keytool -genkey -keyalg RSA -alias tomcat -dname &quot;cn=elim&quot; -storepass changeit 该语句是对我们之前介绍的keytool -genkey -alias tomcat -keyalg RSA的精写，它已经通过相应的参数指定了对应的参数值，而不需要再与用户交互了。如果还用之前的语句生成证书的话，那么对应的值应该这样填： 之后会在用户的对应目录下生成一个.keystore文件。之后需要将该文件导出为一个证书到%JAVA_HOME%/jre/lib/security目录下，对应指令为： 1keytool -export -alias tomcat -file %JAVA_HOME%/jre/lib/security/tomcat.crt -storepass changeit 之后需要将导出的tomcat.crt证书添加到运行时使用的JRE的受信任证书库中，此时如果出现异常可将原本%JAVA_HOME%/jre/lib/security目录下的cacerts删除后继续执行以下指令。 1keytool -import -alias tomcat -file %JAVA_HOME%/jre/lib/security/tomcat.crt -keystore %JAVA_HOME%/jre/lib/security/cacerts -storepass changeit 经过以上几步后就可以启用我们自己的Cas Client应用了，然后初次访问该应用时就会跳转到Cas Server进行登录认证。认证成功后将跳转到我们自己的Client应用进行ticket的验证，验证通过后就可以自由的访问我们的Client应用了。 （注：本文是基于Cas Server3.5.2和Cas Client3.1.11所写） 单点登出Cas Client端配置单点登出单点登出功能跟单点登录功能是相对应的，旨在通过Cas Server的登出使所有的Cas Client都登出。Cas Server的登出是通过请求“/logout”发生的，即如果你的Cas Server部署的访问路径为“https://localhost:8443/cas”时，通过访问“https://localhost:8443/cas/logout”可以触发Cas Server的登出操作，进而触发Cas Client的登出。在请求Cas Server的logout时，Cas Server会将客户端携带的TGT删除，同时回调该TGT对应的所有service，即所有的Cas Client。Cas Server中对应的TGT失效时默认也会触发同样的操作。Cas Client如果需要响应该回调，进而在Cas Client端进行登出操作的话就需要有对应的支持。具体来说，需要在Cas Client应用的web.xml文件中添加如下Filter和Listener。 12345678910111213&lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; SingleSignOutFilter需要配置在所有Filter之前，当Cas Client通过Cas Server登录成功，Cas Server会携带生成的Service Ticket回调Cas Client，此时SingleSignOutFilter会将Service Ticket与当前的Session绑定在一起。当Cas Server在进行logout后回调Cas Client应用时也会携带该Service Ticket，此时Cas Client配置的SingleSignOutFilter将会使对应的Session失效，进而达到登出的目的。 SingleSignOutHttpSessionListener用于在Cas Client应用中的Session过期时将其从对应的映射关系中移除。 Cas Server端禁用单点登出单点登出功能默认在Cas Server端是启用的。可能因为某种原因用户想禁用它。在Cas Server的WEB-INF/spring-configuration目录下有一个argumentExtractorsConfiguration.xml文件，其中定义了两个ArgumentExtractor类型的bean，一个是针对于Cas协议的，一个是针对于SAMP1.1协议的，但是它们都定义了一个共同的属性disableSingleSignOut，如下所示，该值对应的是一个属性替换变量，默认为false。 12345678&lt;bean id="casArgumentExtractor" class="org.jasig.cas.web.support.CasArgumentExtractor" p:httpClient-ref="noRedirectHttpClient" p:disableSingleSignOut="$&#123;slo.callbacks.disabled:false&#125;" /&gt; &lt;bean id="samlArgumentExtractor"class="org.jasig.cas.web.support.SamlArgumentExtractor" p:httpClient-ref="noRedirectHttpClient" p:disableSingleSignOut="$&#123;slo.callbacks.disabled:false&#125;" /&gt; 在前面的内容中已经介绍过，Cas Server的所有属性替换变量都是定义在WEB-INF/cas.properties文件中的。所以如果需要禁用Cas Server的logout功能，我们可以在cas.properties文件中指定“slo.callbacks.disabled=true”。 （注：本文是基于Cas Server3.5.2和Cas Client3.1.11所写） 通过Proxy访问其它Cas应用考虑这样一种场景：有两个应用App1和App2，它们都是受Cas Server保护的，即请求它们时都需要通过Cas Server的认证。现需要在App1中通过Http请求访问App2，显然该请求将会被App2配置的Cas的AuthenticationFilter拦截并转向Cas Server，Cas Server将引导用户进行登录认证，这样我们也就不能真正的访问到App2了。针对这种应用场景，Cas也提供了对应的支持。 原理Cas Proxy可以让我们轻松的通过App1访问App2时通过Cas Server的认证，从而访问到App2。其主要原理是这样的，App1先通过Cas Server的认证，然后向Cas Server申请一个针对于App2的proxy ticket，之后在访问App2时把申请到的针对于App2的proxy ticket以参数ticket传递过去。App2的AuthenticationFilter将拦截到该请求，发现该请求携带了ticket参数后将放行交由后续的Ticket Validation Filter处理。Ticket Validation Filter将会传递该ticket到Cas Server进行认证，显然该ticket是由Cas Server针对于App2发行的，App2在申请校验时是可以校验通过的，这样我们就可以正常的访问到App2了。针对Cas Proxy的原理，官网有一张图很能说明问题，如下所示。 配置Cas Proxy实现的核心是Cas20ProxyReceivingTicketValidationFilter，该Filter是Ticket Validation Filter的一种。使用Cas Proxy时我们需要使用Cas20ProxyReceivingTicketValidationFilter作为我们的Ticket Validation Filter，而且对于代理端而言该Filter需要放置在AuthenticationFilter之前。对于上述应用场景而言，App1就是我们的代理端，而App2就是我们的被代理端。Cas20ProxyReceivingTicketValidationFilter在代理端与被代理端的配置是不一样的。我们先来看一下在代理端的配置。 代理端既然Cas20ProxyReceivingTicketValidationFilter是一个Ticket Validation Filter，所以之前我们介绍的Ticket Validation Filter需要配置的参数，在这里也需要配置，Ticket Validation Filter可以配置的参数这里也可以配置。所不同的是对于代理端的Cas20ProxyReceivingTicketValidationFilter必须指定另外的两个参数，proxyCallbackUrl和proxyReceptorUrl。 proxyCallbackUrl： 用于指定一个回调地址，在代理端通过Cas Server校验ticket成功后，Cas Server将回调该地址以传递pgtId和pgtIou，Cas20ProxyReceivingTicketValidationFilter在接收到对应的响应后会将它们保存在内部持有的ProxyGrantingTicketStorage中。之后在对传递过来的ticket进行validate的时候又会根据pgtIou从ProxyGrantingTicketStorage中获取对应的pgtId，用以保存在AttributePrincipal中，而AttributePrincipal又会保存在Assertion中。proxyCallbackUrl因为是指定Cas Server回调的地址，所以其必须是一个可以供外部访问的绝对地址。此外，因为Cas Server默认只回调使用安全通道协议https进行通信的地址，所以我们的proxyCallbackUrl需要是一个使用https协议访问的地址。 proxyReceptorUrl： 该地址是proxyCallbackUrl相对于代理端的一个地址，Cas20ProxyReceivingTicketValidationFilter将根据该地址来决定请求是否来自Cas Server的回调。 下面是一个Cas20ProxyReceivingTicketValidationFilter在代理端配置的示例，需要注意的是该Filter需要配置在AuthenticationFilter之前，所以完整配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;https://elim:8043&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;proxyCallbackUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8043/app1/proxyCallback&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;proxyReceptorUrl&lt;/param-name&gt; &lt;param-value&gt;/proxyCallback&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 被代理端在被代理端Cas20ProxyReceivingTicketValidationFilter是扮演Ticket Validation Filter的角色，它可以验证正常通过Cas Server登录认证成功后返回的ticket，也可以认证来自其它代理端传递过来的proxy ticket，当然，最终的认证都是通过Cas Server来完成的。既然Cas20ProxyReceivingTicketValidationFilter在被代理端是作为Ticket Validation Filter来使用的，所以Ticket Validation Filter可以有的参数其都可以配置。在被代理端需要配置一个参数用以表示接受来自哪些应用的代理，这个参数可以是acceptAnyProxy，也可以是allowedProxyChains。acceptAnyProxy表示接受所有的，其对应的参数值是true或者false；而allowedProxyChains则用以指定具体接受哪些应用的代理，多个应用就写多行，allowedProxyChains的值对应的是代理端提供给Cas Server的回调地址，如果使用前文示例的代理端配置，我们就可以指定被代理端的allowedProxyChains为“https://elim:8043/app1/proxyCallback”，这样当app1作为代理端来访问该被代理端时就能通过验证，得到正确的响应。下面是一个被代理端配置Cas20ProxyReceivingTicketValidationFilter的完整配置示例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://elim:8081&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https:// elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;acceptAnyProxy&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 请求示例配置好以后接下来将展示一个app1作为代理端访问app2的应用示例。该示例的重点在于app1的请求发起，对于需要请求的app2端的内容我们假设就是一个简单的jsp文件，其简单的输出一些文本。对于代理端而言，其请求的发起通常需要经过如下步骤： 获取到当前的AttributePrincipal对象，如果当前可以获取到request对象并且使用了HttpServletRequestWrapperFilter，我们则可以直接从request中获取。 1AttributePrincipal principal = (AttributePrincipal) req.getUserPrincipal(); 当然，如果使用了AssertionThreadLocalFilter，我们也可以从AssertionHolder中获取Assertion，进而获取到对应的AttributePrincipal对象。 1AttributePrincipal principal = AssertionHolder.getAssertion().getPrincipal(); 通过AttributePrincipal获取针对于被代理端对应的proxy ticket，该操作将促使AttributePrincipal向Cas Server发起请求，从而获取到对应的proxy ticket。针对同一URL每次从Cas Server请求获取到的proxy ticket都是不一样的。以下是一个获取针对于“http://elim:8081/app2/getData.jsp”的proxy ticket的示例： 1String proxyTicket = principal.getProxyTicketFor(&quot;http://elim:8081/app2/getData.jsp&quot;); 在请求被代理端时将获取到的proxy ticket以参数ticket一起传递过去，如： 1URL url = new URL(&quot;http://elim:8081/app2/getData.jsp?ticket=&quot; + proxyTicket); 完整的示例代码如下所示： 1234567891011121314151617181920212223242526272829@WebServlet(name="casProxyTest", urlPatterns="/cas/proxy/test")public class CasProxyTestServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取到AttributePrincipal对象 AttributePrincipal principal = AssertionHolder.getAssertion().getPrincipal(); //2、获取对应的proxy ticket String proxyTicket = principal.getProxyTicketFor("http://elim:8081/app/getData.jsp"); //3、请求被代理应用时将获取到的proxy ticket以参数ticket进行传递 URL url = new URL("http://elim:8081/app/getData.jsp?ticket=" + URLEncoder.encode(proxyTicket, "UTF-8")); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8")); StringBuffer content = new StringBuffer(); String line = null; while ((line=br.readLine()) != null) &#123; content.append(line).append("&lt;br/&gt;"); &#125; resp.getWriter().write(content.toString()); &#125;&#125;]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI持续集成Github]]></title>
    <url>%2Fposts%2F60076.html</url>
    <content type="text"><![CDATA[Travis CI 介绍CI即持续集成系统。对个人而言，就是让你的代码在提交到远程(这里是GitHub)，立即自动编译，自动化测试、自动部署等。 不需要在担心更换电脑时，还要从新部署环境的问题，只要你能向远程推送文章，其他的事情就都可以交给Travis CI处理就ok了。 Travis CI 使用默认前提是已经通过Github进行授权登录Travis网站，并关联了GitHub上的仓库和相关配置。 增加以下文件：gulpfile.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108(function() &#123; 'use strict'; var gulp = require('gulp'), less = require('gulp-less'), rename = require('gulp-rename'), minifycss = require('gulp-minify-css'), autoprefixer = require('gulp-autoprefixer'), uglify = require('gulp-uglify'), jshint = require('gulp-jshint'), stylish = require('jshint-stylish'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), htmlclean = require('gulp-htmlclean'), htmlmin = require('gulp-htmlmin'), rev = require('gulp-rev-append'), sequence = require('gulp-sequence'), path = require('path'), paths = &#123; root: './', source: './themes/snippet/source/' //主题下原文件 &#125; /*==================================================== 开发主题 ====================================================*/ // CSS预处理 gulp.task('less-task', function() &#123; return gulp.src(paths.source + 'css/less/_style.less') .pipe(plumber(&#123; errorHandler: notify.onError('Error: &lt;%= error.message %&gt;') &#125;)) .pipe(less()) .pipe(rename(&#123;basename: "style"&#125;)) .pipe(gulp.dest(paths.source + 'css')) .pipe(notify(&#123;message: 'less compile complete'&#125;)); &#125;); // 校验JS语法和风格 gulp.task('js-task', function() &#123; return gulp.src(paths.source + 'js/*.js') .pipe(jshint()) .pipe(jshint.reporter(stylish)) .pipe(gulp.dest(paths.source + 'js/')) .pipe(notify(&#123;message: 'js compile complete'&#125;)); &#125;); // 监听任务-主题开发模式 gulp.task('dev', function() &#123; gulp.watch(paths.source + 'css/less/*.less', ['less-task']); gulp.watch(paths.source + 'js/*.js', ['js-task']); &#125;); /*==================================================== 部署前代码处理 ====================================================*/ // 压缩处理 css gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(autoprefixer(&#123; browsers: ['last 10 versions', 'Firefox &gt;= 20', 'Opera &gt;= 36', 'ie &gt;= 9', 'Android &gt;= 4.0', ], cascade: true, //是否美化格式 remove: false //是否删除不必要的前缀 &#125;)) .pipe(minifycss()) .pipe(gulp.dest('./public')) .pipe(notify(&#123;message: 'css minify complete'&#125;)); &#125;); // 压缩处理 js gulp.task('minify-js', function() &#123; return gulp.src('./public/js/*.js') .pipe(uglify()) .pipe(gulp.dest('./public/js')) .pipe(notify(&#123;message: 'js minify complete'&#125;)); &#125;); // 压缩处理 html gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true &#125;)) .pipe(gulp.dest('./public')); &#125;); // 添加版本号 gulp.task('rev', function() &#123; return gulp.src('./public/**/*.html') .pipe(rev()) .pipe(gulp.dest('./public')); &#125;); // 同步执行task gulp.task('deploy',sequence(['minify-css','minify-js'],'rev','minify-html')); // 部署前代码处理 gulp.task('default',['deploy'],function(e)&#123; console.log("[complete] please execute： hexo d"); &#125;)&#125;)(); travis.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647language: node_jsnode_js: stablesudo: false #cachecache: directories: - "node_modules"notifications: email: recipients: - snippet@91h5.cc on_success: never on_failure: always# S: Build Lifecycleinstall: - npm install# - gem install travis# - travis login --pro --github-token $&#123;GH_TOKEN&#125;before_script: - export TZ='Asia/Shanghai' - npm install -g gulp - chmod +x _travis.shscript: - hexo clean &amp;&amp; hexo g - gulp after_success: # - LAST_BUILD_NUMBER=68 # - for i in $(seq 1 $LAST_BUILD_NUMBER ); do travis logs $i --delete --force ; doneafter_script: - ./_travis.sh# E: Build LifeCyclebranches: only: - devenv: global: - GH_REF: github.com/shenliyang/shenliyang.github.io.git travis.sh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#--------------------------------------------#!/bin/bash# author：shenliyang# website：https://github.com/shenliyang# slogan：梦想还是要有的，万一实现了呢。#--------------------------------------------#定义时间time=`date +%Y-%m-%d\ %H:%M:%S`#执行成功function success()&#123; echo "success"&#125;#执行失败function failure()&#123; echo "failure"&#125;#默认执行function default()&#123; git clone https://$&#123;GH_REF&#125; .deploy_git cd .deploy_git git checkout master cd ../ mv .deploy_git/.git/ ./public/ cd ./publiccat &lt;&lt;EOF &gt;&gt; README.md 部署状态 | 集成结果 | 参考值---|---|---完成时间 | $time | yyyy-mm-dd hh:mm:ss部署环境 | $TRAVIS_OS_NAME + $TRAVIS_NODE_VERSION | window \| linux + stable部署类型 | $TRAVIS_EVENT_TYPE | push \| pull_request \| api \| cron启用Sudo | $TRAVIS_SUDO | false \| true仓库地址 | $TRAVIS_REPO_SLUG | owner_name/repo_name提交分支 | $TRAVIS_COMMIT | hash 16位提交信息 | $TRAVIS_COMMIT_MESSAGE |Job ID | $TRAVIS_JOB_ID | Job NUM | $TRAVIS_JOB_NUMBER | EOF git init git config user.name "shenliyang" git config user.email "" git add . git commit -m "Build by Travis CI" git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master&#125; case $1 in "success") success ;; "failure") failure ;; *) default esac 配置travis.yml 文件 123456789101112131415161718192021222324252627282930313233343536373839404142language: node_js #使用Node语言环境node_js: stable #安装稳定版Nodesudo: false #cache 启用缓存，加快构建速度cache: directories: - "node_modules"notifications: #启用通知 email: recipients: - snippet@91h5.cc #接收构建消息的邮件 不需要可设置为false on_success: never #部署成功时，可设置alway never change on_failure: always #部署失败时，同上# S: Build Lifecycleinstall: - npm install #安装依赖before_script: - export TZ='Asia/Shanghai' #设置时区 - npm install -g gulp #安装Gulp - chmod +x _travis.sh #授权脚本执行权限script: - hexo clean &amp;&amp; hexo g #清除缓存并生成静态文件 - gulp #执行gulp任务after_success: #实行成功时(以后扩展功能使用)after_script: - ./_travis.sh #执行部署脚本# E: Build LifeCyclebranches: only: - dev #需要监听部署的分支env: global: - GH_REF: github.com/shenliyang/shenliyang.github.io.git #更改为自己git地址 提交代码到Github，实现自动部署当 .travis.yml 配置文件修改完成后，将其提交到远程仓库的 hexo 分支下，此时如果之前的配置一切ok，我们应该能在 Travis CI 的博客项目主页页面中看到自动构建已经在开始执行了。上面会显示出构建过程中的日志信息及状态等。]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Redis的CAS集群]]></title>
    <url>%2Fposts%2F34811.html</url>
    <content type="text"><![CDATA[单点登录（SSO）是复杂应用系统的基本需求，Yale CAS是目前常用的开源解决方案。CAS认证中心，基于其特殊作用，自然会成为整个应用系统的核心，所有应用系统的认证工作，都将请求到CAS来完成。因此CAS服务器是整个应用的关键节点，CAS发生故障，所有系统都将陷入瘫痪。同时，CAS的负载能力要足够强，能够承担所有的认证请求响应。利用负载均衡和集群技术，不仅能克服CAS单点故障，同时将认证请求分布到多台CAS服务器上，有效减轻单台CAS服务器的请求压力。下面将基于CAS 3.4.5来讨论下CAS集群。 CAS的工作原理，主要是基于票据(Ticket)来实现的（参见 CAS基本原理）。CAS票据，存储在TicketRegistry中，因此要想实现CAS Cluster, 必须要多台CAS之间共享所有的Ticket，采用统一的TicketRegistry，可以达到此目的。 缺省的CAS实现中，TicketRegistry在内存中实现，不同的CAS服务器有自己单独的TicketRegistry，因此是不支持分布式集群的。但CAS提供了支持TicketRegistry分布式的接口org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry，我们可以实现这个接口实现多台CAS服务器TicketRegistry共享，从而实现CAS集群。 同时，较新版本CAS使用SpringWebFlow作为认证流程，而webflow需要使用session存储流程相关信息，因此实现CAS集群，我们还得需要让不同服务器的session进行共享。 我们采用内存数据库Redis来实现TicketRegistry,让多个CAS服务器共用同一个TicketRegistry。同样方法，我们让session也存储在Redis中，达到共享session的目的。下面就说说如何用Redis来实现TicketRegistry，我们使用Java调用接口Jedis来操作Redis，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Collection;import org.jasig.cas.ticket.Ticket;import org.jasig.cas.ticket.TicketGrantingTicket;import org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/* * TicketRegistry using Redis, to solve CAS Cluster. */public class RedisTicketRegistry extends AbstractDistributedTicketRegistry &#123; private static int redisDatabaseNum; private static String hosts; private static int port; private static int st_time; // ST最大空闲时间 private static int tgt_time; // TGT最大空闲时间 private static JedisPool cachePool; static &#123; redisDatabaseNum = PropertiesConfigUtil.getPropertyInt("redis_database_num"); hosts = PropertiesConfigUtil.getProperty("hosts"); port = PropertiesConfigUtil.getPropertyInt("port"); st_time = PropertiesConfigUtil.getPropertyInt("st_time"); tgt_time = PropertiesConfigUtil.getPropertyInt("tgt_time"); cachePool = new JedisPool(new JedisPoolConfig(), hosts, port); &#125; public void addTicket(Ticket ticket) &#123; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); int seconds = 0; String key = ticket.getId(); if (ticket instanceof TicketGrantingTicket) &#123; // key = // ((TicketGrantingTicket)ticket).getAuthentication().getPrincipal().getId(); seconds = tgt_time / 1000; &#125; else &#123; seconds = st_time / 1000; &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(bos); oos.writeObject(ticket); &#125; catch (Exception e) &#123; log.error("adding ticket to redis error."); &#125; finally &#123; try &#123; if (null != oos) oos.close(); &#125; catch (Exception e) &#123; log.error("oos closing error when adding ticket to redis."); &#125; &#125; jedis.set(key.getBytes(), bos.toByteArray()); jedis.expire(key.getBytes(), seconds); cachePool.returnResource(jedis); &#125; public Ticket getTicket(final String ticketId) &#123; return getProxiedTicketInstance(getRawTicket(ticketId)); &#125; private Ticket getRawTicket(final String ticketId) &#123; if (null == ticketId) return null; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); Ticket ticket = null; ByteArrayInputStream bais = new ByteArrayInputStream(jedis.get(ticketId.getBytes())); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(bais); ticket = (Ticket) ois.readObject(); &#125; catch (Exception e) &#123; log.error("getting ticket to redis error."); &#125; finally &#123; try &#123; if (null != ois) ois.close(); &#125; catch (Exception e) &#123; log.error("ois closing error when getting ticket to redis."); &#125; &#125; cachePool.returnResource(jedis); return ticket; &#125; public boolean deleteTicket(final String ticketId) &#123; if (ticketId == null) &#123; return false; &#125; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); jedis.del(ticketId.getBytes()); cachePool.returnResource(jedis); return true; &#125; public Collection&lt;Ticket&gt; getTickets() &#123; throw new UnsupportedOperationException("GetTickets not supported."); &#125; protected boolean needsCallback() &#123; return false; &#125; protected void updateTicket(final Ticket ticket) &#123; addTicket(ticket); &#125;&#125; 同时，我们在ticketRegistry.xml配置文件中，将TicketRegistry实现类指定为上述实现。即修改下面的class值 123 &lt;!-- Ticket Registry --&gt; &lt;bean id="ticketRegistry" class="org.jasig.cas.util.RedisTicketRegistry" /&gt; &lt;!-- &lt;bean id="ticketRegistry" class="org.jasig.cas.ticket.registry.DefaultTicketRegistry" /&gt; --&gt; 因为使用了Redis的expire功能，注释掉如下代码： 12345678910&lt;!-- TICKET REGISTRY CLEANER --&gt; lt;!-- &lt;bean id="ticketRegistryCleaner" class="org.jasig.cas.ticket.registry.support.DefaultTicketRegistryCleaner" p:ticketRegistry-ref="ticketRegistry" /&gt; &lt;bean id="jobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean" p:targetObject-ref="ticketRegistryCleaner" p:targetMethod="clean" /&gt; &lt;bean id="triggerJobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.SimpleTriggerBean" p:jobDetail-ref="jobDetailTicketRegistryCleaner" p:startDelay="20000" p:repeatInterval="5000000" /&gt; --&gt; 通过上述实现TicketRegistry,多台CAS服务器就可以共用同一个TicketRegistry。对于如何共享session，我们可以采用现成的第三方工具tomcat-redis-session-manager直接集成即可。对于前端web服务器(如nginx)，做好负载均衡配置，将认证请求分布转发给后面多台CAS，实现负载均衡和容错目的。]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git查看、删除、重命名远程分支和tag]]></title>
    <url>%2Fposts%2F30226.html</url>
    <content type="text"><![CDATA[Git查看、删除、重命名远程分支和tag 查看远程分支加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）： 12345678910$ git branch -a master remote tungway v1.52* zrong remotes/origin/master remotes/origin/tungway remotes/origin/v1.52 remotes/origin/zrong 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： 1$ git push origin --delete &lt;branchName&gt; 删除tag这么用： 1git push origin --delete tag &lt;tagName&gt; 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： 1git push origin : &lt;branchName&gt; 这是删除tag的方法，推送一个空tag到远程tag： 12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 两种语法作用完全相同。删除不存在对应远程分支的本地分支假设这样一种情况： 我创建了本地分支b1并pull到远程分支 origin/b1； 其他人在本地使用fetch或pull创建了本地的b1分支； 我删除了 origin/b1 远程分支； 其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？ 使用下面的代码查看b1的状态： 123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use 'git remote prune' to remove) Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支： 1git fetch -p 重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： 12345678910$ git branch -av* devel 752bb84 Merge pull request #158 from Gwill/devel master 53b27b8 Merge pull request #138 from tdlrobin/master zrong 2ae98d8 modify CCFileUtils, export getFileData remotes/origin/HEAD -&gt; origin/master remotes/origin/add_build_script d4a8c4f Merge branch 'master' into add_build_script remotes/origin/devel 752bb84 Merge pull request #158 from Gwill/devel remotes/origin/devel_qt51 62208f1 update .gitignore remotes/origin/master 53b27b8 Merge pull request #138 from tdlrobin/master remotes/origin/zrong 2ae98d8 modify CCFileUtils, export getFileData 删除远程分支： 123$ git push --delete origin develTo git@github.com:zrong/quick-cocos2d-x.git - [deleted] devel 重命名本地分支： 1git branch -m devel develop 推送本地分支： 12345678$ git push origin developCounting objects: 92, done.Delta compression using up to 4 threads.Compressing objects: 100% (48/48), done.Writing objects: 100% (58/58), 1.38 MiB, done.Total 58 (delta 34), reused 12 (delta 5)To git@github.com:zrong/quick-cocos2d-x.git * [new branch] develop -&gt; develop 然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误： 12345$ git push --delete origin develremote: error: refusing to delete the current branch: refs/heads/develTo git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited)error: failed to push some refs to 'git@github.com:zrong/quick-cocos2d-x.git' 这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作：进入 github 中该项目的 Settings 页面；设置 Default Branch 为其他的分支（例如 master）；重新执行删除远程分支命令。把本地tag推送到远程 1git push --tags 获取远程tag 1git fetch origin tag]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS单点登录(一)]]></title>
    <url>%2Fposts%2F34685.html</url>
    <content type="text"><![CDATA[单点登录（Single Sign On），简称为SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。CAS（Central Authentication Service），中央认证服务。CAS(Central Authentication Service)是一款不错的针对 Web应用的单点登录框架。 CAS基本原理讲解CAS之前先来学习两个基本术语 术语解释：Ticket Grangting Ticket(TGT) ：TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 Ticket-granting cookie(TGC)：存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CASServer用来明确用户身份的凭证。 Service ticket(ST) ：服务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源 深入CAS从结构上看，CAS包含两个部分：CAS ServerCASServer 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 /密码等凭证 (Credentials) 。 CAS Client负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。 CASClient 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 CAS最基本的协议过程： CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web应用的受保护资源，过滤从客户端过来的每一个 Web 请求 （step 1）Web浏览器访问CAS Client，无session并且无票据(ST)，定向到CASServer（step 2），又因为浏览器中并没有cookie，故服务端拿不到TGC，因此需要重新登录 （Step 3）是用户认证过程，如果用户提供了正确的CAS Server 会处理用户名 / 密码等凭证 (Credentials) ，认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，再根据TGT发放票据ST，并且重定向用户到CAS Client（附带刚才产生的ServiceTicket）， Service Ticket 是不可以伪造的（step4） 注：ST前半部分为登录url，后半部分为我客户端要访问的页面地址，只有当登录成功才会直接转向客户端访问的页面 （Step 5）拿着ST去 CAS Server验证一下，验证成功返回用户信息（step6） 注：收到ST后，为什么还要验证呢？ 因为CAS知道这个用户已经登录过了，但是对于这个项目来说，我并不知道这个用户已经登录过了，故需要验证 当用户访问另一个应用的服务再次被重定向到 CAS Server 的时候， CAS Server 会主动获到这个 TGC cookie ，然后做下面的事情： 1)如果 User 持有 TGC 且其还没失效，那么就走基础协议图的 Step4 ，达到了 SSO 的效果； 2)如果 TGC 失效，那么用户还是要重新认证 ( 走基础协议图的 Step3) 。 CAS 请求认证时序图如下： CAS服务端登录时处理：第一步：cas往浏览器增加cookie（TGC） CAS向浏览器送回一个所谓的“内存cookie”。这种cookie并不是真的保存在内存中，而只是浏览器一关闭，cookie就自动过期。这个cookie称为“ticket-grantingcookie”，用来表明用户已经成功地登录。 这个Cookie是一个加密的Cookie，其中保存了用户登录的信息。用于以后其它应用客户端登录。 第二步：cas同时创建一个ticket(ST)重定向到原来的cas客户端 认证成功后，CAS服务器创建一个很长的、随机生成的字符串，称为“Ticket”。随后，CAS将这个ticket和成功登录的用户，以及服务联系在一起。这个ticket是一次性使用的一种凭证，它只对登录成功的用户及其服务使用一次。使用过以后立刻失效。 CAS 客户端应用Ａ的处理第一步：收到ticket后，向cas提交验证ticket 第二步：ticket验证后创建session 以后登录此应用时，没有ticket，但IE能提供session,从session中取得CASReceipt,并验证如果有效说明已经在此应用认证过，允许访问此应用 到此为止，CAS会记录用户已在应用Ａ已经登录 用户登录到应用Ｂ是如何处理用户进入应用Ｂ时，首先仍然会重定向到CAS服务器。不过此时CAS服务器不再要求用户输入用户名和密码，而是首先自动寻找Cookie，根据Cookie中保存的信息，进行登录。然后，CAS同样给出新的ticket重定向应用Ｂ给cas验证（流程同应用Ａ验证方式），如果验证成功则应用Ｂ创建session记录CASReceipt信息到session中，以后凭此session登录应用Ｂ。 原理：１个cookie+Ｎ个sessionCAS创建cookie在所有应用中登录时cas使用,各应用通过在IE创建各自的session来标识应用是否已经登录。 Cookie:在cas为各应用登录时使用，实现了只须一次录入用户密码 Session:各应用会创建自己的session表示是否登录 具体描述一下客户端消息流程 第一次访问http://localhost:8080/a, CLIENT：没票据且SESSION中没有消息所以跳转至CAS CAS：拿不到TGC故要求用户登录 认证成功后回跳 CAS：通过TGT生成ST发给客户端，客户端保存TGC，并重定向到http://localhost:8080/a CLIENT：带有票据(ST)所以不跳转只是后台发给CAS验证票据（浏览器中无法看到这一过程） 第一次访问http://localhost:8080/b CLIENT：没票据且SESSION中没有消息所以跳转至CAS CAS：从客户端取出TGC，如果TGC有效则给用户ST并后台验证ST，从而SSO。【如果失效重登录或注销时，怎么通知其它系统更新SESSION信息呢？？TicketGrantingTicketImpl类grantServiceTicket方法里this.services.put(id,service);可见CAS端已经记录了当前登录的子系统】 单点退出： 再次访问http://localhost:8080/a CLIENT：没票据但是SESSION中有消息故不跳转也不用发CAS验证票据，允许用户访问 实例域名地址的修改：根据演示需求，用修改hosts文件的方法添加域名最简单方便（这个非常重要），在文件 C:\Windows\System32\drivers\etc\hosts 文件中添加三条 12345127.0.0.1 demo.micmiu.com127.0.0.1 app1.micmiu.com127.0.0.1 app2.micmiu.com •demo.micmiu.com =&gt;&gt; 对应部署cas server的tomcat，这个虚拟域名还用于证书生成 •app1.micmiu.com =&gt;&gt; 对应部署app1 的tomcat •app2.micmiu.com =&gt;&gt; 对应部署app2 的tomcat 注：可选配置 端口号的修改：修改tomcat的启动端口（共计5处），在文件conf/server.xml文件找到如下内容： 12345&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; 修改成： 123456&lt;Server port="18005" shutdown="SHUTDOWN"&gt; &lt;Connector port="18080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="18443" /&gt; &lt;Connector port="18009" protocol="AJP/1.3" redirectPort="18443" /&gt; 注：由于需要在同一个机器上演示，故需要修改端口号 安全证书配置：CAS默认使用的是HTTPS协议，如果对安全要求不高，可使用HTTP协议。 修改deployerConfigContext.xml(cas/WEB-INF)增加参数p:requireSecure=”false”，是否需要安全验证，即HTTPS，false为不采用。 12&lt;bean class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" p:requireSecure="false" /&gt; 修改 ticketGrantingTicketCookieGenerator.xml(cas/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml) 中ticketGrantingTicketCookieGenerator p:cookieSecure 属性修改为 false。 12&lt;bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" :cookieSecure="false" p:cookieMaxAge="-1" p:cookieName="CASTGC" p:cookiePath="/cas" /&gt; 配置服务端CAS-Server下载地址：http://www.jasig.org/cas/download 我们以cas-server-3.4.11-release.zip为例，解压提取cas-server-3.4.11/modules/cas-server-webapp-3.4.11.war文件，把该文件copy到G:\sso\tomcat-cas\webapps\ 目录下，并重命名为：cas.war. 启动tomcat-cas，在浏览器地址栏输入：https://demo.micmiu.com:8080/cas/login，回车 CAS-server的默认验证规则：只要用户名和密码相同就认证通过（仅仅用于测试，生成环境需要根据实际情况修改），输入admin/admin点击登录，就可以看到登录成功的页面： 输入用户名admin和密码admin登录则会出现 看到上述页面表示CAS-Server已经部署成功。 配置客户端Cas-Client 下载 CAS-Client下载地址：http://downloads.jasig.org/cas-clients/ 以cas-client-3.2.1-release.zip为例，解压提取cas-client-3.2.1/modules/cas-client-core-3.2.1.jar 借以tomcat默认自带的webapps\examples 作为演示的简单web项目 启动tomcat-app1，浏览器输入http://app1.micmiu.com:18080/examples/servlets/回车： 注：端口号修改 1234&lt;Connector port="18080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="18443" /&gt; &lt;Connector port="18009" protocol="AJP/1.3" redirectPort="18443" /&gt; 看到上述界面表示tomcat-app1的基本安装配置已经成功。 接下来复制client的lib包cas-client-core-3.2.1.jar和commons-logging-1.1.jar到tomcat-app1\webapps\examples\WEB-INF\lib\目录下，在tomcat-app1\webapps\examples\WEB-INF\web.xml文件中增加如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://demo.micmiu.com:8080/cas/login&lt;/param-value&gt; &lt;!--这里的server是服务端的IP --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://app1.micmiu.com:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://demo.micmiu.com:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://app1.micmiu.com:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; 第二个examples类似配置。 启动之前配置好的三个tomcat分别为：tomcat-cas、tomcat-app1、tomcat-app2. 基本的测试预期流程： 打开app1 url —-&gt;跳转cas server 验证 —-&gt; 显示app1的应用 —-&gt; 打开app2 url —-&gt; 显示app2应用 —-&gt; 注销casserver —-&gt; 打开app1/app2 url —-&gt; 重新跳转到cas server 验证. 打开浏览器地址栏中输入：http://app1.micmiu.com:18080/examples/servlets/servlet/HelloWorldExample，回车： 出现CAS登录页 验证通过后显示出 hello world. 教程：http://www.micmiu.com/enterprise-app/sso/sso-cas-sample/#viewSource 数据库查询认证机制-xml方式前面服务端认证机制采用的是默认配置即CAS Servier默认用户名和密码一致即可登录成功，下面侧重于应用方面，真正通过查询用户名密码来进程验证用户是否可以登录。 CAS Server添加相关的jar包需要在web项目的lib下添加两个包：cas-server-support-jdbc-x.x.x.jar和 mysql-connector-java-x.x.x-bin.jar（具体版本号根据情况而定） 修改CAS Server的配置在%tomcat_cas%/webapps/cas/WEB_INF/deployerConfigContext.xml找到如下信息： 1&lt;bean class="org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler" /&gt; 修改成如下： 12345&lt;bean class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;!--&lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt;--&gt; &lt;/bean&gt; 同时增加datasource和加密处理两个bean的定义： 1234567891011&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost/test" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;bean id="MD5PasswordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"&gt; &lt;constructor-arg index="0" value="MD5" /&gt; &lt;/bean&gt; 修改后的效果： 本地数据库中添加用户数据信息 登录。 注意: 密码加密过程，如果不用，注释掉即可。 QueryDatabaseAuthenticationHandler是cas-server-support-jdbc提供的查询接口其中一个是通过配置一个SQL 语句查出密码，与所给密码匹配； sql语句就是查询哪一张表，本例根据t_user表的login_name字段查询密码，CAS会匹配用户输入的密码，如果匹配则通过； passwordEncoder这个是处理密码的加密，如果想要你的应用中数据库保存的是加密过的，比如本例是使用MD5加密的，所以配置了MD5PasswordEncoder这个Handler，cas内置了MD5的功能所以只需要配置一下就可以了；如果在实际应用中使用的是公司自己的加密算法那么就需要自己写一个Handler来处理密码，实现方式也比较简单，创建一个类继承org.jasig.cas.authentication.handler.PasswordEncoder然后在encode方法中加密用户输入的密码然后返回即可。 配置多个数据库如果需要配置多个数据库，可以配置多个QueryDatabaseAuthenticationHandler和多个datasource 假如a_user中有一个用户：auser，b_user中有一个用户buser，这样你无论用哪一个用户登录，CAS就会先查a_user，如果用户名密码都正确，那么就通过，如果a_user中验证失败，那么CAS就会再查b_user，用户名密码都正确就算通过了，此时不正确，就算这次登录验证没通过。 数据库查询认证机制-自定义编码方式通过xml配置方式实现数据库查询认证，的确简单但是不够灵活。但是如果登录验证逻辑稍微复杂些，可能通过这种配置方式就不能满足需求了，比如：当用户登录时，需要判断该用户是否绑定了邮箱，如果未绑定，拒绝登录并给出提示信息。 遇到类似的情况，就需要使用自定义登录来完成，并且给出的提示信息也需要是自定义的。自定义登录验证（默认实现QueryDatabaseAuthenticationHandler） CAS内置了一些AuthenticationHandler实现类，如下图所示，在cas-server-support-jdbc包中提供了基于jdbc的用户认证类。 如果需要实现自定义登录，只需要实现org.jasig.cas.authentication.handler.AuthenticationHandler接口即可，当然也可以利用已有的实现，比如创建一个继承自org.jasig.cas.adaptors.jdbc.AbstractJdbcUsernamePasswordAuthenticationHandler的类，实现方法可以参考org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler类： 修改authenticateUsernamePasswordInternal方法中的代码为自己的认证逻辑即可。 操作步骤： Eclipse中引入cas-server-webapp项目，并在lib下添加两个jar包 123cas-server-webapp-3.5.2.warcas-server-support-jdbc-x.x.x.jarmysql-connector-java-x.x.x-bin.jar 自定义一个类，这个类的内容可以是复制QueryDatabaseAuthenticationHandler 类中的核心方法： 1234567891011121314151617181920protected final boolean authenticateUsernamePasswordInternal(final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; //获取前台传递过来的值，用户名和密码 final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; /** * 以下的代码为CAS的数据库认证默认实现，如果想编写自己的实现方式，可以删除一下代码实现自己的登录认证 */ //sql为配置文件中配置的sql语句 final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. return false; &#125; &#125; 根据业务需求编写自己的自定义登录方法，修改如下代码即可 12final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); 当然也可以访问进行 http://localhost:8080/cas-server-webapp/login 调试。 配置使自定义登录认证生效 1234567891011&lt;!-- 注释掉默认的配置，使用自定义类配置 --&gt; &lt;!-- &lt;bean class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;bean class="com.tgb.handler.CustomQueryDBHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;!-- &lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 完成以上步骤，自定义登录即可实现！ 自定义错误提示消息（默认实现IncorrectResultSizeDataAccessException继承自RuntimeException） CAS AuthenticationException结构如下图，CAS已经内置了一些异常，比如用户名密码错误、未知的用户名错误等。 当用户名输入正确，而密码错误时提示“密码错误” 只需要在自定义的AuthenticationHandler类的验证方法中，验证失败的地方抛出异常即可。 密码错误的异常类： 请注意代码中的CODE私有属性，该属性定义了一个本地化资源文件中的键，通过该键获取本地化资源中对应语言的文字，这里只实现中文错误消息提示，修改WEB-INF/classes/messages_zh_CN.properties文件，添加CODE定义的键值对，如下示例： error.authentication.credentials.bad.usernameorpassword.password=\u5bc6\u7801\u9519\u8bef 后面面的文字是使用jdk自带的native2ascii编码工具：native2ascii转换成utf-8格式。 接下来只需要在自定义的AuthenticationHandler类的验证方法中，验证失败的地方抛出异常即可。 自定义AuthenticationHandler示例代码如下： 123456789101112131415161718@Override protected final boolean authenticateUsernamePasswordInternal(final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; //获取前台传递过来的值，用户名和密码 final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; final String dbPassword = null; if (dbPassword == null || dbPassword == "") &#123; throw new BadPasswordAuthenticationException(); &#125; return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. return false; &#125; 配置使自定义错误提示生效 同上（配置自定义登录认证）！ 配置转换器返回更多用户信息从cas server登录成功后，默认只能从cas server得到用户名。但程序中也可能遇到需要得到更多如姓名，手机号，email等更多用户信息的情况。 cas client拿到用户名后再到数据库中查询，的确可以得到关于该用户的更多信息。 但是如果用户登录成功后，直接从cas server返回给cas client用户的详细信息，这也是一个不错的做法。这个好处，尤其是在分布式中得以彰显，cas server可以把用户信息传递给各个应用系统，如果是上面那种做法，那么各个系统得到用户名后，都得去数据库中查询一遍，无疑是一件重复性工作。 首先需要配置属性attributeRepository首先，你需要到WEB-INF目录找到 deployerConfigContext.xml文件，同时配置 attributeRepository 如下： 1234567891011121314151617181920212223&lt;bean class="org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao" id="attributeRepository"&gt; &lt;constructor-arg index="0" ref="dataSource"/&gt; &lt;constructor-arg index="1" value="select * from t_user where &#123;0&#125;"/&gt; &lt;property name="queryAttributeMapping"&gt; &lt;map&gt; &lt;!--这里的key需写username和登录页面一致，value对应数据库用户名字段--&gt; &lt;entry key="username" value="loginname"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="resultAttributeMapping"&gt; &lt;map&gt; &lt;!--key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值--&gt; &lt;entry key="Id" value="Id"/&gt; &lt;entry key="password" value="password"/&gt; &lt;entry key="age" value="age"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- &lt;property name="queryType"&gt; &lt;value&gt;OR&lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; 其中： 切记：查询出来的字段名中间不能使用 _ (下划线)，否则获取不到数据，如 cell_phone 需要 设置别名为 cellPhone. queryAttributeMapping是组装sql用的查询条件属性，上述配置后，结合封装成查询sql就是 select* from userinfo where loginname=#username# resultAttributeMapping是sql执行完毕后返回的结构属性， key对应数据库字段，value对应客户端获取参数。 如果要组装多个查询条件，需要加上下面这个，默认为AND 12345&lt;property name="queryType"&gt;&lt;value&gt;OR&lt;/value&gt; &lt;/property&gt; 配置用户认证凭据转化的解析器也是在 deployerConfigContext.xml中，为 UsernamePasswordCredentialsToPrincipalResolver注入 attributeRepository，那么 attributeRepository就会被触发并通过此类进行解析，红色为新添部分。 123456789&lt;property name="credentialsToPrincipalResolvers"&gt; &lt;list&gt; &lt;bean class="org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver" &gt; &lt;property name="attributeRepository" ref="attributeRepository" /&gt; &lt;/bean&gt; &lt;bean class="org.jasig.cas.authentication.principal.HttpBasedServiceCredentialsToPrincipalResolver" /&gt; &lt;/list&gt; &lt;/property&gt; 修改 deployerConfigContext.xmldeployerConfigContext.xml中的 org.jasig.cas.services.InMemoryServiceRegistryDaoImpl的属性 registeredServices 修改 registeredServices 列表中的每个协议中的 allowedAttributes属性的值。列出的每个值，在客户端就可以访问了 123456789101112131415161718192021&lt;bean id="serviceRegistryDao" class="org.jasig.cas.services.InMemoryServiceRegistryDaoImpl"&gt; &lt;property name="registeredServices"&gt; &lt;list&gt; &lt;bean class="org.jasig.cas.services.RegexRegisteredService"&gt; &lt;property name="id" value="0" /&gt; &lt;property name="name" value="HTTP and IMAP" /&gt; &lt;property name="description" value="Allows HTTP(S) and IMAP(S) protocols" /&gt; &lt;property name="serviceId" value="^(https?|imaps?)://.*" /&gt; &lt;property name="evaluationOrder" value="10000001" /&gt; &lt;property name="allowedAttributes"&gt; &lt;list&gt; &lt;value&gt;Id&lt;/value&gt; &lt;value&gt;password&lt;/value&gt; &lt;value&gt;age&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 此步骤灰常重要，可以看看 org.jasig.cas.services.RegexRegisteredService的源码，其中的 allowedAttributes是关键 【提示】网上说此bean中的ignoreAttributes属性默认是不添加用户信息，查看了 CAS 3.5.2版本的 AbstractRegisteredService 源码后，发现其默认值就是 false，即：添加属性后，客户端就可见了 修改casServiceValidationSuccess.jsp1WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp 在server验证成功后，这个页面负责生成与客户端交互的xml信息，在默认的casServiceValidationSuccess.jsp中，只包括用户名，并不提供其他的属性信息，因此需要对页面进行扩展，如下，红色为新添加部分 123456789101112131415161718192021222324&lt;cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'&gt; &lt;cas:authenticationSuccess&gt; &lt;cas:user&gt;$&#123;fn:escapeXml(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.id)&#125;&lt;/cas:user&gt; &lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) &gt; 0&#125;"&gt; &lt;cas:attributes&gt; &lt;c:forEach var="attr" items="$&#123;assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes&#125;"&gt; &lt;cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;$&#123;fn:escapeXml(attr.value)&#125;&lt;/cas:$&#123;fn:escapeXml(attr.key)&#125;&gt; &lt;/c:forEach&gt; &lt;/cas:attributes&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;not empty pgtIou&#125;"&gt; &lt;cas:proxyGrantingTicket&gt;$&#123;pgtIou&#125;&lt;/cas:proxyGrantingTicket&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications) &gt; 1&#125;"&gt; &lt;cas:proxies&gt; &lt;c:forEach var="proxy" items="$&#123;assertion.chainedAuthentications&#125;" varStatus="loopStatus" begin="0" end="$&#123;fn:length(assertion.chainedAuthentications)-2&#125;" step="1"&gt; &lt;cas:proxy&gt;$&#123;fn:escapeXml(proxy.principal.id)&#125;&lt;/cas:proxy&gt; &lt;/c:forEach&gt; &lt;/cas:proxies&gt; &lt;/c:if&gt; &lt;/cas:authenticationSuccess&gt; &lt;/cas:serviceResponse&gt; 通过完成上面四个步骤的配置后，CAS Server端的工作就完成了，那么如何在客户端获取这些信息呢？下面进行说明： cas client获取用户信息： 1234AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); Map attributes = principal.getAttributes(); String email=attributes .get("age"); 补充：cas_client项目：web.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;cas_client&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;userInfoView.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- ======================== 单点登录开始 ======================== --&gt; &lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， --&gt; &lt;!-- 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 --&gt; &lt;!-- 比如AssertionHolder.getAssertion().getPrincipal().getName()。根据客户端获取的方式可以选择使用这两种 --&gt; &lt;!-- &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; --&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;com.tgb.cas.client.HelloWorldExample&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/HelloWorldExample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; HelloWorldExample：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class HelloWorldExample extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;html&gt;"); out.println("&lt;head&gt;"); String title = "Hello"; out.println("&lt;title&gt;" + title + "&lt;/title&gt;"); out.println("&lt;/head&gt;"); out.println("&lt;body bgcolor=\"white\"&gt;"); out.println("&lt;a href=\"../helloworld.html\"&gt;"); out.println("&lt;img src=\"../images/code.gif\" height=24 " + "width=24 align=right border=0 alt=\"view code\"&gt;&lt;/a&gt;"); out.println("&lt;a href=\"../index.html\"&gt;"); out.println("&lt;img src=\"../images/return.gif\" height=24 " + "width=24 align=right border=0 alt=\"return\"&gt;&lt;/a&gt;"); out.println("&lt;h1&gt;" + title + "&lt;/h1&gt;"); //以下是两种获取用户信息的两种方式，分别与Web.XML中的配置相对应，大家结合理解 // 通过 CAS HttpServletRequest Wrapper Filter 获取用户信息 String userNameString = request.getRemoteUser(); AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); if (null != principal) &#123; Map&lt;String, Object&gt; attMap = principal.getAttributes(); out.println(" Log | getAttributes Map size = " + attMap.size() + "&lt;br&gt;"); for (Entry&lt;String, Object&gt; entry : attMap.entrySet()) &#123; out.println(" | " + entry.getKey() + "=:" + entry.getValue() + "&lt;br&gt;"); &#125; String username = null; out.print(" Log | UserName:"); if (null != principal) &#123; username = principal.getName(); out.println("&lt;span style='color:red;'&gt;" + username + "&lt;/span&gt;&lt;br&gt;"); &#125; &#125; // 通过CAS Assertion Thread Local Filter 获取用户信息，共两种方式 // Assertion assertion = (Assertion) request.getSession().getAttribute( // AbstractCasFilter.CONST_CAS_ASSERTION); // if (null != assertion) &#123; // // Map&lt;String, Object&gt; attMap = assertion.getPrincipal().getAttributes(); // out.println(" Log | getAttributes Map size = " + attMap.size() + "&lt;br&gt;"); // for (Entry&lt;String, Object&gt; entry : attMap.entrySet()) &#123; // out.println(" | " + entry.getKey() + "=:" + entry.getValue() + "&lt;br&gt;"); // &#125; // // AttributePrincipal principal = assertion.getPrincipal(); // // AttributePrincipal principal = (AttributePrincipal) request // // .getUserPrincipal(); // String username = null; // out.print(" Log | UserName:"); // if (null != principal) &#123; // username = principal.getName(); // out.println("&lt;span style='color:red;'&gt;" + username + "&lt;/span&gt;&lt;br&gt;"); // &#125; // &#125; out.println("&lt;/body&gt;"); out.println("&lt;/html&gt;"); &#125; &#125; userInfoView.jsp（未使用）：1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="servlet/HelloWorldExample"&gt;获取Server端用户信息&lt;/a&gt; &lt;br&gt; &lt;a href="http://localhost:8080/cas/logout?service=http://localhost:18080/cas_client/servlet/HelloWorldExample"&gt;单点退出&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 访问：http://localhost:18080/cas_client/servlet/HelloWorldExample 查看效果 其中cas服务端对应的代码是官网中提供的cas-server-webapp-3.5.2.war，而cas_client客户端代码是我们自己编写的，参照tomcat中的example项目。 附录：JS实现cas登录成功跳转其他页面123456789101112131415161718192021222324252627282930313233&lt;!-- 根据url跳转到不同系统的登录界面. --&gt; &lt;script language="javascript" type="text/javascript"&gt; window.onload=function()//用window的onload事件，窗体加载完毕的时候 &#123; //do something var result = location.search.match(new RegExp("[\?\&amp;]" + 'systemId'+ "=([^\&amp;]+)","i")); if(result == || result.length &lt; 1)&#123; //return ""; result =""; &#125; //alert(result[1]); //return result[1]; if("security"==result[1])&#123; //alert("dfdfsdfasdfasdfasdf"); window.location.href="https://www.xx.com:8443/cas/login?service=http%3A%2F%2F172.16.3.199%3A8080%2Fsecurity%2F"; &#125;else&#123; window.location.href="https://www.xx.com:8443/cas/login?service=http%3A%2F%2F172.16.3.199%3A8080%2Fvms2.0%2Fuser%2FtoMain%2F"; &#125; &#125; &lt;!--封装为函数,也可以直接调用.--&gt; function getQueryStringByName(name) &#123; var result = location.search.match(new RegExp("[\?\&amp;]" + name+ "=([^\&amp;]+)","i")); if(result == || result.length &lt; 1)&#123; return ""; &#125; alert(result[1]); return result[1]; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术教育的兴起]]></title>
    <url>%2Fposts%2F39389.html</url>
    <content type="text"><![CDATA[有一年，我在台湾环岛旅行。 花莲的海边，我遇到一对台湾青年夫妻，带着女儿在海滩上玩。我们聊了起来。 当时，我还在高校当老师。他们问我，是否觉得台湾的孩子很幸福。我说为什么？爸爸指着女儿说：”这些小孩没有升学压力啊。“ 这倒是事实。台湾有100多所高校，可是生育率不断萎缩，导致很多大学招不到学生。有一篇报道说： 2006年，台湾考生每科只需考到15分就可以上大学，2007年这个纪录被打破，4科加起来只需18分，2008年更夸张，总分7分就能当大学生了。7分就能上大学，因此成为年度笑话。有人调侃：”即使什么都不会，选择题全部猜 C 都能上不错的学校吧！“ 但是，这不能解释一个现象。我想了一会，对那位爸爸道出我的疑惑：”如果考大学如此容易，为什么台湾有那么多补习班呢？“ 没到过台湾的人，想象不到补习班可以做成一个这么大的产业：台湾最热闹的商业街上，都是补习班的霓虹广告；补习班老师是高收入行业，名师就是富豪，也是全社会的知名人物。我不明白，为什么补习班有那么多学生，明明没有升学压力啊？ 爸爸答不出来，想了半天，只说“父母都希望孩子出人头地啊”。 旅行回来后，我发现大陆的补习班行业也蓬勃兴起了，比台湾有过之而无不及。 每个居住小区的周围，都有好几家补习班公司，招生对象从两三岁的娃娃到十几岁的中学生，全部通吃。补习科目无所不包，从语数外到艺术和体育，寒暑假还提供美日欧的游学项目，供家长选择。每到夜晚，灯火通明，门口都是接送孩子的家长。 我们的补习班公司，还上市了。从最早的新东方，到后来的达内科技、正保教育、学而思、51Talk都是绩优公司，在纽约交易所上市，受到投资者追捧。后面还有一大批培训类创业公司，排队等着上市。这在全世界恐怕也是绝无仅有。 历史最悠久、市场需求最大的培训项目，就是外语培训。 我读中学时，同学里面流行上《新概念英语》和口语补习班。到了大学，流行的是托福和 GRE 补习班。大家认定，英语好，人生才有出路。 那时，外企的收入高，比国企要高好几倍，还有出国的机会。如果能拿到美国大学的奖学金，那就是”鱼跃龙门，过而为龙”了。大家都想走这条路。马克思的名言”外语是人生斗争的武器“，是大家的座右铭。 外语改变了很多中国人的人生。马云说，他小时候整天就在西湖边，跟外国人搭讪练习口语，因此认识了澳大利亚的一家人，受邀出国去澳大利亚待了一个月。他大学读的是英语系，第一个创业项目是翻译社，1995年第一次去美国，在西雅图见到了互联网，觉得这玩意有前途，开始互联网创业。也是因为英语，结识了雅虎的创始人杨致远，得到了一笔对于阿里巴巴最为关键的投资。 中国人对于英语的学习热情，造就了新东方这样的补习班巨头。但是，20年过去了，我渐渐发现，英语学习没有以前那么重要了。 一方面，国内的机会和收入越来越多，不比国外少。更重要的是，技术的快速发展，使得语言的壁垒越来越低，甚至消失。 最早的时候是词典软件，只要鼠标一指，就有中文解释，省得查字典了。后来有了翻译软件，都不需要鼠标指来指去了，直接把全文翻译成中文。到了现在，机器翻译已经很可靠了，语法规则的文献，机器翻译的质量接近人工翻译。 最新的技术成果是，谷歌公司推出了一款实时翻译耳机 Buds，已经上市了。你把耳机戴上，对方说英语，你会实时听到翻译后的中文；你用中文回答，对方会听到英文！有了这个东西，未来还有必要去上口语补习班吗？ 我曾经一个人在摩洛哥旅行两周。当地的官方语言是阿拉伯语，上层人士说法语，底层民众说柏柏语，我就会一点英语，大多数时候都无法进行语言交流。但是居然没遇到一点困难，顺利地把这个非洲国家玩了一圈，还在撒哈拉沙漠住了两个晚上。这要感谢两样东西，一是遍及摩洛哥全国的3G网络（华为的功劳），可以随时查交通和酒店的信息，二是准确的地图软件，使我不用问路。 技术使得学好外语，不再那么重要了。对于多数人，这不啻于一个福音，因为外语学习非常耗费生命。 2004年，新加坡领导人李光耀承认了一个错误。独立之初，他决定所有新加坡人不管智商如何，都要学习两门语言，一门是英语，另一门是该人的母语（马来语或汉语）。后来，他发现这个决定有大问题，熟练掌握两门语言，对于人民的要求实在太高了。大多数人根本做不到双语，哪怕学习多年英语，一开口还是结结巴巴，词不达意。强迫所有人学英语，实在是浪费国民的生命。于是，这一年新加坡政府改变规定，只要求人民学习一门语言即可。 随着外语培训的重要性下降，我认为，培训的重头将转为技术培训。以前大家排队去上外语补习班，将来会排队去上技术补习班。 原因就是技术正变得比语言更重要。回到20年前，掌握流利的英语，你会比别人有更多的机会；如今，轮到了技术。谁掌握了技术，谁就有大把的机会。许多家长已经意识到了这一点，小朋友从小不仅要教 ABC，还要教一点编程。 未来的形势远比我们想象的严峻，技术会取代越来越多的人工。展望未来，大部分人，甚至90%以上的人，终其一生只是在社会的底层挣扎，拿着小康或比温饱线略高的工资。 只有技术，才有可能让你翻身。比特币就是一个例子，过去几年中，价格上涨了几百万倍。我知道的许多技术人都通过比特币发了财，而这只是技术带来的财富浪潮之中的一个突出案例。如果你了解技术，你就会看到有这样的机会。现在看上去，只有技术才能提供这样的从底层快速上升的机会。 我有一种悲观的预感。未来只有两种途径可以改变人生，一种是学习技术，另一种是购买彩票。 阮一峰著]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术和执行力]]></title>
    <url>%2Fposts%2F35691.html</url>
    <content type="text"><![CDATA[技术和执行力技术是什么？技术用来解决什么问题？技术能为自己带来什么？ 如上三个问题，是近半年来自己一直思考的问题。曾经听一位老师说过一句话，印象深刻。 技术是不值钱的。 技术为何不值钱呢？我也思考过很多次，现在的感觉就是，技术需要依托场景。没有需求，技术是玩具，无用武之地。技术是用来解决问题的，解决业务需求的。不同的业务场景需要不同的技术去解决，资深技术人员拥有的素质是对业务和技术的结合有评判，技术是否适合，性价比高还是低，都需要一个权衡过程。经验不够丰富的技术人员常常追求新技术，忽视业务的重要性。但也有另一个极端，为了保持业务稳定亘古不化，排斥技术升级换代。这两者都是不可取的，有时，需要技术倒逼业务，实现技术进步。 回到开头三个问题，技术是什么？技术是手段。技术解决什么问题？解决业务需求，提供解决方案。结束能为自己带来什么？ 金钱、声望、成就感。 这是我对技术的理解，谈技术的回报，我更愿意相信技术带来的成就感。精神之愉悦远胜物质的愉悦，若技术人员把技术视作糊口的工具，那技术之路也就走的差不多了。搞技术是需要一点热情和极客精神的。“工作不是为了赚钱，还能是为了情怀吗？”很多人如此说，那么，若工作的技术非你所热爱，那就将你所热爱的技术成为业余的精神补品吧。技术的热爱和技术的进步，带来金钱回报。而不应本末倒置，迷失于铜臭金钱之内。 钻研技术的回报，远远超过你现在短视的利益。 而对技术的热情去付诸实施，需要一定的执行力。过去的一年里，技术了解了不少，技术的广度对于能消化的范围内来讲是足够了。学习新技术，能写出的是 demo 级别的小玩具，但是它在真实的生产环境怎么用，复杂业务场景下的使用方式，和一个人写着玩是有很大区别的。这就产生了矛盾，让你保持技术热情的东西没有发挥的余地，工作用不到，如何实践呢？最好的方式就是参加开源社区了吧，这也是将技术的执行力贯彻的一种方式 摘自:https://rainylog.com/post/2017-2018/]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE.js官方API]]></title>
    <url>%2Fposts%2F14214.html</url>
    <content type="text"><![CDATA[VUE是什么? Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 全局配置Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： silent 类型：boolean 默认值：false 用法： 1Vue.config.silent = true 取消 Vue 所有的日志与警告。 optionMergeStrategies 类型：{ [key: string]: Function } 默认值：{} 用法： 123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2 自定义合并策略的选项。 合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue 实例上下文被作为第三个参数传入。 参考 自定义选项的混合策略 devtools 类型：boolean 默认值：true (生产版为 false) 用法： 12// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true 配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型：Function 默认值：undefined 用法： 12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃。 从 2.4.0 起这个钩子也会捕获 Vue 自定义事件句柄内部的错误了。 错误追踪服务 Sentry 和 Bugsnag 都通过此选项提供了官方支持。 warnHandler 2.4.0 新增 类型：Function 默认值：undefined 用法： 123Vue.config.warnHandler = function (msg, vm, trace) &#123; // `trace` 是组件的继承关系追踪&#125; 为 Vue 的运行时警告赋于一个自定义句柄。注意这只会在开发者环境下生效，在生产环境下它会被忽略。 ignoredElements 类型：Array&lt;string | RegExp&gt; 默认值：[] 用法： 1234567Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component', // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型：{ [key: string]: number | Array&lt;number&gt; } 默认值：{} 用法： 123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 "media-play-pause": 179, up: [38, 87]&#125; 1&lt;input type="text" @keyup.media-play-pause="method"&gt; 给 v-on 自定义键位别名。 performance 2.2.0 新增 类型：boolean 默认值：false (自 2.2.3 起) 用法： 设置为 true 以在浏览器开发工具中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 productionTip 2.2.0 新增 类型：boolean 默认值：true 用法： 设置为 false 以阻止 vue 在启动时生成生产提示。 全局 APIVue.extend( options ) 参数： {Object} options 用法： 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id="mount-point"&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') 结果如下： 1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 参考：组件 Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 用法： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;) 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。 Vue.set( target, key, value ) 参数： {Object | Array} target {string | number} key {any} value 返回值：设置的值。 用法： 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 Vue.delete( target, key ) 参数： {Object | Array} target {string | number} key/index 仅在 2.2.0+ 版本中支持 Array + index 用法。 用法： 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 在 2.2.0+ 中同样支持在数组上工作。 目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 Vue.directive( id, [definition] ) 参数： {string} id {Function | Object} [definition] 用法： 注册或获取全局指令。 12345678910111213141516// 注册Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') 参考：自定义指令 Vue.filter( id, [definition] ) 参数： {string} id {Function} [definition] 用法： 注册或获取全局过滤器。 1234567// 注册Vue.filter('my-filter', function (value) &#123; // 返回处理后的值&#125;)// getter，返回已注册的过滤器var myFilter = Vue.filter('my-filter') Vue.component( id, [definition] ) 参数： {string} id {Function | Object} [definition] 用法： 注册或获取全局组件。注册还会自动使用给定的id设置组件的名称 12345678// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component('my-component', &#123; /* ... */ &#125;)// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component('my-component') 参考：组件 Vue.use( plugin ) 参数： {Object | Function} plugin 用法： 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。 参考：插件 Vue.mixin( mixin ) 参数： {Object} mixin 用法： 全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。不推荐在应用代码中使用。 参考：全局混合 Vue.compile( template ) 参数： {string} template 用法： 在 render 函数中编译模板字符串。只在独立构建时有效 123456789var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) 参考：渲染函数 Vue.version 细节：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。 用法： 123456789var version = Number(Vue.version.split('.')[0])if (version === 2) &#123; // Vue v2.x.x&#125; else if (version === 1) &#123; // Vue v1.x.x&#125; else &#123; // Unsupported versions of Vue&#125; 选项 / 数据data 类型：Object | Function 限制：组件的定义只接受 function。 详细： Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。 一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。 实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。 以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。 示例： 123456789101112131415var data = &#123; a: 1 &#125;// 直接创建一个实例var vm = new Vue(&#123; data: data&#125;)vm.a // =&gt; 1vm.$data === data // =&gt; true// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; return &#123; a: 1 &#125; &#125;&#125;) 注意，不应该对 data 属性使用箭头函数 (例如data: () =&gt; { return { a: this.myProp }})。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.myProp 将是 undefined。 props 类型：Array&lt;string&gt; | Object 详细： props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。 示例： 123456789101112131415161718192021// 简单语法Vue.component('props-demo-simple', &#123; props: ['size', 'myMessage']&#125;)// 对象语法，提供校验Vue.component('props-demo-advanced', &#123; props: &#123; // 检测类型 height: Number, // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;&#125;) 参考：Props propsData 类型：{ [key: string]: any } 限制：只用于 new 创建的实例中。 详细： 创建实例时传递 props。主要作用是方便测试。 示例： 12345678910var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'&#125;)var vm = new Comp(&#123; propsData: &#123; msg: 'hello' &#125;&#125;) 参考：Props computed 类型：{ [key: string]: Function | { get: Function, set: Function } } 详细： 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 注意，不应该使用箭头函数来定义计算属性函数 (例如 aDouble: () =&gt; this.a * 2)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果实例范畴之外的依赖 (比如非响应式的 not reactive) 是不会触发计算属性更新的。 示例： 12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4 参考：计算属性 methods 类型：{ [key: string]: Function } 详细： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例： 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 参考：事件处理器 watch 类型：{ [key: string]: string | Function | Object } 详细： 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 示例： 1234567891011121314151617181920212223242526var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4 &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, immediate: true &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1 注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 参考：实例方法 / 数据 - vm.$watch 选项 / DOMel 类型：string | HTMLElement 限制：只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 在实例挂载之后，元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 &lt;html&gt; 或者 &lt;body&gt; 上。 如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。 参考： 生命周期图示 运行时 + 编译器 vs. 只包含运行时 template 类型：string 详细： 一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 &lt;script type=&quot;x-template&quot;&gt; 包含模板。 出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。 如果 Vue 选项中包含渲染函数，该模板将被忽略。 参考： 生命周期图示 用插槽分发内容 render 类型：(createElement: () =&gt; VNode) =&gt; VNode 详细： 字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。 如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。 Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。 参考：渲染函数 renderError 2.2.0 新增 类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode 详细： 只在开发者环境下工作。 当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。 示例： 12345678new Vue(&#123; render (h) &#123; throw new Error('oops') &#125;, renderError (h, err) &#123; return h('pre', &#123; style: &#123; color: 'red' &#125;&#125;, err.stack) &#125;&#125;).$mount('#app') 参考：渲染函数 选项 / 生命周期钩子所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate 类型：Function 详细： 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 参考：生命周期图示 created 类型：Function 详细： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 参考：生命周期图示 beforeMount 类型：Function 详细： 在挂载开始之前被调用：相关的 render 函数首次被调用。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 mounted 类型：Function 详细： el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 beforeUpdate 类型：Function 详细： 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 updated 类型：Function 详细： 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 activated 类型：Function 详细： keep-alive 组件激活时调用。 该钩子在服务器端渲染期间不被调用。 参考： 构建组件 - keep-alive 动态组件 - keep-alive deactivated 类型：Function 详细： keep-alive 组件停用时调用。 该钩子在服务器端渲染期间不被调用。 参考： 构建组件 - keep-alive 动态组件 - keep-alive beforeDestroy 类型：Function 详细： 实例销毁之前调用。在这一步，实例仍然完全可用。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 destroyed 类型：Function 详细： Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 errorCaptured 2.5.0+ 新增 类型：(err: Error, vm: Component, info: string) =&gt; ?boolean 详细： 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。 错误传播规则 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。 选项 / 资源directives 类型：Object 详细： 包含 Vue 实例可用指令的哈希表。 参考：自定义指令 filters 类型：Object 详细： 包含 Vue 实例可用过滤器的哈希表。 参考：Vue.filter components 类型：Object 详细： 包含 Vue 实例可用组件的哈希表。 参考：组件 选项 / 组合parent 类型：Vue instance 详细： 指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。 节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信 mixins 类型：Array&lt;Object&gt; 详细： mixins 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个，两个函数将被调用。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 示例： 123456789var mixin = &#123; created: function () &#123; console.log(1) &#125;&#125;var vm = new Vue(&#123; created: function () &#123; console.log(2) &#125;, mixins: [mixin]&#125;)// =&gt; 1// =&gt; 2 参考：混合 extends 类型：Object | Function 详细： 允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。 这和 mixins 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。 示例： 1234567var CompA = &#123; ... &#125;// 在没有调用 `Vue.extend` 时候继承 CompAvar CompB = &#123; extends: CompA, ...&#125; provide / inject 2.2.0 新增 类型： provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细： provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是一个字符串数组或一个对象，该对象的 key 代表了本地绑定的名称，value 为其 key (字符串或 Symbol) 以在可用的注入中搜索。 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 示例： 1234567891011121314var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; "bar" &#125; // ...&#125; 利用 ES2015 Symbols、函数 provide 和对象 inject： 1234567891011121314const s = Symbol()const Provider = &#123; provide () &#123; return &#123; [s]: 'foo' &#125; &#125;&#125;const Child = &#123; inject: &#123; s &#125;, // ...&#125; 接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 props 和 data 初始化之后得到。 使用一个注入的值作为一个属性的默认值： 12345678910const Child = &#123; inject: ['foo'], props: &#123; bar: &#123; default () &#123; return this.foo &#125; &#125; &#125;&#125; 使用一个注入的值作为数据入口： 12345678const Child = &#123; inject: ['foo'], data () &#123; return &#123; bar: this.foo &#125; &#125;&#125; 在 2.5.0+ 的注入可以通过设置默认值使其变成可选项： 12345const Child = &#123; inject: &#123; foo: &#123; default: 'foo' &#125; &#125;&#125; 如果它需要从一个不同名字的属性注入，则使用 from 来表示其源属性： 12345678const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: 'foo' &#125; &#125;&#125; 对于 prop 的默认值来说是类似的，你需要对非原始值使用一个工厂方法： 12345678const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: () =&gt; [1, 2, 3] &#125; &#125;&#125; 选项 / 其它name 类型：string 限制：只有作为组件选项时起作用。 详细： 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 &lt;AnonymousComponent&gt;，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。 delimiters 类型：Array&lt;string&gt; 默认值：["{{", "}}"] 限制：这个选项只在完整构建版本中的浏览器内编译时可用。 详细： 改变纯文本插入分隔符。 示例： 12345new Vue(&#123; delimiters: ['$&#123;', '&#125;']&#125;)// 分隔符变成了 ES6 模板字符串的风格 functional 类型：boolean 详细： 使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。他们用一个简单的 render 函数返回虚拟节点使他们更容易渲染。 参考：函数式组件 model 2.2.0 新增 类型：{ prop?: string, event?: string } 详细： 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能像使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 Example： 12345678910111213141516Vue.component('my-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; // this allows using the `value` prop for a different purpose value: String, // use `checked` as the prop which take the place of `value` checked: &#123; type: Number, default: 0 &#125; &#125;, // ...&#125;) 1&lt;my-checkbox v-model="foo" value="some value"&gt;&lt;/my-checkbox&gt; 上述代码相当于： 12345&lt;my-checkbox :checked="foo" @change="val =&gt; &#123; foo = val &#125;" value="some value"&gt;&lt;/my-checkbox&gt; inheritAttrs 2.4.0 新增 类型：boolean 默认值：true 详细： 默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 comments 2.4.0 新增 类型：boolean 默认值：false 限制：这个选项只在完整构建版本中的浏览器内编译时可用。 详细： 当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。 实例属性vm.$data 类型：Object 详细： Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。 参考：选项 / 数据 - data vm.$props 2.2.0 新增 类型：Object 详细： 当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。 vm.$el 类型：HTMLElement 只读 详细： Vue 实例使用的根 DOM 元素。 vm.$options 类型：Object 只读 详细： 用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处： 123456new Vue(&#123; customOption: 'foo', created: function () &#123; console.log(this.$options.customOption) // =&gt; 'foo' &#125;&#125;) vm.$parent 类型：Vue instance 只读 详细： 父实例，如果当前实例有的话。 vm.$root 类型：Vue instance 只读 详细： 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。 vm.$children 类型：Array&lt;Vue instance&gt; 只读 详细： 当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。 vm.$slots 类型：{ [name: string]: ?Array&lt;VNode&gt; } 只读 详细： 用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点。 在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助。 示例： 12345678910111213&lt;blog-post&gt; &lt;h1 slot="header"&gt; About Me &lt;/h1&gt; &lt;p&gt;Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.&lt;/p&gt; &lt;p slot="footer"&gt; Copyright 2016 Evan You &lt;/p&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt; 123456789101112Vue.component('blog-post', &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement('div', [ createElement('header', header), createElement('main', body), createElement('footer', footer) ]) &#125;&#125;) 参考： &lt;slot&gt; 组件 使用插槽分发内容 渲染函数 - 插槽 vm.$scopedSlots 2.1.0 新增 类型：{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; } 只读 详细： 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。 vm.$scopedSlots 在使用渲染函数开发一个组件时特别有用。 参考： &lt;slot&gt; 组件 作用域插槽 渲染函数 - 插槽 vm.$refs 类型：Object 只读 详细： 一个对象，持有已注册过 ref 的所有子组件。 参考： 子组件引用 特殊特性 - ref vm.$isServer 类型：boolean 只读 详细： 当前 Vue 实例是否运行于服务器。 参考：服务端渲染 vm.$attrs 类型：{ [key: string]: string } 只读 详细： 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建更高层次的组件时非常有用。 vm.$listeners 类型：{ [key: string]: Function | Array&lt;Function&gt; } 只读 详细： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 实例方法 / 数据vm.$watch( expOrFn, callback, [options] ) 参数： {string | Function} expOrFn {Function | Object} callback {Object} [options] {boolean} deep {boolean} immediate 返回值：{Function} unwatch 用法： 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 示例： 1234567891011121314// 键路径vm.$watch('a.b.c', function (newVal, oldVal) &#123; // 做点什么&#125;)// 函数vm.$watch( function () &#123; return this.a + this.b &#125;, function (newVal, oldVal) &#123; // 做点什么 &#125;) vm.$watch 返回一个取消观察函数，用来停止触发回调： 123var unwatch = vm.$watch('a', cb)// 之后取消观察unwatch() 选项：deep 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 12345vm.$watch('someObject', callback, &#123; deep: true&#125;)vm.someObject.nestedValue = 123// callback is fired 选项：immediate 在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调： 1234vm.$watch('a', callback, &#123; immediate: true&#125;)// 立即以 `a` 的当前值触发回调 vm.$set( target, key, value ) 参数： {Object | Array} target {string | number} key {any} value 返回值：设置的值。 用法： 这是全局 Vue.set 的别名。 参考：Vue.set vm.$delete( target, key ) 参数： {Object | Array} target {string | number} key 用法： 这是全局 Vue.delete 的别名。 参考：Vue.delete 实例方法 / 事件vm.$on( event, callback ) 参数： {string | Array&lt;string&gt;} event (数组只在 2.2.0+ 中支持) {Function} callback 用法： 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例： 12345vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi')// =&gt; "hi" vm.$once( event, callback ) 参数： {string} event {Function} callback 用法： 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 vm.$off( [event, callback] ) 参数： {string | Array&lt;string&gt;} event (只在 2.2.2+ 支持数组) {Function} [callback] 用法： 移除自定义事件监听器。 如果没有提供参数，则移除所有的事件监听器； 如果只提供了事件，则移除该事件所有的监听器； 如果同时提供了事件与回调，则只移除这个回调的监听器。 vm.$emit( event, […args] ) 参数： {string} event [...args] 触发当前实例上的事件。附加参数都会传给监听器回调。 实例方法 / 生命周期vm.$mount( [elementOrSelector] ) 参数： {Element | string} [elementOrSelector] {boolean} [hydrating] 返回值：vm - 实例自身 用法： 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。 如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。 这个方法返回实例自身，因而可以链式调用其它实例方法。 示例： 12345678910111213var MyComponent = Vue.extend(&#123; template: '&lt;div&gt;Hello!&lt;/div&gt;'&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount('#app')// 同上new MyComponent(&#123; el: '#app' &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById('app').appendChild(component.$el) 参考： 生命周期图示 服务端渲染 vm.$forceUpdate() 示例： 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 vm.$nextTick( [callback] ) 参数： {Function} [callback] 用法： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。 示例： 12345678910111213141516new Vue(&#123; // ... methods: &#123; // ... example: function () &#123; // 修改数据 this.message = 'changed' // DOM 还没有更新 this.$nextTick(function () &#123; // DOM 现在更新了 // `this` 绑定到当前实例 this.doSomethingElse() &#125;) &#125; &#125;&#125;) 参考：Vue.nextTick vm.$destroy() 用法： 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 触发 beforeDestroy 和 destroyed 的钩子。 在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。 参考：生命周期图示 指令v-text 预期：string 详细： 更新元素的 textContent。如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。 示例： 123&lt;span v-text="msg"&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 参考：数据绑定语法 - 插值 v-html 预期：string 详细： 更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 &lt;style&gt; 元素手动设置类似 BEM 的作用域策略。 示例： 1&lt;div v-html="html"&gt;&lt;/div&gt; 参考：数据绑定语法 - 插值 v-show 预期：any 用法： 根据表达式之真假值，切换元素的 display CSS 属性。 当条件变化时该指令触发过渡效果。 当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程 参考：条件渲染 - v-show v-if 预期：any 用法： 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。 当条件变化时该指令触发过渡效果。 参考：条件渲染 - v-if v-else 不需要表达式 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 为 v-if 或者 v-else-if 添加“else 块”。 123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; 参考：条件渲染 - v-else v-else-if 2.1.0 新增 类型：any 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 表示 v-if 的 “else if 块”。可以链式调用。 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 参考：条件渲染 - v-else-if v-for 预期：Array | Object | number | string 用法： 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名： 123&lt;div v-for="item in items"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; 另外也可以为数组索引指定别名 (或者用于对象的键)： 123&lt;div v-for="(item, index) in items"&gt;&lt;/div&gt;&lt;div v-for="(val, key) in object"&gt;&lt;/div&gt;&lt;div v-for="(val, key, index) in object"&gt;&lt;/div&gt; v-for 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性： 123&lt;div v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; v-for 的详细用法可以通过以下链接查看教程详细说明。 参考： 列表渲染 key v-on 缩写：@ 预期：Function | Inline Statement | Object 参数：event 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 用法： 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。 从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。 用在普通元素上时，只能监听 原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;。 示例： 1234567891011121314151617181920212223242526272829303132&lt;!-- 方法处理器 --&gt;&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on="&#123; mousedown: doThis, mouseup: doThat &#125;"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter="onEnter"&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13="onEnter"&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once="doThis"&gt;&lt;/button&gt; 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)： 1234567&lt;my-component @my-event="handleThis"&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event="handleThis(123, $event)"&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native="onClick"&gt;&lt;/my-component&gt; 参考： 事件处理器 组件 - 自定义事件 v-bind 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp (optional) 修饰符： .prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 用法： 动态地绑定一个或多个特性，或一个组件 prop 到表达式。 在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。 示例： 1234567891011121314151617181920212223242526272829303132&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src="imageSrc"&gt;&lt;!-- 缩写 --&gt;&lt;img :src="imageSrc"&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src="'/path/to/images/' + fileName"&gt;&lt;!-- class 绑定 --&gt;&lt;div :class="&#123; red: isRed &#125;"&gt;&lt;/div&gt;&lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;div :class="[classA, &#123; classB: isB, classC: isC &#125;]"&gt;&lt;!-- style 绑定 --&gt;&lt;div :style="&#123; fontSize: size + 'px' &#125;"&gt;&lt;/div&gt;&lt;div :style="[styleObjectA, styleObjectB]"&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind="&#123; id: someProp, 'other-attr': otherProp &#125;"&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop="text"&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop="someThing"&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind="$props"&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special="foo"&gt;&lt;/a&gt;&lt;/svg&gt; .camel 修饰符允许在使用 DOM 模板时将 v-bind 属性名称驼峰化，例如 SVG 的 viewBox 属性： 1&lt;svg :view-box.camel="viewBox"&gt;&lt;/svg&gt; 在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。 参考： Class 与 Style 绑定 组件 - Props 组件 - .sync 修饰符 v-model 预期：随表单控件类型不同而不同。 限制： &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components 修饰符： .lazy - 取代 input 监听 change 事件 .number - 输入字符串转为数字 .trim - 输入首尾空格过滤 用法： 在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。 参考： 表单控件绑定 组件 - 在输入组件上使用自定义事件 v-pre 不需要表达式 用法： 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 示例： 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; v-cloak 不需要表达式 用法： 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 示例： 123[v-cloak] &#123; display: none;&#125; 123&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 不会显示，直到编译结束。 v-once 不需要表达式 详细： 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment="msg"&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for="i in list" v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 参考： 数据绑定语法- 插值 组件 - 对低开销的静态组件使用 v-once 特殊特性key 预期：number | string key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 最常见的用例是结合 v-for： 123&lt;ul&gt; &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 例如： 123&lt;transition&gt; &lt;span :key="text"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt; 会随时被更新，因此会触发过渡。 ref 预期：string ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 12345&lt;!-- vm.$refs.p will be the DOM node --&gt;&lt;p ref="p"&gt;hello&lt;/p&gt;&lt;!-- vm.$refs.child will be the child comp instance --&gt;&lt;child-comp ref="child"&gt;&lt;/child-comp&gt; 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 参考：子组件 Refs slot 预期：string 用于标记往哪个具名插槽中插入子组件内容。 详细用法，请参考下面指南部分的链接。 参考：具名插槽 slot-scope 2.5.0 新增 预期：function argument expression 用法： 用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 scope。 此属性不支持动态绑定。 参考：Scoped Slots scope replaced用于表示一个作为带作用域的插槽的 &lt;template&gt; 元素，它在 2.5.0+ 中被 slot-scope 替代。 用法： 除了 scope 只可以用于 &lt;template&gt; 元素，其它和 slot-scope 都相同。 is 预期：string 用于动态组件且基于 DOM 内模板的限制来工作。 示例： 12345678&lt;!-- component changes when currentView changes --&gt;&lt;component v-bind:is="currentView"&gt;&lt;/component&gt;&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;&lt;!-- a `&lt;table&gt;` element and so would be hoisted out --&gt;&lt;table&gt; &lt;tr is="my-row"&gt;&lt;/tr&gt;&lt;/table&gt; 更多的使用细节，请移步至下面的链接。 See also： 动态组件 DOM 模板解析说明 内置的组件component Props： is - string | ComponentDefinition | ComponentConstructor inline-template - boolean 用法： 渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。 12345&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is="componentId"&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is="$options.components.child"&gt;&lt;/component&gt; 参考：动态组件 transition Props： name - string，用于自动生成 CSS 过渡类名。例如：name: &#39;fade&#39; 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 &quot;v&quot; appear - boolean，是否在初始渲染时使用过渡。默认为 false。 css - boolean，是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。 type - string，指定过渡事件类型，侦听过渡何时结束。有效值为 &quot;transition&quot; 和 &quot;animation&quot;。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。 mode - string，控制离开/进入的过渡时间序列。有效的模式有 &quot;out-in&quot; 和 &quot;in-out&quot;；默认同时生效。 enter-class - string leave-class - string appear-class - string enter-to-class - string leave-to-class - string appear-to-class - string enter-active-class - string leave-active-class - string appear-active-class - string 事件： before-enter before-leave before-appear enter leave appear after-enter after-leave after-appear enter-cancelled leave-cancelled (v-show only) appear-cancelled 用法： &lt;transition&gt; 元素作为单个元素/组件的过渡效果。&lt;transition&gt; 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。 12345678910111213141516&lt;!-- 简单元素 --&gt;&lt;transition&gt; &lt;div v-if="ok"&gt;toggled content&lt;/div&gt;&lt;/transition&gt;&lt;!-- 动态组件 --&gt;&lt;transition name="fade" mode="out-in" appear&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/transition&gt;&lt;!-- 事件钩子 --&gt;&lt;div id="transition-demo"&gt; &lt;transition @after-enter="transitionComplete"&gt; &lt;div v-show="ok"&gt;toggled content&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; 123456789new Vue(&#123; ... methods: &#123; transitionComplete: function (el) &#123; // 传入 'el' 这个 DOM 元素作为参数。 &#125; &#125; ...&#125;).$mount('#transition-demo') 参考：过渡：进入，离开和列表 transition-group Props： tag - string，默认为 span move-class - 覆盖移动过渡期间应用的 CSS 类。 除了 mode，其他特性和 &lt;transition&gt; 相同。 事件： 事件和 &lt;transition&gt; 相同。 用法： &lt;transition-group&gt; 元素作为多个元素/组件的过渡效果。&lt;transition-group&gt; 渲染一个真实的 DOM 元素。默认渲染 &lt;span&gt;，可以通过 tag 属性配置哪个元素应该被渲染。 注意，每个 &lt;transition-group&gt; 的子节点必须有 独立的 key ，动画才能正常工作 &lt;transition-group&gt; 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类 (通过 name 属性或配置 move-class 属性自动生成)。如果 CSS transform 属性是“可过渡”属性，当应用移动类时，将会使用 FLIP 技术 使元素流畅地到达动画终点。 12345&lt;transition-group tag="ul" name="slide"&gt; &lt;li v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; 参考：过渡：进入，离开和列表 keep-alive Props： include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 用法： &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 &lt;keep-alive&gt; 树内的所有嵌套组件中触发。 主要用于保留组件状态或避免重新渲染。 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 注意，&lt;keep-alive&gt; 是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，&lt;keep-alive&gt; 要求同时只有一个子元素被渲染。 include and exclude 2.1.0 新增 include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： 1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include="a,b"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include="['a', 'b']"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。 &lt;keep-alive&gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。 参考：动态组件 - keep-alive slot Props： name - string，用于命名插槽。 Usage： &lt;slot&gt; 元素作为组件模板之中的内容分发插槽。&lt;slot&gt; 元素自身将被替换。 详细用法，请参考下面教程的链接。 参考：使用插槽分发内容 VNode 接口 请参考 VNode class declaration。 服务端渲染 请参考 vue-server-renderer package documentation。本文内容来自 https://cn.vuejs.org]]></content>
      <categories>
        <category>VueJs</category>
      </categories>
      <tags>
        <tag>VueJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot微服框架学习(二)]]></title>
    <url>%2Fposts%2F31996.html</url>
    <content type="text"><![CDATA[简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 监听器、过滤器和拦截器监听器、过滤器和拦截器监听器监听器Listener，它是实现了javax.servlet.XXXListener接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 在javax.servlet.XXXListener接口中定义了2种方法： void contextInitialized(ServletContextEvent sce) 监听器的初始化 void contextDestroyed(ServletContextEvent sce) 监听器销毁 过滤器Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可以进行逻辑判断，如用户是否已经登录、有没有权限访问该页面等等工作，它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关的请求，只有当你的web应用停止或重新部署的时候才能销毁。 在javax.servlet.Filter接口中定义了3个方法： void init(FilterConfig filterConfig) 用于完成过滤器的初始化 void destroy() 用于过滤器销毁前，完成某些资源的回收 void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) 实现过滤功能，该方法对每个请求增加额外的处理 拦截器拦截器主要是用在插件上，扩展件上比如spring、struts2等有点类似面向切片的技术，它是基于java反射机制。定义拦截器： 实现HandlerInterceptor 接口，或者继承实现了HandlerInterceptor 接口的类（常用） 。 监听器、过滤器和拦截器的关系及区别 过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。 对请求起到过滤的作用，它在监听器之后，作用在servlet之前，对请求进行过滤。 拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。 监听器（Listener）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。对项目起到监听的作用，它能感知到包括request(请求域)，session(会话域)和applicaiton(应用程序)的初始化和属性的变化 。对请求和返回进行拦截，它作用在servlet的内部 。 它们之间的关系，可以用一张图来表示： 使用原则对整个流程清楚之后，然后就是各自的使用，在使用之前应该有一个使用规则，为什么这个说，因为有些功能比如判断用户是否登录，既可以用过滤器，也可以用拦截器，用哪一个才是合理的呢？那么如果有一个原则，使用起来就会更加合理。实际上这个原则是有的：把整个项目的流程比作一条河，那么监听器的作用就是能够听到河流里的所有声音，过滤器就是能够过滤出其中的鱼，而拦截器则是拦截其中的部分鱼，并且作标记。所以当需要监听到项目中的一些信息，并且不需要对流程做更改时，用监听器；当需要过滤掉其中的部分信息，只留一部分时，就用过滤器；当需要对其流程进行更改，做相关的记录时用拦截器。 监听器实现过程代码注册方式1234567891011121314151617181920import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class IndexListener implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println("IndexListener contextDestroyed method"); &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("IndexListener contextInitialized method"); &#125;&#125;@Beanpublic ServletListenerRegistrationBean servletListenerRegistrationBean()&#123; ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean(); servletListenerRegistrationBean.setListener(new IndexListener()); return servletListenerRegistrationBean;&#125; 注解方式1234567891011121314151617181920212223import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class IndexListener2 implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println("IndexListener2 contextDestroyed method"); &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("IndexListener2 contextInitialized method"); &#125;&#125;@SpringBootApplication@ServletComponentScanpublic class SpringBootSimpleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSimpleApplication.class, args); &#125;&#125; 过滤器实现过程代码注册方式1234567891011121314151617181920212223242526272829303132333435363738public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (......) &#123; ...... response.getWriter().write(writeValueAsString); &#125; else &#123; chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125;@Beanpublic FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); TestFilter testFilter = new TestFilter(); registrationBean.setFilter(testFilter); List&lt;String&gt; urlPatterns = new ArrayList&lt;String&gt;(); urlPatterns.add("/service/extract/json/*"); registrationBean.setUrlPatterns(urlPatterns); return registrationBean;&#125; 注解方式12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; /** * 实现javax.servlet.Filter,覆盖其三个方法 * @author Administrator * */ @WebFilter(filterName="testFilter",urlPatterns="/*") public class TestFilter implements Filter&#123; @Override public void destroy() &#123; System.out.println("TestFilter过滤器销毁"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("TestFilter指定过滤器操作......"); //执行操作后必须doFilter chain.doFilter(request, response); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; System.out.println("TestFilter初始化......"); &#125; &#125; @SpringBootApplication@ServletComponentScanpublic class SpringBootSimpleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSimpleApplication.class, args); &#125;&#125; 拦截器实现过程 创建自己的拦截器实现HandlerInterceptor接口 创建自己的拦截器链，继承WebMvcConfigurerAdapter类，重写addInterceptors方法。 实例化自己的拦截器，并加入到拦截器链中。 123456789101112131415161718192021222324252627282930import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class CustomInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object object, Exception exception) throws Exception &#123; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） System.out.println("3. 整个请求结束之后被调用......CustomInterceptor1......"); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object object, ModelAndView view) throws Exception &#123; // 请求处理之后进行调用，但是在视图被渲染之前 System.out.println("2. 请求处理之后进行调用，但是在视图被渲染之前......CustomInterceptor1......"); &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object object) throws Exception &#123; // 在请求处理之前进行调用 System.out.println("1. 在请求处理之前进行调用......CustomInterceptor1......"); // 只有返回true才会继续向下执行，返回false取消当前请求 return true; &#125; &#125; 123456789101112131415161718192021222324252627import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import com.example.Interceptor.CustomInterceptor; import com.example.Interceptor.CustomInterceptor2; /** * 继承WebMvcConfigurerAdapter，复写addInterceptors方法 * @author Administrator * */ @Configuration public class WebAdapter extends WebMvcConfigurerAdapter&#123; /** * 主要方法说明： * addPathPatterns 用于添加拦截规则 * excludePathPatterns 用于排除拦截 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; //众多的拦截器组成了一个拦截器链 registry.addInterceptor(new CustomInterceptor()).addPathPatterns("/*"); super.addInterceptors(registry); &#125; &#125; 默认日志logback配置日志简介Spring Boot使用Commons Logging记录所有内部日志，但是它将底层日志实现打开，为Java.Util.Logging，Log4J2和Logback提供默认配置。 在每个案例中，loggers都预先配置，以使用控制台输出，同时还提供可选的文件输出。 默认情况下，如果你使用“starters”，Logback将会被用于记录日志。还包括占用Logback路由，以确保使用Java Util Logging、Commons logging、Log4J或SLF4J的依赖库都能正常工作。 默认日志logbacklogback日志简介SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的绑定。 Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，可以看到很多INFO级别的日志。 从上图可以看到，日志输出内容元素具体如下： 时间日期：精确到毫秒 日志级别：ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符：— 标识实际日志的开始 线程名：方括号括起来（可能会截断控制台输出） Logger名：通常使用源代码的类名 日志内容 用Logback来记录日志，需添加日志依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。 application.properties配置中的日志相关属性控制台输出日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可： 在运行命令后加入–debug标志，如： 1$ java -jar springTest.jar --debug 在application.properties中配置debug=true 该属性置为true的时候，核心Loggers（包含嵌入式容器、hibernate、spring）会输出更多内容，启用debug模式并不会使用debug级别配置您的应用程序来记录所有信息。或者，您可以通过在应用程序中使用-trace标志(或在application.properties中配置trace=true)启动应用程序来启用“跟踪”模式。 文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 logging.file，设置指定的日志文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log logging.path，设置指定的目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO日志系统在应用程序生命周期的早期被初始化，并且在通过@propertysource注解加载的属性文件中不会找到这样的日志属性。日志属性与实际的日志基础结构无关。因此，特定的配置键(例如logback中的 logback.configurationFile )不是由spring boot管理的。 彩色日志输出省略... 日志级别所有支持日志记录的系统都可以在Spring环境中设置记录级别（例如在application.properties中）格式为：’logging.level.* = LEVEL’ logging.level：日志级别控制前缀，*为包名或Logger名 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF root日志可以使用 logging.level.root 配置，application.properties实例： 123logging.level.root=WARNlogging.level.org.springframework.web=DEBUGlogging.level.org.hibernate=ERROR 默认情况下，Spring boot对 Thymeleaf INFO 消息进行了重新映射，使它们在调试级别上被记录，这有助于减少标准日志输出中的噪声。有关如何在自己的配置中应用重新映射的详细信息，请参阅LevelRemappingAppender。 自定义日志配置可以通过在classpath中包含适当的库来激活各种日志系统，并通过在classpath根目录提供适当的配置进行定制。或者在适当的位置提供spring 环境属性logging.config。 还可以强制spring boot使用特定的日志系统通过使用 org.springframework.boot.logging.LoggingSystem 系统属性。 该值应该是一个 LoggingSystem 实现的完全限定类名。 您还可以使用none值完全禁用Spring boot的日志记录配置。 由于日志是在应用程序applicationContext上下文创建之前初始化的，所以不可能在Spring @configuration注解文件中控制来自@propertySource的日志记录。系统属性和常规的Spring boot外部配置文件已经工作得很好。 根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载： Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy Log4j2：log4j2-spring.xml, log4j2.xml JDK (Java Util Logging)：logging.properties 在可能的情况下，我们建议您使用-spring变体来进行日志配置( 如使用logback-spring.xml，而不是logback.xml )。如果使用标准配置logback.xml，Spring无法完全控制日志初始化。 Spring boot包含许多对Logback的扩展，可以帮助高级配置，您可以在您的logback-spring.xml文件中使用这些扩展。在标准配置logback.xml中不能使用这些扩展因为它太早被加载，当然如果一定要使用，需定义一个 logging.config 属性。 注：这些扩展不能与Logback的配置扫描一起使用。如果您尝试这样做，对配置文件进行更改将导致类似于以下日志记录之一的错误: 12ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]] logback日志介绍与配置logback介绍Logback是由log4j创始人设计的又一个开源日志组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。 Logback是要与SLF4J结合起来用两个组件的官方网站如下： logback的官方网站： http://logback.qos.ch SLF4J的官方网站：http://www.slf4j.org logback取代log4j的理由Logback和log4j是非常相似的，如果你对log4j很熟悉，那对logback很快就会得心应手。下面列了logback相对于log4j的一些优点： 更快的实现 Logback的内核重写，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升，初始化内存加载也更小。 非常充分的测试 Logback经过了几年，数不清小时的测试，Logback的测试完全不同级别的。在作者的观点，这是简单重要的原因选择logback而不是log4j。 Logback-classic非常自然实现了SLF4j 因为logback-classic非常自然地实现了SLF4J， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。 非常充分的文档 官方网站有两百多页的文档。 自动重新加载配置文件 当配置文件修改，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。 Lilith Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。 谨慎的模式和非常友好的恢复 在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件，RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。 配置文件可以处理不同的情况 开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。 Filters（过滤器） 有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需 加4行XML配置。可以参考MDCFIlter 。 SiftingAppender（一个非常多功能的Appender） 它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。 自动压缩已经打出来的log RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。 堆栈树带有包版本 Logback在打出堆栈树日志时，会带上包的数据。 自动去除旧的日志文件 通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。 总之，logback比log4j优秀。 logback配置Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以开头，后面有零个或多个元素，有零个或多个元素，有最多一个元素。 logback配置文件实例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false"&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name="LOG_HOME" value="/home" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!--myibatis log configure--&gt; &lt;logger name="com.apache.ibatis" level="TRACE"/&gt; &lt;logger name="java.sql.Connection" level="DEBUG"/&gt; &lt;logger name="java.sql.Statement" level="DEBUG"/&gt; &lt;logger name="java.sql.PreparedStatement" level="DEBUG"/&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;/configuration&gt; logback日志详解根节点包含的属性scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 例如： 123&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 其他配置省略--&gt;&lt;/configuration&gt; 根节点的子节点 设置上下文名称：每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。 1234&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置变量：用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 例如使用定义上下文名称，然后在设置logger上下文时使用。 12345&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;property name="APP_Name" value="myAppName" /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 获取时间戳字符串：有两个属性，key:标识此 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循java.txt.SimpleDateFormat的格式。 例如将解析配置文件的时间作为上下文名称： 12345&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置logger节点 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定。有一个必选的name属性，一个可选的level和一个可选的addtivity属性。 name:用来指定受此loger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。这里总结下各个节点的优先级：root&lt;appender&lt;logger。还需要在实践中不断总结，精确控制日志的输出 addtivity:是否向上级logger传递打印信息。默认是true。（用的不多）可以包含零个或多个元素，标识这个appender将会添加到这个logger。 实践总结：当中包含时，如果addtivity=true，则会将打印信息传递到root；如果addtivity=false，则只会在中打印信息，不会向上传递。 设置root节点也是元素，但是它是根logger， 只有一个level属性。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 实例： 12345678910111213141516package com.logback;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class LogbackDemo &#123; private static final Logger log = LoggerFactory.getLogger(LogbackDemo.class); public static void main(String[] args) &#123; log.trace("======trace"); log.debug("======debug"); log.info("======info"); log.warn("======warn"); log.error("======error"); &#125;&#125; logback.xml配置文件 第1种：只配置root 123456789101112&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将root的打印级别设置为“INFO”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，root将级别为“INFO”及大于“INFO”的日志信息交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； 打印结果如下： 12313:30:38.484 [main] INFO com.logback.LogbackDemo - ======info 13:30:38.500 [main] WARN com.logback.LogbackDemo - ======warn 13:30:38.500 [main] ERROR com.logback.LogbackDemo - ======error 第2种：带有logger的配置，不指定级别，不指定appender， 123456789101112&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- com.logback为java中的包 --&gt; &lt;logger name="com.logback" /&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将控制logback包下的所有类的日志的打印，但是并没有设置打印级别，所以继承他的上级的日志级别“DEBUG”；没有设置addtivity，默认为true，将此logger的打印信息向上级传递；没有设置appender，此logger本身不打印任何信息。将root的打印级别设置为“DEBUG”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，因为LogbackDemo 在包logback中，所以首先执行，将级别为“DEBUG”及大于“DEBUG”的日志信息传递给root，本身并不打印； root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台。 打印结果如下： 123413:19:15.406 [main] DEBUG com.logback.LogbackDemo - ======debug 13:19:15.406 [main] INFO com.logback.LogbackDemo - ======info 13:19:15.406 [main] WARN com.logback.LogbackDemo - ======warn 13:19:15.406 [main] ERROR com.logback.LogbackDemo - ======error 第3种：带有多个loger的配置，指定级别，指定appender 123456789101112131415&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.logback" /&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.logback.LogbackDemo" level="INFO" additivity="false"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/logger&gt; &lt;root level="ERROR"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将控制logback包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“DEBUG”；没有设置addtivity，默认为true，将此loger的打印信息向上级传递；没有设置appender，此loger本身不打印任何信息。 控制logback.LogbackDemo类的日志打印，打印级别为“INFO”；additivity属性为false，表示此loger的打印信息不再向上级传递，指定了名字为“STDOUT”的appender。将root的打印级别设置为“ERROR”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，先执行，将级别为“INFO”及大于“INFO”的日志信息交给此loger指定的名为“STDOUT”的appender处理，在控制台中打出日志，不再向次loger的上级 传递打印信息；未接到任何打印信息，当然也不会给它的上级root传递任何打印信息； 打印结果如下： 12314:05:35.937 [main] INFO com.logback.LogbackDemo - ======info14:05:35.937 [main] WARN com.logback.LogbackDemo - ======warn14:05:35.937 [main] ERROR com.logback.LogbackDemo - ======error 如果将修改为 那打印结果将是什么呢？ 没错，日志打印了两次，想必大家都知道原因了，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。 这里要注意，中是包含的，所以和节点中的append-ref同时打印日志信息。但是logger的优先级高于root，所以日志信息以logger为主 打印结果如下： 12345614:09:01.531 [main] INFO com.logback.LogbackDemo - ======info14:09:01.531 [main] INFO com.logback.LogbackDemo - ======info14:09:01.531 [main] WARN com.logback.LogbackDemo - ======warn14:09:01.531 [main] WARN com.logback.LogbackDemo - ======warn14:09:01.531 [main] ERROR com.logback.LogbackDemo - ======error14:09:01.531 [main] ERROR com.logback.LogbackDemo - ======error 设置appender节点 是的子节点，是负责写日志的组件。 有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。 ConsoleAppender: 把日志添加到控制台，有以下子节点： ：对日志进行格式化。（具体参数稍后讲解 ） ：字符串 System.out 或者 System.err ，默认 System.out ； 例如： 1234567891011&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; FileAppender: 把日志添加到文件，有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） ：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。 例如： 12345678910111213&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; RollingFileAppender: 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） :当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 : 告知 RollingFileAppender 合适激活滚动。 ：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 rollingPolicy： TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。有以下子节点： :必要节点，包含文件名及“%d”转换符， “%d”可以包含一个java.text.SimpleDateFormat指定的时间格式，如：%d{yyyy-MM}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\”会被当做目录分隔符。 :可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 FixedWindowRollingPolicy： 根据固定窗口算法重命名文件的滚动策略。有以下子节点： :窗口索引最小值 :窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。 :必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip triggeringPolicy: SizeBasedTriggeringPolicy： 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点::这是活动文件的大小，默认值是10MB。 例如：每天生成一个日志文件，保存30天的日志文件。 1234567891011121314151617&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 例如：按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。 12345678910111213141516171819202122&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其他Appender 另外还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这些就不在这里讲解了，大家可以参考官方文档。当然大家可以编写自己的Appender。 节点详解： 负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。 目前PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\”对“\%”进行转义。 例如： 123&lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder 里面的转换符说明： 格式修饰符，与转换符共同使用： 可选的格式修饰符位于“%”和转换符之间。 第一个可选修饰符是左对齐 标志，符号是减号“-”；接着是可选的最小宽度 修饰符，用十进制数表示。如果字符小于最小宽度，则左填充或右填充，默认是左填充（即右对齐），填充符为空格。如果字符大于最小宽度，字符永远不会被截断。最大宽度 修饰符，符号是点号”.”后面加十进制数。如果字符大于最大宽度，则从前面截断。点符号“.”后面加减号“-”在加数字，表示从尾部截断。 例如：%-4relative 表示，将输出从程序启动到创建日志记录的时间 进行左对齐 且最小宽度为4。 appender节点的子节点filter详解: 过滤器，执行一个过滤器会有返回个枚举值，即DENY，NEUTRAL，ACCEPT其中之一。返回DENY，日志将立即被抛弃不再经过其他过滤器；返回NEUTRAL，有序列表里的下个过滤器过接着处理日志；返回ACCEPT，日志会被立即处理，不再经过剩余过滤器。 过滤器被添加到 中，为 添加一个或多个过滤器后，可以用任意条件对日志进行过滤。 有多个过滤器时，按照配置顺序执行。 下面是几个常用的过滤器： LevelFilter： 级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。有以下子节点： :设置过滤级别 :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：将过滤器的日志级别配置为INFO，所有INFO级别的日志交给appender处理，非INFO级别的日志，被过滤掉。 1234567891011121314151617&lt;configuration&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt;&lt;/configuration&gt; ThresholdFilter： 临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。 例如：过滤掉所有低于INFO级别的日志。 12345678910111213141516&lt;configuration&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 过滤掉 TRACE 和 DEBUG 级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt;&lt;/configuration&gt; EvaluatorFilter： 求值过滤器，评估、鉴别日志是否符合指定条件。有一下子节点： :鉴别器，常用的鉴别器是JaninoEventEvaluato，也是默认的鉴别器，它以任意的java布尔值表达式作为求值条件，求值条件在配置文件解释过成功被动态编译，布尔值表达式返回true就表示符合过滤条件。evaluator有个子标签，用于配置求值条件。 求值表达式作用于当前日志，logback向求值表达式暴露日志的各种字段： :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：过滤掉所有日志消息中不包含“billing”字符串的日志。 123456789101112131415161718192021&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt; &lt;evaluator&gt; &lt;!-- 默认为 ch.qos.logback.classic.boolex.JaninoEventEvaluator --&gt; &lt;expression&gt;return message.contains("billing");&lt;/expression&gt; &lt;/evaluator&gt; &lt;OnMatch&gt;ACCEPT &lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; ：匹配器，尽管可以使用String类的matches()方法进行模式匹配，但会导致每次调用过滤器时都会创建一个新的Pattern对象，为了消除这种开销，可以预定义一个或多个matcher对象，定以后就可以在求值表达式中重复引用。是的子标签。中包含两个子标签，一个是，用于定义matcher的名字，求值表达式中使用这个名字来引用matcher；另一个是，用于配置匹配条件。 例如： 12345678910111213141516171819202122232425&lt;configuration debug="true"&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt; &lt;evaluator&gt; &lt;matcher&gt; &lt;Name&gt;odd&lt;/Name&gt; &lt;!-- filter out odd numbered statements --&gt; &lt;regex&gt;statement [13579]&lt;/regex&gt; &lt;/matcher&gt; &lt;expression&gt;odd.matches(formattedMessage)&lt;/expression&gt; &lt;/evaluator&gt; &lt;OnMismatch&gt;NEUTRAL&lt;/OnMismatch&gt; &lt;OnMatch&gt;DENY&lt;/OnMatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其他Filter不太常用我这里就不讲了，大家可以参见官网。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot微服框架学习(一)]]></title>
    <url>%2Fposts%2F48216.html</url>
    <content type="text"><![CDATA[简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。Spring Boot具有如下特性： 简化maven配置，快速创建独立的spring应用程序。 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 Spring Boot并不是不对Spring功能上的增强，而是提供了一种快速使用Spring的方式。 SpringBoot快速入门快速入门本博客Spring Boot使用版本1.5.8.RELEASE，Spring Boot 1.5.8.RELEASE需要Java 7和Spring Framework 4.3.12.RELEASE或更高版本,你也可以使用Spring Boot with Java 6和一些额外的配置（不建议）,使用Maven（3.2+）或Gradle 2（2.9或更高版本）和3来构建。 本博客系列统一使用Java 1.8，Spring Boot 1.5.8.RELEASE以及Maven3.2.5版本。 一个简单的spring boot项目结构如下： pom.xml：Maven构建说明文件。 DemoApplication.java：一个带有main()方法的类，用于启动应用程序（关键）。 application.properties：一个空的properties文件，你可以根据需要添加配置属性。 创建项目步骤 首先创建一个一般的Maven项目，有一个pom.xml和基本的src/main/java结构。 修改pom.xml为如下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; spring boot父级依赖&gt; 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;&lt;/parent&gt; 这块配置就是Spring Boot父级依赖，有了这个，当前的项目就是Spring Boot项目了，spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。 如果你不想使用某个依赖默认的版本，您还可以通过覆盖自己的项目中的属性来覆盖各个依赖项，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 原本默认版本是Ingalls-RELEASE的，现在就使用Fowler-SR2版本了。 并不是每个人都喜欢继承自spring-boot-starter-parentPOM。您可能有您需要使用的自己的公司标准parent，或者您可能更喜欢显式声明所有的Maven配置。如果你不想使用spring-boot-starter-parent，您仍然可以通过使用scope = import依赖关系来保持依赖关系管理： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 该设置不允许您使用如上所述的属性(properties)覆盖各个依赖项，要实现相同的结果，您需要在spring-boot-dependencies项之前的项目的dependencyManagement中添加一个配置，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 起步依赖spring-boot-starter-*&gt; Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。打个比方来说明一下这个起步依赖的好处，比如组装台式机和品牌机，自己组装的话需要自己去选择不同的零件，最后还要组装起来，期间有可能会遇到零件不匹配的问题。耗时又消力，而品牌机就好一点，买来就能直接用的，后续想换零件也是可以的。相比较之下，后者带来的效果更好点（这里就不讨论价格问题哈），起步依赖就像这里的品牌机，自动给你封装好了你想要实现的功能的依赖。就比如我们之前要实现web功能，引入了spring-boot-starter-web这个起步依赖。 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或者某类功能。 spring boot maven插件&gt; 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 上面的配置就是Spring Boot Maven插件，Spring Boot Maven插件提供了许多方便的功能： 把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。 搜索public static void main()方法来标记为可运行类。 应用入口类DemoApplication 123456789101112package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = "com.example")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; DemoApplication是一个很关键的启动类，程序的入口就是这里。@SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置。main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。 控制类DemoController 123456789101112package com.example.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 控制类中添加@RestController以及index方法，@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 运行 启动应用入口类，打开浏览器访问http://localhost:8080/hello, 你就能看到页面显示Hello Spring Boot效果了，一个简单的Web的项目就是如此简单。 单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new DemoController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 起步依赖spring-boot-starter- 详解 spring-boot-starter –The core Spring Boot starter, including auto-configuration support, logging and YAML. –Spring Boot starter核心模块，包括自动配置支持，日志和YAML。 spring-boot-starter-amqp –Support for the “Advanced Message Queuing Protocol” via spring-rabbit. –高级消息队列协议支持，通过spring-rabbit。 spring-boot-starter-aop –Support for aspect-oriented programming including spring-aop and AspectJ. –面向方面编程支持，包括spring-aop和AspectJ。 spring-boot-starter-batch –Support for “Spring Batch” including HSQLDB database. –Spring Batch批处理框架支持，包括HSQLDB。 spring-boot-starter-cloud-connectors –Support for “Spring Cloud Connectors” which simplifies connecting to services in cloud platforms like Cloud Foundry and Heroku. –简化云平台（Clound Foundry和Heroku）上服务连接的Spring Cloud Connectors支持。 spring-boot-starter-data-elasticsearch –Support for the Elasticsearch search and analytics engine including spring-data-elasticsearch. –Elasticsearch搜索和分析引擎支持，包括spring-data-elasticsearch。 spring-boot-starter-data-gemfire –Support for the GemFire distributed data store including spring-data-gemfire. –GemFire分布式数据存储支持，包括spring-data-gemfire。 spring-boot-starter-data-jpa –Support for the “Java Persistence API” including spring-data-jpa, spring-orm and Hibernate. –持久化支持，包括spring-data-jpa，spring-orm，Hibernate。 spring-boot-starter-data-mongodb –Support for the MongoDB NoSQL Database, including spring-data-mongodb. –MongoDB非关系型数据库支持，包括spring-data-mongodb。 spring-boot-starter-data-rest –Support for exposing Spring Data repositories over REST via spring-data-rest-webmvc. –在REST上暴露spring数据资源库支持，通过spring-data-rest-webmvc。 spring-boot-starter-data-solr –Support for the Apache Solr search platform, including spring-data-solr. –Apache Solr搜索平台支持，包括spring-data-solr。 spring-boot-starter-freemarker –Support for the FreeMarker templating engine. –FreeMarker模版引擎支持。 spring-boot-starter-groovy-templates –Support for the Groovy templating engine. –Groovy模版引擎支持。 spring-boot-starter-hateoas –Support for HATEOAS-based RESTful services via spring-hateoas. –基于hateoas的RESTful服务支持，通过spring-hateoas。 spring-boot-starter-hornetq –Support for “Java Message Service API” via HornetQ. –JMS（java消息服务）API支持，通过HornetQ（支持集群和多种协议，可嵌入、高性能的异步消息系统）。 spring-boot-starter-integration –Support for common spring-integration modules. –公用spring-integeration模块。 spring-boot-starter-jdbc –Support for JDBC databases. –数据库连接支持。 spring-boot-starter-jersey –Support for the Jersey RESTful Web Services framework. –Jersey RESTful Web服务框架支持。 spring-boot-starter-jta-atomikos –Support for JTA distributed transactions via Atomikos. –JTA分布式事务支持，通过Atomikos（Java平台提供增值服务的并且开源类事务管理器）。 spring-boot-starter-jta-bitronix –Support for JTA distributed transactions via Bitronix. –JTA分布式事务支持，通过Bitronix（事务管理器）。 spring-boot-starter-jta-narayana –JTA分布式事务支持，通过narayana（事务管理器）。 spring-boot-starter-mail –Support for javax.mail. spring-boot-starter-mobile –Support for spring-mobile. spring-boot-starter-mustache –Support for the Mustache templating engine. –Mustache模版引擎支持。 spring-boot-starter-redis –Support for the REDIS key-value data store, including spring-redis. –REDIS键值数据存储支持，包括spring-redis。 spring-boot-starter-security –Support for spring-security（基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架）. spring-boot-starter-social-facebook –Support for spring-social-facebook（提供了对Facebook社交网站的支持，只需要简单配置即可）. spring-boot-starter-social-linkedin –Support for spring-social-linkedin（提供了对Linkedin社交网站的支持，只需要简单配置即可）. spring-boot-starter-social-twitter –Support for spring-social-twitter（提供了对Twitter社交网站的支持，只需要简单配置即可）. spring-boot-starter-test –Support for common test dependencies, including JUnit, Hamcrest and Mockito along with the spring-test module. –公用测试依赖支持，包括JUnit，Hamcrest和Mockito，以及spring-test模块。 spring-boot-starter-thymeleaf –Support for the Thymeleaf templating engine, including integration with Spring. –Thymeleaf模版引擎支持，包括spring集成。 spring-boot-starter-velocity –Support for the Velocity templating engine. –Velocity模版引擎支持。 spring-boot-starter-web –Support for full-stack web development, including Tomcat and spring-webmvc. –完整的web开发支持，包括Tomcat和spring-webmvc。 spring-boot-starter-websocket –Support for WebSocket development. spring-boot-starter-ws –Support for Spring Web Services. spring-boot-starter-jooq –对jooq支持，使用jooq访问数据库。 spring-boot-starter-validation –对validation支持，使用Hibernate validation。 spring-boot-starter-activemq –对activemq支持。 spring-boot-starter-data-couchbase –对Couchbase面向文档的数据库和Spring Data Couchbase 的支持。 spring-boot-starter-data-neo4j –对neo4j（高性能的,NOSQL图形数据库）支持。 spring-boot-starter-data-cassandra –对cassandra（开源分布式NoSQL数据库系统）支持。 spring-boot-starter-cache –对缓存支持。 spring-boot-starter-data-ldap –对Spring data 准生产特性的Starter spring-boot-starter-actuator –Production ready features to help you monitor and manage your application. –生产就绪型功能，帮助你监控和管理你的应用。 spring-boot-starter-remote-shell –Adds remote ssh shell support. 排除或替换技术类的Starter spring-boot-starter-jetty –Imports the Jetty HTTP engine (to be used as an alternative to Tomcat). –导入Jetty HTTP引擎(用于作为Tomcat的另一种选择)。 spring-boot-starter-log4j –Support the Log4J logging framework. spring-boot-starter-logging –Import Spring Boot’s default logging framework (Logback). spring-boot-starter-tomcat –Import Spring Boot’s default HTTP engine (Tomcat). spring-boot-starter-undertow –Imports the Undertow HTTP engine (to be used as an alternative to Tomcat). –导入Undertow HTTP引擎(用于作为Tomcat的另一种选择)。 application.properties默认属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193#==============================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^#==============================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)# LOGGINGlogging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logbacklogging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.logging.file= # Log file name. For instance `myapp.log`logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`logging.path= # Location of the log file. For instance `/var/log`logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.# AOPspring.aop.auto=true # Add @EnableAspectJAutoProxy.spring.aop.proxy-target-class= # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false). Defaults to &quot;true&quot; when using Spring Transaction Management, otherwise &quot;false&quot;.# IDENTITY (ContextIdApplicationContextInitializer)spring.application.index= # Application index.spring.application.name= # Application name.# ADMIN (SpringApplicationAdminJmxAutoConfiguration)spring.application.admin.enabled=false # Enable admin features for the application.spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.# AUTO-CONFIGURATIONspring.autoconfigure.exclude= # Auto-configuration classes to exclude.# SPRING COREspring.beaninfo.ignore=true # Skip search of BeanInfo classes.# SPRING CACHE (CacheProperties)spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.spring.cache.caffeine.spec= # The spec to use to create caches. Check CaffeineSpec for more details on the spec format.spring.cache.couchbase.expiration=0 # Entry expiration in milliseconds. By default the entries never expire.spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.spring.cache.type= # Cache type, auto-detected according to the environment by default.# SPRING CONFIG - using environment property only (ConfigFileApplicationListener)spring.config.location= # Config file locations.spring.config.name=application # Config file name.# HAZELCAST (HazelcastProperties)spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.# PROJECT INFORMATION (ProjectInfoProperties)spring.info.build.location=classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.spring.info.git.location=classpath:git.properties # Location of the generated git.properties file.# JMXspring.jmx.default-domain= # JMX domain name.spring.jmx.enabled=true # Expose management beans to the JMX domain.spring.jmx.server=mbeanServer # MBeanServer bean name.# Email (MailProperties)spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.spring.mail.host= # SMTP server host. For instance `smtp.example.com`spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.spring.mail.password= # Login password of the SMTP server.spring.mail.port= # SMTP server port.spring.mail.properties.*= # Additional JavaMail session properties.spring.mail.protocol=smtp # Protocol used by the SMTP server.spring.mail.test-connection=false # Test that the mail server is available on startup.spring.mail.username= # Login user of the SMTP server.# APPLICATION SETTINGS (SpringApplication)spring.main.banner-mode=console # Mode used to display the banner when the application runs.spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.spring.main.web-environment= # Run the application in a web environment (auto-detected by default).# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding= # Expected character encoding the application must use.# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.always-use-message-format=false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.spring.messages.encoding=UTF-8 # Message bundles encoding.spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.# OUTPUTspring.output.ansi.enabled=detect # Configure the ANSI output.# PID FILE (ApplicationPidFileWriter)spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).# PROFILESspring.profiles.active= # Comma-separated list (or list if using YAML) of active profiles.spring.profiles.include= # Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).# SENDGRID (SendGridAutoConfiguration)spring.sendgrid.api-key= # SendGrid api key (alternative to username/password).spring.sendgrid.username= # SendGrid account username.spring.sendgrid.password= # SendGrid account password.spring.sendgrid.proxy.host= # SendGrid proxy host.spring.sendgrid.proxy.port= # SendGrid proxy port.# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.address= # Network address to which the server should bind to.server.compression.enabled=false # If response compression is enabled.server.compression.excluded-user-agents= # List of user-agents to exclude from compression.server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript # Comma-separated list of MIME types that should be compressed.server.compression.min-response-size=2048 # Minimum response size that is required for compression to be performed.server.connection-timeout= # Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector&apos;s container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`server.context-path= # Context path of the application.server.display-name=application # Display name of the application.server.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.server.error.include-stacktrace=never # When to include a &quot;stacktrace&quot; attribute.server.error.path=/error # Path of the error controller.server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.server.jetty.acceptors= # Number of acceptor threads to use.server.jetty.max-http-post-size=0 # Maximum size in bytes of the HTTP post or put content.server.jetty.selectors= # Number of selector threads to use.server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servletserver.jsp-servlet.registered=true # Whether or not the JSP servlet is registeredserver.port=8080 # Server HTTP port.server.server-header= # Value to use for the Server response header (no header is sent if empty)server.servlet-path=/ # Path of the main dispatcher servlet.server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.server.session.cookie.comment= # Comment for the session cookie.server.session.cookie.domain= # Domain for the session cookie.server.session.cookie.http-only= # &quot;HttpOnly&quot; flag for the session cookie.server.session.cookie.max-age= # Maximum age of the session cookie in seconds.server.session.cookie.name= # Session cookie name.server.session.cookie.path= # Path of the session cookie.server.session.cookie.secure= # &quot;Secure&quot; flag for the session cookie.server.session.persistent=false # Persist session data between restarts.server.session.store-dir= # Directory used to store session data.server.session.timeout= # Session timeout in seconds.server.session.tracking-modes= # Session tracking modes (one or more of the following: &quot;cookie&quot;, &quot;url&quot;, &quot;ssl&quot;).server.ssl.ciphers= # Supported SSL ciphers.server.ssl.client-auth= # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store.server.ssl.enabled= # Enable SSL support.server.ssl.enabled-protocols= # Enabled SSL protocols.server.ssl.key-alias= # Alias that identifies the key in the key store.server.ssl.key-password= # Password used to access the key in the key store.server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password= # Password used to access the key store.server.ssl.key-store-provider= # Provider for the key store.server.ssl.key-store-type= # Type of the key store.server.ssl.protocol=TLS # SSL protocol to use.server.ssl.trust-store= # Trust store that holds SSL certificates.server.ssl.trust-store-password= # Password used to access the trust store.server.ssl.trust-store-provider= # Provider for the trust store.server.ssl.trust-store-type= # Type of the trust store.server.tomcat.accept-count= # Maximum queue length for incoming connection requests when all possible request processing threads are in use.server.tomcat.accesslog.buffered=true # Buffer output such that it is only flushed periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # Date format to place in log file name.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address, Hostname, protocol and port used for the request.server.tomcat.accesslog.rotate=true # Enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-connections= # Maximum number of connections that the server will accept and process at any given time.server.tomcat.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.tomcat.max-threads=0 # Maximum amount of worker threads.server.tomcat.min-spare-threads=0 # Minimum amount of worker threads.server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named &quot;X-Forwarded-Proto&quot;.server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected by appending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.server.undertow.accesslog.dir= # Undertow access log directory.server.undertow.accesslog.enabled=false # Enable access log.server.undertow.accesslog.pattern=common # Format pattern for access logs.server.undertow.accesslog.prefix=access_log. # Log file name prefix.server.undertow.accesslog.rotate=true # Enable access log rotation.server.undertow.accesslog.suffix=log # Log file name suffix.server.undertow.buffer-size= # Size of each buffer in bytes.server.undertow.direct-buffers= # Allocate buffers outside the Java heap.server.undertow.io-threads= # Number of I/O threads to create for the worker.server.undertow.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.undertow.worker-threads= # Number of worker threads.# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.cache=false # Enable template caching.spring.freemarker.charset=UTF-8 # Template encoding.spring.freemarker.check-template-location=true # Check that the templates location exists.spring.freemarker.content-type=text/html # Content-Type value.spring.freemarker.enabled=true # Enable MVC view resolution for this technology.spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker&apos;s Configuration.spring.freemarker.suffix=.ftl # Suffix that gets appended to view names when building a URL.spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.spring.freemarker.view-names= # White list of view names that can be resolved.# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.cache= # Enable template caching.spring.groovy.template.charset=UTF-8 # Template encoding.spring.groovy.template.check-template-location=true # Check that the templates location exists.spring.groovy.template.configuration.*= # See GroovyMarkupConfigurerspring.groovy.template.content-type=test/html # Content-Type value.spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.spring.groovy.template.view-names= # White list of view names that can be resolved.# SPRING HATEOAS (HateoasProperties)spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.# HTTP message conversionspring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to &quot;gson&quot; to force the use of Gson when both it and Jackson are on the classpath.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.spring.http.encoding.enabled=true # Enable http encoding support.spring.http.encoding.force= # Force the encoding to the configured charset on HTTP requests and responses.spring.http.encoding.force-request= # Force the encoding to the configured charset on HTTP requests. Defaults to true when &quot;force&quot; has not been specified.spring.http.encoding.force-response= # Force the encoding to the configured charset on HTTP responses.spring.http.encoding.mapping= # Locale to Encoding mapping.# MULTIPART (MultipartProperties)spring.http.multipart.enabled=true # Enable support of multi-part uploads.spring.http.multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.location= # Intermediate location of uploaded files.spring.http.multipart.max-file-size=1MB # Max file size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.max-request-size=10MB # Max request size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.resolve-lazily=false # Whether to resolve the multipart request lazily at the time of file or parameter access.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization.spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.spring.jackson.generator.*= # Jackson on/off features for generators.spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, &quot;date-format&quot; will be used as a fallback if it is configured with a format string.spring.jackson.locale= # Locale used for formatting.spring.jackson.mapper.*= # Jackson general purpose on/off features.spring.jackson.parser.*= # Jackson on/off features for parsers.spring.jackson.property-naming-strategy= # One of the constants on Jackson&apos;s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`# JERSEY (JerseyProperties)spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of &quot;@ApplicationPath&quot; if specified.spring.jersey.filter.order=0 # Jersey filter chain order.spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.spring.jersey.servlet.load-on-startup=-1 # Load on startup priority of the Jersey servlet.spring.jersey.type=servlet # Jersey integration type.# SPRING LDAP (LdapProperties)spring.ldap.urls= # LDAP URLs of the server.spring.ldap.base= # Base suffix from which all operations should originate.spring.ldap.username= # Login user of the server.spring.ldap.password= # Login password of the server.spring.ldap.base-environment.*= # LDAP specification settings.# EMBEDDED LDAP (EmbeddedLdapProperties)spring.ldap.embedded.base-dn= # The base DNspring.ldap.embedded.credential.username= # Embedded LDAP username.spring.ldap.embedded.credential.password= # Embedded LDAP password.spring.ldap.embedded.ldif=classpath:schema.ldif # Schema (LDIF) script resource reference.spring.ldap.embedded.port= # Embedded LDAP port.spring.ldap.embedded.validation.enabled=true # Enable LDAP schema validation.spring.ldap.embedded.validation.schema= # Path to the custom schema.# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.# MUSTACHE TEMPLATES (MustacheAutoConfiguration)spring.mustache.allow-request-override= # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.allow-session-override= # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.cache= # Enable template caching.spring.mustache.charset= # Template encoding.spring.mustache.check-template-location= # Check that the templates location exists.spring.mustache.content-type= # Content-Type value.spring.mustache.enabled= # Enable MVC view resolution for this technology.spring.mustache.expose-request-attributes= # Set whether all request attributes should be added to the model prior to merging with the template.spring.mustache.expose-session-attributes= # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.mustache.expose-spring-macro-helpers= # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.spring.mustache.request-context-attribute= # Name of the RequestContext attribute for all views.spring.mustache.suffix=.html # Suffix to apply to template names.spring.mustache.view-names= # White list of view names that can be resolved.# SPRING MVC (WebMvcProperties)spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.spring.mvc.dispatch-options-request=true # Dispatch OPTIONS requests to the FrameworkServlet doService method.spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.spring.mvc.formcontent.putfilter.enabled=true # Enable Spring&apos;s HttpPutFormContentFilter.spring.mvc.ignore-default-model-on-redirect=true # If the content of the &quot;default&quot; model should be ignored during redirect scenarios.spring.mvc.locale= # Locale to use. By default, this locale is overridden by the &quot;Accept-Language&quot; header.spring.mvc.locale-resolver=accept-header # Define how the locale should be resolved.spring.mvc.log-resolved-exception=false # Enable warn logging of exceptions resolved by a &quot;HandlerExceptionResolver&quot;.spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.throw-exception-if-no-handler-found=false # If a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# SPRING RESOURCES HANDLING (ResourceProperties)spring.resources.add-mappings=true # Enable default resource handling.spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.spring.resources.chain.cache=true # Enable caching in the Resource chain.spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.spring.resources.chain.gzipped=false # Enable resolution of already gzipped resources.spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.spring.resources.chain.strategy.fixed.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.# SPRING SESSION (SessionProperties)spring.session.hazelcast.flush-mode=on-save # Sessions flush mode.spring.session.hazelcast.map-name=spring:session:sessions # Name of the map used to store sessions.spring.session.jdbc.initializer.enabled= # Create the required session tables on startup if necessary. Enabled automatically if the default table name is set or a custom schema is configured.spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.session.jdbc.table-name=SPRING_SESSION # Name of database table used to store sessions.spring.session.mongo.collection-name=sessions # Collection name used to store sessions.spring.session.redis.flush-mode=on-save # Sessions flush mode.spring.session.redis.namespace= # Namespace for keys used to store sessions.spring.session.store-type= # Session store type.# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=false # Enable the connection status view for supported providers.# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.cache=true # Enable template caching.spring.thymeleaf.check-template=true # Check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Check that the templates location exists.spring.thymeleaf.content-type=text/html # Content-Type value.spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.spring.thymeleaf.encoding=UTF-8 # Template encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.# SPRING WEB SERVICES (WebServicesProperties)spring.webservices.path=/services # Path that serves as the base URI for the services.spring.webservices.servlet.init= # Servlet init parameters to pass to Spring Web Services.spring.webservices.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)security.basic.authorize-mode=role # Security authorize mode to apply.security.basic.enabled=true # Enable basic authentication.security.basic.path=/** # Comma-separated list of paths to secure.security.basic.realm=Spring # HTTP basic realm name.security.enable-csrf=false # Enable Cross Site Request Forgery support.security.filter-order=0 # Security filter chain order.security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.security.headers.cache=true # Enable cache control HTTP headers.security.headers.content-security-policy= # Value for content security policy header.security.headers.content-security-policy-mode=default # Content security policy mode.security.headers.content-type=true # Enable &quot;X-Content-Type-Options&quot; header.security.headers.frame=true # Enable &quot;X-Frame-Options&quot; header.security.headers.hsts=all # HTTP Strict Transport Security (HSTS) mode (none, domain, all).security.headers.xss=true # Enable cross site scripting (XSS) protection.security.ignored= # Comma-separated list of paths to exclude from the default secured paths.security.require-ssl=false # Enable secure channel for all requests.security.sessions=stateless # Session creation policy (always, never, if_required, stateless).security.user.name=user # Default user name.security.user.password= # Password for the default user name. A random password is logged on startup by default.security.user.role=USER # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)security.oauth2.client.client-id= # OAuth2 client id.security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default# SECURITY OAUTH2 RESOURCES (ResourceServerProperties)security.oauth2.resource.filter-order= # The order of the filter chain used to authenticate tokens.security.oauth2.resource.id= # Identifier of the resource.security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.security.oauth2.resource.jwk.key-set-uri= # The URI for getting the set of keys that can be used to validate the token.security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.security.oauth2.resource.service-id=resource #security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.security.oauth2.resource.user-info-uri= # URI of the user endpoint.# SECURITY OAUTH2 SSO (OAuth2SsoProperties)security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdaptersecurity.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server# ----------------------------------------# DATA PROPERTIES# ----------------------------------------# FLYWAY (FlywayProperties)flyway.baseline-description= #flyway.baseline-version=1 # version to start migrationflyway.baseline-on-migrate= #flyway.check-location=false # Check that migration scripts location exists.flyway.clean-on-validation-error= #flyway.enabled=true # Enable flyway.flyway.encoding= #flyway.ignore-failed-future-migration= #flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.flyway.locations=classpath:db/migration # locations of migrations scriptsflyway.out-of-order= #flyway.password= # JDBC password if you want Flyway to create its own DataSourceflyway.placeholder-prefix= #flyway.placeholder-replacement= #flyway.placeholder-suffix= #flyway.placeholders.*= #flyway.schemas= # schemas to updateflyway.sql-migration-prefix=V #flyway.sql-migration-separator= #flyway.sql-migration-suffix=.sql #flyway.table= #flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.flyway.user= # Login user of the database to migrate.flyway.validate-on-migrate= ## LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.liquibase.check-change-log-location=true # Check the change log location exists.liquibase.contexts= # Comma-separated list of runtime contexts to use.liquibase.default-schema= # Default database schema.liquibase.drop-first=false # Drop the database schema first.liquibase.enabled=true # Enable liquibase support.liquibase.labels= # Comma-separated list of runtime labels to use.liquibase.parameters.*= # Change log parameters.liquibase.password= # Login password of the database to migrate.liquibase.rollback-file= # File to which rollback SQL will be written when an update is performed.liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.liquibase.user= # Login user of the database to migrate.# COUCHBASE (CouchbaseProperties)spring.couchbase.bootstrap-hosts= # Couchbase nodes (host or IP address) to bootstrap from.spring.couchbase.bucket.name=default # Name of the bucket to connect to.spring.couchbase.bucket.password= # Password of the bucket.spring.couchbase.env.endpoints.key-value=1 # Number of sockets per node against the Key/value service.spring.couchbase.env.endpoints.query=1 # Number of sockets per node against the Query (N1QL) service.spring.couchbase.env.endpoints.view=1 # Number of sockets per node against the view service.spring.couchbase.env.ssl.enabled= # Enable SSL support. Enabled automatically if a &quot;keyStore&quot; is provided unless specified otherwise.spring.couchbase.env.ssl.key-store= # Path to the JVM key store that holds the certificates.spring.couchbase.env.ssl.key-store-password= # Password used to access the key store.spring.couchbase.env.timeouts.connect=5000 # Bucket connections timeout in milliseconds.spring.couchbase.env.timeouts.key-value=2500 # Blocking operations performed on a specific key timeout in milliseconds.spring.couchbase.env.timeouts.query=7500 # N1QL query operations timeout in milliseconds.spring.couchbase.env.timeouts.socket-connect=1000 # Socket connect connections timeout in milliseconds.spring.couchbase.env.timeouts.view=7500 # Regular and geospatial view operations timeout in milliseconds.# DAO (PersistenceExceptionTranslationAutoConfiguration)spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.# CASSANDRA (CassandraProperties)spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.spring.data.cassandra.compression=none # Compression supported by the Cassandra binary protocol.spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.spring.data.cassandra.consistency-level= # Queries consistency level.spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.spring.data.cassandra.fetch-size= # Queries default fetch size.spring.data.cassandra.keyspace-name= # Keyspace name to use.spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.spring.data.cassandra.port= # Port of the Cassandra server.spring.data.cassandra.password= # Login password of the server.spring.data.cassandra.read-timeout-millis= # Socket option: read time out.spring.data.cassandra.reconnection-policy= # Reconnection policy class.spring.data.cassandra.repositories.enabled= # Enable Cassandra repositories.spring.data.cassandra.retry-policy= # Class name of the retry policy.spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.spring.data.cassandra.schema-action=none # Schema action to take at startup.spring.data.cassandra.ssl=false # Enable SSL support.spring.data.cassandra.username= # Login user of the server.# DATA COUCHBASE (CouchbaseDataProperties)spring.data.couchbase.auto-index=false # Automatically create views and indexes.spring.data.couchbase.consistency=read-your-own-writes # Consistency to apply by default on generated queries.spring.data.couchbase.repositories.enabled=true # Enable Couchbase repositories.# ELASTICSEARCH (ElasticsearchProperties)spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.# DATA LDAPspring.data.ldap.repositories.enabled=true # Enable LDAP repositories.# MONGODB (MongoProperties)spring.data.mongodb.authentication-database= # Authentication database name.spring.data.mongodb.database=test # Database name.spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database= # GridFS database name.spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.# DATA REDISspring.data.redis.repositories.enabled=true # Enable Redis repositories.# NEO4J (Neo4jProperties)spring.data.neo4j.compiler= # Compiler to use.spring.data.neo4j.embedded.enabled=true # Enable embedded mode if the embedded driver is available.spring.data.neo4j.open-in-view=false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.spring.data.neo4j.password= # Login password of the server.spring.data.neo4j.repositories.enabled=true # Enable Neo4j repositories.spring.data.neo4j.uri= # URI used by the driver. Auto-detected by default.spring.data.neo4j.username= # Login user of the server.# DATA REST (RepositoryRestProperties)spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.spring.data.rest.default-page-size= # Default size of pages.spring.data.rest.detection-strategy=default # Strategy to use to determine which repositories get exposed.spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.spring.data.rest.max-page-size= # Maximum size of pages.spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.spring.data.rest.return-body-on-create= # Return a response body after creating an entity.spring.data.rest.return-body-on-update= # Return a response body after updating an entity.spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.# SOLR (SolrProperties)spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if &quot;zk-host&quot; is set.spring.data.solr.repositories.enabled=true # Enable Solr repositories.spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.spring.datasource.data= # Data (DML) script resource references.spring.datasource.data-username= # User of the database to execute DML scripts (if different).spring.datasource.data-password= # Password of the database to execute DML scripts (if different).spring.datasource.dbcp2.*= # Commons DBCP2 specific settingsspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.generate-unique-name=false # Generate a random datasource name.spring.datasource.hikari.*= # Hikari specific settingsspring.datasource.initialize=true # Populate the database using &apos;data.sql&apos;.spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.spring.datasource.name=testdb # Name of the datasource.spring.datasource.password= # Login password of the database.spring.datasource.platform=all # Platform to use in the DDL or DML scripts (e.g. schema-$&#123;platform&#125;.sql or data-$&#123;platform&#125;.sql).spring.datasource.schema= # Schema (DDL) script resource references.spring.datasource.schema-username= # User of the database to execute DDL scripts (if different).spring.datasource.schema-password= # Password of the database to execute DDL scripts (if different).spring.datasource.separator=; # Statement separator in SQL initialization scripts.spring.datasource.sql-script-encoding= # SQL scripts encoding.spring.datasource.tomcat.*= # Tomcat datasource specific settingsspring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.spring.datasource.url= # JDBC url of the database.spring.datasource.username= # Login user of the database.spring.datasource.xa.data-source-class-name= # XA datasource fully qualified name.spring.datasource.xa.properties= # Properties to pass to the XA data source.# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.connection-timeout=3000 # Connection timeout in milliseconds.spring.elasticsearch.jest.multi-threaded=true # Enable connection requests from multiple execution threads.spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3000 # Read timeout in milliseconds.spring.elasticsearch.jest.uris=http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.spring.elasticsearch.jest.username= # Login user.# H2 Web Console (H2ConsoleProperties)spring.h2.console.enabled=false # Enable the console.spring.h2.console.path=/h2-console # Path at which the console will be available.spring.h2.console.settings.trace=false # Enable trace output.spring.h2.console.settings.web-allow-others=false # Enable remote access.# JOOQ (JooqAutoConfiguration)spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.data.jpa.repositories.enabled=true # Enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the &quot;databasePlatform&quot; property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum.spring.jpa.generate-ddl=false # Initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Default to &quot;create-drop&quot; when using an embedded database, &quot;none&quot; otherwise.spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.naming.strategy= # Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate 5.spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate&apos;s newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Enable logging of SQL statements.# JTA (JtaAutoConfiguration)spring.jta.enabled=true # Enable JTA support.spring.jta.log-dir= # Transaction logs directory.spring.jta.transaction-manager-id= # Transaction manager unique identifier.# ATOMIKOS (AtomikosProperties)spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool&apos;s maintenance thread.spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool&apos;s maintenance thread.spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.atomikos.properties.checkpoint-interval=500 # Interval between checkpoints.spring.jta.atomikos.properties.default-jta-timeout=10000 # Default timeout for JTA transactions.spring.jta.atomikos.properties.enable-logging=true # Enable disk logging.spring.jta.atomikos.properties.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.spring.jta.atomikos.properties.log-base-dir= # Directory in which the log files should be stored.spring.jta.atomikos.properties.log-base-name=tmlog # Transactions log file base name.spring.jta.atomikos.properties.max-actives=50 # Maximum number of active transactions.spring.jta.atomikos.properties.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.spring.jta.atomikos.properties.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.spring.jta.atomikos.properties.service= # Transaction manager implementation that should be started.spring.jta.atomikos.properties.threaded-two-phase-commit=false # Use different (and concurrent) threads for two-phase commit on the participating resources.spring.jta.atomikos.properties.transaction-manager-unique-name= # Transaction manager&apos;s unique name.# BITRONIXspring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.spring.jta.bitronix.connectionfactory.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.spring.jta.bitronix.datasource.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.properties.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.spring.jta.bitronix.properties.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.spring.jta.bitronix.properties.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.spring.jta.bitronix.properties.current-node-only-recovery=true # Recover only the current node.spring.jta.bitronix.properties.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.spring.jta.bitronix.properties.default-transaction-timeout=60 # Default transaction timeout in seconds.spring.jta.bitronix.properties.disable-jmx=false # Enable JMX support.spring.jta.bitronix.properties.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.spring.jta.bitronix.properties.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.spring.jta.bitronix.properties.force-batching-enabled=true # Set if disk forces are batched.spring.jta.bitronix.properties.forced-write-enabled=true # Set if logs are forced to disk.spring.jta.bitronix.properties.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.spring.jta.bitronix.properties.jndi-user-transaction-name= # JNDI name of the UserTransaction.spring.jta.bitronix.properties.journal=disk # Name of the journal. Can be &apos;disk&apos;, &apos;null&apos; or a class name.spring.jta.bitronix.properties.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.spring.jta.bitronix.properties.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.spring.jta.bitronix.properties.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.spring.jta.bitronix.properties.resource-configuration-filename= # ResourceLoader configuration file name.spring.jta.bitronix.properties.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine&apos;s IP address.spring.jta.bitronix.properties.skip-corrupted-logs=false # Skip corrupted transactions log entries.spring.jta.bitronix.properties.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.# NARAYANA (NarayanaProperties)spring.jta.narayana.default-timeout=60 # Transaction timeout in seconds.spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.spring.jta.narayana.log-dir= # Transaction object store directory.spring.jta.narayana.one-phase-commit=true # Enable one phase commit optimisation.spring.jta.narayana.periodic-recovery-period=120 # Interval in which periodic recovery scans are performed in seconds.spring.jta.narayana.recovery-backoff-period=10 # Back off period between first and second phases of the recovery scan in seconds.spring.jta.narayana.recovery-db-pass= # Database password to be used by recovery manager.spring.jta.narayana.recovery-db-user= # Database username to be used by recovery manager.spring.jta.narayana.recovery-jms-pass= # JMS password to be used by recovery manager.spring.jta.narayana.recovery-jms-user= # JMS username to be used by recovery manager.spring.jta.narayana.recovery-modules= # Comma-separated list of recovery modules.spring.jta.narayana.transaction-manager-id=1 # Unique transaction manager id.spring.jta.narayana.xa-resource-orphan-filters= # Comma-separated list of orphan filters.# EMBEDDED MONGODB (EmbeddedMongoProperties)spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.spring.mongodb.embedded.storage.database-dir= # Directory used for data storage.spring.mongodb.embedded.storage.oplog-size= # Maximum size of the oplog in megabytes.spring.mongodb.embedded.storage.repl-set-name= # Name of the replica set.spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.# REDIS (RedisProperties)spring.redis.cluster.max-redirects= # Maximum number of redirects to follow when executing commands across the cluster.spring.redis.cluster.nodes= # Comma-separated list of &quot;host:port&quot; pairs to bootstrap from.spring.redis.database=0 # Database index used by the connection factory.spring.redis.url= # Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.ssl=false # Enable SSL support.spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.spring.redis.pool.max-idle=8 # Max number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.spring.redis.port=6379 # Redis server port.spring.redis.sentinel.master= # Name of Redis server.spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.spring.redis.timeout=0 # Connection timeout in milliseconds.# TRANSACTION (TransactionProperties)spring.transaction.default-timeout= # Default transaction timeout in seconds.spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.# ----------------------------------------# INTEGRATION PROPERTIES# ----------------------------------------# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default.spring.activemq.close-timeout=15000 # Time to wait, in milliseconds, before considering a close complete.spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.spring.activemq.non-blocking-redelivery=false # Do not stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order will not be preserved when this is enabled.spring.activemq.password= # Login password of the broker.spring.activemq.send-timeout=0 # Time to wait, in milliseconds, on Message sends for a response. Set it to 0 to indicate to wait forever.spring.activemq.user= # Login user of the broker.spring.activemq.packages.trust-all= # Trust all packages.spring.activemq.packages.trusted= # Comma-separated list of specific packages to trust (when not trusting all packages).spring.activemq.pool.block-if-full=true # Block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.spring.activemq.pool.block-if-full-timeout=-1 # Blocking period, in milliseconds, before throwing an exception if the pool is still full.spring.activemq.pool.create-connection-on-startup=true # Create a connection on startup. Can be used to warm-up the pool on startup.spring.activemq.pool.enabled=false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.spring.activemq.pool.expiry-timeout=0 # Connection expiration timeout in milliseconds.spring.activemq.pool.idle-timeout=30000 # Connection idle timeout in milliseconds.spring.activemq.pool.max-connections=1 # Maximum number of pooled connections.spring.activemq.pool.maximum-active-session-per-connection=500 # Maximum number of active sessions per connection.spring.activemq.pool.reconnect-on-exception=true # Reset the connection when a &quot;JMXException&quot; occurs.spring.activemq.pool.time-between-expiration-check=-1 # Time to sleep, in milliseconds, between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.spring.activemq.pool.use-anonymous-producers=true # Use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.# ARTEMIS (ArtemisProperties)spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.spring.artemis.embedded.persistent=false # Enable persistent store.spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.spring.artemis.host=localhost # Artemis broker host.spring.artemis.mode= # Artemis deployment mode, auto-detected by default.spring.artemis.password= # Login password of the broker.spring.artemis.port=61616 # Artemis broker port.spring.artemis.user= # Login user of the broker.# SPRING BATCH (BatchProperties)spring.batch.initializer.enabled= # Create the required batch tables on startup if necessary. Enabled automatically if no custom table prefix is set or if a custom schema is configured.spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.# JMS (JmsProperties)spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.spring.jms.listener.auto-startup=true # Start the container automatically on startup.spring.jms.listener.concurrency= # Minimum number of concurrent consumers.spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.spring.jms.template.default-destination= # Default destination to use on send/receive operations that do not have a destination parameter.spring.jms.template.delivery-delay= # Delivery delay to use for send calls in milliseconds.spring.jms.template.delivery-mode= # Delivery mode. Enable QoS when set.spring.jms.template.priority= # Priority of a message when sending. Enable QoS when set.spring.jms.template.qos-enabled= # Enable explicit QoS when sending a message.spring.jms.template.receive-timeout= # Timeout to use for receive calls in milliseconds.spring.jms.template.time-to-live= # Time-to-live of a message when sending in milliseconds. Enable QoS when set.# APACHE KAFKA (KafkaProperties)spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if &apos;enable.auto.commit&apos; true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.consumer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.enable-auto-commit= # If true the consumer&apos;s offset will be periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn&apos;t sufficient data to immediately satisfy the requirement given by &quot;fetch.min.bytes&quot;.spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request in bytes.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group this consumer belongs to.spring.kafka.consumer.heartbeat-interval= # Expected time in milliseconds between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is &quot;COUNT&quot; or &quot;COUNT_TIME&quot;.spring.kafka.listener.ack-mode= # Listener AckMode; see the spring-kafka documentation.spring.kafka.listener.ack-time= # Time in milliseconds between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.poll-timeout= # Timeout in milliseconds to use when polling the consumer.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Number of records to batch before sending.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.producer.buffer-memory= # Total bytes of memory the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.keystore-location= # Location of the key store file.spring.kafka.ssl.keystore-password= # Store password for the key store file.spring.kafka.ssl.truststore-location= # Location of the trust store file.spring.kafka.ssl.truststore-password= # Store password for the trust store file.spring.kafka.template.default-topic= # Default topic to which messages will be sent.# RABBIT (RabbitProperties)spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect.spring.rabbitmq.cache.channel.checkout-timeout= # Number of milliseconds to wait to obtain a channel if the cache size has been reached.spring.rabbitmq.cache.channel.size= # Number of channels to retain in the cache.spring.rabbitmq.cache.connection.mode=channel # Connection factory cache mode.spring.rabbitmq.cache.connection.size= # Number of connections to cache.spring.rabbitmq.connection-timeout= # Connection timeout, in milliseconds; zero for infinite.spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.spring.rabbitmq.host=localhost # RabbitMQ host.spring.rabbitmq.listener.simple.acknowledge-mode= # Acknowledge mode of container.spring.rabbitmq.listener.simple.auto-startup=true # Start the container automatically on startup.spring.rabbitmq.listener.simple.concurrency= # Minimum number of consumers.spring.rabbitmq.listener.simple.default-requeue-rejected= # Whether or not to requeue delivery failures; default `true`.spring.rabbitmq.listener.simple.idle-event-interval= # How often idle container events should be published in milliseconds.spring.rabbitmq.listener.simple.max-concurrency= # Maximum number of consumers.spring.rabbitmq.listener.simple.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).spring.rabbitmq.listener.simple.retry.enabled=false # Whether or not publishing retries are enabled.spring.rabbitmq.listener.simple.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message.spring.rabbitmq.listener.simple.retry.max-attempts=3 # Maximum number of attempts to deliver a message.spring.rabbitmq.listener.simple.retry.max-interval=10000 # Maximum interval between attempts.spring.rabbitmq.listener.simple.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval.spring.rabbitmq.listener.simple.retry.stateless=true # Whether or not retry is stateless or stateful.spring.rabbitmq.listener.simple.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.spring.rabbitmq.password= # Login to authenticate against the broker.spring.rabbitmq.port=5672 # RabbitMQ port.spring.rabbitmq.publisher-confirms=false # Enable publisher confirms.spring.rabbitmq.publisher-returns=false # Enable publisher returns.spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.spring.rabbitmq.ssl.enabled=false # Enable SSL support.spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.spring.rabbitmq.template.mandatory=false # Enable mandatory messages.spring.rabbitmq.template.receive-timeout=0 # Timeout for `receive()` methods.spring.rabbitmq.template.reply-timeout=5000 # Timeout for `sendAndReceive()` methods.spring.rabbitmq.template.retry.enabled=false # Set to true to enable retries in the `RabbitTemplate`.spring.rabbitmq.template.retry.initial-interval=1000 # Interval between the first and second attempt to publish a message.spring.rabbitmq.template.retry.max-attempts=3 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.max-interval=10000 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.multiplier=1.0 # A multiplier to apply to the previous publishing retry interval.spring.rabbitmq.username= # Login user to authenticate to the broker.spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# ENDPOINTS (AbstractEndpoint subclasses)endpoints.enabled=true # Enable endpoints.endpoints.sensitive= # Default endpoint sensitive setting.endpoints.actuator.enabled=true # Enable the endpoint.endpoints.actuator.path= # Endpoint URL path.endpoints.actuator.sensitive=false # Enable security on the endpoint.endpoints.auditevents.enabled= # Enable the endpoint.endpoints.auditevents.path= # Endpoint path.endpoints.auditevents.sensitive=false # Enable security on the endpoint.endpoints.autoconfig.enabled= # Enable the endpoint.endpoints.autoconfig.id= # Endpoint identifier.endpoints.autoconfig.path= # Endpoint path.endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.beans.enabled= # Enable the endpoint.endpoints.beans.id= # Endpoint identifier.endpoints.beans.path= # Endpoint path.endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.configprops.enabled= # Enable the endpoint.endpoints.configprops.id= # Endpoint identifier.endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.configprops.path= # Endpoint path.endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.docs.curies.enabled=false # Enable the curie generation.endpoints.docs.enabled=true # Enable actuator docs endpoint.endpoints.docs.path=/docs #endpoints.docs.sensitive=false #endpoints.dump.enabled= # Enable the endpoint.endpoints.dump.id= # Endpoint identifier.endpoints.dump.path= # Endpoint path.endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.env.enabled= # Enable the endpoint.endpoints.env.id= # Endpoint identifier.endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.env.path= # Endpoint path.endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.flyway.enabled= # Enable the endpoint.endpoints.flyway.id= # Endpoint identifier.endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.enabled= # Enable the endpoint.endpoints.health.id= # Endpoint identifier.endpoints.health.mapping.*= # Mapping of health statuses to HTTP status codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).endpoints.health.path= # Endpoint path.endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.endpoints.heapdump.enabled= # Enable the endpoint.endpoints.heapdump.path= # Endpoint path.endpoints.heapdump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.hypermedia.enabled=false # Enable hypermedia support for endpoints.endpoints.info.enabled= # Enable the endpoint.endpoints.info.id= # Endpoint identifier.endpoints.info.path= # Endpoint path.endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.jolokia.enabled=true # Enable Jolokia endpoint.endpoints.jolokia.path=/jolokia # Endpoint URL path.endpoints.jolokia.sensitive=true # Enable security on the endpoint.endpoints.liquibase.enabled= # Enable the endpoint.endpoints.liquibase.id= # Endpoint identifier.endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.logfile.enabled=true # Enable the endpoint.endpoints.logfile.external-file= # External Logfile to be accessed.endpoints.logfile.path=/logfile # Endpoint URL path.endpoints.logfile.sensitive=true # Enable security on the endpoint.endpoints.loggers.enabled=true # Enable the endpoint.endpoints.loggers.id= # Endpoint identifier.endpoints.loggers.path=/logfile # Endpoint path.endpoints.loggers.sensitive=true # Mark if the endpoint exposes sensitive information.endpoints.mappings.enabled= # Enable the endpoint.endpoints.mappings.id= # Endpoint identifier.endpoints.mappings.path= # Endpoint path.endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.metrics.enabled= # Enable the endpoint.endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.endpoints.metrics.filter.gauge-submissions=merged # Http filter gauge submissions (merged, per-http-method)endpoints.metrics.filter.counter-submissions=merged # Http filter counter submissions (merged, per-http-method)endpoints.metrics.id= # Endpoint identifier.endpoints.metrics.path= # Endpoint path.endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.shutdown.enabled= # Enable the endpoint.endpoints.shutdown.id= # Endpoint identifier.endpoints.shutdown.path= # Endpoint path.endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.trace.enabled= # Enable the endpoint.endpoints.trace.filter.enabled=true # Enable the trace servlet filter.endpoints.trace.id= # Endpoint identifier.endpoints.trace.path= # Endpoint path.endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.# ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &apos;*&apos; allows all headers.endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. &apos;*&apos; allows all methods.endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. &apos;*&apos; allows all origins. When not set, CORS support is disabled.endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.domain= # JMX domain name. Initialized with the value of &apos;spring.jmx.default-domain&apos; if set.endpoints.jmx.enabled=true # Enable JMX export of all endpoints.endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.add-application-context-header=true # Add the &quot;X-Application-Context&quot; HTTP header in each response.management.address= # Network address that the management endpoints should bind to.management.context-path= # Management endpoint context-path. For instance `/actuator`management.cloudfoundry.enabled= # Enable extended Cloud Foundry actuator endpointsmanagement.cloudfoundry.skip-ssl-validation= # Skip SSL verification for Cloud Foundry actuator endpoint security callsmanagement.port= # Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.management.security.enabled=true # Enable security.management.security.roles=ACTUATOR # Comma-separated list of roles that can access the management endpoint.management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).management.ssl.ciphers= # Supported SSL ciphers. Requires a custom management.port.management.ssl.client-auth= # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store. Requires a custom management.port.management.ssl.enabled= # Enable SSL support. Requires a custom management.port.management.ssl.enabled-protocols= # Enabled SSL protocols. Requires a custom management.port.management.ssl.key-alias= # Alias that identifies the key in the key store. Requires a custom management.port.management.ssl.key-password= # Password used to access the key in the key store. Requires a custom management.port.management.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.management.ssl.key-store-password= # Password used to access the key store. Requires a custom management.port.management.ssl.key-store-provider= # Provider for the key store. Requires a custom management.port.management.ssl.key-store-type= # Type of the key store. Requires a custom management.port.management.ssl.protocol=TLS # SSL protocol to use. Requires a custom management.port.management.ssl.trust-store= # Trust store that holds SSL certificates. Requires a custom management.port.management.ssl.trust-store-password= # Password used to access the trust store. Requires a custom management.port.management.ssl.trust-store-provider= # Provider for the trust store. Requires a custom management.port.management.ssl.trust-store-type= # Type of the trust store. Requires a custom management.port.# HEALTH INDICATORSmanagement.health.db.enabled=true # Enable database health check.management.health.cassandra.enabled=true # Enable cassandra health check.management.health.couchbase.enabled=true # Enable couchbase health check.management.health.defaults.enabled=true # Enable default health indicators.management.health.diskspace.enabled=true # Enable disk space health check.management.health.diskspace.path= # Path used to compute the available disk space.management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.management.health.elasticsearch.enabled=true # Enable elasticsearch health check.management.health.elasticsearch.indices= # Comma-separated index names.management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.management.health.jms.enabled=true # Enable JMS health check.management.health.ldap.enabled=true # Enable LDAP health check.management.health.mail.enabled=true # Enable Mail health check.management.health.mongo.enabled=true # Enable MongoDB health check.management.health.rabbit.enabled=true # Enable RabbitMQ health check.management.health.redis.enabled=true # Enable Redis health check.management.health.solr.enabled=true # Enable Solr health check.management.health.status.order=DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.# INFO CONTRIBUTORS (InfoContributorProperties)management.info.build.enabled=true # Enable build info.management.info.defaults.enabled=true # Enable default info contributors.management.info.env.enabled=true # Enable environment info.management.info.git.enabled=true # Enable git info.management.info.git.mode=simple # Mode to use to expose git information.# REMOTE SHELL (ShellProperties)management.shell.auth.type=simple # Authentication type. Auto-detected according to the environment.management.shell.auth.jaas.domain=my-domain # JAAS domain.management.shell.auth.key.path= # Path to the authentication key. This should point to a valid &quot;.pem&quot; file.management.shell.auth.simple.user.name=user # Login user.management.shell.auth.simple.user.password= # Login password.management.shell.auth.spring.roles=ACTUATOR # Comma-separated list of required roles to login to the CRaSH console.management.shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.management.shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).management.shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.management.shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.management.shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.management.shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.management.shell.ssh.enabled=true # Enable CRaSH SSH support.management.shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.management.shell.ssh.key-path= # Path to the SSH server key.management.shell.ssh.port=2000 # SSH port.management.shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is available.management.shell.telnet.port=5000 # Telnet port.# TRACING (TraceProperties)management.trace.include=request-headers,response-headers,cookies,errors # Items to be included in the trace.# METRICS EXPORT (MetricExportProperties)spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.spring.metrics.export.includes= # List of patterns for metric names to include.spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.# ----------------------------------------# DEVTOOLS PROPERTIES# ----------------------------------------# DEVTOOLS (DevToolsProperties)spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.spring.devtools.livereload.port=35729 # Server port.spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-paths= # Additional paths to watch for changes.spring.devtools.restart.enabled=true # Enable automatic restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.# REMOTE DEVTOOLS (RemoteDevToolsProperties)spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.spring.devtools.remote.debug.enabled=true # Enable remote debug support.spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.spring.devtools.remote.restart.enabled=true # Enable remote restart.spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.# ----------------------------------------# TESTING PROPERTIES# ----------------------------------------spring.test.database.replace=any # Type of existing DataSource to replace.spring.test.mockmvc.print=default # MVC Print option. application.properties配置和使用 摘要: Spring Boot使用“约定优于配置”（项目中存在大量配置，此外还内置了一个约定的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。所以，我们想要熟练使用Spring Boot，就要懂得如何开启各个功能模块的默认配置，这就需要了解Spring Boot的配置文件application.properties。 Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。接下来，让我们一起来解开配置文件的面纱。 注:如果你工程没有这个application.properties，那就在src/main/java/resources目录下新建一个。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里： 12com.qiuqiu.name=&quot;球球&quot;com.qiuqiu.want=&quot;祝大家鸡年大吉！&quot; 然后直接在要使用的地方通过注解@Value(value=”${XXX}”)就可以绑定到你想要的属性上面 123456789101112@RestControllerpublic class UserController &#123; @Value("$&#123;com.qiuqiu.name&#125;") private String name; @Value("$&#123;com.qiuqiu.want&#125;") private String want; @RequestMapping("/hello") public String hello()&#123; return name+","+want; &#125;&#125; 属性很多时，一个个绑定到属性字段上太麻烦，官方提倡绑定一个对象的bean，这里我们建一个ConfigBean.java类，顶部需要使用注解@ConfigurationProperties(prefix = “XXX”)来指明使用哪个 1234567@ConfigurationProperties(prefix = "com.qiuqiu")public class ConfigBean &#123; private String name; private String want; // 省略getter和setter&#125; Spring Boot 会自动转换类型，当使用List的时候需要注意在配置中对List进行初始化！Spring Boot 还支持嵌套属性注入。 123456789101112131415161718name=Isea533servers[0]=dev.bar.comservers[1]=foo.bar.comjdbc.username=rootjdbc.password=root@ConfigurationPropertiespublic class Config &#123; private String name; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); private Jdbc jdbc; // 省略getter和setter class Jdbc &#123; private String username; private String password; // 省略getter和setter &#125;&#125; 另外一种使用配置文件属性的方式，在@Bean方法上使用@ConfigurationProperties 12345@ConfigurationProperties(prefix = "com.qiuqiu")@Beanpublic ConfigBean configBean() &#123; ...&#125; 属性占位符例如： 12app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application 可以在配置文件中引用前面配置过的属性（优先级前面配置过的这里都能用）。通过如${app.name:默认名称}方法还可以设置默认值，当找不到引用的属性时，会使用默认的属性。由于${}方式会被Maven处理。如果你pom继承的spring-boot-starter-parent，Spring Boot 已经将maven-resources-plugins默认的${}方式改为了@ @方式，例如@name@。如果你是引入的Spring Boot，你可以修改使用其他的分隔符。 通过属性占位符还能缩短命令参数 例如修改web默认端口需要使用–server.port=9090方式，如果在配置中写上： 1server.port=$&#123;port:8080&#125; 那么就可以使用更短的–port=9090，当不提供该参数的时候使用默认值8080。 使用自定义配置文件有时我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里我们定义一个名为test.properties配置文件，路径跟也放在src/main/resources下面。 12345678910com.md.name="球球"com.md.want="祝大家鸡年大吉"@Configuration@ConfigurationProperties(prefix = "com.md") @PropertySource("classpath:test.properties")public class ConfigTestBean &#123; private String name; private String want; // 省略getter和setter&#125; 注：如果你使用的是1.5以前的版本，那么可以通过locations指定properties文件的位置，这样： 1@ConfigurationProperties(prefix = "config2",locations="classpath:test.properties") 但是1.5版本之后就没有这个属性，需要添加@Configuration和@PropertySource(“classpath:test.properties”)后才可以读取。 随机值配置配置文件中${random.*} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。 123456qiuqiu.secret=$&#123;random.value&#125;qiuqiu.number=$&#123;random.int&#125;qiuqiu.bignumber=$&#123;random.long&#125;qiuqiu.uuid=$&#123;random.uuid&#125;qiuqiu.number.less.than.ten=$&#123;random.int(10)&#125;qiuqiu.number.in.range=$&#123;random.int[1024,65536]&#125; 外部配置-命令行参数配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行： 1java -jar xx.jar 可以以下命令修改tomcat端口号： 1java -jar xx.jar --server.port=9090 可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。 如果你怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。 测试中的@TestPropertySource注解。 测试中的@SpringBootTest#properties注解特性。 命令行参数 SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。 ServletConfig初始化参数。 ServletContext初始化参数。 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}）应用程序以外的application.properties或者appliaction.yml文件打包在应用程序内的application.properties或者appliaction.yml文件通过@PropertySource标注的属性源 默认属性(通过SpringApplication.setDefaultProperties指定). 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，例如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件优先级application.properties和application.yml文件可以放在以下四个位置： 外置，在相对于应用程序运行目录的/config子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.properties里的属性里面的属性就会覆盖application.yml。 profile-多环境配置当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。 如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 当然你也可以用命令行启动的时候带上参数： 1java -jar xxx.jar --spring.profiles.active=dev 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，我们还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口 : 123public interface DBConnector &#123; public void configure(); &#125; 定义俩个实现类来实现它: 12345678910111213141516171819202122/** * 测试数据库 */@Component@Profile("testdb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125;/** * 生产数据库 */@Component@Profile("devdb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125; 通过在配置文件激活具体使用哪个实现类 1spring.profiles.active=testdb 然后就可以如下方使用： 12345678910111213@RestController@RequestMapping("/task")public class TaskController &#123; @Autowired DBConnector connector ; @RequestMapping(value = "/hello") public String helloTask()&#123; connector.configure(); //最终打印testdb return "hello task !! myage is " + myage; &#125;&#125; 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile。 12spring.profiles.active=testdb spring.profiles.include=proddb,prodmq 读取系统环境变量和application配置文件中的属性实现EnvironmentAware接口 12345678910111213141516171819202122232425import org.springframework.boot.bind.RelaxedPropertyResolver;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;@Configurationpublic class MyEnvironmentAware implements EnvironmentAware &#123; /** * 注意重写的方法 setEnvironment是在系统启动的时候被执行。 */ @Override public void setEnvironment(Environment environment) &#123; // 通过 environment 获取到系统属性. System.out.println(environment.getProperty("JAVA_HOME")); // 通过 environment 同样能获取到application.properties配置的属性. System.out.println(environment.getProperty("spring.datasource.url")); // 获取到前缀是"spring.datasource." 的属性列表值. RelaxedPropertyResolver relaxedPropertyResolver = new RelaxedPropertyResolver(environment, "spring.datasource."); System.out.println("spring.datasource.url=" + relaxedPropertyResolver.getProperty("url")); System.out.println("spring.datasource.driverClassName=" + relaxedPropertyResolver.getProperty("driverClassName")); &#125;&#125; 实现ApplicationContextAware接口 123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.env.Environment;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;@Componentpublic class SpringCtxHolder implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; private static Environment env; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringCtxHolder.applicationContext = applicationContext; env = applicationContext.getEnvironment(); &#125; public static Environment getEnv() &#123; return env; &#125; public static void setEnv(Environment env) &#123; SpringCtxHolder.env = env; &#125; public static String getProperty(String key) &#123; if (StringUtils.isEmpty(key)) &#123; return ""; &#125; return env.getProperty(key); &#125;&#125; 1SpringCtxHolder.getProperty("spring.datasource.url"); 全局异常处理简介全局异常处理是个比较重要的功能，一般在项目里都会用到。 实现方式使用@ControllerAdvice或@RestControllerAdvice注解使用@ExceptionHandler注解 通过使用@ControllerAdvice或@RestControllerAdvice定义统一的异常处理类。@ExceptionHandler用来定义函数针对的异常类型， 自定义错误处理器，可自己组装json字符串，并返回 。 应用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.HttpMediaTypeNotSupportedException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.MissingServletRequestParameterException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import com.nxtcec.ordering.mlsoa.exception.SoaException;import com.nxtcec.ordering.mlsoa.model.BodyStatus;import com.nxtcec.ordering.mlsoa.model.BodyValidStatus;import com.nxtcec.ordering.mlsoa.util.Constants;import com.nxtcec.ordering.mlsoa.util.DataUtil;/** * 全局Exception处理 * * @author liusq * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class); @SuppressWarnings("rawtypes") @ExceptionHandler(value = Exception.class) public ResponseEntity handle(Exception e) &#123; e.printStackTrace(); BodyStatus bodyStatus; if (e instanceof SoaException) &#123; bodyStatus = ((SoaException) e).getBodyStatus(); &#125; else if (e instanceof MissingServletRequestParameterException) &#123; bodyStatus = DataUtil.bodyStatus("0002"); &#125; else if (e instanceof HttpRequestMethodNotSupportedException) &#123; bodyStatus = DataUtil.bodyStatus("0003"); &#125; else if (e instanceof HttpMediaTypeNotSupportedException) &#123; bodyStatus = DataUtil.bodyStatus("0004"); &#125; else if (e instanceof HttpMessageNotReadableException) &#123; bodyStatus = DataUtil.bodyStatus("0005"); &#125; else if (e instanceof BindException) &#123; bodyStatus = DataUtil.bodyStatus("0006"); &#125; else if (e instanceof NumberFormatException) &#123; bodyStatus = DataUtil.bodyStatus("0007"); &#125; else if (e instanceof DataIntegrityViolationException) &#123; bodyStatus = DataUtil.bodyStatus("0008"); &#125; else &#123; bodyStatus = DataUtil.bodyStatus(Constants.ERROR_CODE); &#125; LOGGER.error(bodyStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyStatus, HttpStatus.OK); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import org.apache.commons.lang.builder.ToStringBuilder;/** * 处理成功或失败时的响应体 * * @author liusq * */public class BodyStatus &#123; // 代码 private String code; // 代码解释 private String message; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125;&#125; 1234567891011121314151617181920212223242526272829import com.nxtcec.ordering.mlsoa.model.BodyStatus;import com.nxtcec.ordering.mlsoa.util.DataUtil;public class SoaException extends RuntimeException &#123; private static final long serialVersionUID = -2945796190275982393L; private BodyStatus bodyStatus; public SoaException() &#123; super(); &#125; public SoaException(String code) &#123; this.bodyStatus = DataUtil.bodyStatus(code); &#125; public SoaException(String code, String message) &#123; this.bodyStatus = DataUtil.bodyStatus(code, message); &#125; public BodyStatus getBodyStatus() &#123; return bodyStatus; &#125; public void setBodyStatus(BodyStatus bodyStatus) &#123; this.bodyStatus = bodyStatus; &#125;&#125; validation参数校验对于任何一个应用而言在客户端做的数据有效性验证都不是安全有效的，这时候就要求我们在开发的时候在服务端也对数据的有效性进行验证。 Spring Boot自身对数据在服务端的校验有一个比较好的支持，它能将我们提交到服务端的数据按照我们事先的约定进行数据有效性验证。 pom依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 校验使用实例配置要验证的请求实体123456789public class User &#123; @Null private Long id; @NotBlank private String name; @Email private String email; // 省略getter和setter&#125; 控制器方法配置1234@PostMapping("/addUser")public String addUser(@Valid @RequestBody User user)&#123; ...&#125; 校验失败统一处理校验失败时将抛出MethodArgumentNotValidException异常 123456789101112131415161718192021222324252627282930313233/** * 全局Exception处理 * * @author liusq * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class); @SuppressWarnings("rawtypes") @ExceptionHandler(value = Exception.class) public ResponseEntity handle(Exception e) &#123; if (e instanceof MethodArgumentNotValidException) &#123; BindingResult bindingResult = ((MethodArgumentNotValidException) e).getBindingResult(); if (bindingResult.hasErrors() &amp;&amp; bindingResult.hasFieldErrors()) &#123; FieldError fieldError = bindingResult.getFieldError(); BodyValidStatus bodyValidStatus = new BodyValidStatus.Builder().code("0009") .message(fieldError.getDefaultMessage()) .field(fieldError.getField()).build(); LOGGER.warn(bodyValidStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyValidStatus, HttpStatus.OK); &#125; else &#123; bodyStatus = DataUtil.bodyStatus("0009"); &#125; &#125; else &#123; bodyStatus = DataUtil.bodyStatus(Constants.ERROR_CODE); &#125; LOGGER.error(bodyStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyStatus, HttpStatus.OK); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class BodyValidStatus &#123; // 错误代码 private String code; // 错误代码解释 private String message; // 错误字段 private String field; public BodyValidStatus() &#123; &#125; public BodyValidStatus(String code, String message, String field) &#123; this.code = code; this.message = message; this.field = field; &#125; private BodyValidStatus(Builder builder) &#123; setCode(builder.code); setMessage(builder.message); setField(builder.field); &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getField() &#123; return field; &#125; public void setField(String field) &#123; this.field = field; &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125; public static final class Builder &#123; private String code; private String message; private String field; public Builder() &#123; &#125; public Builder code(String val) &#123; code = val; return this; &#125; public Builder message(String val) &#123; message = val; return this; &#125; public Builder field(String val) &#123; field = val; return this; &#125; public BodyValidStatus build() &#123; return new BodyValidStatus(this); &#125; &#125;&#125; 验证注解详解 自定义验证注解和验证规则12345678910111213141516171819202122import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import javax.validation.Constraint; import javax.validation.Payload; import com.xxx.xxx.constraint.impl.MoneyValidator; @Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy=MoneyValidator.class) public @interface Money &#123; String message() default"不是金额形式"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; &#125; 12345678910111213141516171819202122232425import java.util.regex.Pattern; import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; import com.xxx.xxx.constraint.Money; public class MoneyValidator implements ConstraintValidator&lt;Money, Double&gt; &#123; private String moneyReg = "^\\d+(\\.\\d&#123;1,2&#125;)?$";//表示金额的正则表达式 private Pattern moneyPattern = Pattern.compile(moneyReg); public void initialize(Money money) &#123; // TODO Auto-generated method stub &#125; public boolean isValid(Double value, ConstraintValidatorContext arg1) &#123; // TODO Auto-generated method stub if (value == null) return true; return moneyPattern.matcher(value.toString()).matches(); &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark抓包工具使用以及常用抓包规则]]></title>
    <url>%2Fposts%2F64619.html</url>
    <content type="text"><![CDATA[Wireshark是一个非常好用的抓包工具，当我们遇到一些和网络相关的问题时，可以通过这个工具进行分析，不过要说明的是，这只是一个工具，用法是非常灵活的，所以今天讲述的内容可能无法直接帮你解决问题，但是只要你有解决问题的思路，学习用这个软件就非常有用了。 Wireshark官方下载地址：http://www.wireshark.org/download.html 简单介绍这个软件的一些常用按钮，因为本人也是接触这个软件不久，所以就简单的说下最常用的按钮好了，打开软件后，下面红框中的按钮从左到右依次是： 列表显示所有网卡的网络包情况，一般用的很少； 显示抓包选项，一般都是点这个按钮开始抓包； 开始新的抓包，一般用的也很少； 停止抓包，当你抓完包之后，就是点这个停止了； 清空当前已经抓到的数据包，可以防止抓包时间过长机器变卡； 而实际上，一般我们只要知道上面加粗部分的按钮功能，就可以完成抓包了，剩下的就是如何抓你想要的数据包，如何分析的问题了。 接下来说下抓包选项界面，也就是点第二个按钮出来的界面，同样，这里也只介绍最常用的几个功能，首先下图中最上面的红框是选择需要抓的网卡，选择好网卡后会在下面显示这个网卡的IP地址。 然后Capture Filter中就是要写抓包规则的地方，也叫做“过滤规则”，我们下面要说的很多规则都是要写到这个框里的，规则写好后，点下面的Start就开始抓包了。 当抓包结束之后，如果你需要把抓到的数据包找其他人分析，那么可以点菜单上的file，然后点Save As保存抓到的数据包，如下图： ok，到这里，基础的使用方法说完了，接下来步入很关键的内容。 使用Wireshark时最常见的问题当您使用默认设置时，会得到大量冗余信息，以至于很难找到自己需要的部分。这就是为什么过滤器会如此重要。它们可以帮助我们在庞杂的结果中迅速找到我们需要的信息。 过滤器的区别 捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。 显示过滤器（DisplayFilters）：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。那么我应该使用哪一种过滤器呢？ 两种过滤器的目的是不同的。 捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。 显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。 两种过滤器使用的语法是完全不同的。 捕捉过滤器 Protocol（协议）:可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.如果没有特别指明是什么协议，则默认使用所有支持的协议。 Direction（方向）:可能的值: src, dst, src and dst, src or dst如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。例如，”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的。 Host(s):可能的值： net, port, host, portrange.如果没有指定此值，则默认使用”host”关键字。例如，”src 10.1.1.1″与”src host 10.1.1.1″相同。 Logical Operations（逻辑运算）:可能的值：not, and, or.否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。例如，“not tcp port 3128 and tcp port 23″与”(not tcp port 3128) and tcp port 23″相同。“not tcp port 3128 and tcp port 23″与”not (tcp port 3128 and tcp port 23)”不同。 例子：tcp dst port 3128 //捕捉目的TCP端口为3128的封包。 ip src host 10.1.1.1 //捕捉来源IP地址为10.1.1.1的封包 host 10.1.2.3 //捕捉目的或来源IP地址为10.1.2.3的封包。 ether host e0-05-c5-44-b1-3c //捕捉目的或来源MAC地址为e0-05-c5-44-b1-3c的封包。如果你想抓本机与所有外网通讯的数据包时，可以将这里的mac地址换成路由的mac地址即可。 src portrange 2000-2500 //捕捉来源为UDP或TCP，并且端口号在2000至2500范围内的封包。 not imcp //显示除了icmp以外的所有封包。（icmp通常被ping工具使用） src host 10.7.2.12 and not dst net 10.200.0.0/16 //显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0/16的封包。 (src host 10.4.1.12 or src net 10.6.0.0/16) and tcp dst portrange 200-10000 and dst net 10.0.0.0/8 //捕捉来源IP为10.4.1.12或者来源网络为10.6.0.0/16，目的地TCP端口号在200至10000之间，并且目的位于网络 10.0.0.0/8内的所有封包。 src net 192.168.0.0/24src net 192.168.0.0 mask 255.255.255.0 //捕捉源地址为192.168.0.0网络内的所有封包。 注意事项：当使用关键字作为值时，需使用反斜杠“/”。“ether proto /ip” (与关键字”ip”相同).这样写将会以IP协议作为目标。 “ip proto /icmp” (与关键字”icmp”相同).这样写将会以ping工具常用的icmp作为目标。 可以在”ip”或”ether”后面使用”multicast”及”broadcast”关键字。 当您想排除广播请求时，”no broadcast”就会非常有用。 Protocol（协议）:您可以使用大量位于OSI模型第2至7层的协议。点击”Expression…”按钮后，您可以看到它们。比如：IP，TCP，DNS，SSH String1, String2 (可选项): 协议的子类。点击相关父类旁的”+”号，然后选择其子类。 例子：snmp || dns || icmp //显示SNMP或DNS或ICMP封包。 ip.addr == 10.1.1.1//显示来源或目的IP地址为10.1.1.1的封包。 ip.src != 10.1.2.3 or ip.dst != 10.4.5.6 //显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。 换句话说，显示的封包将会为： 来源IP：除了10.1.2.3以外任意；目的IP：任意以及来源IP：任意；目的IP：除了10.4.5.6以外任意ip.src != 10.1.2.3 and ip.dst != 10.4.5.6 //显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。 换句话说，显示的封包将会为： 来源IP：除了10.1.2.3以外任意；同时须满足，目的IP：除了10.4.5.6以外任意tcp.port == 25 //显示来源或目的TCP端口号为25的封包。tcp.dstport == 25 //显示目的TCP端口号为25的封包。tcp.flags //显示包含TCP标志的封包。tcp.flags.syn == 0×02 //显示包含TCP SYN标志的封包。 如果过滤器的语法是正确的，表达式的背景呈绿色。如果呈红色，说明表达式有误。 更为详细的说明请见：http://openmaniak.com/cn/wireshark_filters.php 以上只是抓包和简单的过滤，那么其实如果你要想达到能够分析这些网络包的要求时，还需要了解下一些数据包的标记，比如我们常说的TCP三次握手是怎么回事？ 三次握手Three-way Handshake一个虚拟连接的建立是通过三次握手来实现的 (Client) –&gt; [SYN] –&gt; (Server)假如Client和Server通讯. 当Client要和Server通信时，Client首先向Server发一个SYN (Synchronize) 标记的包，告诉Server请求建立连接.注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识到这点很重要，只有当Server收到Client发来的SYN包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不 能让外部任何主机主动建立连接。 (Client) &lt;– [SYN/ACK] &lt;–(Server)接着，Server收到来自Client发来的SYN包后，会发一个对SYN包的确认包(SYN/ACK)给Client，表示对第一个SYN包的确认，并继续握手操作.注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包. (Client) –&gt; [ACK] –&gt; (Server)Client收到来自Server的SYN/ACK 包,Client会再向Server发一个确认包(ACK)，通知Server连接已建立。至此，三次握手完成，一个TCP连接完成。Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建立以后，TCP连接的每个包都会设置ACK位。 这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火墙将无法判断收到的ACK包是否属于一个已经建立的连接.一般的包过滤(Ipchains)收到ACK包时,会让它通过(这绝对不是个 好主意). 而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已建连接，否则丢弃该包。 四次握手Four-way Handshake四次握手用来关闭已建立的TCP连接 (Client) –&gt; ACK/FIN –&gt; (Server) (Client) &lt;– ACK &lt;– (Server) (Client) &lt;– ACK/FIN &lt;– (Server) (Client) –&gt; ACK –&gt; (Server) 注意:由于TCP连接是双向连接, 因此关闭连接需要在两个方向上做。ACK/FIN 包(ACK 和FIN 标记设为1)通常被认为是FIN(终结)包.然而, 由于连接还没有关闭, FIN包总是打上ACK标记. 没有ACK标记而仅有FIN标记的包不是合法的包，并且通常被认为是恶意的。 连接复位Resetting a connection 四次握手不是关闭TCP连接的唯一方法. 有时,如果主机需要尽快关闭连接(或连接超时,端口或主机不可达),RST (Reset)包将被发送. 注意在，由于RST包不是TCP连接中的必须部分, 可以只发送RST包(即不带ACK标记). 但在正常的TCP连接中RST包可以带ACK确认标记 请注意RST包是可以不要收到方确认的? 无效的TCP标记Invalid TCP Flags 到目前为止，你已经看到了 SYN, ACK, FIN, 和RST 标记. 另外，还有PSH (Push) 和URG (Urgent)标记. 最常见的非法组合是SYN/FIN 包. 注意:由于 SYN包是用来初始化连接的, 它不可能和 FIN和RST标记一起出现. 这也是一个恶意攻击. 由于现在大多数防火墙已知 SYN/FIN 包, 别的一些组合,例如SYN/FIN/PSH, SYN/FIN/RST, SYN/FIN/RST/PSH。很明显，当网络中出现这种包时，很你的网络肯定受到攻击了。 别的已知的非法包有FIN (无ACK标记)和”NULL”包。如同早先讨论的，由于ACK/FIN包的出现是为了关闭一个TCP连接，那么正常的FIN包总是带有 ACK 标记。”NULL”包就是没有任何TCP标记的包(URG,ACK,PSH,RST,SYN,FIN都为0)。 到目前为止，正常的网络活动下，TCP协议栈不可能产生带有上面提到的任何一种标记组合的TCP包。当你发现这些不正常的包时，肯定有人对你的网络不怀好意。 UDP (用户数据包协议User Datagram Protocol) TCP是面向连接的，而UDP是非连接的协议。UDP没有对接受进行确认的标记和确认机制。对丢包的处理是在应用层来完成的。(or accidental arrival). 此处需要重点注意的事情是：在正常情况下，当UDP包到达一个关闭的端口时，会返回一个UDP复位包。由于UDP是非面向连接的, 因此没有任何确认信息来确认包是否正确到达目的地。因此如果你的防火墙丢弃UDP包，它会开放所有的UDP端口(?)。 由于Internet上正常情况下一些包将被丢弃，甚至某些发往已关闭端口(非防火墙的)的UDP包将不会到达目的，它们将返回一个复位UDP包。 因为这个原因，UDP端口扫描总是不精确、不可靠的。 看起来大UDP包的碎片是常见的DOS (Denial of Service)攻击的常见形式 (这里有个DOS攻击的例子，http://grc.com/dos/grcdos.htm ). ICMP (网间控制消息协议Internet Control Message Protocol) 如同名字一样， ICMP用来在主机/路由器之间传递控制信息的协议。 ICMP包可以包含诊断信息(ping, traceroute - 注意目前unix系统中的traceroute用UDP包而不是ICMP)，错误信息(网络/主机/端口 不可达 network/host/port unreachable), 信息(时间戳timestamp, 地址掩码address mask request, etc.)，或控制信息 (source quench, redirect, etc.) 。 你可以在http://www.iana.org/assignments/icmp-parameters 中找到ICMP包的类型。 尽管ICMP通常是无害的，还是有些类型的ICMP信息需要丢弃。 Redirect (5), Alternate Host Address (6), Router Advertisement (9) 能用来转发通讯。 Echo (8), Timestamp (13) and Address Mask Request (17) 能用来分别判断主机是否起来，本地时间 和地址掩码。注意它们是和返回的信息类别有关的。 它们自己本身是不能被利用的，但它们泄露出的信息对攻击者是有用的。 ICMP消息有时也被用来作为DOS攻击的一部分(例如：洪水ping flood ping,死 ping ?呵呵，有趣 ping of death)?/p&gt; 包碎片注意A Note About Packet Fragmentation 如果一个包的大小超过了TCP的最大段长度MSS (Maximum Segment Size) 或MTU (Maximum Transmission Unit)，能够把此包发往目的的唯一方法是把此包分片。由于包分片是正常的，它可以被利用来做恶意的攻击。 因为分片的包的第一个分片包含一个包头，若没有包分片的重组功能，包过滤器不可能检测附加的包分片。典型的攻击Typical attacks involve in overlapping the packet data in which packet header is 典型的攻击Typical attacks involve in overlapping the packet data in which packet header isnormal until is it overwritten with different destination IP (or port) thereby bypassing firewall rules。包分片能作为 DOS 攻击的一部分，它可以crash older IP stacks 或涨死CPU连接能力。 Netfilter/Iptables中的连接跟踪代码能自动做分片重组。它仍有弱点，可能受到饱和连接攻击，可以把CPU资源耗光。 OK，到此为止，关于Wireshark抓包工具的一些小教程已经写完了，而导致我想写这么一个纠结的教程的原因是，前几天通过这个抓包解决了梦幻西游在网维大师无盘上容易掉线的问题，当时捕捉到梦幻西游掉线时的数据包是这样的。注意下图中的红色数据，123.58.184.241是梦幻西游的服务器，而192.168.1.41是玩梦幻西游的客户机，在掉线时，发现是先有梦幻西游的服务器向客户机发送一个[FIN,ACK]数据包，根据上面的解释，FIN标记的数据包是代表要断开连接的意思，而接着客户机又回给服务器一个确认断开链接包。当看到这个抓包数据时，就意识到，大家说的在网维大师系统虚拟盘上梦幻爱掉线的问题，并非普通的网络问题，因为通过数据包的信息来看，是梦幻服务器主动要求断开链接，产生这个情况无非是以下几个原因：1、服务器发现客户端非法，比如有外挂什么的，踢掉了客户机；2、服务器压力大，踢掉了客户机；3、总之不是客户端问题导致的掉线； 那么既然结论是如此，为什么会有在网维大师系统虚拟盘上容易出现梦幻掉线问题呢？原因是由于网维大师系统虚拟盘是模拟真实硬盘方式来实现的，而在模拟过程中，将硬盘的序列号设置为固定过的OSDIY888了，而梦幻西游刚好后识别客户机硬盘信息，发现大量客户端的硬盘序列号都是一样的，就认为是作弊或者使用挂机外挂了，结果就导致随机被服务器踢下线的情况发生，后来我们将硬盘序列号设置为空，则没再出现该问题。这个问题在未来的新版本中会解决掉。 说这个案例的目的并不是为了说明抓包多有用，而是想说明一些解决问题的思路和方法，有些人是有思路，但是缺方法，比如不会用工具，而有些人收集了很多工具却不会用，而我其实就属于后者，几年前就收集了n多工具，但是用到的没几个。慢慢的学会用这些工具后，发现思维+工具，解决问题是效率暴增，接下来的几天里，会陆续介绍写小工具给大家，也希望大家有空学习下，有问题先百度，再自己摸索，而不是一味的求助，毕竟求人不如求己！自己能直接搞定，是皆大欢喜的事情~注意：由于某些系统为了防止ARP攻击，都免疫掉了一个Npptools.dll文件，这会导致该软件无法正常安装，打下这个补丁就可以了。]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot开发新一代项目]]></title>
    <url>%2Fposts%2F10370.html</url>
    <content type="text"><![CDATA[Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 安装Spring Boot从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用Groovy环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。在OS X上安装Boot可以使用Homebrew包管理器。为了完成安装，首先要使用brew tap pivotal/tap切换到Pivotal仓库中，然后执行brew install springboot命令。要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。 构建项目步骤 首先要下载maven 用maven管理项目很方便，下载完maven配置好环境，maven我就不细说了。 创建一个maven项目 pom.xml文件里面写这些: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;testSpringBoot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;testSpringBoot&lt;/name&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 继承父包 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.1.3.RELEASE&lt;/version&gt; &lt;relativePath&gt;&lt;/relativePath&gt; &lt;/parent&gt; &lt;!-- spring-boot的web启动的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jpa的jar包 ，操作数据库的，类似hibernate--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--thymeleaf模板jar，是很不错的html数据传递取值，类似jsp的jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--maven的插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 配置java版本 不配置的话默认父类配置的是1.6--&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 创建的文件目录如图: 在com.boot(即最外层目录文件)下写一个如下main方法: 12345678910111213141516package com.boot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@EnableAutoConfiguration@ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; 在com.boot.web下创建一个类如下: 123456789101112131415161718package com.boot.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MainController &#123;// @RequestMapping("")// public String index()&#123;// return "examples/index";// &#125; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125;&#125; @RequestMapping @ResponseBody 这两个注解都是springMVC的,不懂得可以看springMVC 在resources下增加一个application.properties文件 文件内容如下配置: 123456789101112131415161718192021222324252627spring.datasource.platform=mysqlspring.datasource.url=jdbc:mysql://localhost/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;autoReconnect=true&amp;failOverReadOnly=falsespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driverClassName=com.mysql.jdbc.Driver# Advanced configuration...spring.datasource.max-active=50spring.datasource.max-idle=6spring.datasource.min-idle=2spring.datasource.initial-size=6#create tablespring.jpa.hibernate.ddl-auto=validateserver.port=8080server.session-timeout=30server.tomcat.uri-encoding=UTF-8spring.thymeleaf.prefix=classpath:templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false 该文件的配置可以参考springboot的官网 该文件的全部参数配置；如下(摘自官网) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410# ===================================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^# ===================================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# SPRING CONFIG (ConfigFileApplicationListener)spring.config.name= # config file name (default to &apos;application&apos;)spring.config.location= # location of config file# PROFILESspring.profiles.active= # comma list of active profiles# APPLICATION SETTINGS (SpringApplication)spring.main.sources=spring.main.web-environment= # detect by defaultspring.main.show-banner=truespring.main....= # see class for all properties# LOGGINGlogging.path=/var/logslogging.file=myapp.loglogging.config= # location of config file (default classpath:logback.xml for logback)logging.level.*= # levels for loggers, e.g. &quot;logging.level.org.springframework=DEBUG&quot; (TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF)# IDENTITY (ContextIdApplicationContextInitializer)spring.application.name=spring.application.index=# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.port=8080server.address= # bind to a specific NICserver.session-timeout= # session timeout in secondsserver.context-path= # the context path, defaults to &apos;/&apos;server.servlet-path= # the servlet path, defaults to &apos;/&apos;server.ssl.client-auth= # want or needserver.ssl.key-alias=server.ssl.key-password=server.ssl.key-store=server.ssl.key-store-password=server.ssl.key-store-provider=server.ssl.key-store-type=server.ssl.protocol=TLSserver.ssl.trust-store=server.ssl.trust-store-password=server.ssl.trust-store-provider=server.ssl.trust-store-type=server.tomcat.access-log-pattern= # log pattern of the access logserver.tomcat.access-log-enabled=false # is access logging enabledserver.tomcat.internal-proxies=10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 169\.254\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 127\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125; # regular expression matching trusted IP addressesserver.tomcat.protocol-header=x-forwarded-proto # front end proxy forward headerserver.tomcat.port-header= # front end proxy port headerserver.tomcat.remote-ip-header=x-forwarded-forserver.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)server.tomcat.background-processor-delay=30; # in secondsserver.tomcat.max-threads = 0 # number of threads in protocol handlerserver.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding# SPRING MVC (HttpMapperProperties)http.mappers.json-pretty-print=false # pretty print JSONhttp.mappers.json-sort-keys=false # sort keysspring.mvc.locale= # set fixed locale, e.g. en_UKspring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyyspring.mvc.message-codes-resolver-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODEspring.view.prefix= # MVC view prefixspring.view.suffix= # ... and suffixspring.resources.cache-period= # cache timeouts in headers sent to browserspring.resources.add-mappings=true # if default mappings should be added# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string (e.g. yyyy-MM-dd HH:mm:ss), or a fully-qualified date format class name (e.g. com.fasterxml.jackson.databind.util.ISO8601DateFormat)spring.jackson.property-naming-strategy= # One of the constants on Jackson&apos;s PropertyNamingStrategy (e.g. CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES) or the fully-qualified class name of a PropertyNamingStrategy subclassspring.jackson.deserialization.*= # see Jackson&apos;s DeserializationFeaturespring.jackson.generator.*= # see Jackson&apos;s JsonGenerator.Featurespring.jackson.mapper.*= # see Jackson&apos;s MapperFeaturespring.jackson.parser.*= # see Jackson&apos;s JsonParser.Featurespring.jackson.serialization.*= # see Jackson&apos;s SerializationFeature# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html # ;charset=&lt;encoding&gt; is addedspring.thymeleaf.cache=true # set to false for hot refresh# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allowRequestOverride=falsespring.freemarker.cache=truespring.freemarker.checkTemplateLocation=truespring.freemarker.charSet=UTF-8spring.freemarker.contentType=text/htmlspring.freemarker.exposeRequestAttributes=falsespring.freemarker.exposeSessionAttributes=falsespring.freemarker.exposeSpringMacroHelpers=falsespring.freemarker.prefix=spring.freemarker.requestContextAttribute=spring.freemarker.settings.*=spring.freemarker.suffix=.ftlspring.freemarker.templateLoaderPath=classpath:/templates/ # comma-separated listspring.freemarker.viewNames= # whitelist of view names that can be resolved# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.cache=truespring.groovy.template.charSet=UTF-8spring.groovy.template.configuration.*= # See Groovy&apos;s TemplateConfigurationspring.groovy.template.contentType=text/htmlspring.groovy.template.prefix=classpath:/templates/spring.groovy.template.suffix=.tplspring.groovy.template.viewNames= # whitelist of view names that can be resolved# VELOCITY TEMPLATES (VelocityAutoConfiguration)spring.velocity.allowRequestOverride=falsespring.velocity.cache=truespring.velocity.checkTemplateLocation=truespring.velocity.charSet=UTF-8spring.velocity.contentType=text/htmlspring.velocity.dateToolAttribute=spring.velocity.exposeRequestAttributes=falsespring.velocity.exposeSessionAttributes=falsespring.velocity.exposeSpringMacroHelpers=falsespring.velocity.numberToolAttribute=spring.velocity.prefix=spring.velocity.properties.*=spring.velocity.requestContextAttribute=spring.velocity.resourceLoaderPath=classpath:/templates/spring.velocity.suffix=.vmspring.velocity.viewNames= # whitelist of view names that can be resolved# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.basename=messagesspring.messages.cacheSeconds=-1spring.messages.encoding=UTF-8# SECURITY (SecurityProperties)security.user.name=user # login usernamesecurity.user.password= # login passwordsecurity.user.role=USER # role assigned to the usersecurity.require-ssl=false # advanced settings ...security.enable-csrf=falsesecurity.basic.enabled=truesecurity.basic.realm=Springsecurity.basic.path= # /**security.filter-order=0security.headers.xss=falsesecurity.headers.cache=falsesecurity.headers.frame=falsesecurity.headers.contentType=falsesecurity.headers.hsts=all # none / domain / allsecurity.sessions=stateless # always / never / if_required / statelesssecurity.ignored=false# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.name= # name of the data sourcespring.datasource.initialize=true # populate using data.sqlspring.datasource.schema= # a schema (DDL) script resource referencespring.datasource.data= # a data (DML) script resource referencespring.datasource.sqlScriptEncoding= # a charset for reading SQL scriptsspring.datasource.platform= # the platform to use in the schema resource (schema-$&#123;platform&#125;.sql)spring.datasource.continueOnError=false # continue even if can&apos;t be initializedspring.datasource.separator=; # statement separator in SQL initialization scriptsspring.datasource.driver-class-name= # JDBC Settings...spring.datasource.url=spring.datasource.username=spring.datasource.password=spring.datasource.jndi-name # For JNDI lookup (class, url, username &amp; password are ignored when set)spring.datasource.max-active=100 # Advanced configuration...spring.datasource.max-idle=8spring.datasource.min-idle=8spring.datasource.initial-size=10spring.datasource.validation-query=spring.datasource.test-on-borrow=falsespring.datasource.test-on-return=falsespring.datasource.test-while-idle=spring.datasource.time-between-eviction-runs-millis=spring.datasource.min-evictable-idle-time-millis=spring.datasource.max-wait=# MONGODB (MongoProperties)spring.data.mongodb.host= # the db hostspring.data.mongodb.port=27017 # the connection port (defaults to 27107)spring.data.mongodb.uri=mongodb://localhost/test # connection URLspring.data.mongo.repositories.enabled=true # if spring data repository support is enabled# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.jpa.properties.*= # properties to set on the JPA connectionspring.jpa.openInView=truespring.jpa.show-sql=truespring.jpa.database-platform=spring.jpa.database=spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendorsspring.jpa.hibernate.naming-strategy= # naming classnamespring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbsspring.data.jpa.repositories.enabled=true # if spring data repository support is enabled# JTA (JtaAutoConfiguration)spring.jta.log-dir= # transaction log dirspring.jta.*= # technology specific configuration# SOLR (SolrProperties&#125;)spring.data.solr.host=http://127.0.0.1:8983/solrspring.data.solr.zkHost=spring.data.solr.repositories.enabled=true # if spring data repository support is enabled# ELASTICSEARCH (ElasticsearchProperties&#125;)spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch)spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node)spring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled# DATA RESET (RepositoryRestConfiguration&#125;)spring.data.rest.baseUri=foo # base URI against which the exporter should calculate its links# FLYWAY (FlywayProperties)flyway.locations=classpath:db/migrations # locations of migrations scriptsflyway.schemas= # schemas to updateflyway.initVersion= 1 # version to start migrationflyway.sql-migration-prefix=Vflyway.sql-migration-suffix=.sqlflyway.enabled=trueflyway.url= # JDBC url if you want Flyway to create its own DataSourceflyway.user= # JDBC username if you want Flyway to create its own DataSourceflyway.password= # JDBC password if you want Flyway to create its own DataSource# LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yamlliquibase.contexts= # runtime contexts to useliquibase.default-schema= # default database schema to useliquibase.drop-first=falseliquibase.enabled=trueliquibase.url= # specific JDBC url (if not set the default datasource is used)liquibase.user= # user name for liquibase.urlliquibase.password= # password for liquibase.url# JMXspring.jmx.enabled=true # Expose MBeans from Spring# RABBIT (RabbitProperties)spring.rabbitmq.host= # connection hostspring.rabbitmq.port= # connection portspring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111)spring.rabbitmq.username= # login userspring.rabbitmq.password= # login passwordspring.rabbitmq.virtualHost=spring.rabbitmq.dynamic=# REDIS (RedisProperties)spring.redis.host=localhost # server hostspring.redis.password= # server passwordspring.redis.port=6379 # connection portspring.redis.pool.max-idle=8 # pool settings ...spring.redis.pool.min-idle=0spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1spring.redis.sentinel.master= # name of Redis serverspring.redis.sentinel.nodes= # comma-separated list of host:port pairs# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url=tcp://localhost:61616 # connection URLspring.activemq.user=spring.activemq.password=spring.activemq.in-memory=true # broker kind to create if no broker-url is specifiedspring.activemq.pooled=false# HornetQ (HornetQProperties)spring.hornetq.mode= # connection mode (native, embedded)spring.hornetq.host=localhost # hornetQ host (native mode)spring.hornetq.port=5445 # hornetQ port (native mode)spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar)spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer)spring.hornetq.embedded.persistent=false # message persistencespring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled)spring.hornetq.embedded.queues= # comma-separated queues to create on startupspring.hornetq.embedded.topics= # comma-separated topics to create on startupspring.hornetq.embedded.cluster-password= # customer password (randomly generated by default)# JMS (JmsProperties)spring.datasource.jndi-name= # JNDI location of a JMS ConnectionFactoryspring.jms.pub-sub-domain= # false for queue (default), true for topic# SPRING BATCH (BatchDatabaseInitializer)spring.batch.job.names=job1,job2spring.batch.job.enabled=truespring.batch.initializer.enabled=truespring.batch.schema= # batch schema to load# AOPspring.aop.auto=spring.aop.proxy-target-class=# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding=false# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # enabled by default# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by defaultspring.mobile.devicedelegatingviewresolver.normalPrefix=spring.mobile.devicedelegatingviewresolver.normalSuffix=spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/spring.mobile.devicedelegatingviewresolver.mobileSuffix=spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/spring.mobile.devicedelegatingviewresolver.tabletSuffix=# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.port= # defaults to &apos;server.port&apos;management.address= # bind to a specific NICmanagement.contextPath= # default to &apos;/&apos;management.add-application-context-header= # default to true# ENDPOINTS (AbstractEndpoint subclasses)endpoints.autoconfig.id=autoconfigendpoints.autoconfig.sensitive=trueendpoints.autoconfig.enabled=trueendpoints.beans.id=beansendpoints.beans.sensitive=trueendpoints.beans.enabled=trueendpoints.configprops.id=configpropsendpoints.configprops.sensitive=trueendpoints.configprops.enabled=trueendpoints.configprops.keys-to-sanitize=password,secret,key # suffix or regexendpoints.dump.id=dumpendpoints.dump.sensitive=trueendpoints.dump.enabled=trueendpoints.env.id=envendpoints.env.sensitive=trueendpoints.env.enabled=trueendpoints.env.keys-to-sanitize=password,secret,key # suffix or regexendpoints.health.id=healthendpoints.health.sensitive=falseendpoints.health.enabled=trueendpoints.health.time-to-live=1000endpoints.info.id=infoendpoints.info.sensitive=falseendpoints.info.enabled=trueendpoints.metrics.id=metricsendpoints.metrics.sensitive=trueendpoints.metrics.enabled=trueendpoints.shutdown.id=shutdownendpoints.shutdown.sensitive=trueendpoints.shutdown.enabled=falseendpoints.trace.id=traceendpoints.trace.sensitive=trueendpoints.trace.enabled=true# HEALTH INDICATORShealth.diskspace.path=.health.diskspace.threshold=10485760# MVC ONLY ENDPOINTSendpoints.jolokia.path=jolokiaendpoints.jolokia.sensitive=trueendpoints.jolokia.enabled=true # when using Jolokia# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.enabled=trueendpoints.jmx.domain= # the JMX domain, defaults to &apos;org.springboot&apos;endpoints.jmx.unique-names=falseendpoints.jmx.staticNames=# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# REMOTE SHELLshell.auth=simple # jaas, key, simple, springshell.command-refresh-interval=-1shell.command-path-patterns= # classpath*:/commands/**, classpath*:/crash/commands/**shell.config-path-patterns= # classpath*:/crash/*shell.disabled-plugins=false # don&apos;t expose pluginsshell.ssh.enabled= # ssh settings ...shell.ssh.keyPath=shell.ssh.port=shell.telnet.enabled= # telnet settings ...shell.telnet.port=shell.auth.jaas.domain= # authentication settings ...shell.auth.key.path=shell.auth.simple.user.name=shell.auth.simple.user.password=shell.auth.spring.roles=# GIT INFOspring.git.properties= # resource ref to generated git info properties file 找到com.boot下的Application 以java Application方式启动，然后打开浏览器输入localhost:8080就会出现Hello World! 这样一个简单的web开发就搭建好了。 启动图片:]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2Fposts%2F41659.html</url>
    <content type="text"><![CDATA[Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。 spring只是一个框架想跟着 spring in action 4 系统的研究下spring，结果发现忘了怎么建一个spring项目。 关键是，不知道该建一个什么项目，Java项目？Maven项目（Java项目？Web项目）？ 一直以来都是直拿以前的项目配置修修改改，结果居然忘了spring的本质是什么，我是说，居然把spring当成web专属了。 颇有些提笔忘字的意思。 spring只是一个框架，第三方jar包，作用就是IoC、DI、AOP。 所以，spring与web没有必然关系，可以用在任何需要的项目中 — 它就一中介和监管机构！！！ 核心：加载配置文件applicationContext.xml，生成一个ApplicationContext对象，继而就可以提供被其代理的对象了！！！ 本质就是这么简单。 spring提供xml方式和注解方式配置bean。（可以认为bean就是我们需要spring创建的对象） 前者是在xml中配置bean，。 后者只需要在bean对应的类上@Component （或 @Repository ）即可。 需要注意的是，spring会根据配置或者注解生成对象，从而注入到需要的地方。 所以需要指定怎么生成对象，初始化参数是什么。 默认情况下，使用无参构造方法创建对象。 spring与web的结合： 在web.xml中启动spring即可！！！ spring与jdbc的结合： 在spring中配置连接所需信息，提供DataSource即可（也行还有事务）。 Spring事务：调用同一个类中的方法问题： 如果同一个类中有方法：methodA(); methodB()。methodA()没有开启事务，methodB()开启了事务 且methodA()会调用methodB()。 那么，methodA()调用methodB()时，不会开启事务！！！ 即：同一个类中，无事务的方法调用有事务的方法，结果就是没有事务！！！ 原因：点这里 解决办法：要么声明要事务，要么分开成两个类，要么直接在方法里使用编程式事务。 建议直接分成两个类。 Spring配置相关Spring容器中bean的id或name，都可以有多个，且第一个为标识符（Qualifier），其余皆为别名（Alias）。所以都可以通过applicationContext.getBean(“id or name”, Type.class)获取。 如果同时存在id和name，则name为别名！！！ Spring容器目前能对各种基本类型把配置的String参数转换为需要的类型。 注：Spring类型转换系统对于boolean类型进行了容错处理，除了可以使用“true/false”标准的Java值进行注入，还能使用“yes/no”、“on/off”、“1/0”来代表“真/假”，所以大家在学习或工作中遇到这种类似问题不要觉得是人家配置错了，而是Spring容错做的非常好。 12345678910// 测试类public class BooleanTestBean &#123; private boolean success; public void setSuccess(boolean success) &#123; this.success = success; &#125; public boolean isSuccess() &#123; return success; &#125;&#125; 12345678910111213// 配置文件（chapter3/booleanInject.xml）片段：&lt;!-- boolean参数值可以用on/off --&gt;&lt;bean id="bean2" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="on"/&gt;&lt;/bean&gt;&lt;!-- boolean参数值可以用yes/no --&gt;&lt;bean id="bean3" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="yes"/&gt;&lt;/bean&gt;&lt;!-- boolean参数值可以用1/0 --&gt;&lt;bean id="bean4" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="1"/&gt;&lt;/bean&gt; Spring通过标签或value属性注入常量值，所有注入的数据都是字符串，那如何注入null值呢？ 通过“null”值吗？当然不是因为如果注入“null”则认为是字符串。Spring通过标签注入null值。 即可以采用如下配置方式： 1234&lt;bean class="..."&gt; &lt;property name="message"&gt;&lt;null&gt;&lt;/property&gt; ...&lt;/bean&gt; 使用标签来开启注解形式的依赖注入。 使用标签来表示需要要自动注册Bean定义，而通过base-package属性指定扫描的类路径位置。 注意，默认开启了annotation-config。 使用标签开启Spring对@AspectJ风格切面的支持。 @AspectJ风格的切面可以通过@Compenent注解标识其为Spring管理Bean，而@Aspect注解不能被Spring自动识别并注册为Bean，必须通过@Component注解来完成。 123456789101112package cn.javass.spring.chapter12.aop;//省略import@Component@Aspectpublic class TestAspect &#123; @Pointcut(value="execution(* *(..))") private void pointcut() &#123;&#125; @Before(value="pointcut()") public void before() &#123; System.out.println("=======before"); &#125;&#125; Spring 父子容器必须要说的是，父子容器是通过设置形成的关系。 容器实现了 ConfigurableApplicationContext 或 ConfigurableBeanFactory 接口，这两个接口中分别有setParent 及setParentBeanFactory 方法，可以将指定容器设置为当前容器的父容器。 首先，默认情况下，Spring + SpringMVC 框架的web项目，会先创建 WebApplicationContext（应用上下文环境，就是IoC容器啦），并以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 为Key，将其存储到ServletContext 中 —这就是根容器。 然后，创建DispatcherServlet ，注意，这是个Servlet，而Servlet也是有ServletContext 的，而且，它也会创建自己的IoC上下文（IoC容器）。这个IoC容器会去ServletContext 中查找根容器，并将其设为自己的父容器！！！—小疑问，这个ServletContext 和 IoC容器 是否一个？？？待验证。。 简单的可以推知：子容器可以访问父容器中的bean，父容器则无法访问子容器中的内容！！！ 参考： spring的启动过程 Spring中父子容器的实现实例 Spring bean的初始化及销毁Spring bean的几个属性：scope、init-method、destroy-method、depends-on等。 Scope 在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。 scope分类：singleton, prototype, request, session, global session。 这里的singleton和设计模式里面的单例模式不一样，标记为singleton的bean是由容器来保证这种类型的bean在同一个容器内只存在一个共享实例，而单例模式则是保证在同一个Classloader中只存在一个这种类型的实例。 init-method 是指创建bean时调用的方法，注意，不是创建bean的方法。 destroy-method 是指销毁bean时调用的方法，同样，不是销毁bean的方法。 注意：scope为prototype的bean，容器会将创建好的对象实例返回给请求方，之后，容器就不再拥有其引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。 所以：scope为singleton的bean的destroy方法则是在容器关闭时执行，而scope为prototype的bean是不会执行destroy方法的。 depends-on 用于指定bean初始化及销毁时的顺序。注意上面的结论。 123456&lt;bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/&gt;&lt;bean id="decorator" class="cn.javass.spring.chapter3.bean.HelloApiDecorator" depends-on="helloApi"&gt;&lt;property name="helloApi"&gt;&lt;ref bean="helloApi"/&gt;&lt;/property&gt;&lt;/bean&gt; “decorator”指定了“depends-on”属性为“helloApi”，所以在“decorator”Bean初始化之前要先初始化“helloApi”，而在销毁“helloApi”之前先要销毁“decorator”，大家注意一下销毁顺序。 Spring 允许 Bean 在初始化完成后以及销毁前执行特定的操作。下面是常用的三种指定特定操作的方法： 通过实现 InitializingBean / DisposableBean 接口； 通过 元素的 init-method / destroy-method属性； 通过@PostConstruct或@PreDestroy注解。 Bean在实例化的过程中：Constructor &gt; @PostConstruct &gt;InitializingBean &gt; init-method Bean在销毁的过程中：@PreDestroy &gt; DisposableBean &gt; destroy-method 参考：Spring bean 的init-method和destroy-methodSpring容器中的Bean几种初始化方法和销毁方法的先后顺序Spring scope属性详解 可以和@Component一起使用的注解： @Lazy(true) – 延迟初始化 @DependsOn({“managedBean”}) – 初始化及销毁时的顺序 @Qualifier – 见 Spring 依赖注入（DI）的注解 @Primary – 当有多个候选时，被注解的bean作为首选项，否则异常。 Resource接口，及资源Resource介绍编码的时候，除了代码本身，我们还需要对外部的资源进行处理。例如：URL资源、URI资源、File资源、ClassPath相关资源、服务器相关资源（VFS等）等等。 而这些资源的处理是类似而繁琐的，如：打开资源、读取资源、关闭资源。 所以Spring提供了一个专门的接口Resource 用于统一这些底层资源的访问。 就是说，Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。 源码如下： 12345678910111213141516public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125;public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。 ByteArrayResource代表byte[]数组资源，对于 getInputStream() 操作将返回一个ByteArrayInputStream。ByteArrayResource可多次读取数组资源，即 isOpen() 永远返回false。 InputStreamResource代表java.io.InputStream字节流，对于getInputStream() 操作将直接返回该字节流，因此只能读取一次该字节流，即 isOpen() 永远返回true。 FileSystemResource代表java.io.File资源，对于 getInputStream() 操作将返回底层文件的字节流，isOpen() 将永远返回false，从而表示可多次读取底层文件的字节流。 ClassPathResource代表classpath路径的资源，将使用ClassLoader进行加载资源。classpath 资源存在于类路径中的文件系统中或jar包里，且 isOpen() 永远返回false，表示可多次读取资源。 ClassPathResource加载资源替代了Class类和ClassLoader类的getResource(String name)和getResourceAsStream(String name)两个加载类路径资源方法，提供一致的访问方式。 ClassPathResource提供了三个构造器： public ClassPathResource(String path)：使用默认的ClassLoader加载“path”类路径资源； public ClassPathResource(String path, ClassLoader classLoader)：使用指定的ClassLoader加载“path”类路径资源； – 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/test1.properties”； public ClassPathResource(String path, Class&lt;?&gt; clazz)：使用指定的类加载“path”类路径资源，将加载相对于当前类的路径的资源； – 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties”； – 而如果需要 加载的资源路径为“test1.properties”，将加载的资源为“cn/javass/spring/chapter4/test1.properties”。 – 需要注意一定：资源查找顺序是先查找当前类路径的资源，再去查找jar包，而且，只要找到就会返回。 – 如果是在jar包中的资源，需要使用getURL()，而不是getFile()，因为资源不是存在于File系统，而是存在于jar包中！！！ UrlResource代表URL资源，用于简化URL资源访问。“isOpen”永远返回false，表示可多次读取资源。 UrlResource一般支持如下资源访问： http：通过标准的http协议访问web资源，如new UrlResource(“http://地址”)； ftp：通过ftp协议访问资源，如new UrlResource(“ftp://地址”)； file：通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”)； ServletContextResource代表web应用资源，用于简化servlet容器的ServletContext接口的getResource操作和getResourceAsStream操作； VfsResource代表Jboss 虚拟文件系统资源。 Resource访问ResourceLoader接口用于返回Resource对象；其实现可以看作是一个生产Resource的工厂类。 1234public interface ResourceLoader &#123; Resource getResource(String location); ClassLoader getClassLoader();&#125; getResource接口用于根据提供的location参数返回相应的Resource对象；而getClassLoader则返回加载这些Resource的ClassLoader。 Spring提供了一个适用于所有环境的DefaultResourceLoader实现，可以返回ClassPathResource、UrlResource； 还提供一个用于web环境的ServletContextResourceLoader，它继承了DefaultResourceLoader的所有功能，又额外提供了获取ServletContextResource的支持。 ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：“classpath:path”表示返回ClasspathResource，“http://path”和“file:path”表示返回UrlResource资源；如果不加前缀则需要根据当前上下文来决定；另外，DefaultResourceLoader默认实现可以加载classpath资源。 目前所有的ApplicationContext都实现了ResourceLoader，因此可以使用其来加载资源。 ClassPathXmlApplicationContext：不指定前缀将返回默认的ClassPathResource资源，否则将根据前缀来加载资源； FileSystemXmlApplicationContext：不指定前缀将返回FileSystemResource，否则将根据前缀来加载资源； WebApplicationContext：不指定前缀将返回ServletContextResource，否则将根据前缀来加载资源； 其他：不指定前缀根据当前上下文返回Resource实现，否则将根据前缀来加载资源。 ResourceLoaderResourceLoaderAware是一个标记接口，用于通过ApplicationContext注入ResourceLoader。 注入Resource通过注入来获取ResourceLoader，再来访问资源，很麻烦！！！ Spring提供了ResourceEditor（这是一个PropertyEditor），用于在注入的字符串和Resource之间进行转换。 因此可以使用注入方式注入Resource。 1234567891011package cn.javass.spring.chapter4.bean;import org.springframework.core.io.Resource;public class ResourceBean3 &#123; private Resource resource; public Resource getResource() &#123; return resource; &#125; public void setResource(Resource resource) &#123; this.resource = resource; &#125;&#125; 123456&lt;bean id="resourceBean1" class="cn.javass.spring.chapter4.bean.ResourceBean3"&gt; &lt;property name="resource" value="cn/javass/spring/chapter4/test1.properties"/&gt;&lt;/bean&gt;&lt;bean id="resourceBean2" class="cn.javass.spring.chapter4.bean.ResourceBean3"&gt; &lt;property name="resource" value="classpath:cn/javass/spring/chapter4/test1.properties"/&gt;&lt;/bean&gt; 注意此处“resourceBean1”注入的路径没有前缀表示根据使用的ApplicationContext实现进行选择Resource实现。 Resource通配符路径Spring提供了一种更强大的Ant模式通配符匹配，能匹配一批资源。 1234Ant路径通配符支持“？”、“*”、“**”，注意通配符匹配不包括目录分隔符“/”： “?”：匹配一个字符，如“config?.xml”将匹配“config1.xml”； “*”：匹配零个或多个字符串，如“cn/*/config.xml”将匹配“cn/javass/config.xml”，但不匹配匹配“cn/config.xml”；而“cn/config-*.xml”将匹配“cn/config-dao.xml”； “**”：匹配路径中的零个或多个目录，如“cn/**/config.xml”将匹配“cn /config.xml”，也匹配“cn/javass/spring/config.xml”；而“cn/javass/config-**.xml”将匹配“cn/javass/config-dao.xml”，即把“**”当做两个“*”处理。 小结： ① Spring通过Resource接口统一访问外部资源，并提供了一堆实现类，可以分别访问File、classpath、URL、URI等等资源。 ② Spring通过ResourceLoader接口获取Resource。 ③ ApplicationContext都实现了ResourceLoader接口，所以可以直接加载资源！ ④ 实现ResourceLoaderAware接口，可以注入ResourceLoader。 ⑤ 注入Resource。 ⑥ Resource通配符路径。 Spring 依赖注入（DI）的注解Spring中想要使用注解进行依赖注入，需要进行如下配置： 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; Spring自带依赖注入的注解@Required，该注解必须用是setter方法上面，目的是强制要求提供setter所需数据，否则报错。 例如，BeanA中的字段field，有一个setField( T field)方法。当在该方法上使用了@Required之后，在XML中创建BeanA时就必须给出设置field所需的数据。 如下所示： 12345678910111213141516package o1.bean;import org.springframework.beans.factory.annotation.Required;public class BeanA &#123; private String message; public String getMessage()&#123; return message; &#125; @Required //只能放在setter上,在XML配置BeanA时必须指定setter注入，否则在Spring容器启动时将抛出异常 public void setMessage(String message)&#123; this.message = message; &#125;&#125; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class="o1.bean.BeanA"&gt; &lt;!--因为有了@Required，所以这里必须提供，否则报错--&gt; &lt;property name="message" ref="message"/&gt; &lt;/bean&gt; &lt;bean name="message" class="java.lang.String"&gt; &lt;constructor-arg index="0" value="hello world"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223package o1;import o1.bean.BeanA;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class A &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void run1()&#123; BeanA bean = applicationContext.getBean(BeanA.class); System.out.println(bean.getMessage()); &#125;&#125; @Autowired(required=true)自动注入，required=true的作用与@Required相同。 可用于构造器、字段、方法。 默认根据参数类型自动装配，但必须只能有一个候选项（required=false则可以允许0个候选项）。 @Value(value=”SpEL”)可用于字段、方法（@Autowired method）。 如： 123456@Value(value="#&#123;message&#125;")private String message;@Autowiredpublic void initMessage(@Value(value = "#&#123;message&#125;") String message) &#123; this.message = message;&#125; @Qualifier(value=”限定标识符”)可用于方法、字段、参数。 配合@Autowired使用，可用于多个候选项的情况。 实例如下： 12345678910111213141516171819202122232425262728293031package o1.bean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import javax.sql.DataSource;public class BeanB &#123; private DataSource dataSourceA; private DataSource dataSourceB; public DataSource getDataSourceA()&#123; return dataSourceA; &#125; @Autowired public void initDataSource(@Qualifier( "mysqlDataSource2" ) DataSource dataSource)&#123; // this.dataSourceA =dataSource; &#125; public DataSource getDataSourceB()&#123; return dataSourceB; &#125; @Autowired public void setDataSourceB(@Qualifier( "mysqlDataSource1" ) DataSource dataSourceB)&#123; this.dataSourceB = dataSourceB; &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;context:property-placeholder location="db.properties"/&gt; &lt;bean class="o1.bean.BeanB"/&gt; &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="mysqlDataSource1"/&gt; &lt;!--type可以省略--&gt; &lt;property name="driverClassName" value="$&#123;driverClass&#125;"/&gt; &lt;property name="url" value="$&#123;jdbcUrl_1&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="mysqlDataSource2"/&gt; &lt;property name="driverClassName" value="$&#123;driverClass&#125;"/&gt; &lt;property name="url" value="$&#123;jdbcUrl_2&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324package o1;import o1.bean.BeanB;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class B &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContextB.xml"); &#125; @Test public void run1()&#123; BeanB bean = applicationContext.getBean(BeanB.class); System.out.println(bean.getDataSourceA()); System.out.println(bean.getDataSourceB()); &#125;&#125; db.properties 12345driverClass=com.mysql.jdbc.DriverjdbcUrl_1=jdbc\:mysql\://localhost\:3306/testdb1?useUnicode=true&amp;amp;characterEncoding=UTF8jdbcUrl_2=jdbc\:mysql\://localhost\:3306/testdb2?useUnicode=true&amp;amp;characterEncoding=UTF8user=rootpassword=root 如果有几个常用的DataSource，那么可以自定义注解来使用，而不必每次都是@Qualifier(“xx”)。如下： 自定义@MySQL和@Oracle 1234567891011121314package o1.customize_qualifier;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target( &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125; )@Retention( RetentionPolicy.RUNTIME )@Qualifierpublic @interface MySQL &#123;&#125; 1234567891011121314package o1.customize_qualifier;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target( &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125; )@Retention( RetentionPolicy.RUNTIME )@Qualifierpublic @interface Oracle &#123;&#125; 使用qualifier来限定需要注入的bean： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class="o1.bean.BeanC"/&gt; &lt;bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="o1.customize_qualifier.MySQL" value="mysqlDataSource"/&gt;&lt;!--value可以省略！--&gt; &lt;/bean&gt; &lt;bean id="dataSource2" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="o1.customize_qualifier.Oracle" value="oracleDataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 要被注入的bean： 12345678910111213141516171819202122232425262728package o1.bean;import o1.customize_qualifier.MySQL;import o1.customize_qualifier.Oracle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import javax.sql.DataSource;public class BeanC &#123; private DataSource dataSourceA; private DataSource dataSourceB; @Autowired public void initDataSource(@MySQL DataSource dataSourceA, @Oracle DataSource dataSourceB)&#123; this.dataSourceA = dataSourceA; this.dataSourceB = dataSourceB; &#125; public DataSource getDataSourceA()&#123; return dataSourceA; &#125; public DataSource getDataSourceB()&#123; return dataSourceB; &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930package o1;import o1.bean.BeanB;import o1.bean.BeanC;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;public class C &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContextC.xml"); &#125; @Test public void run1()&#123; BeanC bean = applicationContext.getBean(BeanC.class); DataSource dataSource1 = applicationContext.getBean("dataSource1", DataSource.class); DataSource dataSource2 = applicationContext.getBean("dataSource2", DataSource.class); Assert.assertEquals(dataSource1, bean.getDataSourceA()); Assert.assertEquals(dataSource2, bean.getDataSourceB()); &#125;&#125; 使用标签来开启注解形式的依赖注入。 使用标签来表示需要要自动注册Bean定义，而通过base-package属性指定扫描的类路径位置。 注意，默认开启了annotation-config。 使用标签开启Spring对@AspectJ风格切面的支持。 @AspectJ风格的切面可以通过@Compenent注解标识其为Spring管理Bean，而@Aspect注解不能被Spring自动识别并注册为Bean，必须通过@Component注解来完成。 Spring的p标签看Spring in action的时候看过p标签，可惜这东西不用就忘。 p标签是为了简化setter的注入而引入的。 用法： 12p:属性 = &quot;&#123;值&#125;&quot;p:属性-ref = &quot;&#123;引用bean的id&#125;&quot; 示例Bean： 1234567891011121314151617181920212223242526272829303132333435363738394041package o3.bean;import java.util.Date;public class Person &#123; private String name; private int age; private Date date; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public Date getDate()&#123; return date; &#125; public void setDate(Date date)&#123; this.date = date; &#125; @Override public String toString()&#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", date=" + date + '&#125;'; &#125;&#125; XML配置： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:component-scan base-package="o3.bean"/&gt; &lt;bean id="person" class="o3.bean.Person"&gt; &lt;property name="name" value="Kute"/&gt; &lt;property name="age" value="22"/&gt; &lt;property name="date" ref="date"/&gt; &lt;/bean&gt; &lt;bean id="date" class="java.util.Date" autowire="constructor"/&gt; &lt;bean id="person2" class="o3.bean.Person" p:name="Bill" p:age="23" p:date-ref="date" /&gt;&lt;/beans&gt; 测试代码： 123456789101112131415161718192021222324package o3;import o3.bean.Person;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class P &#123; private ApplicationContext ac; @Before public void setUp()&#123; ac=new ClassPathXmlApplicationContext("classpath:applicationContextPerson.xml"); &#125; @Test public void run1()&#123; Person person = ac.getBean("person", Person.class); Person person2 = ac.getBean("person2", Person.class); System.out.println(person); System.out.println(person2); &#125;&#125; 测试结果： 12Person&#123;name=&apos;Kute&apos;, age=22, date=Fri May 27 10:13:27 CST 2016&#125;Person&#123;name=&apos;Bill&apos;, age=23, date=Fri May 27 10:13:27 CST 2016&#125; Spring RestTemplate 小结关于RestTemplate 首先，你可以把它理解为一个发起请求并接收响应的工具类（功能类似浏览器）。 其次，它其实是一个壳，具体还是通过调用别的接口来实现（如jdk自带的连接，或者HttpClient之类的，需要设置）。 官方介绍Spring’s central class for synchronous client-side HTTP access.It simplifies communication with HTTP servers, and enforces RESTful principles.It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. Note: by default the RestTemplate relies on standard JDK facilities to establish HTTP connections.You can switch to use a different HTTP library such as Apache HttpComponents, Netty, and OkHttpthrough the HttpAccessor.setRequestFactory(org.springframework.http.client.ClientHttpRequestFactory) property. 使用这个其实没什么说的，不外乎创建template，设置底层连接，然后增删改查。 请参考Spring REST和 RestTemplate实践 。 唯一需要注意的就是默认的jdk连接是不支持delete带请求体–解决办法见下面链接。 其他暂时不清楚使用RestTemplate和直接使用HttpClient有什么区别，感觉HttpClient足够用了–囧。 –突然想到的，RestTemplate可以配合MessageConverter等使用！！！也就是配合SpringMVC使用，而HttpClient则需要手动转换！ 杂： 1httpHeaders.add(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en;q=0.6&quot;); q是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容，若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目运维中常用SQL]]></title>
    <url>%2Fposts%2F54584.html</url>
    <content type="text"><![CDATA[结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 删除表空间12drop tablespace pt6 INCLUDING CONTENTS;drop tablespace mpm INCLUDING CONTENTS; drop tablespace sf INCLUDING CONTENTS;drop tablespace bt INCLUDING CONTENTS; 删除用户1234drop user pt6 CASCADE;drop user mpm CASCADE;drop user sf CASCADE;drop user bt CASCADE; 创建表空间当首次导入时创建表空间 （运行脚本时会提示输入 &amp;1 输入数据文件希望存放的物理地址 例如 D:\OracleData） 1create tablespace pt6 datafile '&amp;1\pt6.dbf'size 100m autoextend on next 10m;create tablespace mpm datafile '&amp;1\mpm.dbf'size 100m autoextend on next 10m; 创建用户1create user pt6 identified by cape default tablespace pt6;create user mpm identified by cape default tablespace mpm; 授权123grant dba to pt6;grant dba to mpm;grant all on dual to pt6 with grant option;grant all on dual to mpm with grant option; 数据库的备份：方法一：数据泵方式 导出： 1expdp pt6/cape@localhost:1521/bt dumpfile=ORCL_2014-08-18.EXPDP logfile=ORCL_2014-08-18.log schemas=(pt6,mpm,sf,bt) //如果是用数据泵倒入，把文件必须放在例：D:\app\rongda\admin\bt\dpdump(oracle的安装目录) 导入： 1impdp pt6/cape@localhost:1521/bt dumpfile=NEWBT_2015-03-16.EXPDP logfile =NEWBT_2015-03-16.log schemas=(pt6,mpm,sf,bt) 方法二： 导出： 1exp pt6/cape@localhost:1521/TEST file=c:\test_2014-04-02.dmp log=c:\test_2014-04-02.log owner=(pt6,mpm) 导入: 1imp pt6/cape@localhost:1521/orcl file=D:\app\rongda\oradata\orcl\20140704sf.dmp full=y log=c:\test_2014-04-02.log 1imp pt6/cape@localhost:1521/orcl file=D:\app\rongda\oradata\orcl\20140704sf.dmp fromuser=pt6 touser=pt6 fromuser=mpm touser=mpm log=c:\test_2014-04-02.log 说明：如果高版本的数据库导向低版本的数据库脚步，那么在导出的时候加上低版本号 version=11.1.0.7.0 版本号即可。导入不需要加入。10.1.0.2.0 例如： 1expdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=EXP_TEST_2014-04-02.log schemas=(pt6,mpm) version=11.1.0.7.0 1expdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=EXP_TEST_2014-04-02.log schemas=(pt6,mpm) version=10.1.0.2.0 1impdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=IMP_TEST_2014-04-02.log schemas=(pt6,mpm) 同义词创建：1create or replace synonym pt6.application_anplan for bt.application_anplan 表的恢复与表数据恢复对误删的表，只要没有使用 purge 永久删除选项，那么基本上是能从 flashback table 区恢复回来的。数据表和其中的数据都是可以恢复回来的，记得 flashback table 是从 Oralce 10g 提供的，一般步骤有： 从 flashback table 里查询被删除的数据表 1select*from recyclebin orderby droptime desc 执行表的恢复 1flashback table'需要恢复的表名'to before drop 删除表中数据有三种方法： delete（删除一条记录） drop或truncate删除表格中数据 delete误删除的解决方法原理：利用oracle提供的闪回方法: 如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据 具体步骤为： 确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点) 用以下语句找出删除的数据： 1select * from 表名 as of timestamp to_timestamp('删除时间点','yyyy-mm-dd hh24:mi:ss'); 把删除的数据重新插入原表： 1insert into 表名 (select * from 表名 as of timestamp to_timestamp('删除时间点','yyyy-mm-dd hh24:mi:ss')); 注意要保证主键不重复。如果表结构没有发生改变，还可以直接使用闪回整个表的方式来恢复数据具体步骤为：表闪回要求用户必须要有flash any table权限 1alter table 表名 enable row movement ·flashback table 表名 to timestamp to_timestamp(删除时间点','yyyy-mm-dd hh24:mi:ss') drop误删除的解决方法原理： 由于oracle在删除表时，没有直接清空表所占的块,oracle把这些已删除的表的信息放到了一个虚拟容器“回收站”中，而只是对该表的数据块做了可以被覆写的标志，所以在块未被重新使用前还可以恢复 具体步骤：查询这个“回收站”或者查询user_table视图来查找已被删除的表: 1select table_name,dropped from user_tables · select object_name,original_name,type,droptime from user_recyclebin 在以上信息中，表名都是被重命名过的，字段table_name或者object_name就是删除后在回收站中的存放表名*如果还能记住表名，则可以用下面语句直接恢复： 1flashback table 原表名 to before drop 如果记不住了，也可以直接使用回收站的表名进行恢复，然后再重命名，参照以下语句： 1flashback table "回收站中的表名(如：Bin$DSbdfd4rdfdfdfegdfsf==$0)" to before drop rename to 新表名 oracle的闪回功能除了以上基本功能外，还可以闪回整个数据库：使用数据库闪回功能，可以使数据库回到过去某一状态, 语法如下： 1alter database flashback onSQL&gt;flashback database to scn SCNNO;SQL&gt;flashback database to timestamp to_timestamp('2007-2-12 12:00:00','yyyy-mm-dd hh24:mi:ss'); 总结：oracle提供以上机制保证了安全操作，但同时也代来了另外一个问题，就是空间占用，由于以上机制的运行，使用drop一个表或者delete数据后，空间不会自动回收，对于一些确定不使用的表，删除时要同时回收空间，可以有以下2种方式： 采用truncate方式进行截断。（但不能进行数据回恢复了） 在drop时加上purge选项：drop table 表名 purge 该选项还有以下用途： 通过删除recyclebin区域来永久性删除表 ,原始删除表 1drop table emp cascade constraints purge table emp; 删除当前用户的回收站: purge recyclebin; 删除全体用户在回收站的数据: purge dba_recyclebin]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN的使用]]></title>
    <url>%2Fposts%2F57755.html</url>
    <content type="text"><![CDATA[SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。 为什么要使用配置管理及时了解团队中其他成员的进度。 轻松比较不同版本间的细微差别； 记录每个文件成长的每步细节，利于成果的复用(reuse); 资料共享，避免以往靠邮件发送文件造成的版本混乱； 人人为我，我为人人。所有成员维护的实际是同一个版本库，无需专人维护所有文件的最新版本； 协同工作，大大提高团队工作效率，无论团队成员分布在天涯还是海角； Subversion/TortoiseSVN的版本控制系统Subversion：是一个开源的版本控制系统，拥有CVS的大部分特征，并在CVS的基础上有更强的扩展，用来代替 CVS 系统。 TortoiseSVN：SVN的客户端工具，和资源管理器完美集成，基于TortoiseCVS的代码开发，使用上与TortioseCVS极其相似; 配置库（ Repository ）SVN的核心是配置库，储存所有的数据，配置库按照文件树形式储存数据－包括文件和目录，任意数量的客户端可以连接到配置库，读写这些文件。通过写数据，别人可以看到这些信息；通过读数据，可以看到别人的修改。 最特别的是 Subversion 会记录配置库中的每一次更改，不仅针对文件也包括目录本身，包括增加、删除和重新组织文件和目录。 工作副本（WorkSpace）与位于中央配置库相对应的是每个人的工作空间，它是每个程序员工作的地方，程序员从配置库拿到源代码，放在本地作为工作副本，在工作副本上进行查看、修改、编译、运行、测试等操作，并把新版本的代码从这里提交回配置库库中。 SVN工作模式复制-修改-合并方案(Subversion默认的模式)在这种模型里，每一个客户读取项目配置库建立一个私有工作副本——版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。 锁定-修改-解锁方案在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。 SVN安装 安装完毕后，在“资源管理器”里点击右键，会有如下菜单出现： 目录结构 SVN使用流程 SVN使用图标说明 SVN CheckOut检出 SVN CheckOut检出注意事项 检出深度： 全递归(默认选择) 检出完整的目录树，包含所有的文件或子目录。 直接节点，包含目录 检出目录，包含其中的文件或子目录，但是不递归展开子目录。 仅文件子节点 检出指定目录，包含所有文件，但是不检出任何子目录。 仅此项。 只检出目录。不包含其中的文件或子目录。 省略外部引用：如果项目含有外部项目的引用，而这些引用我们不希望同时检出，请选中忽略外部项目复选框。如果选中了这个复选框，更新的时候要使用命令”更新至版本Update to Revision…” SVN Update更新作用：更新工作副本使其成为版本库中的最新版本 SVN将显示出更新的文件和更新的次数 SVN Commit提交对工作副本进行编辑后提交到SVN 在右键菜单中点击SVN Commit 提交前写好信息，点击确定 SVN 权限控制当进行提交文件操作的时候您将看到权限提示信息 输入您的用户名和密码 保存权限设置（见红圈） ，可以避免将来重复输入用户名和密码 SVN 如何删除认证数据 步骤：点击右键 —— 选择设置 —— 以保存数据 —— 清除认证数据 SVN Show log显示日志 SVN 日志信息填写规则好的日志信息和糟糕的日志信息 日志信息主要记录的是每次的修改内容。建议把一些重要数据、关键操作写到日志信息中。 注：修改人和提交时间由软件自动记录，无需人工写入日志信息 SVN 如何得到历史版本工作副本右键 - 显示日志 - 选择所需的版本号 - 保存版本至 SVN Revert(还原)作用：撤销本地所有未提交的修改 注意：还没有执行Commit操作之前执行此命令才可以，否则无效 SVN Add添加选中文件/文件夹（在新文件/文件夹所在父文件夹点击右键）， 在菜单中选择“添加Add”命令。不需要受SVN控制的文件请取消打钩。 SVN Add to Ignore List （忽略文件） 添加忽略文件 右键一个单独的未进入版本控制文件TortoiseSVN (加入忽略列表)Add to Ignore List，会出现一个子菜单允许你仅选择该文件，或者所有具有相同后缀的文件。 删除忽略文件： 如果你想从忽略列表中移除一个或多个条目，右击这些条目，选择TortoiseSVN → 从忽略列表删除。 已进入版本控制的文件或目录不能够忽略 SVN 版本分支这个版本历史分析图能够显示分支/标签从什么地方开始创建，以及什么时候删除。 版本分支图将显示以下内容: 增加文件/文件夹 已删除文件/文件夹 分支最新版本 一般的文件/文件夹 SVN 如何创建分支两种方式： 在版本库浏览器中创建分支 在工作副本创建分支 创建分支成功 SVN Switch切换 文件创建分支后，可通过Switch选择在主干工作或者在分支工作; 注意: 切换操作起来就象更新，因为它没有丢弃我们在本地做的修改。 在工作副本里，当我们进行切换的时候，任何没有提交过的修改都会被混合。 解决方法： 在切换前提交修改; 把工作副本恢复到一个已经提交过的版本(比如最新版本)。 SVN 合并假设我们在分支上进行修改：添加一条输出语句： System.out.println(“测试是否能将分支的修改合并到主干中!”) ;提交到配置库中，现在执行将分支合并到主干的操作 SVN 分支合并到主干右键- 主干的文件- 选择合并 SVN 合并时出现冲突 SVN 编辑冲突 SVN 冲突已解决 SVN 合并成功 SVN 什么是冲突团队协同工作时，当多位团队成员同时修改同一个文件，造成本地文件与SVN系统中的文件版本不一致，而导致文件无法提交的情况 SVN 冲突产生原因当团队协同工作的时候，多位团队成员同时操作一个文件。团队成员A操作完成后，将该文件提交到SVN上。此时，其他团队成员的本地文件与SVN上的文件版本不一致。当团队成员B操作完成并对文件进行提交操作时，就会产生冲突 SVN 冲突提示页面提交时产出冲突 SVN 冲突解决方案遇到冲突时，需要update该文件。我们将看到三个带问号的文件 filename.mine filename.rOLDREV filename.rNEWREV 面对文件冲突，我们可以选择以下两种方式解决冲突 使用工具解决冲突 用revert放弃所做的修改 SVN 使用工具解决冲突使用自带工具，如图所示 对比两个版本的文件，解决冲突 工具中会列出两个版本冲突的部分，并让我们选择使用哪个版本的内容 SVN 用revert放弃所做的修改选择SVN还原（revert） 放弃自己所做的修改 SVN 解决冲突之后通过上面所说的方法，解决冲突后要选择已解决的（resolved） 解决后，带问号的三个文件将自动删除 最后选择commit提交到SVN SVN 关于冲突的建议修改文件之前，先进行一次update操作 修改完成后，及时commit，不要在本地停留过长时间 在多位团队成员协作时，尽量修改自己撰写的部分，尽量不要修改不属于自己撰写的部分 出现冲突很正常，可以通过前面的方法解决，不要相互覆盖 SVN 其他SVN的功能 Export（导出） 导出你需要的文件，导出后不在受SVN控制；而checkout检出的文件仍受SVN控制； Import（导入） 将需要的文件导入到版本库中； Relocated（重新定位） 当服务器上的版本库目录已经改变，我们可以把工作复本重新定位； CleanUp（清理） 递归的清理工作副本，删除锁定和保留的未完成操作，如果你得到工作副本已经锁定的错误，运行这个命令删除无用的锁定，并将工作副本恢复到可用的状态； SVN Subclipse的安装步骤（Eclipse集成） 帮助 &gt; 软件更新 &gt;查找并安装 选择“要安装的新功能部件” 选项并点击Next。 点击“新站点”并且创建一远程站点， 名字:Subclipse URL:http://subclipse.tigris.org/update_1.2.x 在结果安装窗口中，把”Subeclipse in the Features” 选择到安装列表中，并且通过向导来开始安装插件。 完成这些之后，重新启动Eclipse。 SVN 在Eclipse下使用的图标 SVN Eclipse下使用的主要功能将版本库导入到SVN资源库 将新建项目导入到版本库 Eclipse中小组的使用]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荒原，我的国]]></title>
    <url>%2Fposts%2F12381.html</url>
    <content type="text"><![CDATA[自由在追寻自由的路上，像风一样掠过无数的山川，以及开满鲜花的旷野。山鹰在身后的气流中盘旋，只有它明白风的走向，又如何消失在无垠的大地。狼群在两侧高地似幽灵如影相随，它们希冀着远方有片肆意的江湖，来断一世恩仇。脚下野草按捺不住狂野的心，挣脱生于斯、死于斯的方寸之地，随风而往，在别处轮回生灭。一只迷途的蜜蜂轻落在湿润的额头，喃喃细语，无人知晓其意。只见前方瑰丽云霞，点燃了正欲黯淡下去的天宇。在冰与火的冷暖间，在明与暗相交的时光里，我一次次眺望，那云之落处的远方，是否有位美丽姑娘正在煎煮着热茶，准备好了我急于得知的一切答案。而有些答案，早已写在了故事的开头。 第一次踏入羌塘旷野，只是意识反复挣扎后的必然结果。 那是二〇〇九年，清晰记得狮泉河小镇的那个夜晚。三个朋友砸开了我的房门，惊恐之色令人诧异。他们魔怔般扯拉着我，劝说不要进入羌塘……那焦急、哀求、惊恐，伴着急泣的混乱场景让我心悸，犹如末世巨浪逼近头顶。原来他们在自己的慈善总结会议中，有一人开小差，恍见一副场景，大意是我进入羌塘荒原再也没有出来，直白的意思就是死在荒原里了。随后，他将这种不详预感分享众人。一粒微尘落入水中却惊起骇浪涟漪，他们居然严肃地认定为神启？先知警告？必定发生的凶兆？总之，他们在半夜闯进了我的小旅馆房间，演绎出了这么一幕劝生大剧。 我不想与他们的预感交锋，这个预感本身是否有意义，都不应热烈地去回应。我严厉地请他们离开房间，简单而粗暴地驱逐着他们的善心。又一番拉扯、苦劝后，我心生愤怒，劝留的起因对我来说只是个笑话，却被他们演绎成生离死别的闹剧。 我的愤怒最终平息了这场闹剧，或者说我进入羌塘的决绝让他们死心。但不得不承认，他们用夸张表情说出那个预感后，我着实起了一身鸡皮疙瘩，这分明是一个鬼故事嘛。并且，这个故事强有力的进入了我的心房，久踞盘旋。你可以吓唬我荒原里的气候有多么极端恶劣，豺狼虎豹又如何残忍，但是不能用一个鬼故事去诛我原本虚弱不堪的心。我的愤怒其实来源于虚弱。 朋友们走后，我无法抑制地陷入深深地恐慌中，虚弱内心最后一道庇护的城墙就这般无情地被摧毁了。没有人是绝对唯物的，这个世界有太多的未知。我理性分析着朋友们的言行，试图以摧毁他们的方式来重塑自己的内心。是的，他们都有强烈的宗教皈依感，在神山冈仁波齐山脚下的塔钦村时，他们夜夜入睡前均要抄讼一百遍《心经》，平日谈佛论道也是玄奥。虽然，日日礼佛念经，但在我眼中他们却不是真正的宗教皈依者，而是盲目的神秘主义追随者。正是这个世界没人能说的明白，而产生了许多能说明白的理论。正是每个人内心都虚弱的沉浮着，才有了那不顾一切的执信。我们塑造的神，只是我们极端存在的另一种形式。 我们的内心越虚弱与无助，我们塑造与信奉的神就越强大。力量的两个极端最终融为一体，达到完美的平衡之境。那个开会走神的朋友，当脑海里浮现我凶兆的景象时，或许只是他对羌塘荒原无力征服感的映射。这种映射以谎言的形式保护了虚弱的自我，巧妙地修复了人与神瞬间的失衡。此刻，神主宰了他的一切，可为与不可为都是一种命理注定。 我成功以否定别人的方式重塑了自己的内心，让他维系在一个脆弱却不至崩塌的状态。那个令人毛骨悚然的鬼故事，还是如幽灵般不时掠过心田，发出两声渗人的冷笑。 彼时，我对羌塘的认识只是反复臆想的摸样，我从未置身于如此广袤的一片旷野。犹如初恋，对于情人的幻想是甜美爱情的全部，当现实取代了幻想，爱情也就不复存在了。因而，进入羌塘的前夕，并没有太多体能、风险、未知与恐惧的困扰，幻想衍生出的淡淡欢愉始终萦绕着美丽的旅程。由于毫无骑行经验，大腿严重拉伤，瘸子可以进入羌塘吗？拉萨至阿里漫长的拉练骑行中，近三分之一路程是靠装可怜搭车前行的，意志力就像抽了大烟疲软无力。我没法和汽车同在一条路上，尤其当年还是土路的新藏线，当被包裹在汽车飞驰后的灰尘里时，骑行的心便顷刻间被瓦解了。所以，我深佩那些骑车进藏不搭车的人们，在诱惑中咬牙前行，无视身边飞驰而过的汽车，放弃高效的捷径抵达终点，埋首在自己的执着里，专注着心灵的移动。 为什么要去羌塘？我无法在我深爱的时候去缕析情人的本质，却对旧欢有着无比深刻的认识。〇七与〇八年交接的腊月，南方遭逢百年大雪，我带着一条充气船来到贵州那个魂牵梦萦的洞穴前。这是洞穴里的峡谷，在深暗的地下奔腾着湍急的水流，只有法国探洞联盟多年前成功漂流过。 显然，这不是一个适合漂流的天气，且我被当地政府盯上，只能在寒夜里悄然下水。我的两个助手是当地的苗族人，以往的经历已缔结了生死之谊。刚入洞口，我就被冲下了水，和法国探洞联盟初次漂流经历如同一辙。他们也因此放弃，直至三年后才完成此洞的漂流。我幸运的很快爬上一片巨石堆，浑身湿漉漉的，风从洞外呼啸的吹进来，越发浸入骨髓的湿冷。他俩从石缝里收集着被水流冲下来已干枯的木棍，在两块大石间生起火堆，然后把我像腊肉般架在上面烘烤。 许久缓过来，然后是长久的沉默。 这是一场儿戏之旅，偷偷摸摸，没有后援，山寨装备。回程逆水行舟，我们解决动力的办法居然是在竹竿上栓上铁钩，计划着勾拉洞壁回逆。这是一趟即便去得了也难回来的旅程。 我提出放弃，我难以承受捎带两人命运的旅程。正是我们在一起已经历了很多，让我对风险有了更为直面的清晰认识。他们最终闷声说道，继续。声音缺乏底气。他们远比我恐惧，但深知我，即便此刻糟糕的状态，也不足以动摇内心的执着。对于他们的选择，我沉默，唯有深深的无言的感动。他们为了成全我的梦想忽视了自我对死亡的恐惧。 漂流的艰险已成淡薄往事，唯有洞穴深处那片寂静，无法在光阴河流里轻易的散去。那是洞穴深处，死水之潭，弯曲促狭，世界仿佛停止了一切运作。蓦然，听见尖利的呼啸声，查明声源是气嘴漏气。船一直慢漏气，苦于一直找不到位置，此刻，他以这种嘶吼的方式倒数着自己的生命。接着，听见急促的擂鼓声，一支鼓，两支鼓，三支鼓。原来是三人的心跳声，此起彼伏的跳动着。再接着，听见水流奔腾的声音，可周遭的深潭死水一片，水流声从何而来？水流声从我们的身体深处而来，那是奔腾在血管里的鲜红血液。 我从未置身于如此安静的地方，肉身是世界里唯一的声源。那种感觉如同置身在躯体之外，看着那载了半生的皮囊不过是一台冷血机器，毫无感情与目的，他的存在就是维系自己的运转。时而，又会觉得自己被一台机器紧紧束缚着，你无法逃脱，只能与之共存亡。我前所未有的认识到承载自己的肉体是如此脆弱，与自己又是如此紧密相连、息息相关。世界就要消散，我极力挣脱，却又无能为力，这种矛盾如同用手捂住自己的鼻嘴窒息而亡。 这段特殊地形造就了至极安静，我不知和著名的奥菲尔德消音室相比哪个更安静？但我知道，没有人能单独待在奥菲尔德消音室里超过四十五分钟，否则，将会发疯。人无法在绝对安静的地方生存。在奥菲尔德消音室里，你无法忍受了可随时抽离。然而在这幽暗的地下深处，却无处可逃。 翌日中午，我们回逆到洞口，成功结束了漂流。当我站在洞外，被刺眼阳光包裹的瞬间，我仿佛看到明晃晃的眼前是一片广袤无边的旷野。 从那以后，我再也没有探过洞穴，甚至数年来再无踏足充满地穴的西南诸省，那是一片我不愿再回去的疆域。我希冀着被一块足够大的旷野承载，如风自由，往来无羁。我已被紧紧束缚在自己的躯体里，不愿自己的躯体再被无情的束缚。旷野，那自由的旷野，像天一样高远，像海一样辽阔，任由我盲目的游荡，无论朝哪个方向，都是没有边界的远方。 果真身临这片旷野时，他没有给我与现实接触必然的失落感，反而是更爱，深爱。羌塘，是我必定要经历的地方，彼此宿命中都残留着前世的印痕。进入荒原的第一次露营，是完美的夕阳，金色光芒抚慰着苍凉荒原，世间一切杂念与恶欲皆被抹去。白日的辛劳犹如迅速退去的海浪，前一秒是久远的过去，后一刻是无限的未来，时空凝滞在一片跳跃的金色中，温暖触手可及。 我长久凝视着自己斜长的影子，看着他一点点延伸，然后冷淡下去。怀念即刻心生，怀念那温暖的光，魔法般将烈日下枯燥乏味的荒原变成金色殿堂，怀念那由金到绛红直至冷却为幽蓝的色彩，怀念微风披着光羽在大地上自由的奔跑，怀念那通透的远方不再是残忍的诱惑，怀念一朵云被点燃及熄灭的时光。怀念应该是对一件久远的事物在记忆上的复苏。然而，在羌塘的第一夜，我就无可救药地迷恋上了那夕阳下欢颜的旷野。在透彻温暖的光中，随着镀金的野草欢快的跳跃，荒原上是一望无际的火焰。燃烧吧，我们一同燃烧，尽情把握短暂的欢愉，直至成为静谧且幽蓝的灰烬，然后一同在冷夜里怀念彼此曾经的辉煌，期待下一次重生的曙光。 生命短至一日，轮回却无止境，每一天即是消亡也是重生。这便是我初入羌塘，与之暗合的节奏。 这是一条穿越羌塘西部的路线，完全由鲜亮的梦规划。我用笔在地图上把心仪的山谷、河流、雪山、湖泊连成一条线，这便是我的旅程了。随着旅行的深入，时间的流逝，这片荒原总是适时地在我激情消退之际，变出新的戏法。陷在沙地里万分沮丧之时，他派来一只萌到翻的小藏羚羊，我有什么理由拒绝此番鼓励？当我被冰雹砸得抱头卷缩后，一道彩虹悬挂在触手可及的身旁，我有什么理由拒绝欣赏此番盛景？陡峭的山梁之后是万顷碧蓝的波涛，我有什么理由拒绝登高？粘稠陷人的湿地里，同时也开满鲜艳的野花，在这荒凉的无人高原，我有什么理由不心心相惜、心生爱慕？ 当我被一条河流迂回阻截，数十次淌着刺骨的水流周旋两岸后，我看到了一群群数目庞大的藏羚羊群，在河谷中欢快的列队奔跑着。那低闷密集的蹄声让我恍惚置身于《动物世界》里的非洲草原。又时而穿越到上世纪西方探险家对羌塘那如潮水般野生动物的描述中。虽然，山野中漂泊多年，但如此恣意奔放的盛景从未有过。藏羚羊们并不十分惧我，但绝不会过度热情的亲近我。我坐在一块干燥的石头上，凝视着他们矫健的身影，长久之后，忽然意识到他们从哪里来？这贫瘠、酷寒的高原，野花只是点缀，水草需要费力的寻觅，他们何以为生，以此为家？ 这是一片奇幻的旷野，野生动物不真实的存在着，从你身边缓缓走过，在远处山头凝望你，黑夜里徘徊在帐篷周围……他们又以如此真切的方式证明自己的存在，和对这片旷野所有权的宣示。 在这条充满狂风、冰雹、湿地遍布的河谷里，我踽踽前行了五天。每天都有数量庞大的藏羚羊群擦身而过。后来，我知道了，这条山谷是羌塘西部藏羚羊一条非常重要的迁徙通道。早年，夏勒博士想探寻此道无功而返。若干年后，两个美国旅行家向北寻找这条迁徙通道，收获甚微。而在九月份，向外界关上大门独自狂欢的泥泞羌塘，却被我无意的闯进了这条河谷。那时，以我对羌塘浅薄的了解，并没有闯进土豪晚宴的喜悦，而只是，对这片荒原，对身处大自然中的我，都充满了难以言喻的敬意。 随后，穿过一条羌塘西部几大山脉交错的边缘山系后，我进入一个宽阔的湖盆地带。这里又完全是另一幅景象，雪山，湖泊，草地，自由的生灵，他们在夕阳下为我搭建了一个完美的梦幻场景。 我恍惚，那年寒冷的冬天，我从地下深处走出来看见阳光下明晃晃摇曳的旷野，就是此时脚下的这片大地。我的躯体不再被束缚，而我也难觉察到我被躯体束缚着，一切是那么的淡然，随意江湖。 我醉了，醉在无边的旷野里。 我些许颤抖，那样的美，纯净空灵。 我心生妄念，以此为家，安度余生。 人群的拥挤，不过是个体随波逐流相互碰撞的表象。每个人都试图逃离着，在璀璨夜里独自盘算着自己的远方。远方是什么地方？没有人能清晰告知我们，但他一定有别当下被裹挟的疲惫生活。 多年前的我，希望远方是一个像乌金贝隆一样的地方。我并不在意牛奶河、糌粑山，我憧憬那是一个没有争议与烦恼的世界，那里的人生活在和谐的精神秩序里，相互爱慕，恬静淡泊。 多年前的我，很年轻，因而尚有逃离的热情与力量。我在西南偏远的山区，游历在闭塞的村寨之间。那里的人如同那里的山水一样清澈，我只要坐在吊脚楼下发一会呆，就会有人把你领回家给你可口的食物和温暖的夜。我陶醉在质朴的人心里，万物以安静平和轨迹悄然运转着，每个人的脸上都绽放着幸福的花朵。城市的嚣泄与设防如同西山落日，且坠入黑暗深渊后再无轮回。 是的，我一直憧憬平和的岁月与人。人群不再拥挤，人们的眼神不再空洞茫然，相互的碰撞应是温暖的传递。但已知的几千年来，我们都试图相互远离，那是避免彼此伤害唯一的方式。是的，年轻的我充满了违背我们特质的憧憬，希冀一个与世无争的山谷只能是欧洲人厌倦战乱臆想出的香格里拉。当我在一个寨子待上三日后，能用肢体语言和拙劣的第六感与人交流后，发现他们也在意邻家的猪偷吃了我家的菜，谁家的姑娘轻薄的与少年郎微笑，慈祥的老奶奶也有愁眉解不开的心结，喝酒的热烈汉子麻痹着一颗火辣的心……更不消说，我以为的那些外面世界的垃圾其实是他们一直渴望尝试的。 当我在一个美丽寨子待上三个月后，自己便成了打破和谐秩序的最大因由。人们像商量好了一样琢磨出对你的三个判断，前提你只是一个没有任何背景符号的旅人。一，失恋的。从情感上判断一个人，佐证了八卦是人们不可或缺的生活要素。二，淘宝的。这十分符合一个男人对世俗的终极追求，即女人和财富。当上述两个判断都不成立时，你就只好委屈的成为第三个可能，逃犯！ 世俗的逻辑竟如此一致，对于一个男人而言，你不为钱和女人，就一定是为了钱和女人犯了事。 我坐上竹筏顺流而下，离开山峦深围的美丽村寨，有人在岸边哭泣，有人在行囊里塞了一双绣花鞋垫，更多人目光空洞不知所然。我离开了，并非我是一个逃犯，而是乌金贝隆又一次必定的破碎了。那温和的表面涌动着深不可测的鬼魅，随时成为一幅令人厌恶的面孔，我们在厌弃他人时也被他人厌弃，我们就这么悲哀与孤独的活着。无论走到哪里，我们都在人群里相互拥挤。 最终，我明白，那些我有意、无意逃避的事物，并不存在于理想国之乌金贝隆里。因为，乌金贝隆从不存在，他只是我对这个世界以及自我最终的幻想。眼前景象，在某个瞬间，让我游离到一个曾被我否定的叫乌金贝隆的圣境。一只狼的出现适时打破这一幻幕，让我走出稚嫩少年才有的心境。 荒原自有他的游戏规则，以此为家的生灵一样拥有无常生灭。每一个生灵生存的基础都是建立在其他生灵毁灭之上。野草吸食着大地的养分，牛羊咀嚼着鲜美的野草，豺狼在一旁窥视着自己丰盛的晚餐，最终，凶狠的豺狼也会被病魔或时光之剑杀死，腐烂成富饶的大地。生命在循环中创造无数悲剧，这才是荒原最真实本质的一面。生命最终都会消亡，生亦灭，虽已注定，但存在于每个生灵体内的自私与智慧，让其不甘俯首命运而勇于抗争。生亦灭，我们无从选择，但之间的长度却有可能被有限的延长。 第一次，面对狼，就这么猝不及防的来了。 之前，我的意识里，狼更多是一个传说中的符号。我曾赋予这个符号为自由。多年前，曾写过一本小说，大意是随着人类对自然的掠夺，原本狼自由栖息的草原日渐萎缩。一只被猎人捕获的小狼崽，被包装成宠物贩卖到繁华的城市。狼变成了狼狗，开始了他从未想过的只需依靠献媚就能获得丰富物质的宠物生活。对于放弃自由的代价，他似乎默认了，并从中尝到了甜头。随着时间的推移，草原在他内心深处慢慢复苏，他最终鼓起勇气抛弃繁华，一路艰辛回到那已不复存在的草原。 那时年轻的我，写完这本寓言式的小说后不久，便选择了一直在路上的生活，寻找着我心中的那片草原。而今，我真的遇见了狼，在一片真正的广袤的草原之上。我略有恐惧，那是本能必然的应激。我的理性告诉我，其实你并不了解狼，一切关于狼的知识只是那些文人意淫的。或是人类对自我缺陷的转移，似乎一个人欺负了姑娘只是狼附体而已。同时，对狼的负面幻想也无限放大，他是否会一跃扑向我咬断我的喉咙？或者像猫捉老鼠一样，尾随我几天之后再无玩耍兴致，便一口吃掉精疲力尽的我？不管哪种结局，他都不会为我捕获一只兔子，烤熟后以讨好我那忍够了辣椒和糌粑的肠胃。事实上，他对于我的不了解和我对他的不了解一样多。 我们就这样对视着，风中无语，亦无过激的提放，彼此都充满了好奇。然后，他走了。然后，我继续往前。此次短暂的相遇，我并不能确定有多么的了解狼了，但内心不再有盲目无知的恐惧。 我希冀着，能再次遇见这只狼，我们熟识为友了，一同坐在草地上聊天，彼此讲述初遇的感念。我希冀着，有一天，我和草原上每一个生灵都能做到：在路上，你看着我，我也看着你，一个眼神就能明了，彼此的困顿与幸福。 当我决定游历羌塘前，已然思量如何避免介入荒原上的厮杀。我有我的宿命，但绝对不是在荒原弱肉强食的链条中轮回。一位试图穿越羌塘的人曾短信说，做了一张弩，箭头涂有毒汁……还有一位则认真欲讨论猎捕鼠兔作为有效补给。我屏蔽了此些人，异常反感此般论调。人类总是因为恐惧而先发夺人，或者将自己塑造成食物链的顶端，其实，我们什么也主宰不了。 对于荒原，我们只是过客，而他们生于斯、死于斯。 作为客人，我们应是卑微的姿态和感恩的情怀。遇到友善主人，我们报以诚挚的微笑，遇到刁蛮主人，我们时刻隐忍与耐心沟通。带着刀和充满戾气的心，征服不了那早已不再属于我们的荒原。 我的一把随身小刀只是切大蒜和酥油，我的鞭炮从未试图点燃，我的防狼喷雾剂时常忘记放在了哪个口袋里。在末进入荒原前，我并不确定带着一颗过客的心是否能畅通无阻，是否过度理想化了我与荒原的关系？ 之前一路，我都认为过客的身份得到了荒原生灵的认同。不仅传说中的狼对我友善有加，就连食物链顶端的棕熊也认可了。第一次与熊是个偶遇，我在山坡上，他在山坡下，冷不丁一个转角彼此对上了眼神。他极度敏感的直立站起，两只前腿怕打着胸脯，嘴里嗷嗷吼着同时摇摆着憨厚的大脑袋。他站起来足够高大，和一个篮球中锋并无差异。面对此状，我居然禁不住笑起来，他完全和想象中的不一样。我坐在地上，悠然的点燃一根烟，看着他一番耍宝。他很快自觉无趣，仓皇逃向另一侧山坡。当我来到他原先待着的地方时，他居然躲在不远处的一块石头后。其实我没有看见他，他以为我看见了他，从石头后再度仓皇地逃离。我不禁又傻乐起来，这棕熊肥大的屁股扭起来真是性感。 过客不仅是我在荒原里的身份标签，也是我人世间游历的法则。无论我们与谁相遇，相伴多远，在浩渺的时光洪流里都不过是短暂的邂逅，终将生离亦或死别。那些纠缠的恩怨情仇，不过是虚无中凭空生成的嗔怨。不要执着于彼此的关系，我们会被人辜负，也会辜负别人，但我们始终会别离，再无关联。遗憾的是，人世间过客的身份难以获得单纯的对待，我们总是在彼此辜负中互生怨艾，甚者诅咒，路遇拔剑，生死不往。什么样的怨恨使我们即便相互远离也无济于事？什么样的怨恨伴随灵魂在轮回中不灭？我所秉持的人世间那份过客的淡然，难以持久的维系，最终成为人群之外的旁观者，看人群与浮云的流动，在地平线上起伏连绵。那么，我凭什么执信荒原里就存在简单的彼此，就认定最好的防卫是颔首微笑？世间，有没有一片旷野，广袤无垠，自由的跋涉。不去伤害，不被伤害，我们的轨迹即便交错，也只是温暖的传递。 我深爱上了这片荒原，其实，我只是深爱上了行走在荒原中的我。 曾经，我也经过很多高山，但视野终要回到逼仄谷地。那种对顶点愉悦的深刻怀念，不过是为下一次重复，酝酿心智而已。起伏的旅程最终在失去与得到的反复拉扯下，成为一条铺满无奈与哀伤的直线。 曾经，我也走过密密山林，满树繁花与翠绿确实赏心悦目，但不免格局有限。我更喜冬日里萧瑟的树木，繁华虽已落尽，却是通透开阔，直抵人心。曾经，我也深入幽暗地下，迷恋着手中光亮开启永恒黑暗，我与所见景致均是生命中第一次相遇。创世般的惊喜在时间尺度上极为微小，却足以温暖整个艰辛的旅程。然而，持久的黑暗才是那些景致的本质，一次次转身光灭的瞬间，最终叠加成一个毫无色彩的记忆片段，我在黑暗中照亮的只是自我。曾经，我遇到过很多人，他们怀着各自缘由陪伴我进出险恶之地，不论我们曾有怎样的分歧，最终，我们将力量汇聚一处，所向披靡。我们在风景里，我们本身也是风景，这是我极力却也是无力摆脱的困境。 曾经，我去过很多地方，他们成为经历的组成要素。我不能否定他们曾带给我的快乐与虚荣，但我总是在善变中寻找新的可能。我要去的不是某个地方，而是那个地方有我的存在。这不是轻易的事情，若干年前的同一时刻，是否还记得身在何处，内心涌动着至今难以消退的触动？回首，过往，多是淡薄的苍白了一片的琐碎。记忆是唯一能证明曾经的存在，没有记忆的时刻，我在何处游离失所？ 羌塘，位于高原北部的无人之地，我处心积虑地走了进来，看似两个老友随意约定。但我深晓他不仅缺乏绕指柔情的表象，本质上也是冷酷、荒凉、死亡的内核。很多人尝试走进他，左右徘徊不得法门。更多人只是远远地瞥了一眼，便明了无法驾驭他的深邃。他在物欲横流的当下，依然持有着本真面目令人陌生的伫立在极遥的远方。 我不知，羌塘何时将成为靠记忆拼凑的过往。那年，那时，初遇的淡然，让我感受到了某种可能，彼此一番纠缠难以轻易了结。 至少五年过去了，我们一直相互依恋。 初次进入羌塘，那近似完美的旅程一度让我不知所措。没有体能困扰，没有单调食物难忍之心，没有冷酷风雪中的倦意，没有孤单至深的恐慌，没有野兽堤防之意，没有方向错乱之惑，反而，这一切都成为了完美的注脚。对于这片传说中恐怖色彩笼罩的荒原，进入的能力与技巧，我居然不费心机的掌握。我对荒原的恐惧一个个湮灭，行走的脚步越发愉悦。这种愉悦不同以往旅行，他更似一种深谙气流的飞翔，在客观世界无法摆脱的诸多阻力中，以最轻盈的姿态无拘无束的游历。 直到一个夜晚，月影憧憧，难以无眠，我在帐篷里辗转反侧。忽然，那个心中的鬼故事悄然浮现脑海。不同以往，他清晰的面容难以用最强硬的手段使之沉入海底。就那么无奈的，在月光铺洒的静谧海岸，我跪立在礁石上，与那张漂浮在水面上惨白面孔相互凝视。他的眼睛空洞黑暗，深不见底。我好奇隐藏着什么，俯下身去，凑近他的眼睛看个究竟……蓦然，所有惊悚的记忆从那个被我凝视的黑洞里涌了出来……我极力对每出现的一幕场景加以理性的解读，却让自己更深陷一场无法自拔的泥淖。我想呼救，可无人应答。我想逃离，却无处可逃。我暗自憎恨阿里的三个朋友，为何在深夜闯入我的房间，用惊恐的表情和夸张的肢体语言为我讲述了他们的预感。现在，好了，他们在人群中相互取暖，可曾想旷寂荒原中无法沉睡的我，将如何面对这未知的世界？克制与隐忍达到一个边界，无力阻挡鬼魅在黑夜里潮水般的入侵。我钻出帐篷，在它不远的周围徜徉着，试图用夜的寒凉让自己清醒与理智。远处群岚围合着清凄的月夜，我难觅明日将要行往的方向，我只能等待曙光的来临，将大地透彻的展现在眼前，从而判断与决策。之前，我所能做的便是学会如何将这个无眠的夜晚抛弃。如果我失忆，这个世界是否记得我曾经存在？ 我没有宗教皈依，我无神可倚。 我总是执信自己有足够力量把握自己，而不是将自己的失与得归咎于冥冥中的上帝之手。无情的是，面对未知的世界，我们谁也无法坚定的持有此般执念。万物回逆必有一个起点，总有一个力量无视逻辑与规律，在我们连意识都无法抵达的远方负责无中生有。因而，在内心极度虚弱的时候，我可以不信赖我们塑造出的各路神仙，以及种种无法被检验的理论，但我无法回避我的存在本身就表明了，确有一股力量在我之前就已然存在。 内心深处，我并不能轻易的接受，神的确以某种形式存在。或者说，我只是在神和自己之间选择了自己。我选择自己，安排自己，独立成完整的我。我的命运，我在人世间获得的不公与幸福与他无关。我只是单纯的我而已，或许平凡，或许闪光，或许沉沦，那都是完全属于自己的经历，而非某种被注定的无法挣脱的轨迹。这同样不是一件轻而易举的事情，这需要自我有足够的力量和心智与之抗衡。在这场不明意义的长久拉锯中，我和我的神各有胜负，至少我是这么自负的认为着。显然，这次，我输了，输得极其惨烈。 在完成羌塘西部的穿越旅行后，我应与边区牧点相隔一百公里平行，然后在预设的牧点获得补给后掉头继续深入荒原。正是在那个鬼故事的干扰下，我偏离预设轨迹近二十公里，与牧点更为接近的平行。只为那个鬼故事果真灵验后，我可以迅速逃离。实际上，偏离二十公里在客观上毫无意义，他只是满足了虚弱的内心，让自己看起来比之前强壮一些罢了。 没有预料的是，我对边区牧点的判断完全错误，我所偏离的二十公里与他们撞个满怀。那是敏感地带与敏感时节，我被牧民热情的扣留了。良久，我都没有缓过神来。我已然身处于拥挤的人群中，而我的心还在那片自由的荒原里独自跋涉。 牧民将我的证件送我乡政府，以便确定我的去留，那是离无人区最近的一个行政点，即便如此，他们往返了三天。因而，我在牧点魂不守舍的居住了三天。这是一个在物理空间上更为闭塞，更类似于我曾希冀的如乌金贝隆的地方。三顶帐篷聚在一个土坡环绕的谷地，十来个牧民与世隔绝的相依共存，与一群牛羊终年重复着简单的生活。帐篷是由牦牛毛编制而成的黑帐篷，这种原始帐篷已并不多见了。最初收纳我的帐篷，过于拥挤，一个年轻的孩子不得不与露天的羊群相拥而睡。 他们对我极为友善，每天吃不完的炖羊肉和至纯的酸奶，以及廉价却对我诱惑十足的烟草。他们对我并无提放，其实，我也无处可去，对于他们而言，这偌大的荒原便是最好的牢笼。我参与着他们的劳作，放牧，剪牛毛，挤羊奶，揉皮，在大雪覆盖的清晨拍打掉帐篷上的积雪。我享受着田园般恬静无争的生活，暂忘那无法应变的明天。我所能回报他们的便是一本地藏王菩萨经书，他们对菩萨有着与生俱来的虔诚与恭敬，十分满意我的礼物。经书是阿里朋友赠送的，他们劝留不了我，并将地藏王菩萨经书赠与我，佑护我在荒原里的旅行。地藏王菩萨曾有誓言，地狱不空，誓不成佛。他不仅度芸芸众生，也度地狱饿鬼，慈悲心境舍我其谁。朋友之意显然，在我生死渺茫的荒原旅行中，无论何方神圣都在地藏王菩萨的感召下为我让路开道。 初始，我对经书这样的礼物十分为难，沉重的行囊着实不愿再多加这样无用的东西。且不能被随便挤压，玷污，毁损，我得把他像宝贝一样收置好。对于艰苦的旅行，无形中增添了我小小的负担。现在，终于解脱了，我将崭新如初的经书转赠于更需要的人。 他们并不执意我的去留，尤其在我能念诵莲花生心咒之后，只碍于一人最初的强硬，他是牧民点唯一的党员。我刻意靠近这个强硬的人，彼此熟识后，他像了换了一副面孔，极为温和友善的待我，神情中不时有些许逃避，一定是愧疚自己的行为导致了我夭折的旅行。其实，他们并无恶意，他们即使身处荒原深处，也摆脱不了在人群中的随波逐流。 三天后，乡长开着车将我带回了乡政府驻地。即将离开牧点时，所有人向我挥手告别，不舍之情，无言以表。几天的相处，我无时无刻不在表明远行的执着，然而，我们都被卷入了一场无法把握的激流中。他们辜负了我，他们有所负疚，他们对我的依依不舍，更像是对自我的某种忏悔。我强忍感怀，看着他们逐渐消失在视野，最终融化在无边的荒原中。就这样，我离开了荒原，沉默不语的离开。但我并没有放弃，我臆想着在乡政府能把自己的行为解释清楚，然后休整几日，继续北上找寻那荒原中还在踽踽独行的我。 五天后，我又被县上警车带走。当我坐上车时，依然没法面对即将远离荒原的事实。随着车后的乡村也如那牧点一点点的消失在视野，直至完全融化在无边的狂风中，我才意识到，完美的旅行彻底终结了。非常难以理解的事情，我的身体随之剧烈的变化，一股股恶臭从身体里涌出来，不停的闷屁与打嗝，类似一种腐烂鸡蛋的怪味。车上人被熏得难以忍受，询问我驮包里是否有腐烂的肉食？我佯作什么也没闻到，事事与我无关的神情，随着颠簸的车厢面无表情的打嗝、闷屁。每一阵过后，他人便要打开车窗透气，任凭冷风吹打着抖索的身体。如此无奈的一幕反复演绎，让我有种复仇的快感。远离荒原，我的身体也似腐烂了，再无生气。 忧伤与怀念主宰了我离开荒原后的心情。有过类似心境，对一个难以抵达的地方有着备受折磨的思念。我不断反思，那偏离二十公里的轨迹，缘何就变成了前往相反方向的岔口？ 人生有多少时刻，是被这微小的力量毫无知觉的改变。我一边追索这种改变的每一个错误细节，修正他，完善他，一边积蓄力量重新开始。 起点，我们皆为一致，在生命起源的混沌中走向明晰，在人类文明的洪流中相互裹挟，在无穷轮回的时光里生生灭灭。远古，我们手揣石器孤独地在旷野里游荡，不知方向，不记来路。生命如同浮云，散聚无常，脆弱不堪。但我们从容，不惧命运。如同山鹰深谙气流的走势，藉以在广袤的天地里自由飞翔。生命的意义不值得追寻，就如这无涯的旷野，方向没有实际存在的意义。生命的终结只是另一个生命的站起，我们累了，便随意躺在一片野花丛中，安静的沉睡，只待春日里的曙光将我们温柔的唤醒。 春日迟迟不来，野草爬上了额头。最终，未知与恐惧，使我们从四面八方聚集一起，建立弱小城邦抵御不可知的自然。自由天性使我们的相聚充满了争斗，为了不被相互伤害，自由被约束，每个人都必须将部分自由交给彼此都信赖的人掌管，他是巫师，亦或王。我们在共同约定的守则下生息、繁衍，集聚众人之力获得与自然对抗的力量。我们像狼群一样在旷野里结伴而行，试图触摸它的边界，挑战他的威严。最终，我们遍及旷野里的每一个角落，却悲哀的发现，我们已成为旷野的主体。 我们再无处可去，只能相互拥挤，像蜂群一样建立起一座座巨大的蜂巢，那昔日弱小的城邦最终发育成偌大的都城。我们已然成为一个被同质化的庞大群体，制造出了一台喂养我们的机器，我们存在的意义与目的便是保证这台机器的正常运转。然而，在不灭的夜里，每一盏灯火都是孤立的，那看似璀璨的都城，不过是所有孤立的灵魂集合的表象罢了。无论我们拥有怎样空虚的内心，都要在曙光中无奈地飞出巢穴，为维系息息相关的生存机器辛勤劳作，在一个由我们共同创造的循环结构中冷漠的疲于奔命。 行走荒原最大的障碍，其实是我们自己。 喜欢深度旅行难以抵达的秘境，享受着难得一见的自然与生活。在他眼中，旅行是一种单纯的生活状态。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北方的空地，孤身穿越大羌塘无人区]]></title>
    <url>%2Fposts%2F52480.html</url>
    <content type="text"><![CDATA[藏语“羌塘”，意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用“可可西里”代替了这片广袤的荒原。实际上，可可西里不论行政疆域还是地理疆域都只是大羌塘这片荒原的一小部分。大羌塘，自由最后追逐之地。北方的空地相信，荒原彼端，云之落处远，方是永远到达不了的地方。 此次穿越的路线前无古人，被誉为历史上最伟大的探险旅程。 北方的空地作者以自己孤身穿越这片最后自由之地的经历为出发，用生动的文字、富于冲击力的照片，用满含的激情与深邃的思考，为读者真实再现了这片神奇而瑰丽的土地，每一段文字，读来都让人有身临其境的感觉，而每一章照片，都是那样恰到好处的精美，记录着羌塘的美丽、神秘和朴实。让读者阅读之后，不仅为大自然的雄奇瑰丽而深深震撼，满足潜藏在每个人内心深处的远足梦想，更能让心灵受到涤荡。” 序言行走荒原，放逐心灵 羌塘之行，头戴英雄桂冠，只是迎合了世人幻梦，头顶依旧是被电脑辐射得越来越稀的毛发，那才是真实的自我。 回眸荒原，那个孤寂身影不再，而荒原依故。有人默默走过，有人轰然倒下，有人留恋舞台。荒原不会为任何人改变，改变的只是行者的心，抑或世人的目光。不论谁，对于荒原而言，都不过光阴驹隙里的过客。行走荒原，并不需要多么高超的技巧，它远比人世间的游历轻松。那些笑对生活困顿的人，才是真正的强者。行走荒原，也不会使人有多么高尚，它仅仅是一种生活方式，没有什么可值得炫耀。如果爱，就去，不知不觉转到另一条路上，只说明还不够爱。不要轻易给自己冠冕堂皇的借口，滑动的人生并不会有更丰富的体验，那只是一种随波逐流的状态，在不断反悔与更替的价值观中游弋。你可能属于每一个经历过的时代，但没一个是属于自己的美好时代。若说行走荒原所需的品质，就羌塘而言，无疑是坚持、隐忍和乐观。坚持可以让扫地的成为少林寺高僧，可以让唐僧轻易摆脱女儿国的纠缠。没了坚持，生命中只剩无穷诱惑，就会轻信看漫画书也能练就如来神掌。没有什么事能轻轻松松成功，走路还有嘴啃泥的时候。隐忍则抑制着复杂多变的情绪，以客观姿态旁观自己的行为。谁都能在别人骂街的时候充当一个优秀的老娘舅，当自己身处骂街角色中，观音姐姐来劝都不顶事。很多事情真没什么大不了，不就是搞不清谁踩谁一脚嘛。现实又是残酷的，有些事不是那么好轻易接受，所以需要乐观，它可以将任何苦难变成一出事不关己的舞台剧，既饱含泪水，更充满啼笑皆非的趣事。荒原在哪里？它可以是一片广袤的无人区，也可以是小区里夜深人静的花园，甚至是野草滋长的内心。荒原真正的含义，是一片心灵自由放逐之地。那里有久违星空，只随意地仰望一眼，就知自己的位置，既没想象的那么高尚，也没想象的那么卑微。那里有单纯，模糊的道德边缘是分外明晰的善恶边界。那里有安静，可以毫无顾忌地打量自己，只有独我的时候，才无视那些形形色色的标签。 人是群体动物，但心灵是孤独的。 不时去荒原，摒弃繁华，看看真实的自己，想要什么，不想要什么，也可什么都不想。不要怕迷路，世间本就无路，迷失才可怕，走在正确的路上都觉得行往错误的方向。祈愿每一个尘世中的孤寂旅人，都能找到属于自己的安宁之地。 自序第二次穿越大羌塘无人区已过三月，期间不少志同道合者询问事宜，今儿便呈一贴，简叙过往。 此次穿越从青藏高原的西端至高点界山大阪开始，时间4月20日，一路向东经邦达错、羊湖、若拉错、岗扎日，横穿整个藏北无人区后改由北上进入阿尔金无人区，经可可西里山脉、昆仑山脉、鲸鱼湖……在阿奇克库勒湖遇人，再三天车程至花土沟镇，时间七月五号，总历时77天。在离开界山大阪至阿奇克库勒湖的74天里独处无人区，此间行程1400公里左右，跨度四个月。大羌塘藏语“羌塘”意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用可可西里代替了这片广袤的荒原，实际上，可可西里不论是行政疆域还是地理疆域都只是大羌塘这片土地的一小部分。大羌塘，他是自由最后追逐之地…… 穿越路线图： 前戏三月初入藏，一路烦心事。原装插头居然正负极接反，驮包铆钉再而三的轻易断裂，多个设备共用的充电器损坏……骑车前往阿里，作为前期体能拉练，一路上丢三拉四，先是遗了背包捡回，后失了相机包再寻回，第三次在警察林立的江孜县街头丢了一个大驮包，衣物、太阳能板等尽失。无奈，重返拉萨调整，整顿装备。随后与友人去了林芝赏桃花、泡温泉以求转运，更享得“十凤一龙浴”的传奇，想必晦气已散，再返拉萨，做着去阿里的准备。没想到又遇江湖客忽悠，失了小钱又耽搁一周，不得已自己找车速到阿里。谁料自行车竟在途中被颠掉了后轮快拆杆，一时在偏远的阿里无所适从，即便拉萨有零件走邮政快递也得十天不定。多啦同学凭借巧嘴托一司机将快拆杆从拉萨捎来。以为最后一遭，不曾想一次未用的新油炉又断了喷嘴。翌日到处寻焊接，一连三家皆无铜焊，第四家倒是可以，老板事先说明，“如果焊好给十块，坏了可别怨我。”我应下。只见电光闪烁，不消一分钟喷嘴便彻底毁了，无语。又是多亏多啦同学，将自用的MSR油炉及丁丁的睡袋托志鹏捎回了阿里。时间已4月16日了，我已没有多少时间再耽搁，翌日便找车前往界山大阪。 雅江上的漫天黄沙 雅江大峡谷的桃花，遗世独立 山野中的原生态温泉，边酒边歌（此张友人拍） D1（4-20），16K，宿营5192M这是一辆装满废铁的卡车，到达界山大阪凌晨六点。夜黑酷寒中，司机冷得都不愿露头，我独自攀上废铁将自行车取下，慌乱中将跟随多年的鸭嘴兽水袋刺破。好在多带了个友人赠送的MSR水袋，否则我将再度功亏一篑。猛烈的寒风中第一次搭建新帐篷，若不是单层一体结构（1.5层），是搭不起来的。极冷，温度在–15℃下，把头钻进睡袋，却被呛了出来，丁丁睡袋的那个味可不一般。中午十一点醒来，大风依旧，全靠身体压着帐篷。烧水吃饭，忽四个边防官兵走近，他们诧异一个人竟在此季宿营界山大阪。我是万分紧张，生怕是堵我的人，去年便是被从无人区“押”了出来，有此一遭更是疑神疑鬼。好在四个边防官兵不知我的去向，嘘寒问暖，不断叮嘱小心小心。官兵走后，我随即打包装车走向无人区的深处，恐再有变。车子沉重，车把难以掌握，途中一个小坡居然要拆掉驮包才能推上来。这对我打击很大，现在硬路且如此，后路漫无边际的荒原如何可行。此次从界山大阪进入荒原竟连一个人也没见着，而去年九月时无人区边缘游牧甚多，可想此时大风低温天气还不是放牧季节。十六公里处有一间羊圈，在龙木错东端，去年也经过，到了此地后再无力推行，决定宿营，好好整理下思绪。安顿好后便去了山谷中寻找湿地，去年多啦和流虻经过时发现，而我竟一无所知，所以这次要寻个明白。湿地中泉眼众多，是恒温的地下水，所以外面世界一片冰冻，水里却春意盎然，水草，游鱼……这是我在海拔5200米高原唯一见此的独特地貌。 谷地里的积雪被大风吹成尖锥装 此湿地由多啦和流虻发现，附近矿上的人也不知，我去年也是错过 地下水恒温，所以外面世界冰天雪地，水中一幅春意盎然，有鱼有草 D2（4-21），0K，宿营5192M一夜狂风，海啸般此起彼伏。第二日没有往前，而是在羊圈里思前顾后。的确，前事诸多不顺，体能尚未拉练，负重到了极限，咳嗽不见好转，寒风低温甚烈……我并不认为这是一场精心准备好了的旅行，身体和心理上都存有巨大的阴影。何去何往，一直纠结着。心里没底的还有装备，能否承受的住，还没怎么着，驮包铆钉又断了一个，前货架松脱。下午把所有驮包的铆钉撬掉换上准备好的螺丝，效果非常好，整个行程再无有过一次故障。前货架重新调整，由于没有带匹配的扳手，我并不认为一劳永逸了。晚上下定决心，继续往前，其实这个决定一点也不意外。 幽兰水草 遍布湿地的小泉眼，水质清冽 泉水流出不久便上了薄冰 羊圈，睡袋下是门板，没有挪动过，和去年一样，感觉昨日 黄昏中的湿地 黄昏中的龙木错，如果图片有声音，可以听见排山倒海的风声 D3（4-22），52.4K，宿营5145M早起，东西竟塞不进包里，无奈扔掉了三碗糌粑、护肘、冰爪才得以顺利装包。顺着铅锌矿的路找到进入荒原的岔路，岔路在河床上，很难发现，去年就错过，后回头直接插进去的，所以今年寻的特别仔细。接着便是翻越大丘陵，坡顶海拔5275米，也是此程最高点。下午两点过了去窝尔巴错的“岔路”，至此全新的旅程开始，前方的路不再是熟悉的了。随后吃了一块压缩饼干，冻得硬邦邦，用铁锹砸碎。到了下午六点，边推边骑走了32公里，如果轻装的话速度至少能提高一倍。风越来越大，我打开“伞帆”测试了一下，利用风能的效果远大于预期，一路飞驰。八点后开始留意路边水源准备随时宿营，地图上显示路边有连续泉水并聚集成沟，但我高估了此季的水资源，山谷里一边荒芜，滴水不见。随着天色黯淡，不免有些紧张，“伞帆”被吹断了三个辐条，当天便彻毁，并不可惜，只是个试验（被风直接吹了20公里，今后大有利用价值）。到了九点半，渐黑透，只好放下自行车，先去了北侧山谷里找水。这是一片宽阔的沙地，连条沟也没有，再远点的地方什么也看不见。我回头取了GPS查看等高线，发现南侧沙地离山势较近便寻去。终于在一条沟壑里发现一块冰，用铁锹砸了20升，冰块很浅，还夹杂着羊粪。回程时逆风，把眼睛给吹坏了，两天里都半眯着。等把帐篷搭好，已经快23点了，融冰又用了40分钟，倦的不想吃东西，喝了点牛奶。没想到，这么快就开始缺水，如此狼狈。 途中的溪流，冰层触底 此河汇入马头湖，而湖的北侧有个卫星湖，绝好的溜冰场 夜深融冰，需要40分钟 D4（4-23），31K，宿营5028M一整天阴霾，大风不断，不时有冰雹云从身后袭来，又忽而一晴。沙土极重，基本推行。下午3点到了鲁形湖，此处有一间土房，是最后一处人类固定建筑。去年，多啦和流虻曾在土屋里住了三天，无人。今年似乎也如此，但房子前一辆卡车不免让人浮想联翩。我先去羊圈侦查了一番，只有几次小羊羔，它们见了我后就一直跟在身后，心中平添不少暖意。用望远镜查看四周，不见人与羊群，确定无人后用螺丝刀拧开门栓。屋子里很干净，地上有两箱饮料，里屋挂了一串风干的羊腿。炉子上有壶水，微热，说明主人并未远去。我把水袋灌满后出来，将门栓螺丝再拧上，不留一丝有人潜入的痕迹。然后在卡车的工具箱里顺走一把匹配的扳手，解决了最后一个装备上的障碍。前货架每两个小时就松脱一次，组合钳子根本拧不紧，如果没有匹配扳手是迟早要回头的。即便有了扳手，前货架依然每天都要松脱，驮包太重了，所以每天晚上把前货架拧紧成了例行工作。快速离开土房子，有了去年一遭，牧民成了我最不想见的人。离开土房子数百米后车辙骤然变的稀疏，沙重的下坡也推不动车子。从路的角度来看，过了鲁形湖才是真正的进入无人区。很多天以后，常怀念起屋子里的羊肉，可惜那时食物充足，车子太重，恨不得多扔掉些东西。 早晨继续融冰，光线好，羊粪都被捡了出去 营地，面对的小山就是昨夜取冰处 鲁形湖边的土房子，无人，最后的人类建筑 D5（4-24），19.8K，宿营4951M十点半出发，天气依旧。可能此段路从界山大阪开始是台地风口，所以风难止歇。风速通常保持在六级，瞬间风速到九级。沙土依然很重，双手适应了沉重的车头，前日被风吹坏的右眼疼痛加剧。下午三点，瞥见右侧山头上有一截凸起物，貌似天线，于是爬上去细瞧，原来是一个铁塔（大地三角点）。上世纪71年，三大军区联合对羌塘做了初步测绘，留下大量三角点和水准点，今天终于得以见识实物。傍晚来到邦达错附近的一处泉眼，泉水流进冰封湖区，冰面上黄斑遍布，是风携来的黄沙与尘土。近湖冰面有很多裂口，我推测下面有泉眼，而非冰层融化所至。邦达错西侧便是通往克里雅山口的岔路，越野车可以直接开到山口，我一路留意，却没有发现车辙。阴霾天空终于呼啦啦飘下雪来，我不慌不忙搭好帐篷，附近有如此一口清冽的泉水，便再也没什么大不了的事了。 71年三大军区联合测绘羌塘时竖立的大地三角点 邦达错冰层上的空隙，推测下有泉眼 伏地风暴团，扫过时天昏地暗 邦达错一片冰封，野鸭更显旷寂，他也是藏西北四大错之一 风雪说来就来，这个季节天气不应该频繁的阴霾 D6（4-25），4.3K，宿营5002M此处风化地貌丰富，充满气泡的火山石随处可见。推车转过小山是一条大冰河，此河是饮水河，从窝尔巴错流出汇进邦达错，去年走过上游，它也是一条动物迁徙通道。饮水河下游极为宽阔，冰层厚有一米，中间是未冰封的主河道，很深。河岸边有很多泉眼，水质极好。今天只推行了四公里多，却走了二十多公里探路，主河道是过不去的，北侧邦达错更别想，只能向南寻路找一处浅滩，谁知南侧是更大一片湿地，一直把路逼向西方，彻底南辕北辙，令人琢磨不透。花了四五个小时不得过河的路径。下午横下心一直沿着湿地走，直到山脚下，湿地才止住得以东寻。此处火山地貌丰富，还发现了游牧痕迹，和用火山石垒起的玛尼堆。此处也是最后一处游牧痕迹，想必是一个夏季牧场，再之后的路，荒原彻底与人类社会断绝了关联。寻路一直到天黑，确定了明天行进的方向。 此处类似雅丹地貌很多，同时又是火山地貌带 从窝尔巴错流出的饮水河 河边泉水众多，平添一丝绿意 主河道很深，下午碧水间夹杂着黄水带，那是融化的冰雪携带的泥沙 冰层很厚，冰面呈凹陷状，是风吹所至 此图才是饮水河南来主道，分叉无数，其右侧是大片泉水滋养的湿地 绕路东寻探路，发现游牧痕迹，这是火山石堆砌的玛尼堆 营地，从上图中可看见遥对的此山 D7（4-26），11K，宿营5009M朝着昨天探路的方向前进，绕过湿地转向东方。下午两点再度遇到曲折的饮水河，这次是躲不过去了。河面近700米宽，覆冰，冰面由外至里呈现不同形态。岸边有悬冰、褶皱冰、堆积冰、冰窝、冰凌等。见此情形我断定河水会在傍晚时分消融，所以才造就了如此多的冰形。换上拖鞋探到主河道时发现主河道至少有三条，冰面厚薄不一，水深至膝。我长吁，如过了此河便无法回头了。有很多路都是如此，只能走一次，第二次便没了胆。推车强渡，有些冰软，卡着轮胎，得用脚破冰，有些冰厚，底部且半融彻底陷住车子，有些冰水下面是软沙，寸步难行。最后一段冰河拆了驮包才得以过去。整整用了四个小时才过河，腿上被冰块划了数道血口。六点钟时，冰面基本化尽，水面大涨，混沌一片，恰时狂风卷着冰雹袭来。我想，若迟疑一刻，赶上此时怎么也横不下心过河的。河岸沙重的超乎想象，且垂直，又卸了一次驮包才推上去。到了日落时分，天气又出奇的好起来，霞光，蓝宇，明月……喜欢这样颜色的羌塘，喜欢这样颜色下的营地。 这类冰薄而悬空，远离主河道 冰面硬，下而半融，最怕下面还有一层软沙 这种情况下车轮会被卡的很死，很难弄出来 卸包过河，很是繁琐 转瞬，河水混沌，冰雹袭来 终于找到曾经的羌塘，金色的黄昏，暖冷色调相间 D8（4-27），14.6K，宿营5112M昨夜忘了收码表，冻坏，之后路程远近靠GPS数据。双路温度计探头冻坏，内置探头到了–10℃就乱码，只能用水银温度计临时采集数据。夜间温度基本在–15℃—–20℃之间，帐篷内温度在–10℃左右。一体式单人帐的好处就是限制了空气流动易于保温，缺点同样大，就是结露现象严重，每天早晨帐篷里的冰霜有半升之多，穿衣服时先把连衣帽戴上，不然冰块呼啦啦的往脖子里掉。另外，羌塘的风终于回到了我之前预测的规律上，早晨无风，或极小的风，下午两点后风起逐渐加大，傍晚八点左右风逐渐小，这个规律准确率达到80%。今天路况很糟糕，下午在一条古河床的软沙里艰难前行，需拼得全力才前一步，然后停下大喘，速度也就可以在蜗牛面前吹。挣扎了五个小时后，当我看到草岸时，眼睛蓦地湿润一下，终离苦海了。 清冷的早晨 内帐结露严重，每天都清理出近半升的冰霜 这样的朝阳预示着今天的天气依旧阴霾为主 D9（4-28），18K，宿营5072M上午又进入一段重沙路，苦不堪言。GPS专用的太阳能板短路，查修是二极管坏了，好在备了零件。由于采用了最新的三结非晶硅太阳能板单独给GPS供电，使得GPS高耗电成了历史，七十多天里只因故障换过一次电池，节省了需携带的大量碱性电池。同时备了一块功率5.4W的太阳能板，专给7.4V的相机、DV及其他数码设备供电，路上没缺过电只缺水。下午七点抵达普尔错，此湖冰面怪异非常，岸边的冰卷扬上翘，湖岸裂开，推测是大风推冰拱岸所至。冰体夹杂的黄色，应是碱渍。湖对面有很多野牦牛，及两头闪烁不定的棕熊。湖东面是一座深入湖心的半岛，我与之犄角之势扎营。晚上砸开岸边的冰取水，碱味很大，只采了冰回去。第一次煮麦片，第一次带麦片旅行，只因在阿里装包时发现还有一点空间，就买了包两斤的麦片。很不好吃，还是碱水味太重？反正是倒掉一半，其实还是负重的阴影，能轻点就轻点。 早晨晒装备必不可少 普尔错黯淡的黄昏 被冰拱起的堤岸，再加上羌塘强大的风化力，便如拉链般敞开 不断挤压的冰面 取水处，踏过冰锥有一薄冰处 日落前一刻，一道金光照在普洱错上，一切变了模样 D10（4-29），16K，宿营5141M上午绕行普尔错北面，岸边是此起彼伏的大坡，稀疏的草地生出嫩黄，野牦牛多三两结伴各霸一处。忽然有五头结群的野牦牛向我冲来，一时尘土飞扬，雷霆万钧之势，非常有震撼力，对野牦牛脾性不熟悉的人定会被惊吓一番。结群的野牦牛并不会伤人，冲人只是在表述领地，在离人近时会突然九十度转向，绝尘远去，然后停在一处高地远远的观察你。身躯重达一吨的野牦牛其实是荒原中生性最胆小的动物，他们遇人最初的反应是尾巴翘起，前蹄磨地，犄角向前，双眼发红，披身长毛不时抖动，一副不干死你就不叫牛魔王的凶狠劲头（示警）。这种举动是内心恐惧的反馈，期望用凶狠的表情吓退外来之物，你只要壮着胆子不去理睬，当靠近野牦牛群时，他们会突然溃败转身逃去，和先前狠劲截然相反，情势转变之快令人错愕。只有胆大的野牦牛群才会短暂的冲向人，但绝对不会真有胆量查看你的护照。野牦牛群的数量越少，这种恐惧的反馈机制越明显。在羌塘，有经验的司机是不会从两三头野牦牛前经过的，远远的就避开了，实在绕不过去，就点上一根烟等牛吃饱草自然走开。因为野牦牛是会真的顶车，而非流言，能把越野车轻而易举的顶翻。我曾向他们求疑，为什么我推着自行车没遭到过一次恐怖袭击？老师傅给我的答案是我的车太小，牛看不上!离群或发情的孤牛的恐惧反馈机制就更大了，我路过它们时也是心里没底的，那种对峙令人窒息。我个人经验是极慢速度靠近，不要对视牛的眼睛，不要在乎他做什么凶恨的动作，但只要他的前蹄往前迈一步，那怕一小步的挪动，就要利马停下来，给对方一个缓气调整心态的时间。如此反复前行。若逼急了，野牦牛将是地球上最具杀伤力的动物，没有什么能够阻挡，一般的子弹打在它的皮上根本穿不透，顶多一个小眼。以往，无人区附近的牧民会把捕获到的野牦牛皮切下来做菜板，几十年都剁不坏。中午时候，夹在背包外侧的360度遮阳帽丢了，还未用一次，没有回去捡，导致以后的日子里一顶抓绒帽白天黑夜里戴到底。好在皮粗肉糙，否则对脸部的伤害是致命的。一点半的时候发现一辆废弃的吉普车，翻了个身，有十几年的历史了，推测是盗猎车。如今，羌塘的野生动物保护的特别好，至少藏羚羊的盗猎极罕有了，但盗猎野牦牛的却应孕而生。盗猎者把野牦牛的头割下弃之，然后扒皮，再把肉剁碎，拉出去当家养牦牛肉买。因为没有硕大的头骨且肉剁烂，难以检查其肉家养野生，这让盗猎者赚了空子。盗杀一头野牦牛肉的利润在万元左右，铤而走险的人不少。盗猎者通常冷季进入无人区，活动直径两百公里左右，所以无人区深处的野牦牛对人的恐惧心里要比外缘的低很多。在阿尔金无人区曾发生过一起野牦牛报复盗猎者的行为，母牦牛寻到前日打死小牛犊的盗猎者，钢刀般的犄角穿过那人胸膛，顶在头上，十几天不放下来。母子之情，撼动人心。三点左右出了普洱错盆地，下一坐标是红山大阪，然后下到土则岗日的月牙湖。此时，发现了一条南北纵向的车辙，探了半天路不知走向。我带上地图、GPS、指南针爬上一座小山测算红山大阪方位。山势浑圆，山口难寻，确定大阪位置后抄直线前行。经过一片烂草地时，不想看见的一幕来了，草地上零散着百个劈开的野牦牛头，无疑是盗猎现场。之后是漫长的古河床，软沙铺地，缓上至山脚。 野牦牛舌头上长有一层肉齿，可以做梳子，俗称肉梳，牧人用他一头青丝梳到银发 废弃的车子，疑是N年前盗猎者遗下 被宰杀的野牦牛，头被割下，硕大，可比车圈，有的头骨被劈开，不知因何，难道是取舌做肉梳子？ 大阪下的营地，夕阳金辉，明日还是个好天气 D11（4-30），20.4K，宿营5120M上红山达坂的地面很硬，碎石为主，加上下了一个大坡，今天推行距离在过鲁形湖后首次超过20公里。山口平坦，似一条宽阔山脊，海拔最高5256米。上了平坦山口，海拔6356米土则岗日便映入眼帘了，山顶浑圆，丝毫没有一座雪山的筋骨。羌塘深处的雪山大多如此，在经过数次夷平地质运动后不再有鲜明的棱角。谷地里藏羚羊很多，多是十几只成群。自去年在某河谷里看见迁徙的绵延不绝的超大藏羚羊种群后（可能是近年发现的最大种群），便对这种小型羊群完全没了兴趣。羌塘的食草动物种群恢复的极快，例如野牦牛、藏羚羊、原羚、鼠兔、旱獭等。深入羌塘深处，你绝不会对突然出现在眼前的藏羚羊感到惊喜，因为太平常了。此季藏羚羊已经公母分群，路上多见带孕的母藏羚羊，公藏羚羊不知迁往何处出了。近年研究，藏羚羊繁育中心不仅只有卓乃湖，整个大羌塘无人区有四个藏羚羊繁育中心，一是卓乃湖，二是兔子湖，三是黑石北湖，还有一个记不清了。我认为，藏羚羊的繁育中心远不止四个，多数种群并没有不可想象的长途迁徙。他们的生育性迁徙大致南北走向，南到中央山脉附近，北到横亘天际的昆仑山脉。藏羚羊看似胆小，其实对外界事物充满了好奇。羌塘深处的藏羚羊并不十分怕人，最近距离可至30米。它们会安静的看着你，揣测着你是什么玩意，为何走的这么慢。它们会在你的前方来回穿插，时而佯作一副胆小的神情踌躇不定，实则逗你玩。性格决定命运也适用动物，藏羚羊就是典型代表，它跑的快，身姿矫健，最厉害的是头顶一对长角，其硬度和锋利是数一数二的。如果它们转了性，三头藏羚羊戳死一头狼是很简单的事情。可它们倒好，这对角是在发情时和竞争对手玩命用的，一剑封喉啊！下达坂有段路陡直，试着骑车顺坡溜一段，却被厚重的沙土绊了大跟头，前货架松脱，一驮包直接飞到沟壑里。至山下就是土则岗日脚下的月牙湖，湖面冰封，近岸稍融，依然是个重矿水湖。月牙泉岸边有许多露头的岩石，风化的极为厉害，一道道的排列，有如城墙，有如房舍，因此也使得我数次停下侦测。心里是明白的，只是那些风化的岩石造型太拟物了。其中一人形石头还折腾我躲到一沟里用望远镜看了许久，太逼真了。湖岸散落的黑色火山石也很多，总之这一处地貌非常奇特。过了月牙湖进入一片不见边际的古湖床，我的GPS地图显示这一带是一个触须般的大湖，如今放眼望去，四周一片荒芜，不见一水一冰。粗略测算，这片古河床将近1200平方公里。羌塘是一个没有大比例地形图的地方，也没有过大比例尺度的地面实测，地图上的有些地标往往只是一种记忆，比如脚下这片古湖床，几十年前或许还碧波荡漾着。推行在古湖床平坦的沙砾中，极易混淆方向，心理也是，仿佛这就是一片没有方向的疆域。 借用去年拍的一张动物迁徙的照片 上达坂的路，碎石地面，硬，已经非常理想的推行地貌了 土则冈日下的月牙湖，雪山浑圆，没有山骨，一瞥之间有时难以分清山和云 古湖床，地上的白渍是盐碱，常会和冰雪混淆46# 豆豆它爸2老范好。横走的话绝对无人区的天数和线路太长，是双湖至阿尔金的三倍，油料？另外车辙比较少，多是高原寒漠土、古湖盆沙地，表层非常软，因为不懂摩托车，不知轮胎和动力能否克服？去年流虻和多啦在鲁形湖遇到的骑摩托车跑山人吹嘘自己去过很多地方，我是不信的，挺多也就是在昆仑山南麓和藏西北四大错之间转，地貌环境不允许啊。老范，摩托车你专业，也许改装下（三轮模式什么的）在冬季走是可行的。关于野生动物（上）申明：个人体会，非书本，仅参考。对于在荒原中行走的旅人，野兽是亘古不灭的话题。以羌塘为例，野兽主要有两种，一是狼，二是棕熊。还有两个替补野兽，分别是野牦牛和乌鸦，把他们列入残忍一类随后解释。如何防范野兽伤害，首先自己不要有害它之心，人与动物在本能上的情感是一样的。【狼】此次遇狼七次，其中五次是对狼。狼现在的基本社会属性是神雕侠侣模式，至于集团军似的狼群很罕见了。闲扯一句羌塘的生态问题，现在不是藏羚羊等少了，而是位于食物链顶端的野兽一直没有恢复，导致荒原生态另类失衡。尤其是失去天敌的鼠兔、旱獭把荒原折腾的够呛，直接显现结果就是草原沙化。早在上世纪中叶，狼还是这片荒原的主宰，他们为非作歹，无恶不作，然后政府决定号召牧民打狼除害，就变成现在这副情形了。最近一次关于狼群袭人的有效记录是七几年的一次科考，在巴毛穷宗遇到狼群围困，队员们开枪射狼，而狼前仆后继，饿的以为子弹真是花生米。如今，狼绝对是孤独的。我此次第一次遇狼是对狼，一只在前面佯攻，一只在后面守着，这种一前一后是基本战略。首先不要紧张，野兽是能嗅到人的恐惧气息，其次不要后退，后退就等于承认自己是猎物，不要做过大的肢体语言，觉得安全时拍个照片没问题，然后凝视对方的眼睛僵持着。僵持时间少则几分钟，多则半小时，当狼搞不懂你后且不觉得你有什么危险，就会汇集一处从山坡后溜走。要知道，狼不缺食物，搞定一只鼠兔比搞定一个比自己身形大的人要轻松的多。即使他饥饿，他首先也要评估自己能不能搞定你。而你要传达给狼的信息就是我对你没兴趣，也不怕你，更不会给你看身份证。至于狼群？真的，好多年没听见过了，如果遇上，且他们只有你这一块肉的话，就看造化了。事实上，这么多年来，鲜有狼伤人的事件。但这么多年来，恐狼的流言依旧漫天飞，尤其是新藏线上。 此行与狼最近的一次，小沟遭遇，无一点过激反应【棕熊】这家伙伤人是真的，每年在昆仑山北麓的新疆地区和藏北草原上，都会发生几起熊伤人甚至致死事件。不仅如此，熊还会袭击你家房子，用板砖拍碎你家玻璃，偷吃你家羊……以至于，在藏北有些县区有种补贴，就是熊给牧民造成的破坏政府买单，不允许你致命反击，除非人身危险了。曾经有一个牧民教我防熊术，就是捡一根棍子给熊吃，熊以为是你的手，咬了一口棍子觉得不好吃就走了。听完我笑的把糌粑喷出来，即使此计可行，在藏北荒原上找根棍子的难度比中彩票都高。熊是杂食动物，对人肉是不感兴趣的，很多熊致人死伤事件中并没发现肉被吃了，纯一个开瓢玩。那熊为什么伤人了？答案是生态冲突，牧民侵犯了熊的生存领地，长期摩擦导致。另外熊的智商很高，他也可能认为偷吃羊圈里的羊比抓鼠兔轻松多了。此次旅行遇熊五次，有两次距离特别近，其中还和一只同走了一段路，就像约好了散步似的，没有想象的那么可怕。与遇狼一样不要后退、不要恐惧。把熊惹火了，他的冲刺时速是40公里，你能在海拔5000米的高原跑过他吗？但另外一种情形就很危险，就是遭遇战，被恐惧激活的绝地反击是停不住的，不是你死就是我活。去年有次急转山谷，忽然撞见前面一头熊，他也吓一跳，竟直立起来双手挥舞口中嗷嗷。我坐在地上不理他，不回应，他嗷几下就跑了。羌塘深阔，绝对不会发生贴面遭遇战，假使了，看造化。（熊的嗅觉极为灵敏，所以个人比较坚定的认为至少在深阔羌塘是不会贴面遭遇的。） 此行与熊最近的一次，他后来混入野牦牛群中不见了，还找了他一会，奇怪 关于野生动物（下）申明：个人体会，非书本，仅参考。【野牦牛】鉴于他以往业绩，把他列为替补野兽。对他的描述“D10”天帖子里有，不再叨叨。 此行与孤牛相持最滑稽的一次，遭遇型，他无警示动作，我坐下他就坐，我往前他就站，不知脑子里琢磨啥【乌鸦】把乌鸦列为替补野兽是因为当你昏倒在荒原中的时候，第一个吃你肉的绝对是他。羌塘里的乌鸦不似内地，它们体型如鹰，飞过头顶时似乌云掠过。它们是食腐动物，但更渴望鲜肉，曾有牧区婴儿被它残忍叼死过，而葬送它嘴下的羊羔不计其数。曾有牧民问我索要鞭炮，目的就是要吓走偷吃羊羔的乌鸦。（神鸟，不能搞死。）防范乌鸦很简单，永远保持自己的斗志，不要在荒原里倒下。 去年照片，一次小憩，乌鸦就落在旁边守着，打错算盘了【此行防范措施】在界山达坂遇到官兵时，他们就用野兽吓唬我，并问我是否带了电击器？若知道我一个人进无人区估计得搜身有无带枪。我的防卫装备只带了鞭炮和辣椒水，实际使用情况是一次也没用。鞭炮过河时打湿了仍了，辣椒水都没打开过。（注：不到万不得已不要使用辣椒水防卫，因为野兽大多靠嗅觉搏生，嗅觉毁了就等于要他命了。）晚上宿营没考虑过防范，觉得实在没有必要。白天遇野兽连贴身小刀也没摸过，徒步探路时基本无防范。羌塘真的很大，有什么东西早发现了。另外，离发情期的野兽越远越好，发情期的兔子都咬人。如果棕熊、野牦牛之类的攻击你恐怕带枪也不行，所以说心态最重要。闲扯一句，比野兽厉害的是狗，被藏狗追过，被发情狗扑过，被十来条土狗围了一晚上……防范狗更实用些。再申明：上述经验只限于羌塘环境。防范野兽越周全越好，不能逞强斗勇。 D12（5-01），23.8K，宿营5117M今天是五一劳动节，一直走在地图上已消失的湖区。湖盆平坦而坚硬，所以今天推行距离超过了20公里，算是羌塘对我五一节的奖励吧。十二点过后天空阴沉起来，大风随行。自昨天过了月牙湖，之后一直到羊湖，期间路上再无大湖（将从碱水湖和拜惹布错中间走），连轻度的盐碱水都没了，所以特别留意寻水，随时补充水袋。途中倒是有几个很小的海子，均是盐碱水洼地，水极浅，淹不过半指，上面托着一层盐冰混合状的硬壳，走近可明显闻到一股腐臭的味道，毒水也。此类型海子的岸边是一片软泥，很难接近，没有丝毫冻土形象。将近六点半才在一条土沟里发现一处雪锥，也是今天唯一可利用的水源。雪锥附近地表融有一层薄水，薄水不仅捞不起来且被地面盐碱渍严重污染。雪锥是未化厚雪，在大风的吹打下呈尖锥状，雪质干硬，充满小孔隙，貌似冰。碾碎了几根雪锥装进水袋，今晚的饮用水解决了。此处雪锥是今天荒原中的唯一，它未消融的原因是下方土壤里含有大量地下水凝结成的冰块，起到了冰箱效果。晚上大风，帐篷抖动的巨响让人受不了。小型单人帐的好处就是只要帐内有人就不会被吹走，但搭帐篷时要极小心，每个步骤都不能大意，先前搭帐时一不注意，大风将帐篷吹走，似个大灯笼在地面滚动……把帐篷追回来时，那个累。靠帐钉完全固定帐篷是不可能的，小帐篷的地钉在大风天气里只是一种摆设。23点开始下雪，先伴着呼啸的西风，后只有安静的雪花纷落在帐篷上，终于可以安静的睡去。 平坦的古湖盆，为今天行距超二十公里立下汗马功劳 途中洼处的小海子，超重矿，极毒水 雪锥，今天唯一可利用的水源 D13（5-02），0K，宿营5117M早晨醒来，掀开帐篷一看，这雪大的完全是羌塘强迫我五一节休假。睡了个小懒觉便出去踏雪寻踪，一些羚羊群映入眼帘，他们很容易发现，在雪地里似一条黑线分外明显。取了相机追拍去了，无奈他们始终和我保持着相当长的距离，是一群受孕的母藏羚羊，本能防护吧。水是不缺了，雪水是极品，问题是非常耗费汽油。此行带了8.6升93号汽油，油炉是多啦的MSR耳语，大锅1.5升，主要是烧水用，经过几天下来的实测，烧水需时如下：液体水，早晨要用16分钟烧开，晚上则快些，14-15钟的样子。化冰35-40分钟左右，化雪耗时最长，45-50分钟。化雪极耗汽油，所以在雪和轻度盐碱水同存的情况下，我多数会选择后者作为水源。躺在帐篷里听歌，边抽着烟，边注视着经过帐篷外的越来越多的藏羚羊群。因为天气很冷，所以进羌塘以来一直都是穿着鞋子进出帐篷，趁着好天气晒了下郁闷的脚丫子。手上出现了三个裂口，脚掌上有一个，裂口有四厘米长，看着很恐怖，其实一点感觉都没有。脚趾有一半磨透皮了，有针痛感。取出药品袋发现只带了四片创可贴，严重失误。手指关节处的裂口自有了后就再也没有愈合过，直到出了无人区，几十天里总觉得手指随时会掉下来。其余的裂开不知不觉就好了，然后其他地方新裂口出来，周而复始。裂口产生和干冷天气、缺少维生素有关。雪消失的很快，这是此季羌塘特有的现象，由于湿度低，太阳辐射高，雪会很快被蒸发，蒸发的速度远大于雪自身融化的速度，所以雪消失后的地面还是干透透的。（这也是羌塘雪线特别高的原因。）一般情况下，雪会在下午两三点后蒸发的只剩下2/5了，小块地面路出，到了第二天就完全可以行路了，第三天只有些阴坡、沟壑、潜冰上会存有些小块雪。所以，一场大雪可以维持三天饮用水。一个后驮包裂开了，DEUTER最贵的一款防水驮包，关于驮包的问题日后详说。 大雪覆地，今天是走不了了 听着音乐，抽着小烟，暂且还有愉悦的心情 迁徙的母藏羚羊，估计是去黑石北湖方向集中生育 雪水是极品，但太消耗汽油 天气尚很冷，一直穿着鞋子进出帐篷 逐渐被蒸发的大雪 防水驮包这么快就不防水了，更担心的是他彻底脱线 最坚持的裂口之一，两个来月不愈（DV拍）谢谢骑士追贴，月华与你。由于单人所以自己的照片很少。带了线控和遥控，线控拍星轨用，遥控自拍，两个都没用过一次，白带了。用DV自拍了些。上了张“裂口”照片，有人背景，勉强入眼。今天估计不更新了，写字挺累，还消耗香烟。关于食物装备总重在200斤左右，包含车子本身。其中食物总计100斤左右，分列如下。主食：糌粑50斤（丢弃一斤），压缩饼干25斤。辅食：大蒜4.5斤（腐烂半斤），酥油4斤，花生米4斤，盐2斤，麦片2斤（丢弃一斤），紫菜1.5斤，辣椒粉1.5斤，奶粉1斤，白糖1斤，茶叶1斤，巧克力0.5斤，虾皮0.5斤，调料包0.5斤。食物以糌粑和压缩饼干为主，零食可忽略不计。在羌塘大体力环境下，每日摄取热量至少应在5000大卡，显然食物携带量要达到这一指标是不可能的。上世纪早期以斯文赫定为代表的西方人首次触及这片神秘疆域，虽然他们带了大批活羊鸡什么的，但捕猎还是非常重要的补给手段，那时野生动物太多了，也没有现在的动物保护观念。能坚持就不要打动物的主意，再则一个人在没有机动装备情况下猎杀动物是非常难的，没有想的那么浪漫。言归正传，本次旅行每天摄取食物热量有如下四个阶段。一、克制期，前45天里每天摄取热量在1400大卡左右，大致4两糌粑和2.5两压缩饼干，一些汤料为辅。摄取热量属于中度饥俄状态，下午四点以后基本就无力了。此阶段食物控制的极为严格，以至于45天里消耗的主食才30斤（另有三天意外补给，后文详述）。二、提升期，由于前期食物控制非常成功，所以总行程过3/5，食物却消耗2/5，因此每日口粮提升至5两糌粑和3.75两压缩饼干。但仅一周后，食物就完全失控了。三、失控期，从第52天开始，食物完全失控，原因既有生理上的需求，也有精神上的欲望，每天夜不能寐，脑海中总是一幅山珍海味的蜃景。控制力低下时，干吃糌粑粉都能吃掉半斤，如零食般。四、超控期，第64天开始至74天遇人救助，每天食物热量摄取不足800大卡，少于身体基本代谢量。从食物种类上可以看出，为了控制负重，食物以热量转换效率高的碳水化合物为主。零食基本没有，花生米都觉得不该带，因为后期会控制不住，花生米会被当做美食很快消耗掉。全程无肉，吃过一次蔬菜，微量元素靠金施尔康。没有动物脂肪的缺点是，抗寒力和身体耐力会下降，例如生活在北极圈的爱斯基摩人，不吃肉是没法长久活下去的。水，始终是个大问题，期间断水多次。后期虽雨季水多，河系泛滥，但水质多混杂不堪，时而无奈。纵观全程，饮用清洁地表水的天数约占20%，融雪和矿水（包括轻度盐碱水、泥沙水等）各占40%。可见若无雪则命不保，当然轻度盐碱水喝多了麻烦是非常大的，后文详述。 标准早晚餐，糌粑+辣椒+大蒜（借用去年照片） 自制辣椒酱，不带成品辣椒酱进无人区，重量大，辣椒粉自制重量比高（借用去年照片） D14（5-03），25.2K，宿营5118M通过坐标确定了今天日出时间，八点十分（时差比北京时间晚两个小时左右，前期日出在八点左右，后期稳定在七点四十分左右），目地就是要感受下清晨低温，羌塘一天气温最低时刻是日出前半小时内。自离开硬路每天均速才16公里，而我必须要达到均速20公里才有可能完成计划中的旅行，否则……加上大雪封路、地况特糟、生病、洪水、偷懒睡大觉等突发事件，所以每天行距尽量超过20公里才行。根据去年经验，均速20公里是很难达到的，推行不仅比徒步慢的多，还对地况严苛。唯一解决的办法就是早起，在冻土最甚的时候多赶些路。羌塘早起是很痛苦的事情，蚁力神，谁吃谁知道。前几天都是等太阳先起我才起，然后烧水、晾装备、收拾打包等琐碎，实际上路时间都十点多了。帐内温度－11℃，外面－16℃，无风，没有想象的冷。一番折腾后9.37分正式上路。虽只比以往早走半小时多些，但地面感觉却好的太多，加上今天红土居多、大雪湿气，地面冻的更硬，仅三个小时，推行距离就有12公里，将近当天一半路程。羌塘日照时间长，剩下的一半路就是慢慢耗，能走多少是多少，一般耗到下午八点左右扎营。当天8.49分扎营，行距25.2公里，等于后面八个多小时耗十三公里。重装推行是徒步者难以感同身受的。我也有过多次极限徒步经历，那种煎熬远没法跟推车比（大负重除外）。早起痛苦最大表现在呼吸道上，大运动大呼吸量，使得更多冷空气进入体腔，有如一根冰凌直接插进气管直触胃部，鼻涕哗啦啦的。口罩？有经验者会明白为什么不戴口罩，不多说。下午六点进入稀疏的草地，彻底绕出湖盆，部分地面稍融，大雪还是有些影响，地面看似干燥，但轮胎一过就沾满泥沙，卡死轮胎。最后选择一处坡地扎营，因为这里的野生动物很多，藏羚羊、野驴、野牦牛都有，人多热闹。 羌塘一天温度最低时刻在日出前一秒 早行半小时，地面的硬度就有明显的差距 今天藏羚羊很多，却很难发现，片雪白云混淆，动物草色相近 稀疏的草地，土质很粘，看似干燥 轮胎时被卡死，沙土并不烂，却是粘性十足 当天宿营地，附近野生动物多，热闹，近九点的光景，相当于北京时间七点 帐篷坡顶慢悠悠掠过的羚羊，好奇的会瞥上一眼 D15（5-04），26.2K，宿营5011M今天是个小节点，之后日子只要天气不特殊，早起时间都将比太阳公公早半小时，尽量早行，充分利用冻土硬度。因此晾装备也取消了，好在丁丁的防水睡袋非常好，但里面的湿气却没了时间排除，明显重了一些。因为今行又比昨日提前半小时多，那地面硬的居然可以小骑一段，小骑绝对指下坡，丘陵地貌，但前货架在颠簸下会松脱。最郁闷的是清水鼻涕，如滔滔江水绵延不绝，黏在胸襟上不久即冰。当下午开始留意片雪时竟无发现，茫茫大地真绝情。一直推行太阳快下山才在一处坡顶发现一米见方的积雪，缘分。扎营时间常态下不会在太阳下山以后，太冷，光线也不利于观察地貌。今天比较累，时间长，翻了不知几个大坡，铲雪融水也折腾了一番。晚上第一次用了湿巾，擦脚，脚是荒原旅行的命根子。 中途一处特殊地貌，山坡上突兀着众多城垛模样的沙石堆，查看确是自然形成 前日大雪融的难见踪迹，茫茫荒原真绝情 光线作画，绚烂的黄昏，绚烂的大地 营地不远的坡上有一片小积雪 烧水空隙，掀开帐篷，拍了这张火烧云 D16（5-05），19.5K，宿营5033M今天起的更早，这两天十分干冷，帐内都在－10℃上，怕赖床，定了两个闹钟。今天按地图线路指示从碱水湖和拜惹布错之间插到羊湖方向。实测地形才知两湖由此起彼伏的山坡阻隔。通往两湖之间的路极为荒凉，死寂，动物不见一个，少见。地软，今天在路上耗了十三个小时居然差0.5公里到20，略郁闷。下午三四点的样子在左手山坡上又发现个大地三角点，决定爬上去瞧瞧。爬山俨然是种休息方式，挣脱桎梏的鸟儿，桎梏就是看一眼仇恨一眼的自行车。铁塔下零散着许多罐头皮，烧得黑黑，里面充满沙土，或许是当年架铁塔的解放军留下的。铁架顶端有个大鸟窝，毫无疑问是乌鸦的闺房。在羌塘，荒芜是主题，却时时有如幻境，那些野生动物不真实的存在着。尤其有一种叫“哦哦”的小鸟，近乎每天都能听见他们在帐篷外叫床，只两个旋律，“哦-哦”，“哦哦”比麻雀还小，多成双成对。所以，当看见这个鸟窝时我就想起“哦哦”，他们如何在恶劣的羌塘生存，晚上又栖息何处？要知道，羌塘没有一棵树，超过膝盖的草也找不出几根。“哦哦”带给了我太多的感悟，每天听着他们的叫声，开始着一天的旅行。虽从两湖之间经过，却不见真容，在铁塔坡上北望才勉强看见白乎乎的碱水湖。而失落的是水，一路连个雪影都不见，倒是白色的盐碱骗的我几次枉寻一番。到了天黑才扎营，水袋里还剩一点水，没喝没吃，留着明天早晨用。昏暗的光线中，忽然发现对面半坡上有一只健壮的藏羚羊，且是此行首见的公藏羚羊，所以格外注意。他威武的伫立着，一动不动的注视着我，心理素质之强在羚羊界少有的。相视一会，两只母藏羚羊出现在公的身后，稍有不安的游移，公藏羚羊依旧，气势逼人。我似有明白，这是发情期的羚羊在保护爱妾。刚想入睡，大风四起，夹杂着雪花，雪不大，难以估算落到够我融雪的厚度需要几时。没去理睬，抽了根烟，最后一根烟，抽到很细心，然后在呼啸的风中沉眠。 位于碱水湖和拜惹布错之间的三角点，顶端有一个大鸟窝 坡顶北望碱水湖，隐约白乎乎 入睡前风雪起，但要积到融水的厚度尚早，今夜无水无食，抽掉最后一支烟 D17（5-06），28.9K，宿营5003M早晨，雪还是极薄一层，用纸片轻轻的掠，好歹扫出一小堆雪，加上剩水够一顿饭用的了。查看地图时才注意，此点居然是我第二条备用逃命路线。第一条是克里雅山口，早过了。在已知的仅靠自力穿越记录中，没有人能超过此点，因为前方是更广阔的大羌塘无人区核心，前退都很尴尬。其北面的昆仑山脉有一条著名的库亚克大裂沟，约十五天时间可到达新疆的最近居民点。2002年美国人瑞克·瑞吉韦等四人便是遵循此路线进入新疆。所以这个点是道坎，过了这个点后最近的逃生点也得一个月以上。我自省一番，觉得状态不上不下，很中庸，就像平日的某个清晨，毫无思绪的开始无聊一天。算是尚可吧，继续往前，就这么不小心人类第一次靠自力横穿羌塘。横穿路径一直贴着新疆和西藏的分界线，巍巍昆仑一直横亘在北方天际。过了碱水湖，昆仑山北弧，此后再难相见。晨温比昨天高三度，地很硬，出门就是一个大下坡，两小时追掉十公里，超爽，然后进入一片边际难寻的古湖床。十一点的时候来到“陷车点”坐标，这是一条连接碱水湖和拜惹布错之间的河，2003年由一支记者组成的汽车穿越队陷在此河，通过卫星电话向新疆军区求援，后被西藏方面救出。此时，宽阔河道近乎干涸，只有东侧边缘有一条三米宽的水道支撑着。水质很差，强碱水，味如漂白水，连冰也是苦涩不已。奇迹在一条浅埂上，居然有一片积雪，在水袋里先装了一点碱水，然后装雪，让之一点点融化。继续湖床，平坦而坚硬，阳光炙烤，迷迷糊糊的推车，速度竟也极快，类似一种催眠状态。下午云会从西方天际涌起，向东方漂移，一朵朵的偶尔遮蔽。云遮时，拉上拉链，云过时，打开拉链，羌塘的温度变化一朵云都能极大的左右。下午发现一块“大地水准点”，依旧是当年测绘兵所留。七点才走出湖床，上了稀疏的沙草地，一片野草豁然眼前，终于再见生的气息。 过河小麻烦，内有沟壑，软沙陷住， 漫无边际的平坦湖床，一种催眠状态推行 水准点，向当年的测绘兵致敬 终见生的气息，虽然沙草地极难行走 D18（5-07），25.7K，宿营4974M今天翻越碎石山，海拔不高，山势少有极陡处，碎石铺地，路面较硬，近二十公里上坡，下午六点抵达山口，用了九小时，后急速下山六公里。在山口北眺可见昆仑山系，已是极远了，之后日子难再见昆仑。后驮包又涨开一大口，用帐篷胶布勉强粘了下，再用4毫米登山辅绳捆束，否则驮包命不久矣。另两个DEUTER驮包一个背板被货架磨破，一个横杆处裂开。还有一个廉价的DOITE驮包，车友用的比较多，去年走羌塘用的，补了今年丢失的DEUTER驮包。DOITE驮包多天前就断了一个卡扣，一直用绳子挂在货架上，全程再无故障。不得不提DOITE驮包，除了卡口外，质量非常好，其实比昂贵的防水驮包更适于恶劣的羌塘环境。苦恼还是水，以为碎石山上沟壑里会有些残冰，却是碎石一片，燥风猎猎。六点在山口放眼前方，天空阴霾，风暴云游荡，山脚不远处有一个白色的湖泊，便锁定方位，抄直线下山奔去，看似咫尺，遥不可及。干涸的河道里发现一丝水痕，薄的用嘴也吸不起来，且是极碱水。又是一个奇迹，居然捡到两瓶矿泉水，生产日期3.15号，我怀疑是不是早前有探矿的深入羊湖一带，至少不会是近18天留下的，一路独我，又或许是方向一致路线有别绕到了我的前面？顾不得想那么多了。八点半大风，且风向乱了，西方急转东风，黑云压顶。赶紧扎帐，手忙脚乱，地钉被吹起的帐篷弹走一根，此时才发现没有一根多余的了（好像总共有10/11根地钉，记不清了），这些天都被吹走了，竟无留心。只好一番细找，把先前吹走的地钉找到，一共就剩七根了，少一根都无法基本稳住帐篷。此后，这七根地钉宝贝似的，就是被风吹到天涯海角也要找回。再前后陆续，帐篷袋、地钉袋、帐杆袋、地布皆被风挟至荒野，消失的了无踪迹。此说HW1.5层单人帐，由于设计问题市面上基本买不到，然而却是最适用羌塘穿越的，这个结果是考察了所有国外国内品牌单人帐中偶然发现的，700（或是670，记不清了）银子进货，物美价廉。另说，今天营地4974米，十八天来首次下海拔5000米。想念山上看见的湖，明天上午就可到达。 载物太重，驮包撑开 北眺昆仑，隐约一道雪山便是，与他越行越远 碎石山典型地貌 山顶平缓，小坡连绵，难以确定主山口 放眼前方，风云四起为什么称这张龙卷风照片罕见，因为是一种龙吸水模式，顶端盘旋着不断壮大的云团。很幸运，遇上。羌塘，气候的变化有时是超越想象的。羌塘腹地我是难以到达了，看了丁丁的穿越日记，对比楼主前17日的行程，可以对羌塘简单遐想一下。羌塘西部由于高寒干燥，植被稀少，野生动物也相对较少，而羌塘与可可西里接壤的东段植被以及动植物都较丰富（从丁丁他们如此频繁与熊、野牦牛遭遇可见一斑），对否，望楼主指正！！羌塘东西南北野生动物都是多的，没有孰轻孰重，只有人进动物则退的区别，唯有中间一块稍微少些，因深受西风环流带影响，印度洋和太平洋暖湿气流也皆难到达，所以常年寒旱，被地质学家称为“亚洲寒旱中心”。但羌塘又是幻觉的，“寒旱中心”仅四五日动物罕见外还是很多，尤其狼。明日就见了一群规模较大的迁徙藏羚羊种群。前十七日动物还是非常多，经常和羚羊野牦牛头碰头，只是见多不怪了，不再描述。同时，遇见野生动物也是机遇，阿尔金路线也涉及，我却没一天见六熊。相比较来说，野生动物最密集的地方是若拉错，多到有如牧场，这与季节也有关系，春天来了，山上的下来了，躲在被窝里的出来了。闲扯，中国对羌塘的长期深入考察是极其缺乏的，更别说什么动物专项了，科学家的深入还没有盗猎者的零头多，包括此行也是走马观花，见到的成了数据，没见到的便是零，不能成为体系，只是个人感受而已。 D19（5-08），23.5K，宿营4942M昨天下午在碎石山上看见了日冕，晨起果然大风，下午五点，狂劲北风夹杂着小冰雹把左脸都快要打烂了。风暴持续一个小时后停歇，风没了先前的张狂，蓝色天空也显露不少。推行不久便在一条沟里遇狼，先是一只狼从前方沿着土埂小跑。又觉得眼花，田埂后有一黑物闪烁，果然也是只狼，便盯着隐狼看他去向。隐狼完全现身一会后又不见了，再看前狼朝我直奔而来。我靠着车子密切注视，他开始时而横切时而直行时而扑腾，慢慢接近。心里略有紧张，或许是激动，此行首次遇狼。回头查看退路，以便紧急之需。却见另只狼像尊罗汉似的蹲着，没有理睬他，他的行动受前狼操控，只要和前狼关系搞好即可。僵持了十多分钟，前狼也没再敢靠近，左右徘徊着。受缺水影响，又这么僵持着，心里极郁闷，朝狼呵斥起来，什么两块肉过来啊，爷正缺吃的之类的。前狼一顿，后退两步，随后和后狼汇合从土埂后面远去了。相比狗，喜欢狼，不干你时绝不吭声，干你时绝对血盆大口，哪像狗，汪汪个不停，虚张声势。下午一点才到昨日看见的湖，不看不知道，一看气死人，这水毒的远离水域就扑鼻一股恶臭，令人窒息，白色部分也非冰雪。奇在湖边生长着一些腌菜似的植物，也是臭气弥漫。再远些的干燥地方布满鼠洞，地面点缀着稀疏的针茅草，还二度发现甲虫。这种不可思议的生态关系令人费解。下午一场大风暴停了不久发现一根木桩，估计下面埋着水准点，木桩是地面标记。水，水，水，一天不见。 狼，欣赏，不乱叫，一叫定血腥 来到昨日山口看见的白湖,腐臭扑鼻而来 甲虫 鼠洞，白色是盐碱，很难想象这是一种怎样生态关系 水准点上木桩标记 D20（5-09），35.5K，宿营4905M八点出头就出发，急需找水，所以使足力气快行。途中被白色盐碱骗了多次，最郁闷下了一条大沟，回途纠结，受侥幸心理驱使的频率过高了。 九点半的时候遇见一群规模较大的藏羚羊群，雌性，可能是前往昆仑山某个未知湖泊集中生育。羊群不怎么怕人，慢悠悠在前面横切，避免打扰，我放倒车子让他们先行。近十二点，发现一块平滑的黄地，干硬了得，如岩石般，其小沟壑里居然藏有一层薄雪，喜出望外。雪薄，选些稍厚的用手指轻掠。雪的密度很低，又非冰体，所以扒遍沟壑约取了一升的水，解了燃眉之急。因一路下坡至羊湖湖盆，便想再拼一天多赶些路，早遇水。水不见一滴，天色却大变，近八点扎营。吃了一块压缩饼干，喝了点水底子，浑身无力。天黑时风雪四起，把帐篷吹的稀里哗啦，我也懒得等雪，便睡下。约十点，忽然听见有人唤“英雄……”疑似幻觉，风声作祟，可“英雄……”越发明晰。扭过头看见一丝微光，打开帐篷，天啊，居然一辆越野车停在外面……司机透过车窗兴奋的说，在饮水河迷路，然后回铅锌矿问路，矿上人说有一人骑车进了羌塘，不知去哪里了，他便跟着我的车印子一路追踪至此。而他们进入羌塘是因为一辆大车坏在前面，去修车的……由于风雪飘摇，寒风刺骨，简单交流了两分钟，他们便赶路去，说明天能遇上。临走前我讨了瓶矿泉水，一口气喝完。然后半夜难眠，既兴奋，明天可遇人，说不定能吃顿热饭，又紧张，不知他们是什么人……但至少不是坏人，又觉梦幻，看看矿泉水瓶确实无疑。另一说，矿上人说看见我，还劝我不要前行是胡诌的。估计第一天在羊圈休息时，夜晚开车经过看见我靠在外面的自行车，随后又发现车印拐向深处，才确定有人进去了。去年我和流虻、多啦两伙皆遇矿人，他们俩甚至错路骑到矿上，因此矿人有了前事可签。 途中所遇一群较大的羚羊群，通常，百只就是大群 经过一硬地，沟壑中发现今日之水，左下可不是兽迹 D21（5-10），20.6K，宿营4809M大早起，奔向热饭。昨夜雪不厚，中午即化的差不多了，再则也顾不了这么多了。一路下坡，页岩地面，虽对昨夜之人不甚了解，但在这无人区深处遇人总是梦幻之事，脑海里也早已勾勒出一幅豪华营地、肉香汤热的美景，所以趁坡势强行骑车，一不留神车被片岩爆胎。近五点来到传说中的英雄地，这是上世纪七十年代三大军区联合测绘会师的地方，因而取名英雄地。八十年代，中科院考察队曾横穿至此，因前路恶劣折返，直到本世纪初，中科院与商业联姻，才对羌塘进行了连续三年的大规模科考，羊湖便是最后一条科考线路。近七点到达羊湖西侧，风暴中终于看见昨夜之车缓缓开来，后一辆卡车，共四人。昨夜说话之人李哥随即给我一杯预备好的热咖啡，感动。大风，冷，车下寒暄片刻便挤上大车。他们极为热情，又狐疑满腹，说没见过这么玩法的，说我一个人肯定带了卫星电话，还检查了证件……而我只想着蹭些补给。大餐不见，豪华营地没有，总得有些香烟。他们也是麻烦一堆，补给不多，最后给了大约三天食物，些许蔬菜和水果，散烟合两包，馕等，见此，觉得自己从未如此富过。这就是前文所说，在前45天食物克制期里意外获得的三天补给。双方都很激动，但只聊了一会，他们便要赶路从界山大阪出无人区，临走再问“真不要跟车回去？”二十天来，奇迹遇人一小时，获三天补给，下次再遇奇迹是53天后了。恍然如梦，那夜羌塘风雪听见“英雄”的呼唤，今生难以忘却。就地扎营，水果狠吃一半，缓过神来，决定休息一天，太累了。 一夜风雪将帐篷吹的稀里哗啦 首爆胎 传说中的英雄地，会师情景，可以想象，他们才是英雄，后人按图索骥 D22（5-11），0K，宿营4809M有了额外三天补给，休息一天并不觉浪费了。两棵小卷心菜、两根小葫芦瓜，若干西红柿，个头还挺大，74天里唯一蔬菜，算上后期，将近80天了。依河，依湖，以为水不缺了，没想盐碱味甚重，可怜了蔬菜。更糟糕的是靠近水源是稀烂泥地，取水提心吊胆，而稍微洁净的冰又远离岸边。闲扯一句，盐水的冰是淡是咸？很多人困惑这个问题，答案是即不是淡水也不是咸水。冰是单晶体，理论上，一旦结冰就盐水分离了，但在实际中，冰体中含有大量盐泡及混杂物，所以他不咸不淡。下午准备把脏袜子洗掉，找水却是大问题，因为近不了水，稀烂，陷人，后找到远离水域的沟壑之水，同样稀烂不已，悲愤。下午做针线活，缝补裤子、羽绒服，裤子裂大口，是材料在恶劣气候下老化所致，后期更是溃烂的连犀利哥也不会瞧一眼。但还是得一针一线，不能马虎，为了减轻负重，我没带一条备用裤，连轻薄快干裤也没，包括鞋。现在回想，不可思议。湖边转了不少地方，但都不远，羊湖东面的独尖山清晰可见，他是羊湖的标志，谋杀了不少快门。晚上又狠吃一顿，撑得弯不了腰，幸福的再点支小烟。晚上变天，狂风大雪，估计明天走不了了。并不急，趁势好好休息。为了快速穿越寒旱带，多天来起得比太阳早，一天推行超过十二小时，休息时间超过五分钟就觉得是犯罪，再不缓口气迟早会跨的。身上已多处不适，尤其右腿，血痂已和内衣相连。上陡坡停顿时全靠右腿抵住脚踏不至下滑，久之便斑斑，刚结痂又被抵破，反反复复。而意外补给给了我一个难得喘息时刻，感恩。 比彩票概率还低的蔬菜，感恩 眺望羊湖东侧独尖山，羊湖标志，看山跑死马，还是很远 腿是陡坡的主力刹车，但不耐磨损 洗袜子的沟壑，岸边碱渍，貌似干硬，依然稀泥 这就是取水、洗袜子……遇水的代价，还不是好水 风雪再起，羌塘换了规律，夜必风雪 D23（5-12），0K，宿营4809M睡了懒觉，掀开帐篷，一片白茫茫，分不清湖与地，今天终于不需喝羊湖的水了。纠结的是，雪融，沙土粘性十足，一抬脚两斤泥，这不是一个好兆头。羌塘的年温差不大，日温差大，顷刻可冰雪，顷刻也可晒的人皮开肉绽。白天的绝对温度高，意味着冻土消融将提前。温度也不仅是温度表里的，他是一个多因素，受空气温度、湿度、光辐射、风速，四大因素结合才是一个真实的温度，体感温度，还得加上运动量。今天闲暇，做了个简单对比。下午两点时，测得帐篷里的温度居然高达32℃，裸浴都行，但到了有风的帐外还是得穿羽绒服。然后趁天气还不错，取了扳手弄货架，转瞬一朵大云遮天蔽日，风速加快，五分钟大概，我的手就冻麻木了，一不小心还伤了手，赶紧丢下扳手，跑到帐篷里避寒。纵观整个旅程，这种温度的体感差异就更大了，有时间再细说。 融雪，稀泥，水 也是错觉的地面，很是泥泞 风暴开始酝酿，半小时候，天色全变 D24（5-13），28.1K，宿营4805M八点半就出发，天寒地冻，原本想多赶些路，谁知在河湾里绕了四个小时才出来。早晨沿着地图上的河界走，尽头是一片湖滩挡道，四处探路，无法通行，逼近十一点，地面有些融化，一想起昨天一脚两斤泥的画面，头皮发酥。赶紧往回绕，选了一处稍硬河床强行推到对面山脚。山脚土质不似湖畔泥泞，却十分松软，一直耗到下午三点钟，才推行十公里。后面十八公里是个奇迹，源于羊湖北岸异常平整坚硬，多数可小骑。在羊湖岸边骑车的感觉非常美妙，湖水波澜，远山淡淡，风也知趣，此行最难忘的一段骑行。6.40分就停下了，一番游玩，登上了竖有铁塔的山坡，还发现了中科院考察队前几年竖立的“金字塔”。初见山坡上有道金光时，蓦地想起一位朋友，曾问我为何喜欢羌塘，我说火山多，有宝石，有金子……越近山顶，金光越闪，心想，莫非真是金子？果真带块金子回去，看你以后还敢说我吹牛。晚上扎营在湖边，全天吃馕，之后，再度自力更生。入黑，又如昨日狂风大雪，加固帐篷，这可是咫尺湖畔，好比玩火自焚。进入五月中旬，季风交替，羌塘深处或多或少受到影响，天气越发没了规律，已连续四个晚上风暴起。 羊湖北侧眺望羊湖标志 暮色羊湖 耸立羊湖岸边小山上的三角点 中科队的“金字塔”，只放字面，上有赞助单位，鼓励 D25（5-14），22.3K，宿营4867M破冰，水袋里打点盐水底，然后把雪压实一点点装入。雪装水袋个人体会，雪一定要压实，手指捏成团，要有挤出水的感觉。新雪、风化雪、粉雪密度皆很低，只有水的十几分之一，若不压实，即便水袋装满，小口水矣。苦的是手，压实两升雪就会冻僵，但值得。二是水袋里打点液体水做底，会利于雪融化。若是轻度盐碱水，被冰雪稀释后也会好很多，另外盐碱水冰点低，比净水更利于冰雪融。三是就寝前将水袋放在头部垫子下，既做了枕头，也保温了，否则翌日定是冰坨一块，浪费汽油还不算，问题是根本倒不出冰来。今天直奔独尖山，那年科考志愿者称之鹰嘴山，地图上，独尖山。据说山顶确有鹰窝，或者鸦居？天气差，大风，时而冰雹。又是傍晚时分，风速骤然增剧，密集雪子遮蔽视野，能见度数米。此般天气，皆顺风放倒自行车，蜷缩在包后。趁风雪小了些，赶紧扎营，生怕更猛烈的下一波。果然如此，搭好帐篷，按了两下快门，这天就完全黑压压起来，连续第五天风暴。 晨，冰雪羊湖 近瞧独尖山 趁风暴暂缓，赶紧扎营，地上非雪，是冰雹，雪的前奏 D26（5-15），31.3K，宿营4903M今天的状态超常，大雪涌进帐篷，雪漫四处。路硬，红土面，抖抖鞋子里的雪就穿上走人，也没吃饭，准备待到土软之后才吃。时间就是效率，适用于羌塘。雪一直到下午两点才化掉大半，路也神奇的这才干软，一点不湿，雪留无痕，极不真实，数小时前还是一片白茫茫。草地上残雪与白云恍惚，美，却极易视觉疲劳，迷了天空与大地。吃饭时选择一处羚羊多的地方，边吃边看，藏羚羊初始有些羞怯，慢慢的也就放松警惕，认为我不是披着羊皮的狼，靠得近了些。公藏羚羊终于回归草原，还夹杂着母藏羚羊。此季尚是生育季节，母藏羚羊应在别处做月子，为何公母混群了？这点，看的有些不明白。或者，羊们也有羊的私生活，人类并不知晓全部秘密。还疑惑的是，羊湖东侧与西侧地域环境雷同，为何野生动物一夜间冒出似的，星星点点在草原随处。或许，节气就差那么一天，局面就大不相同，或许，巧合，缘分。下一坐标，耸峙岭雪山，凡向雪山行，皆有沟槽循。天高云阔，望山而去，意识似乎先行到达了。 风雪涌进帐篷，无暇顾及，抖掉鞋子里雪，饭也不吃，去响应时间就是效率 残雪与低矮白云，时常混淆 天高云阔，意识似已先行到达了 公藏羚羊回归草原，其实先前也是在草原 D27（5-16），23.8K，宿营5145M通往耸峙岭雪山，缓上缓下，是一片稀疏的草地丘陵。耸峙岭海拔6370米，是重要的地理分界点，他便是可可西里山脉西部源头。是的，同学们，我们进入了可可西里，欢呼吧。行政上的可可西里保护区只是可可西里的一小部分，人为的划分。国家在划分这片广袤荒原时以省界为界，分为了西藏羌塘保护区、新疆阿尔金山保护区、新疆昆仑山保护区、青海可可西里保护区。实际上，长达四百余公里的可可西里山脉绝大部分在西藏境内，包括主峰岗扎日。同时，耸峙岭雪山也是此行的一个重要里程碑，前27天依偎昆仑山脉一路向东，后27天则依偎可可西里山脉一路向东，直至到主峰岗扎日后转向北方，再二十多天纵向翻越可可西里山脉与昆仑山脉……“可可西里”是蒙语，意为“青色山梁”，过几日后，可可西里山梁之态才会完全显露，青色则因人而异了。下午六点多上到耸峙岭雪山下的一片雪原，硬雪壳，块状分布，间隙生有凄凄黄草，冷。雪壳很难推行，他无冰的硬度却有冰的分层特质，所以轮胎很容易压碎雪壳，再一点点破雪推行。几度欲放弃，待到明日晨行，想必雪壳会硬很多。探路过程中却有了惊人发现，在一条宽阔的河床里居然有一条清冽溪水，天啊，这是二十一天来首次见到的可直接饮用的地表水，简直乐疯了，想着今天无论如何也得把自行车推此扎营。先前，就确定了会经过雪山下面的伏沙河和降龙河，但并不认为能遇水。一路行来，地图上标示的河流此季中无一不干涸。实际上，明后天的伏沙河和降龙河确实无水，却没想到在一条地图上无标示的河里居然有溪水。搭好帐篷去打水，溪流表面已结了薄冰，破之取水，格外酷寒，水杯捞起转瞬间杯壁上便结了冰。手冷的不行，几秒就冻僵，换只手取水，反复。一边烧着清冽的溪水，一边欣赏着金色夕阳，一地碎金，铺垫在荒原上，这种金色不是形容词。遗憾的是，我们永远无法拍出金色的赐予者太阳，在羌塘，即便太阳落得只剩一个边角，依然刺眼的不会与众生对视。 耸峙岭雪山下的雪原，上一层硬雪壳 终见洁水，举国欢庆 金色夕阳，羌塘的颜色，碎金一地 在羌塘，即便太阳落得只剩一个边角，依然刺眼的不会与众生对视 D28（5-17），0K，宿营5145M耸峙岭雪山有太多含义，他不仅是地理界点，里程碑，水圣地，同时也是我生理上一个转折点。昨夜，沿袭往日，入夜后不久风雪袭来。深夜，风雪停了，而我糟糕的身体感觉却愈发加剧。大约凌晨三点，实在无法控制，披上衣服钻出帐篷，蹲在雪地里一通狂拉，瑟瑟仰望，也是此行第一次欣赏羌塘星空。要知道，羌塘的夜有多寒，晚上钻进帐篷后打死也是不会出来的，所以原本带了个线控拍星轨，不仅一次未用，就连星空也不多见。纵观全程，若不是三次因恙夜起，羌塘星空哪能相见。星空我划为三等，一是黯淡星空，世界大多地方可见。二是灿烂星空，只有偏僻荒野可见。三是水波星空，星辰点缀在片片光芒中，如水波荡漾，在极高山巅可见，高域羌塘却是寻常。晨醒，身体依然难受的不行，胃绞，无力，恶心，反酸，臭屁。实在起不来，病躺一天。这种症状即不是拉肚子也不是胃病和发热，我也只得过一次，便是去年羌塘之旅。所不同的是，去年是即出羌塘所得，很快调理了过来。而此次症状居然一连50天（除了断水两天），直至出了无人区就蓦然好了，不打针不吃药。症状后续平缓下来的反应是：每天平均拉三次肚子，饭后十分钟后定是反胃，一股股酸味，然后放屁不断，也是酸味，不怕笑话，一天数百屁算是少的。身体其他方面倒无大碍，偶尔胃难受一会。所以，之后，在羌塘里一连拉了50天肚子，出来即好，兴奋的发短息给一个朋友说“昨天终于硬了”。心情很是沮丧，又耽搁一天，我已经停不下来了，原地踏步是一种煎熬。好在下午一对狼探望，依旧，一只在帐篷前面，一只在帐篷后面，前面的狼折腾一番后，居然匍匐在地，用下巴蹭着地面玩，翻滚，耍泼，再静坐……如此一小时，后汇聚走向耸峙岭雪山深处。 抽空，晾装备，电池充电…… 荒野来宾，相互守望谢谢各位，备受鼓舞。 D29（5-18），27.8K，宿营5020M昨夜，沿袭，连续十天夜风雪。身体还有些不适，今天反而行得早，无暇顾及。为了控制腹泻，晨晚皆没吃，全天靠中午两块压缩饼干，居然走了近三十公里，当天日记写下了个“牛”，自我鼓励。全程下坡为主，顺干硬河床，天气极好，我需要的干冷，羌塘很体恤民情。鞋面一处裂开，好在干雪难以快速渗透，抖抖即掉，但想着以后春暖花开……实在不敢想，得过且过。藏羚羊很多，已经分群，多十来只拉帮结伙，全公是黑社会，有母有幼是四世同堂。又遇狼，猥琐，想象着同一片草地上，狼和羊会演绎怎样的惊心动魄。是拔刀亮剑拼得你死我活，还是“嗨”一声，各奔前程？我的答案是后者情况居多，狼的速度比羚羊稍慢，好比夏利追QQ，这比搞只鼠兔来说难太多了。当下羌塘，的确是那些野兽的黄金时代，不愁吃不愁穿。太多了也不好，不够吃就相互残杀，高级灵长类动物已做了表率。十九点多，看见一座“城堡”，便想着那处扎营，赶了一个半小时，他只大了一点点，无力扎营。羌塘的距离很难测算，一是过于平面化，二是缺乏地标物，三是地貌变化小。会导致你把一个很近白色塑料桶看成遥远蒙古包，更会把一座山看成几根烟的功夫。更为麻烦的是地面辐射导致的光线抖动，视场紊乱（空气密度也会不同，光线折射），尤其烈阳下，稍远处的石头便会强烈抖动。白色盐碱辐射微波就更大了，即便用望远镜拉近也难以分辨，所以导致多次误冰雪跑冤枉路（某些时候是非常严重的后果，甚至致命的，D38天遭遇）。想体验这种辐射很简单，太阳最辣的中午，找一栋大楼，眼睛贴着墙壁，向上望去。所以，望远镜是羌塘旅行的重要装备，但使用他是个苦力活。我的是望远镜规格10×25，要端稳望远镜分辨出怀疑物是非常难的，长焦抖动，平面空间更被压缩，抖动中的抖动，这需要平抑呼吸，持稳，耳水平衡，心率……三五秒便会有头晕眼黑恶心的反应。即便如此，望远镜使用频率每天也要十几、几十次，谁知道土堆不是一处外星人古迹，谁又知道那块黑石不是撇大条的熊。 晨起（个人很喜欢的一张营地照） 上午雪，薄，密度高，很适宜推行 藏羚羊开始分群了，但似乎又早了些 D30（5-19），27.2K，宿营4972M夜风雪暂告段落，羌塘恢复规律。早起，跨上车，沿着冷透透、干硬硬、平缓缓的河床一路下溜，爽的脸都抽筋了，冷的。约八公里才到昨天看见的“城堡”，是一处风化土山。今天一路许多这种逼真拟物的风化地貌，有似房舍，有似羊圈……对于非专业人来说，把楼兰古城的残垣与之对比，绝对后者更牛更实体。下午，进入苦不堪言的沙草地，天气变的恶劣，狂风大作，沙尘四起，眼前一片昏黄，视野近零。是的，就是沙尘暴。测量，瞬间最高风速达到了27.8 m/s，接近十一级。不过，羌塘的沙尘暴不会持续太久，很快平息，只猎猎大风七级左右。顺风顺路，趁势推行，我负责扶稳车把掌握方向，风负责后面做苦力推车，瞬间大风时还会踉跄。口念金刚经，诸神佑我啊。另说羌塘风，常年大风，八级风天至少占全年天数1/4强。但风速不等于风压，风压通俗点说就是风的破坏力。风压受诸多因素左右，风速，温度、湿度、重力……但最大的因素是空气密度。所以，同等风速下，羌塘的风虽大，但实际破坏力是小的，八级大风简单换算下只相当于内地六级左右。若羌塘大风相当于内地大风，那草是长不出来的。再另说珠峰顶部大风也是如此，风的实际破坏力更小。踉跄，GPS支架摔断，晚上修理。水是冰，吃完饭，反完胃，然后拉完肚子才钻进睡袋，这寒夜，谁敢起来。 昨日看见的“城堡” 又一处风化地貌，羌塘很多，但今天密了些 很像围墙房舍，确实不是，我也希望发现石器时代的痕迹（那时羌塘温和，有祖先来过） 修理时间，各等螺丝 D31（5-20），16.5K，宿营4935M今天，极重的沙草地，一直大风，阴沉发灰的云，跟江南梅雨季似的。空气通透度极差，雾霭霭。下午五点后，大风忽然停歇，很奇异的感觉，荒野中静的只有呼吸和推车声，而云层却是越发浓稠暗灰。羌塘降雨主要受印度洋暖湿气流控制，加上先前东南风，让我觉得羌塘在酝酿一场强烈而持久的风雪。所以，短暂的静默期过后，大风冰雹席卷而来，我便以最快速度扎营，这可不是西风带控制的短暂风暴。判断错误，这风雪也就张扬了半个来小时就没了，之后的灰云也慢慢消隐。适才发现前方突兀着四座火山，前往探寻。有种行在素描画的感觉，天空是铅笔灰，雪一缕缕，再点缀着一些凄凄黄，着实是一幅彩笔素描画。是泥火山，高度在五十米左右，土质甚红。这种规模庞大的泥火山是很罕见的，其泥火山在地球上也是罕有的。泥火山不是通常意义的火山，高度一般不超过十米，小个子，只喷出泥浆和气体，没有岩浆管道。到底是不是泥火山？我个人分析是百分百。一是如此庞大的尖锥型孤立土丘在地质运动中很难形成，二是此处是青藏高原一条重要的构造带（高原有过四次隆起运动，印度洋板块不是一次性撞出珠峰的，所以羌塘荒原中的火山遗迹遍布），三是在火山顶部发现了类似喷口封土，四是未来几天将遇到更多的泥火山群，特征也将更明显。显然，这是剧烈地质运动下特有的泥火山地貌带。泥火山风化严重，NN年前了，有的火山充满孔隙洞穴，我还臆想有否藏宝？选择一个好的角度观察，他又会呈现别样形态，我便发现了一只羌塘之鹰。（不是地质专家，关于是否是沉寂的泥火山，待我更新完未来几天的照片后，相关专业网友可给出科学结论，以正视听。） 典型沙草地，试着装上一百五十斤大米在沙滩上推上十公里就知感觉了 风雪袭来，误判，很快就停了 雾霭散去，帐篷前惊现一处火山群 有如彩色铅笔素描画 爬了两座玩，放眼，是一幅更大的彩色铅笔素描画 左下角，疑似喷口封土 天色渐晴，一只羌塘雄鹰 D32（5-21），27K，宿营4880M今天，格外漫长……今天，天气也是格外好。上午穿过一段泥火山地貌，依旧未到此行最震撼的。一路踏雪，前方的胜利湖盆雪厚许多，直到中午才化去，好在此前搏命赶路。十二点半，车子被粘土卡死轮胎，甚至把后轮给顶了出去，可见土粘，可见我急于摆脱的发力。苦等了一个小时，地面才在午后烈阳下干了些许。下午三点遇到胜利湖北侧的胜景河，碱水，泥沼型，探了无数次路过不去，泥沼太陷，也很冷。每次在泥沼里探路不会超过三分钟，否则会冻的失去知觉，一辈子就这么被陷住了。我放弃了，决定等明天早晨看能否上冻些。有些分心，此点是我第三组逃生路线，一是北上经可可西里山、巴杂钦山、昆仑山进入位于新疆境内的土啦牧场，二是南下经绥加日、藏色冈日、措尼、玛尔果察卡找到无人区最近的荣玛乡，一南一北两条逃生路线距离相等，都约需二十天时间。再度反省一番，不上不下，状态尚可，那么就继续往前吧。恒了心，恐多变，咬牙过了河，断后路，其艰辛不表。过河后是绵延的寒漠土丘陵，属于非常难行级地貌。由于错判前方会有大量水资源，所以上午没有融雪，下午没灌盐碱水。实际情况一片极度荒芜。渴的厉害，又误判前方有水，疯了般推车，一直到太阳下山前一刻才发现一个湖泊，就是照片中那个。放下车，第一时间去打水，才发现这个湖居然是盐湖，薄薄一片水，水下是不知多厚的一层盐粒。此水自是不能喝，活不过当夜。光线已无，我绕了盐湖一圈，心存侥幸。这段记忆很深刻，有种在暮色荒原中没有归宿的感觉。当夜无一滴水，但还是吃了一块压缩饼干，因为明天还得继续，往前，找水，没力气可不行。 上午，穿过火山地貌，很多 远眺胜利湖，背景是玛岗喀日雪山 轮胎被卡死，后轮被顶出 胜景河，碱性泥沼河 白色是盐碱，泥沼很冷，每次探路不会超过三分钟 太阳下山前一刻终于看见一个湖，却是一个大盐缸，今夜无水 关于探险当今，没有探险，地上宝马，头顶波音，还有GE。撕了脸面，上网恶炒，全世界也都会瞬间知道。地球不再是旧石器时代，逐猎而生，不问方向。地球也不再是哥伦布时代，手持圣经发现上帝遗弃之地。所以，没了探险。羌塘，走的人多了，有科学家，有测绘兵，有探矿的，有开车探险的，有盗猎的，有淘金的，有外国探索者，虽然我暂时走的更深些，在无人区里待的最久些，但依然只是一次艰苦的旅行，还上升不到探险高度。若较真地球上再找一个探险之地，那便是地下世界。中国占世界喀斯特地貌三分之一，无数的洞穴。但探索者寥寥无几，因为地下世界没有第一，你今天发现了最大地宫，可能明天就被取代。没有第一的游戏是没人玩的，所以都挤上珠峰，因为全世界都能瞧见身影。当今，没有探险，但不能失去探索精神。依旧羌塘，某年，某个俄罗斯人带了几个伙伴，经克里雅山口来到昆仑山玉龙河上游漂流，死了几个，他活着，后被军区直升机救出。去年见一新闻，说是俄罗斯人在昆仑山遇大雪，危急，又被军区直升机救出，查名字，还是那哥们。这就是俄罗斯人的探索精神，不顾规则，不论成败，管几斤几两，计划好了就去做。或许鲁莽，但墨守成规是做不出事的。所以，没有探险，只有探索，对自然，对自我。 D33（5-22），18.9K，宿营4986M天气，好周期。继续东进，寻找绥加日山的风翎垭口，准备进入朝阳湖盆区。晨，没吃。上午近十点发现一个湖泊，微碱性，可适量饮用，利马取冰融水，此行唯一一次途中生火烧水吃饭，有些虚脱。喝饱未吃饱，已经好很多，赶路。十二点上一个大坡蓦然眼前的是，一个宽大的盆地里居然有几十上百个泥火山，锥形特征更明显，恍然异星球。这使我更加坚信两日来所见的是泥火山。一片闪闪银光吸引我，初以为是露头水晶，近处才知是云母片，一层层相叠，似一本厚书，可轻易剥开，稍有韧性，易碎，手指一捏便咔嚓。半透明，似熬成片状的糖浆，很美。不知此种云母石和泥火山成因是否有关联，但此处露头云母太多了，风化的也厉害。有专业人士可以再结合这云母判断一下，以正视听。可惜未拍一张云母照片，遗憾。另说，盆地东侧小山上有一大地三角点，这至少说明了当年测绘兵来过，至于科学工作者是否来过未知。羌塘地质资料中确无发现沉寂泥火山相关内容，所以，泥火山是否还是存疑。穿过火山盆地，东侧地貌呈现盆地戈壁，风化石极多，很拟物，上了一张骆驼石，大家可以看像不像。有几次误判，终于确定一条通往垭口的河道，人品不好，干硬河床很快变成软沙底，推得我十分的十分的忧郁。途中看见一只硕大的死乌鸦，原本想拔根羽毛随身带着，因为有个朋友不相信有这么的大的乌鸦，他看了这长达40厘米的主羽一定会心服口服。还是忧郁，顿了一下，瞥了一眼，走过。河道开始有了新特点，纵深，两岸陡直，走在里面感觉既像甬道也似迷宫。八点钟，遇河道分叉的开阔处，再无一丝力气，扎营，然后又轻松的徒步探路半个小时，把河道走向搞了清楚，确定明天方向。水是上午灌的碱水及冰，捂了一天后味道甚重，已经习惯，但今天却不知怎么惦记起最后一点白砂糖。一斤白砂糖吃到现在再也留不住了。是半夜，迷迷糊糊的醒了，一直想着最后一点白砂糖，真的很馋，于是挣扎起来，把睡袋里的水壶掏出，将最后的白砂糖冲了。味道？很不好，就行骨头汤里放糖一样。这是一个非常危险的信号，从精神层面上开始动摇了对食物的控制。 晨起，才清晰昨夜地貌 遇水，途中唯一烧水吃饭，有些虚脱了 盆地里的火山，再结合周边的云母片，专业的看判断下，以正视听 盆地东侧的戈壁地貌，风化石多 骆驼？狮身人面？ 河道通常是优先选择的推行地貌，但人品不好时很痛苦-宿营，本想山坡下，避免风头，没力了 D34（5-23），16.2K，宿营5212M好天气周期继续。今天吃了四块压缩饼干，是平日两倍，实在无力推向垭口，只能在食物上给自己找借口。全天就拍了两张照片，一是下午遇见的狼，拍他是因为自相遇后他就蹿上坡脊一路跟了我半个多小时。那狼在山坡上，映着蓝天白云的感觉勾起了感悟，江湖是孤独的，在于内心。另一张照片是雪袋里混杂糌粑粉。还是欲望，对食物的失控，弄了些糌粑粉搅在装雪的袋子里，做起“糌粑冰沙”。创意无限，食物有限，不可取。另说水源是山坡附近一块积雪，海拔高，过了5200米，冷，风大，铲雪时帐篷被吹翻了，好在防风绳拴在自行车上。那一刻，坐在雪地旁，看着暮色中翻腾的帐篷，想象着帐篷果真跌落山谷我将如何。所以，晚上除了“糌粑冰沙”，还把最后一点牛奶给消灭了，算是补偿帐篷。从精神上再次为自己开脱，补偿帐篷我喝牛奶是什么逻辑。一斤牛奶也是挺到现在，终于完成了他的使命。用自行车驮物穿越羌塘是国外探索者最先采用的，确实也是目前长线穿越羌塘最有效工具。但绝对无人区的天数都很难超过五十天，除了体力、心理，食物也是主要原因之一，所以一直都是纵穿，羌塘东中西三条线他们都走了，有兴趣的可以查下网络，就那几个人。纵穿是因为线路相对较短，而且两边都有牧民深入，容易紧急情况下得到求助。我的逃生路线也是如此，皆是南北方向。同纬度横行，永远都处在纵行的中间点上。我的食物重量已是所能承受的极限，即便半饱走完全程都是不可能的，这就需要极力控制，控制生理上的需要和心理上的欲望，只要不饿死怎么都行。去年就曾尝试横行，设计了“V”和“W”型两条路线，就是反复斜插，途中寻找一到两个牧民点获得补给。却在斜插完羌塘西部无人区时被牧民揪住了，随后就是各级政府尽职尽责。这也是当地公安局仅在无人区里抓住的两次人之一（仅指旅行者），上一次是那三个国外探索者走的中线。此前，可信的单人模式穿越羌塘最长记录的人是Martin，纵穿最难的中线，耗时35天，其中完全没有遇人19天，有粮食剩余。Martin也是穿越羌塘次数最多的人，彪悍，狂野。 江湖是孤独的 糌粑冰沙，创意无限，食物有限 D35（5-24），29.5K，宿营4965M很早起来，趁天寒地冻，迅速翻越风翎垭口。海拔5200米的山口不算高，但此地是个风口，清水鼻涕稀里哗啦，乱甩。下山时，寻了一条硬干沟，碎石很多，也不顾，一直溜到山脚下，几头野牦牛吓得抱头鼠窜。最有意思是一大群藏羚羊，被我冲的七零八落，有点像被炒家的劲头。乱石沟里溜坡确实奇妙，靠的不是技术，是感觉，一种身体和心理完全打开的感觉。仅有一次遇挫，一个坑，没留神，屁股和手都被颠起，车子就这么从身下独自溜了下去。我坐摔在地上，车子撞石倒下，还好当时没有牛羊，否则定是幸灾乐祸的狂笑。今天人品不错，下山后干沟变成干硬河床，有一段跟水泥地似的，骑得我兴奋的发颤。行距早已达到预期，便鼓足精神又翻了常雾岭小山口，下山口迎面就是可可西里山脉，他终于完整的呈现出山梁之态。（明天是雪染可可西里山，所以今天的可可西里照片就不发了。）随后几天都在可可西里山脉与常雾岭、玉帽雪山之间狭长的盆谷里一路东进，直杀布若错。水源是一个水坑，周边满是动物脚印，水质尚可，微生物多。灌好水后准备就地扎营，却看见几只羊在不远处的小土堆后闪闪躲躲。原来霸了他们的水源，于是又沿着河床往下推了数百米，直面可可西里山脉扎营。晚上分析地图，种种因素都表明了未来几天，甚至今后的日子水源将一直丰富。说近期，一是我的前面就有条春雨沟，瞧这名字多好听，而两边雪山下也有多条河流汇集在狭长的盆谷里，朝阳湖也在前面直线距离30公里的地方……一切都显得那么美好，实际上…… 途中一群藏羚羊挡道，我吆喝了一声，一同将屁股对准我，无语 营地，旷远 D36（5-25），14.8K，宿营4873M夜风雪，雪小，风大，气温干冷，帐内温度低于-10℃。可可西里山脉点缀着稀拉雪，像是染上去的，地面被吹的一条条模样，可见风之大。早晨赶了一段硬路后就全是重沙草地了，推到下午5点没力，扎营。另说中午吃了三块饼干，比计划的又多了一块。晚上又琢磨着饼干烧成糊糊的味道，尝试了下，不错，又多消耗了两块饼干，对食物的探索精神貌似超过了旅行本身。所谓的河，无水，深沟壑极多，垂直，松土，自行车推上推下就像推土机在搞基建。水是一个小海子，湖畔淤泥，经验多了，看一眼便能大致断定水的品质。非常疲倦的感觉，有过经历的人就知道，每天近二十公里的速度是怎么来的。除了极少的路可小骑过个小瘾，其余路况很少能一次推一百米不停下喘两口气的。硬草地一般推个五十米喘口气，寒漠土二十米喘口气，沙土路十米喘口气，重沙地三五米喘口气，陡坡半个轮圈喘口气。这羌塘就是这么一口口气喘过来的。呼吸很重要，学会呼吸就可控制心率，控制心率是为了减少血液循环，减少血液循环代谢就少，代谢少了就能节约热量，节约热量就能省食物。呼吸和食物之间的关系便如此，体力减少更不必说。如果一个小时休息十分钟，不如学会一个小时休息六十次，每次十秒，使你的心率永远控制在低频。（仅指羌塘推行，因人因线路而异控制休息次数和时间，徒步控制心率更容易些。）我的体格并不强健，中等，除了探路外每天长休息三次左右，每次不超过十分钟，其他时间推一会，喘口气，控制心率。提高推行频率，比太阳起得早，速度就是这么来的，尽量不做无氧运动（过多使用爆发力）。另外，胡思乱想、多愁善感、吟诗作画、悲天悯人也都会消耗体力（尤其拍照）。有网友问心情变化，大部分时间里是没心情的，有心情时也要控制成一个平滑的状态，套句网络语就是“蛋定”。 可可西里山脉，呈现“山梁”之态 藏羚羊越发不惧人了，尤其慢似蜗牛者 乌鸦，终于拍下很猥琐的表情 水源，一个很美的小海子 取水的代价 D37（5-26），19.8K，宿营4775M从宿营海拔可见一直下坡，但速度提不上，主要原因就是重沙地。今天肚子过闹，不知是否和前天水有关。今天小苍蝇很多，不粘人。一路无水源，用存水。太累了，那天没什么记忆，日记字数也少，估计又是大部分时间都是催眠状态。弄的当下也没什么心情，凑合着写了几个字把今天内容应付。 重沙草地，这些天频繁了些-营地，天高云阔，却无水源 D38（5-27），18.5K，宿营4764M今天话多，因为漫长。用最后一点水泡了糌粑，不急。找了条沟推行，沟窄，如地道战。地表过于平坦，沟壑很难发现，方向一致更要检验人品。今天发现这沟，归功于“拉肚子”。硬沟缓上，到了坡顶后是一片开阔草地，动物很多，却没发现水源。春雨沟和峡丹沟相向汇合，再九十度南下与朝阳湖相连，再无水源天理不容，所以，身上无水不急不急，一直朝那汇河推去。上午十点，终见此河，一道波光粼粼，望远镜中看去，更是水波荡漾，岸边耸立奇特小山。绝美景象，便想着推到河边休息半日，把疲惫的状态调整下。到了近处，一个霹雷，这河居然是一片干涸盐碱地，先前看见的波光粼粼是地辐造成的视场紊乱。更麻烦的是，盐碱看似干透，实则陷人无比，走不到三米便得丢盔弃甲，一时不知如何是好。有客来，一只高原沙蜥，还有三头驴在河坡上看笑话。思量，沿河往朝阳湖方向推去，动物白骨极多，半沙淹没，衬着死寂河滩，有股死亡味道。烈日也炎炎，脱得只剩抓绒，还开了拉链。一个半小时候后，寻到一处便宜处过河，又是错觉，那龟裂河床不过是个幌子，不到五米，粘土卡死轮胎。这土奇异，粘性十足，似胶。放下车子，往前寻了几步，人都过不去了。那三头驴居然一路跟来，在山坡上，发呆的样子，心里定想，小样，看你怎牛。无奈，继续往下游方向走，几经探寻，过了盐碱河滩。接着便是火星一样的沙漠，燥热，更渴了，嗓子冒烟。沙漠是古湖床，红沙，其间点缀怪异小山，左边古湖床边缘也是怪异山，稍高，只是不孤立，重重叠叠，类似喀斯特地貌的峰丛。望远镜找水，不见水，转向玉帽雪山方位推行。到雪山是不可能，雪山西侧有座狮子岭，山地草原，定有水。一直推到八点，进入一条沟壑，放下车子，探路边找水。渴的失常，忘了带背包、GPS等。走啊走，先沟壑而上，翻上沟壑，再下沟壑……就这么一个小时过去了，不见水，只有稍湿润的盐碱渍。九点往回走，发现迷途，一条条并行的沟壑，一道道无尽的山梁……风景却是罕见的美，绚烂黄昏，月出东山，一边晚霞似火，一边月华静谧，可惜没带相机。寻啊寻，越发迷失，即便找到停车的沟壑，也不知身在沟壑那端。西边景致全无，只剩东方皓月当空。坐在一处山梁顶端，沐浴晚风，努力使自己平静下来。困顿显然，身无一物，幸有月光，但在月光下找到自行车更是渺茫。我做好了最坏打算，在哪个土堆后猫一晚上，明天日头下便一目了然。有了最坏打算，那么心情便可平静，心平静了，便可尝试再一次找寻。策略是走向沙漠，方位简单，地貌特征明显，易寻。然后在沙地边缘找到车印，有点难，需要细心。顺着车印进入山地，虽没了车印，但记忆有了逻辑可循，坡，沟，右行，坡，沟，左行，直上……运气好，判断正确，十点多，在如水月华中找到了自行车。漫长的一天，筋疲力尽，这才又想起渴来，无食无水。半夜醒了几次，风沙打在帐篷上，以为是雪花。我祈祷着，下一场雪吧，给你一百块钱。 沟壑也是首先推行地貌，但方位要判断好 汇合河，虚妄的幻觉-岸边的小山重重叠叠，很似喀斯特地貌的峰丛 风化胀缩泥河床 高原沙蜥，身下是根草，以为身体一部分，罕见新品或基因突变什么的 问朋友，说不会是草吧，写今天文字时在硬盘里找了近影，确实是根草 看似龟裂盐碱滩，十分粘土，似胶 红色沙漠，其间点缀怪异小山，火星地貌？ 寻到月色中的自行车，淡定 D39（5-28），5.8K，宿营4768M今天，推车五公里，徒步找水二十二公里。观测前方，狮子岭一带无水痕迹，推车前往也是艰辛，便掉头直奔朝阳湖，哪怕盐水也罢。不过五公里，便无力，于是装上所有水具，徒步去找水。还带了糌粑、油炉、锅，遇水得先造一顿，补充体能，也是节约一顿做饭的水，然后再背水回来。望远镜里，朝阳湖烟波浩渺，心旷神怡。先是古湖床的沙子，再是爆裂缩胀的泥床，再是一块块呈现几何图案的盐田，很沮丧，前方却依然一片烟波浩渺。此时，望远镜已没用途，挺多放大烟波浩渺，甚至出现了芦苇丛……光折射、抖动太厉害了，蜃景。查看三份地图，对比，朝阳湖不仅有水，还极有可能是淡水。干盐湖不好走，上是一层硬壳，有空隙，下面不知几米厚的盐，一踩即碎，再拔脚，难行度和齐膝深的雪相当。地图显示已进入湖区，可还是盐田，有些领悟，GE卫星图显示这片湖畔的大片白色，非冰，而是盐。热，极热，干，极干，盐湖似无尽头，但前方烟波浩渺无限。人有些撑不住了，高原的太阳辐射之狠去过藏地的人知晓，再加上盐体的放大效应，有如烤炉。终于晃到盐湖中间的一座小孤岛，爬上，四周寻望，不是盐田就是沙漠，孤岛无依，我比孤岛更无依。侥幸着深入盐湖，多少会有些水，便选了一条面对常雾岭的直线穿越湖区，即便湖区无水，在湖的西侧也有河流与湖泊。体力下降极快，行在盐田，如行尸走肉般……临近岸，是一个个盐窝，从未见过如此景象。（一般徒步探路、找水不带相机，否则今天的盐窝大家就看不见了。）盐窝内陷，是盐泽，盐壁干硬，可行脚，要小心，掉进盐窝里便成了腌肉。锁定直线，在盐壁上绕的头晕，不知又走了多久，盐窝变成了盐锅巴，终可直线。上了岸，看地图，已经横切了湖区。放弃湖区寻水，找西侧的河，无水，白色盐碱渍却是不少，很迷惑人。最迷惑的是常雾岭半山上有片白，盐碱而已，却是那么诱惑，再三观察，思量，放弃侥幸心理。若爬上山，非雪也，估计人就下不了山了，身体已经很糟糕。又去找西南侧的另一个小湖，还是杯具，盐湖。再朝朝阳湖南侧湖区寻去，希望盐湖里有些液体水，也可利用，研究过以色列的海水淡化技术，所以随身带了一段导管和喷雾瓶。依然一片盐场，更宽阔，坐在地上，脑袋一片空白。缓了会后，爬上一山坡，用望远镜四处瞭望，皆是蜃景，就连回路方向都是一片烟波浩渺。拒绝诱惑，但还是又奔着寻了一程……下午五点进入一片沙漠特质的古湖床，彻底不行了，口腔溃烂，黏在一起，人也迷糊。一泡尿液进了杯子，用尿液漱口，口腔才好了些。虽有些尿液会进入喉咙，但绝非主观意愿，喝尿救生是不科学的，不多说。尿液是很好的消毒剂，但慎用，非绝对杀毒，尿液里也含有害成分，加速伤口感染，只紧急情况下润喉、消毒。用衣服遮住头部在沙地里躺了会，好很多。六点往回走，晕一脚，眼睛腿断一根，找到车，搭帐，喝尿润喉，睡觉。 回首 渐变的地貌。沙，土，盐 辐射高，难行，煎锅似 登上孤岛，比孤岛无依 奇异的盐窝，小心，陷，成腌肉 边缘，逐渐衰落的盐窝，似一口口大锅巴 所有地图中湖，皆盐湖(拼接图） 眼镜腿断了一根，半稳架在鼻子上居然也走了好几天，只是滑稽些 D40（5-29），5.8K，宿营4764M早晨醒来，看见干透透的帐篷非常惊诧，甚至有些恐慌，此行唯一帐内没有结露现象，甚至连湿的痕迹都无一丝。这说明了空气的湿度有多低，侧面也反映出呼吸中的水分也少的可怜。尿了一泡，润口腔，吃饼干，今天还得继续找水，所以压缩饼干必须吃些。如果有直升机投水来，我一定会躺着不动，不吃一点东西。但眼下情形必须要有体力去寻水，自我拯救。眼镜腿断了一根，但还能半稳架在鼻子上。拍了今天唯一张照片，就是留言纸条，“我是旅行者，去找水了，如果有神人路过，请不要随意动东西。请留下些补给给我，最好有大量的水。”将纸条夹在拖鞋里。我了然，这是火星撞地球的概率，但还是留了纸条，或许潜意识里……随后，带上半壶存尿，水具，DV去寻水了，又给自己拍了唯一段视频，“今天早晨很美，如果今天再找不到水，马克思就要找我去开会了，所以今天一定要找到水。”其后不表，过于琐碎，不时用尿液润口腔找水而已，遗憾的是，没有找到水，庆幸的是，马克思还没找我去开会……睡前，尿液，吃饼干，明天还得要有体力。祈祷，下场雪吧，爱下不下！ 今日唯一照片 今日唯一视频（镜头太近，其实很帅，汗）十二点上一个大坡蓦然眼前的是，一个宽大的盆地里居然有几十上百个泥火山，锥形特征更明显，恍然异星球。这使我更加坚信两日来所见的是泥火山。一片闪闪银光吸引我，初以为是露头水晶，近处才知是云母片，一层层相叠，似一本厚书，可轻易剥开，稍有韧性，易碎，手指一捏便咔嚓。半透明，似熬成片状的糖浆，很美。不知此种云母石和泥火山成因是否有关联，但此处露头云母太多了，风化的也厉害。有专业人士可以再结合这云母判断一下，以正视听。可惜未拍一张云母照片，遗憾。另说，盆地东侧小山上有一大地三角点，这至少说明了当年测绘兵来过，至于科学工作者是否来过未知。羌塘地质资料中确无发现沉寂泥火山相关内容，所以，泥火山是否还是存疑。 应该还是剥蚀地貌，此处风化严重，早晚温差大，且大风、气候变化多样，易于物理风化。至于为什么形成那么多的土堆，很可能是土堆下面及附近有较周围不易风化的物质，比如说一些坚硬的基岩，由于该处的隆起，表面又土化，故而形成土堆。那些云母片儿，照楼主的描述可能是类似于绢云母千枚岩或是石英片岩之类的变质岩，变质程度低等-中等，那些土堆下面很可能是变质砂岩一类较硬的基岩。这个地区整体覆盖较厚，上面是一层冻土，下面的砂砾石或许能看出一二，但此间的信息能透露这么多，已经是非常难能可贵的了。谢谢指教，以正视听。我觉得你分析是对的，我只是粗陋凭借地貌揣测，且缺乏相关专业背景，大的理论还能嚼些，分枝就远不能胜任了。 D41（5-30），0K，宿营4764M夜里醒多次，口腔黏在一起，喉咙也仿佛合拢了，喘不过气来，嚼口唾液撕裂的痛。担心早晨醒来口腔会张不开，最后，用一个长尾夹放在嘴里，既是物理隔绝也是刺激唾液分泌，再用一根红绳子栓在长尾夹上，以免不小心吞咽。迷迷糊糊听见帐篷沙沙声，以为又是风沙作祟，微明，掀开帐篷一角，见是雪子，再看了眼天际，灰云铺顶。不喜不悲，因为羌塘白天是很难下大雪的，更难积蓄。心中也并无打算今天如何找水，身体透支太多，再难强打精神，也无祈祷，该怎样怎样。无视，继续睡去。天色放亮，雪越下越大，才清醒些，认为是生机。然后三两分钟掀帐看下雪情，待到有些积淀，便赶紧扒了些雪融水，生怕云散雪化。终于喝了水，这才感触颇多（可能诸神也喜欢看帖J）。写今天文字时翻看当天DV，有一段自拍，很是矫情，眼有泪花，觉得做作。人的一生不可能踏入同一条河流两次，此时彼时，我再也无法感同身受了。趁雪未停，继续化，没想这雪越来越大，鹅毛之势，傍晚才歇，这是此行唯一一次，在羌塘也是鲜见的。不停取雪化水，把所有水袋装满，人也喝得饱，整整7L，唱歌，尿液亮晶晶，兴奋。除了控制粮食，水也是受控的，是为节省汽油，水再多，一天两锅水，3L，所有食物用和饮用，显然此环境下也是不够的，尿液一直淡黄。今天，终于见白，闪着亮光，耀武扬威。吃饱喝足，外面风雪，困在帐篷里听音乐，如果再有根烟，我情愿再喝尿一天。果有根烟，我还能等到明天吗？客观的回想，是不能了。 见雪稍有积攒，便速融了水 可能诸神也喜欢看贴J赏了口水喝 傍晚，雪才停下，这在羌塘时鲜见的 D42（5-31），0K，宿营4764M昨夜，又一次半夜雪地欣赏水波星空，要来的不请自到。（当夜，非常糟糕，不表。）这老天爷要么渴死我，要么淹死我，昨儿一整天大雪封了大地，只能再休息一天。无聊，很容易乱心智，手机里的音乐听得不再觉得经典，就像燕窝吃多了跟粉丝无异。稳定心智的唯一办法就是吃，用一种代价换另一种代价。做了糌粑冰沙，做了糌粑泥人，做了糌粑烤饼，最后让他们在胃里团聚。哦哦鸟格外的频繁，就那三两只，围着帐篷转，“哦-哦”，估计是食物吸引了他们，便洒了些糌粑粉在稍远的雪地上，反而，他们跑了。有乌鸦，闷闷的扇翅声，要早两天看见他一定恨死。午后，日冕，踏雪上山，遥望四野，一切显得那么久远。继续无聊，找事情打发。修了GPS，线路老化，想着老无所依可以做电工；缝了裤子，材料老化，想着老无所依娶个裁缝老婆；然后写日记，拍照片，觉得做卡梅隆其实也不错，当然，首先要华谊兄弟鼎力支持……又想了一堆乱七八糟，改换压缩饼干镇压一切妄念。 修理时间 裤子频繁轻易破损，与气候悬殊，盐碱腐蚀都有关联 踏雪四野，一切显得如此久远 坠入地下的夕阳，依然无法见真容 D43（6-1），24.8K，宿营4837M昨夜两次起，第一次水波星空，第二次月华铺地，真是奇妙，肚子和某处压力各闹一次。温度开始提升，-6.4℃，想起今天是儿童节，阳光定要灿烂。地只冻了一小时就软了，白天记忆很是模糊，追赶流逝的时间，一直无视风景。其实，也无风景，羌塘即没那么美了，也没那么糟了，种种幻想也变得实际，走一步算一步，挣扎是所有情感的总和，新鲜感一过，剩余的只有时间在流淌。荒芜永远是羌塘的背景，偶尔的奇异地貌和掠过眼前的动物只是衬托了荒芜。很晚才拍了一张照片，然后进入一条河床，发现几个破损的大油桶，历史怎么也十年上了。滚了一个回来，在帐篷前挡风，第二天，被风吹跑了。夜里有过一场虚惊，有人窜门，似咚咚的敲门声。用手扑打了两下帐篷，声音消失一会又起，起身，用电筒巡视一番，没有什么发现，躺下，咚咚声又起……以往，根本不担心有动物骚扰，开门迎客便是，但这声音着实诡异，加上前几日的折腾，神经有些敏感。又起身一次，原来破损的油桶里有只鼠兔，不知怎么进来的，想逃出去又不敢弄出大响声惊扰未知怪物。没有理睬，放心睡去，迷迷糊糊风起，很大，帐篷哗啦啦的响。翌日起来便不见了油桶，估计被风吹到了河床下游去了，或鼠兔练就了如来神掌，粉碎了油桶跑了。 斜阳下的羌塘，化平凡为神奇-挡风的破油桶，第二天，跑了 D44（6-2），24.8K，宿营5014M又是追时间一天，将翻越可可西里山、横云山、玉帽山相交地带。预估会很难，地质复杂，实际出奇的好，一条条干硬河床及沟壑相互交错，如同网络。先前说过，干涸河道、沟壑都是首选推行地貌，原因是坚实的沉积物多，方向也好掌握。若是山地貌，就一定有硬沟可循，若是湖盆区，那一定有干河道可依。确定河道沟壑的最有效方式是GE地图，这也是GE地图唯一有实用价值的地方。羌塘广袤，GE细节无法呈现，但一条条沟壑却是清晰，将设计好的路线转成KML格式，同时再在周围多设些参考坐标，最后将GE地图打出，便能快速的寻找沟壑以及确定方位，速度和精准性极高。如果有支持位图的GPS手持机就更容易操作了。另随身携带一个传统指南针，电子罗盘不可靠，（电磁干扰大，有巨大风险隐患，）GPS算出方位角，用指南针定位。体能下降越来越快，到了十一点就惦着压缩饼干了。很难判断，是馋食物了，还是生理需求到了底限。应该两者都有，交织在一起，结成一对恶棍。眼镜很麻烦，大点颠簸就半搭着，袜子也不够穿了，必须将脏的洗掉，肚子闹的有些厉害，头发打结严重，内衣也够呛……这一切让我急于寻个完美营地休整一天。完美营地必须满足三个条件，一是有硬岸的清河或湖泊，二是适合扎营的土质，三是天高云阔的好天气，后者简单，前两者是大问题。硬岸清河自不必说，适合扎营的土质同样也难。草地不平，沙地扎不稳帐篷，石砾地帐钉无力，漠土浮尘太厚……完美营地，应再加上遗世独立的风景，这又可遇不可求。大蒜开始发绿，变软，腐烂，只能将坏的部分咬掉食用。先前将大蒜分几袋密封，隔绝氧气，避免发芽，但随着白天温度升高，大蒜也有被捂烂的风险。大蒜是数着瓣数买的，每顿几瓣严格控制，人算不如天算。辣椒粉也是超出预期，估计也挺不了多久。如果没了这些敷料，馋嘴的欲望将更难控制，转而向主食寻找慰藉，后期，的确也这样了。 形单影只，一路相携 大蒜开始损坏，咬掉坏的部分仍可食用 D45（6-3），14.2K，宿营4988M丰富的一天，天气，水文，个人生活。晨，雪原茫茫，暧昧雾气，风无一丝，静的诡异。所有的游戏规则仿佛都被抹去了，包括荒原的规则。一片静谧的暧昧白，却无迷失感，最大程度的自我。十一点就“饿”了，吃了路餐，然后在深陡的红土沟壑里翻上翻下，几度不支，最终进入可可西里山与玉帽雪山之间的宽阔台地。雪难觅踪迹了，风却猎猎起。下午两点，发现一个小海子，便打算休整，可惜不是一个完美营地，海子周围一片烂泥。下午四点半，经过玉帽雪山脚下的一条沙质河床，其间有一条溪水，沙重，但不至浑浊不堪。恰无一丝风，烈日当头，且视野开阔，可可西里雪山和玉帽雪山皆在视野，南北相对，勉强算个完美营地，便急速扎营，调整。先洗头，此行唯一一次，头发打结，再不处理，便成鸟窝。溪水太浅，水道中挖了一深坑，才蓄住水。然后洗脏袜子、内裤，挂在帐篷上晾晒。换了一套内衣，带两套，脏的一套扔弃。照镜子，很陌生的面孔，其实连声线也变了很多。清点食物，辅料消耗极快，主食控制的很好，于是决定增量，其实也由不得自己了，生理和心理都很难再支撑。修眼镜，用绳子串起，回想蛮可笑，一只腿的眼镜居然在鼻子上架了好几天。为何？应是一种麻木，半稳的眼镜不值得小题大做，它被更艰辛的旅行给埋没了。开始享受生活，自制酥油茶。一般藏人在野外的酥油茶非混合的，简单的油汤，我也如此。今天探索了下，把酥油和茶水装在杯子里，上下猛摇50次，左右猛摇50此，前后猛摇50次……就像调酒杯，油茶完全混合，味道绝对比所谓的知名藏餐厅要好，因为他们不可能用好酥油调制。一边喝着香喷喷的酥油茶，一边远眺着可可西里雪山，对前途满是憧憬。忽听见帐篷外有流水声，出来瞧，发现河床上遍布分叉的河流，这离先前挖坑的单溪不过两小时。这是一个重要的河流节点，随着温度升高，雪山加速了融化，季节河开始苏醒。不想再挪动帐篷，便用铁锹将切过帐篷边缘的一条浅沟堵住。事必，发现先前因水沙太多没有补水，这下只能打些泥水沉淀明天用了。 一片静谧的暧昧白，却无迷失感 途遇海子，周边烂泥，非完美营地 自制混合型酥油茶，享受生活 眼镜折腾好，很潮 晾晒衣服，此时浊水未起 傍晚，水漫河床，突兀 一夜间，季节河苏醒了，这既非好消息也非坏消息 D46（6-4），24.6K，宿营4937M天气，整天都很糟糕，唯有晚霞亦真亦幻。河流苏醒，浊水在宽阔河床上四溢，上午过了无数小河岔，皆不深，不难逾越。到了下游，河床再度干涸，上游的水还没下来。中午太阳出来一会，正休息吃饼干，闻滔滔声，见一股浊流顺着沟槽涌下，急忙起身推行，黄色浪头基本追着脚后跟，有黄河之势，却无黄河之实，很有趣。直到一处开阔地，水流被分散，适才喘口气。用不了多久，河床将会被融水彻底打通。有些河汇入盆谷低处的湖泊，有些则满溢在开阔的空地上，形成吃人沼泽。随后，大雪风天，湿脚极冷。再随后，对流天气，一会东风压倒西风，一会西风压倒东风，两股妖风纠缠过程中，惊雷四起。此行第一次，之后是常态。惊雷是雨季的号角，我并未从中听出惊悚意味。对羌塘的雨季早有提放，没有人能在雨季穿越羌塘，机动车更不行了，所以，雨季里的羌塘才是真正的无人区，没有盗猎的，探矿的，游荡的，出风头的。原计划四月初进入羌塘，只压雨季十来天的时间，后因背运晚了二十天进入。当下还感觉不出这晚二十天有什么严重后果，如果早知，那些设计的逃生路线就会派上用场了。下午到达旭光湖，一个超强风暴团正从身后涌起，风暴前锋蔚为壮观，只见玉帽雪山被一点点吞噬。仔细观察，风暴前锋离我尚远，且风向东南，我非挡道，便拿上水袋准备去湖畔打水。走了不过十来米，不放心，回头一瞥，只见一团白色急速涌来，心想不好，奔到自行车处，刚掏出救生毯，这风暴便夹着冰雹昏天黑地了，十分恐怖。救生毯，十元钱，就是塑料布涂上一层锡箔。此行第一次用（总共用两次），当时见风暴来，就觉非同寻常，掏冲锋衣肯定来不及了，顺手取了夹在背包外侧的救生毯。十元钱，效果好，昏天黑地中不觉一丝冷意，但明显感觉自行车被推动了，人用脚撑住地面才能稳住，勉强测了风速，瞬间十一级。风暴掠过后去打水，旭光湖被搅得一片混沌。傍晚进入一条纵深河谷，三头驴子带路，在河道中央，走一段等我一段，我只能断定此驴非常驴，心智过高了。约半个小时候，三驴跃上山坡不见了。我查看地图，正好是横切至烈马河的标点处。推上两河之间的草地，天色渐暗，打算宿营，却发现周边有许多小土坡，因昨夜有梦，和土坟有关，心有阴影，便又往前推了数百米，并将帐门面对亦真亦幻的晚霞。 夜风雪，湿软，赶路无视 季节河苏醒，破鞋子，很纠结 可可西里山脉，青色山梁 魔幻色彩，羌塘夕阳 D47（6-5），27.8K，宿营4868M上午漫河滩，过水难以计数，鞋湿透，脚泡白，冻僵。水多从鞋子烂口处渗进，很担心之后的日子。中午摆脱水域，进入干谷。谷地中有一块孤雪堆，呈冰性，高约两米，尘染，有些时日了，周围是一圈动物脚印。不解，首先干谷里此处唯一，即无冰川推至的可能，也无地泉喷塑的迹象，更无积雪不化的因素。不解二，一圈动物足迹，却无靠近，仿佛是一场围绕篝火的晚会。此景随后两日又各见一次，同样状况。下午进入另条一纵深河道，闹肚子，半响才注意，右首一只野牦牛虎视眈眈，左首三只藏羚羊好奇张望。好不尴尬，他们一定在想，这玩意蹲在地上作甚？河道探路，确定走向，是一百八十度后正转，回程从山梁上直插，由于没带GPS，无法准确判断停车之处，犹疑之际，见先前观我闹肚子的三只藏羚羊背对我往河谷下张望。我一个恶作剧，吓的羚羊惊慌逃窜。走到羚羊先前处往下一望，见是自行车。原来三只藏羚羊尾随了一个多小时，非要把我研究个透彻。的确，这里野生动物如同人类，对未知充满好奇。今天罕见的吃了六块压缩饼干，先早早吃了两块饼干，下午吃一块饼干，找了个太累的借口又吃了一块饼干。傍晚时分为庆祝即将抵达若拉错又吃了两块饼干。最初，一天两块饼干，分两次食用，支撑着漫长的白昼，那样的豪情万丈再也不复，只剩下一副被欲望填充的皮囊。七点就扎营，天气不好，浑身也湿乎乎的，又来了几头野驴在山坡上盯着帐篷良久，我希望他们能给我驮些压缩饼干出来。大声问可否？他们吓跑了。 水漫河床，但下游尚未贯通 野驴和藏羚羊混合群，有意思 守望帐篷，却不愿为我驮些美味来本来今晚无暇更新，但网友们的热情感动了DZY、GWY，特命我怎么的也要更新一天内容，节后必须正常更新，增加内容。在此，深表歉意，并祝大家国庆快乐。 D48（6-6），23.8K，宿营4871M照例，顺着一条浊水四溢的河床来到若拉错湖畔，这里是动物坟场，白骨累累。老死病死的野牦牛随处可见，尸体被野兽撕的散落。伴随死亡的是生命，此处的野生动物繁盛有如牧场，这与湖畔大片的硬草地及温湿小气候有关。沿着湖畔走，很少见的硬岸，蓦然发现一条“车印”，只有单道，约二十多公分宽，十公分深，起初怀疑是牧民的独轮车，后想想不现实，此地无人区腹地，人力独轮车即便能到也无法压出如此厚实的“车印”。有一点可以肯定，不是机动车所为。之后的日子里，常见到此种“车印”，一直到阿尔金白石山下。很大谜团，不解，后期深入雨季有所悟，“车印”是野牦牛的安全通道。它们同样惧怕冻土消融和沼泽，巨型身材比人更容易陷落，所以一条坚实可信的通道是生存必须。有些“车印”里充满牦牛脚印，有些“车印”则被踩实脚印难留。最后的疑惑，牦牛可以在二十多公分宽的通道里行走嘛？事实上是可以的。这是野牦牛在无人区腹地生活习性的一个重要发现。之后的日子里，有相当长的一段路是压着野牦牛通道走的，的确安全可靠。午后，湖畔一场风暴过后，空气中弥漫着泥土芬芳。“泥土芬芳”不是形容词，他是暴雨过后泥土中的植物孢子被释放而产生的怡人气味，这是春天到来的显著标志。想必很多人有过类似经历，某个午后，雨后浓烈的泥土气息扑面而来。下午来了一场更猛烈的风暴，平均风速达到十级，风中夹杂着硬雪子，若迎风的话一分钟就能把脸打烂。我躲在一条深沟里，见风暴时间太长，便琢磨利用下势能。先探了几十米的路，人不稳，回程倒着走，花样脸可不能毁了。确定前方地貌后便跃出深沟，那风瞬间就推着人急速向前，甚时，我得小跑才能追上自行车的步伐。雪子从耳畔呼啸而过，前方一片昏暗，没有视野，却也无阻挡，如此晕头转向的被风推了几公里，实在奇妙。风暴渐歇，忽见遍地的小花，多到难以下脚，紫黄两色，粘着风雪，楚楚可怜。羌塘，冬天与春天并存。蒙蒙中，前方一头小野驴，像是迷路，游荡着，伴我行了一程。雾霭散去，一群野驴围着我绕圈奔跑，时而一列绕圈，时而分成两列相迎绕圈，持续良久，他们难道特地为我表演“驴术”？若论羌塘最爱的动物，一是野牦牛，二就是野驴了。前者外表狂野、内心温和，后者外表温和、内心狂野。为人处事，更欣赏后者，但凡不惹事，逼急了一个驴后腿，不是常说嘛，脑袋被驴踢了。 刚老死的野牦牛，他们社会形态是老者自动离开族群，寂寞死去 尸体很快被野兽撕裂，累积的白骨更是遍野 风暴肆虐，湖面呈现汪洋的气魄 若拉错湖畔的野牦牛 再一场风暴后，春天蓦然眼前，冬天与春天并存 野驴很热情，为远客表演着精彩驴术，并让我代祝全国驴友国庆快乐 D49（6-7），24.9K，宿营4943M目标，翻越若拉冈日与可可西里山之间的台地，进入多格错仁强错盆区。路线好寻，若拉冈日一条山脊向北延伸，尾端有一座独山，锁定即可。台地缓上，需横切多条雪山下的山涧，有水则只一条。山涧充满浑圆巨石，这在羌塘河流地貌中少见的。其中一条山涧两岸陡峭，土质，河道里却是无数有棱碎石，应是冰川造就。此河难逾，思量之际，三头野牦牛从远处山坡上直冲下来，逼近二十米才转向，冲刺时间、路程之长罕见，我也着实心里没底一回。过了独山垭口是一片高山草甸，厚，块状，也是羌塘少见，一地牦牛粪，牦牛四处散居，貌似牧场。海拔6035的若拉冈日雪山一直在右首近处，相对高度低，浑圆无势，总有上去溜一圈的冲动。左首则是锯齿状的可可西里山脉，宛如一把钥匙，若是，一定是打开羌塘宝藏的钥匙。傍晚寻路，走了数公里，遇一奇景，斜阳下的金光透过云层打下几束，照在草地上的牛群，看得忘乎所以，用眼睛代替相机拍下。今天发生一件很糟糕的事情，就是炉头坏了。炉头坏了，无疑等于慢性自杀，所以国外探索者一般此长线，多会备一个炉头。早晨从六点半修到十点半，晚上从九点修到凌晨一点，全天修理时间八个小时。此前，炉头多次修理，多是分火盘和喷嘴积炭，清理便好，而今天似乎没这么简单了。早晨，炉子反复拆多次，总算折腾出些小火苗，烧了热水上路。晚上，又把炉子拆得七零八碎，能拆的都拆了，不能拆的硬拆。话说炉头是借朋友的，肯定比主人分解的厉害，因为没他那么爱惜。发现症状，是油管和喷嘴连接处的细管堵塞，内部，垂直，针眼般小，根本没法疏通。不知拆了多少遍，折腾了多少次，很焦心，依然无法打通淤积，倒是把汽油弄得四处。一次点火中，帐篷里火焰腾起，以最快速度将油炉扔到帐篷外，然后扑灭帐篷里的火苗，万幸，无大碍，只是防潮垫烧黑一块（帐篷等都是防火材料，只融不燃，速度快可避免杯具）。若迟疑一秒，后果不堪设想。实在无法，我已接受现实，炉子彻底废了，一路冷水泡糌粑何妨？客观说，这个打击是非常巨大的，在羌塘，如果连基本的热水都无法保证，确是和慢性自杀等同。至于烧牦牛粪，那是过度的浪漫主义，不现实。正因此，我又侥幸的一试再试，把喷嘴拆下，当废品折腾，直烧油管。忽然，“嘭”一声，火焰蹿升，烈焰熊熊，又是连忙把炉子仍到帐外。心里却是兴奋，炉子被烧通了？等火焰熄灭后，再次试验，果然，炉子正常了，真是死马当做活马医的一次典型案例。爱迪生试验灯泡，最后一刻，世界亮了。 右首若拉岗日相对高度低，浑圆无势，总有上去溜一圈的冲动 左首可可西里山脉，呈现钥匙形态，玩味 稀有的厚草甸，牛粪随地，远处黑点是牛不是粪 这个拍照姿势有点像芙蓉 D50（6-8），23.9K，宿营4833M整五十天了，却是迄今最狼狈的一天，究其原因，雪的节点。一天无照片，艰难前行。天空阴沉，大风裹挟冰雹时起。前路缓下且平铺，视野模糊也无妨，心里多少有些迷失感，全靠回望车轮印判断直行。唯一陡坡上演完美前空翻，顺坡溜一段，刹车早已真亦假，速度快，见一个沙坑，心想不妙，少顷前轮陷死，人被甩到空中。意识清晰，想着摔在沙土上没什么大不了。随即三百六十度前空翻落地，没有一丝卡带，就势爬起返身扶起自行车继续推行。稍后，才想起先前的流畅，一番自嘲，真是帅呆。下午七点过一条宽河，不再是小河小沟，四条主道，十多条小河岔，先探路到对岸，确定河底软硬分布。回程中，大风夹着鹅毛大雪扑面而来。恐怖的序幕终于拉开，雪不再干硬，而是着物即化的湿雪，衣物快速湿透，有如水捞。羌塘，不怕下雪，不怕刮风，可一旦进入雨季，雪变得又湿又软，加上大风裹挟着湿空气，挺不了几分钟就会把人体温抽尽。另外，湿雪也直接影响到地表变化，那就是沼泽和烂泥回归了。淌在回程的水中，挣扎着，是先扎营休息，等天气好转再过河？还是趁摸清了水道长痛不如短痛？答案是选择短痛。下身是水，一片冰寒，上身湿透，前方那鹅毛大雪封了视野，完全靠先前的GPS轨迹过河。半途便不支，浑身发颤，强忍着在水中推行。过河，即刻扎营，脱下湿衣，钻进睡袋，然后首次在内外帐之间生火烧水，来回三趟，一点五公里，体温低到极限。若论羌塘冻死，唯雨季风险最大，因为来不及防范，就可能在一场猛烈的冻雨湿雪中丧失体温。今日，天气的渐变，雪的节点，超轻羽绒服彻底进入了历史，换上劣质冲锋衣（此前50天只穿过一次），着装开始以防水为主。关于着装和气温变化单独简说了一段，后见文。 完美营地，西羌塘清澈湖一带（今日无片，借用去年） 野生动物乐园，和谐共处（今日无片，借用去年） 关于着装和气候【气候与体感】混沌但有逻辑，照顾好自己。此行羌塘横行高纬，只有节气变化，跨度4-7月份，海拔高于羌塘平均水平，世界屋脊之屋脊，地势西高东低，落差在400米左右。（不算阿尔金）。相同节气，东部雨水比西部多。小型风暴团频繁，区域性气候主因，夹杂冰雹，一天经历五个也不算多。从羌塘夜间温度来看，常年寒冬，从白天温度来看，四季皆有。通过近十年周边县市气象资料分析，推测羌塘腹地四月份夜间温度在－10℃-－25℃间，白天温度则受外界因素影响大，常态均在0℃上，天气受冷高压控制，季风猛烈，湿度低，沙尘大，降雨为固态。羌塘后期进入雨季，受印度洋暖湿气流影响大，对流天气频繁，固态降雨变成湿雪、雪球、冻雨等半固态模式，夜间温度在0℃-－10℃，极端可达－15℃以下，白天温度同样变化大，最高可达25℃。之前预测的温度变化通过实测是完全正确的，理性的，不夹杂超低温流言。今年，羌塘雨水偏多，温度偏暖，雪融性洪水和降雨共同引发河流失控。事后得知，昆仑山全线洪水，东侧格尔木市险些被上游水库冲决，西侧玉龙喀什河将淘金者围困，和田河也多年罕有的全程贯通塔克拉玛干大沙漠，至于昆仑山中段则亲身经历了。羌塘温度一日最低点在日出前半小时，最高温度通常在下午四点至八点。这种温度的高低分布与高原大气密度和地貌引发的辐射变量有关。体感温度则富于戏剧性，最高体感在上午十点左右，即便前期四月份，多次可只穿抓绒。最低体感通常在下午，如此倒置跟风力变化有关，风寒效应是体感变化的主要因素。纵观全程，前期低温体感并无显著不适，后期高温反而有多次全天冻僵，原因很复杂，即有后期的湿度、河水、装备溃烂的影响，也有身体摄取热量过少有关。如果各用一个字来表达羌塘前后期的体感，分别是“冻”和“冷”，前期“冻”得手脚麻木、脸歪嘴斜，但没危机感，后期“冷”得浑身发颤，体温似被抽尽，随时呜呼。【着衣】实用唯上，素色更好。此行着装很大胆，从专业角度来看很菜。也的确因减少负重而没带备用，吃了苦头。服装标准是按白天－5℃+八级风寒效应装备的，体感大致在－30℃左右，都为精品。可惜衣物在江孜县尽失，只剩身上所穿，随后极简（但并未脱离气温因素），在拉萨买了一套极星抓绒和非户外的超轻羽绒服御寒。夜间由睡袋和密封帐篷限制了空气对流，风寒效应指数小，比较容易掌握体感。前五十天着装：超轻羽绒服+极星抓绒套装+普通冲锋裤+普通内衣+GOX登山鞋+冲锋衣和救生毯各用一次。五十天后着装：劣质冲锋衣+极星抓绒套装+普通冲锋裤+普通内衣+GOX登山鞋+救生毯用一次。 可见，前期着装并不多，原因是运动状态，身体自身热量大，一旦静止时间超过五分钟，体感温度会明显下降，超过十分钟，那还是赶紧起来锻炼身体吧，好在休息时间都很短。衣物具体如下：超轻羽绒服：非户外，忘了什么杂牌，充绒90几克，春季款，非防水防风面料，前50天主穿，实际效果好，冲锋衣只套过一次，堪称奇迹。破洞多，用透明胶粘贴，第50天湿透后再没穿过，第58天丢掉。假THE NORTH FACE冲锋衣：不到三百块，前50天只穿一次，套在羽绒服外，50天后主穿。携带劣质冲锋衣是考虑磨损因素，只当雨衣就行，岂知太假，失算。探路者普通冲锋裤：轻便型，兼顾热天，全程穿，第18天开始裂缝，后期连犀利哥也不会瞧一眼，原因与气候恶劣、盐碱腐蚀有关，材料明显老化，防水贴条最先脱落。极星抓绒一套：普通加厚型，全程穿，感觉不错。普通内衣：天气总体干冷，对排汗要求并不高，带两套，扔一套。探路者GEX登山鞋：有过四个月使用历史，很舒服，轻便，质量不错，全程穿。第27天鞋面裂缝，后期破的连犀利哥也不会瞧一眼。主要原因是没带备用鞋，过于单一磨损，加之盐碱腐蚀，牛皮面老化。正因破鞋破裤破衣，后期惨遭雨季蹂躏，险些废脚。有条件，要买最好的登山鞋，脚是命根子。洞洞鞋：轻便，质优，第58天过河时先后被冲走，因公殉职，默哀。袜子：一双普通厚袜，四双迪卡侬徒步袜，后期磨损严重，基本是光脚走出无人区。手套：一双薄抓绒，一双军厚，一双极星专卖店买的杂牌，五双白纱。9.9块的薄抓绒是最冷季的主力手套，杂牌（还是最贵的）保暖性还比不上薄抓绒，军厚手套后期为主。出无人区时，就只剩一支军厚。雪套：没用一次，雪大戴雪套也走不了，雪小戴雪套累赘，过河戴雪套还不如赤脚，陆续扔。迪卡侬抓绒帽：全程穿，昼夜穿，劳苦功高，现仅存的羌塘遗物之一（后期弃车逃命，装备基本全扔），可拍卖换烟。360度遮阳帽：未用一次，第10天遗失，望捡到者拾金不昧。护膝：超市普通型，棉制，很好。护腕：一双连指型，全程穿，一双魔术贴型，未用一次，均该他用。救生毯：十元，效果好，用两次，不耐用，一场大风就把锡箔打得差不多了。魔术头巾：多用做汗巾。简易冰爪和护肘：第一天就扔。此行衣物最大杯具是衣物尽失，后期极简弥补，最大失误是没带双备用军胶、外裤，冲锋衣失算，袜子太少。如果驾驶越野车深入羌塘，自身热量少，衣服要加厚，不然会冷的骂娘。 关于装备装备永远是消耗品，不要被装备玩。装备体现对旅行计划的实施，很繁琐，仅束缚类就有6MM登山辅力绳、4MM登山辅力绳、1.5M魔术贴捆扎带、1M魔术贴捆扎带、20CM魔术贴捆扎带、硅胶弹力带、普通松紧绳、红头风筝绳、凯夫拉鱼线、两色缝补线、5号铁丝、2号铁丝、大号长尾夹、小号长尾夹、橡皮筋、别针、小快扣、主锁。所以只介绍部分装备，以供参考。美利达公爵自行车：入门级山地车，如果不是竞速竞技，足够好了。尼康D80相机：几年来的出生入死，更加证明了经典。至于镜头，利用好了，只发帖和杂志使用，和牛头之间并没有不可想象的差距。如果你想大幅输出展览，特殊摄影，镜头越牛越好，最好全幅CCD。佳能HF100DV：再昂贵的家用高清始终是鸡肋。GARMIN60CSX：困于GPS技术，后续产品往娱乐化发展，其核心技术未变，荒原旅行GARMIN60CSX仍是不可替代的经典。MSR耳语者油炉：省油，轻便，易维修，经典。HW1.5层单人帐：专为特殊环境设计，缺点自然也明显，就是结露严重，每天与冰同眠。质量超乎想象，全程帐杆无弯曲，帐布无破损，但防水胶条皆松脱，好在羌塘无液体雨，无渗透现象，相比价格，国外品牌也未必做的到。Ontrip防水睡袋：朋友的，质量好，同HW1.5层单人帐使用是绝配，否则麻烦大了。DEUTER防水驮包：防水面料皆易在低温下脆化，廉价的DOITE驮包稍加改装足以胜任羌塘恶劣环境，包括DOITE车首包。太阳能板：尽量自己组装，减少功率损耗，至于推荐，因物而异，但至少要有点基础电工知识，不然四处请教也是雾里看花。熊猫10×25MM望远镜：国产正牌就够了，除非军事侦察。又鉴于其重要性，带个好货更好，注意镜头畸变、边缘成像、通光量、倍数、分辨率、视场等。Nalgene水杯：一个好的水杯比水袋还重要，特殊环境下，广口比窄口好，透明比非透明好。Therm-a-rest防潮垫：从来不用好防潮垫，把它当做绝对消耗品。这次是借朋友的，效果好，质量优，但从舒适性和保暖性上来说并未有很大感触。但一个好防潮垫最大的问题是，质量太好了，一次艰苦的旅行结束后舍不得丢弃轻装行。fenix LD20手电：体积小，营地照明省电，三防，强弱光兼备，照明防身兼备。从实用角度看，一个好手电要比一个好头灯重要。Turning铲子：强力推荐，这款铲子找了很久，只有五百多克，钢口好，可当刀斧，紧急情况下有效防身，重要的是可通过安检。缺点是铲面小，煎鸡蛋都得小心，只适合土木工程不大的旅行。LED打火机：两块钱的那种，从性价比、功能性角度来说，它都是无敌的。尽量在高海拔县城购买，要磨轮的，此行带了八个，剩两个出来，送一个给朋友，他一听说是从羌塘里带出来的，利马还给了我。360度遮阳帽：虽然在着衣一文里提过，虽然遗失未戴一次，但还是要再说一遍，目的是为不要因大意，或为证明自己去过高原、走过艰苦路线而把皮肤晒黑，事实上得不偿失，隐患很多。此行即便天再热，也绝不会脱手套、卷裤腿、露胳膊，忍点热是超值的。迪卡侬指南针：任何情况下都要带个传统指南针，电子罗盘不可靠。6MM登山辅力绳加主锁：在减轻负重前提下，一根6MM登山辅力绳足以保障你的安全，若懂些绳索知识，仅配合一把主锁，会让弱者变成强者。在减负前提下，绳索最适宜配置应是8MM+6MM登山绳。（绳索使用谨慎。）墨镜夹片：羌塘紫外线高，保护眼睛很重要。有可能多备一副，我的眼镜、墨镜都被冰雹打花的不成样子了。组合钳：必带。尽量优化修理工具，很多功能都是重复的，重量自然也重复了。12V电压表头：现代电子产品都是集成芯片，坏了就坏了，要么就是线路问题，一个电压表头足以排查线路，如果和太阳能配合，电池充满了一测就知道，省去大量充电电路管理。各种小仪器：尽量采集些气候、水文等信息，带着问题旅行会学到很多新东西。暂时想到这些，随意简说。装备跟个人习惯、线路有关，仅供参考。一分价格一分货自然不错，但大多旅行远未达到装备精益求精的地步，实用就好。对装备要有包容，没有什么装备能让人变成超人。有必要，就稍加改装，也没有什么装备是特意为每个旅行量身定做的。多和别人交流，但不能迷信经验，要以自我为中心。注：特殊领域必须专业装备，知名品牌质量更好。 D51（6-9），0K，宿营4833M天气未见好转，阴沉，冷风，身体还未缓过来，蜷缩到十点钟起来，依然裹在睡袋里烧水热身。烧水过程中，又吃起糌粑粉，已然成了常态，糌粑粉成了无法抗拒的零食。无需水，满嘴粉末，如果不加限制，可以连续吃掉二两，竟也不觉得口干舌燥。下午一点，多云，太阳时闪，裤子干了，鞋子阴湿，羽绒服还在滴水，穿上拖鞋，披上正式上岗的冲锋衣在周边溜达。原本只是溜达，稍微探下前路，没想越走越远……先是登上河边一座沙山，瞭望前方见是一片沼泽，于是下山往北查看有无硬土通往高地，以便绕过沼泽。下山，干河道，草地，小海子，河滩……大约走了三公里终于确定可借高地绕过沼泽。回程中，土坑里窜出一只狼，闪电逃遁，因为连脸都没看清，此类遭遇均未归入猛禽数据里，或许是只狐狸什么的。但被狼这么一闪，居然迷路了。上了沙山，沿山脊边行边往下张望，可怎么也找不到帐篷。由于昨日阴霾天气没有显著坐标，对岸一片稀疏草地不分彼此，营地附近地标物更没留心，导致俯瞰山下河道基本一个摸样。一会儿觉得帐篷在东，恒下心往东寻，觉得不对，又恒下心往西寻……如此反复数次仍没发现帐篷。又开始认为帐篷被沟壑土坎挡住，于是下到半山东西搜寻，即有视野又少阻挡，未果。又沿着河边滩涂东西搜寻，总能找到昨天过河车印吧，未果。真是见鬼了，心态有点失衡，胡思乱想着。如此一段短程，且有河道可循，怎么帐篷会找不到呢？糟糕的是，午后的小风暴团生成，那边一团，这边一团，雷声此起彼伏。再找不到帐篷会很纠结，睡袋、衣服都在帐外晾晒，更纠结帐篷会被风刮走，临走之前未有任何加固，溜达嘛。一片冰雹已经扫到了我，顾不得，再恒心，告诉自己，不能再疑神疑鬼、犹豫不决，一直走到河西端一个小冰湖，冰湖之上是一片沼泽，这说明，帐篷必在相反一端，但又不能百分百确定，纠结啊。再恒心一直往东，一直走，不管内心忐忑，反正见鬼了就见到底吧……六点多终于看见帐篷，真激动，那可是家，荒原里的归宿。好在没哪个小风暴团扫到帐篷，正庆幸，一股大风将睡袋吹了数米，离水咫尺，真险。折腾的够呛，甩掉拖鞋上的泥，躺在帐篷里一边干吃糌粑一边反省，到底缘何？至今仍无答案，在谜一样的河流边茫然徘徊数个小时。 上午还未完全缓过来，依旧裹着睡袋烧水暖身 D52（6-10），18K，宿营4824M早行，推过沼泽边缘进入山地，眺望，真是英明决策，冬布勒山（东西转南北走向，孕育了若拉冈日、冈盖日等众多雪山）和五泉河之间的开阔地带皆是融化沼泽。山地遍布黑色火山石，点缀在浮土稀草间，土质干燥，底部干硬，发现多条野牦牛通道，追随一段。有段地貌类似连绵不绝的火山锥，确实不是，但遭遇那头搞笑野牦牛就在此处。牦牛堵在前面，我走就站，我坐就坐，我绕行就横堵，却无任何示警动作。我乐得顺带休息，他也惬意的继续晒太阳。通过外貌简单判断是一头衰老母牛，其诡异行为难以揣度。相持许久，见牦牛毫无让路的意思，便哄闹一番，这才懒洋洋的远去。丘陵缓上缓下，土质湿软，有局部陷土。今天状态一直不好，无力感，迷迷糊糊的，早晨就忘了装水，余水不多，过了中午就开始留意水源。五点多发现小河，近前却是泥浆水，又寻了相邻一条小河，还是泥浆水，所汇和所源的两处洼地皆如此。无奈灌了一壶水，想着一夜沉淀，晨用。灌好水不久，强对流天气袭来，三个大型风暴团相互拉锯。环顾周遭，一圈闪电，见此景便急速扎营，这般厉害的对流天气并不常见。刚顺风搭好帐篷，风向便猛烈掉头，夹着冰雹，骤然增大，帐钉瞬间便被弹飞，若不是手快抓住帐篷，被吹走就不会有往次好运气了。手根本抓不稳帐篷，身体倒进帐篷里压住，脚踩手按，帐篷变形，根本无暇顾及头顶滚雷是否会击中。如此靠身体压帐二十分钟才平息，作为帐篷，这是他经历的最大一场风暴。作为一款超轻单人帐，它要比我在这恶劣的荒原中承受的更多，当下，防水贴条已基本脱落，幸在无妨。 绕过沼泽上高地，即纠结也很危险 冬布勒山下的消融沼泽，若从中穿越，会成茶几 山地遍布黑石火山石，土质干燥，浮土厚 搞笑的牦牛，我走他站，我坐他坐，我绕行他横堵 破烂的鞋子，还不是最糟状态，却让人已经很纠结了 从高地上遥看冬布勒山，他由多座六千米雪山组成，都差不多高，难辨主峰 强对流天气，用身体压住帐篷 帐篷连接处的防水贴条基本脱落，帐篷比我承受的更多 D53（6-11），17.3K，宿营4830M昨日风暴过后小雪稀拉，晨，铺了薄薄一层。泥水沉淀一夜后好很多，烧水过程中翻起一股土腥味，倒掉，掠了一堆薄雪重新烧水。今天的路很难熬，以为小雪，可越往前走雪越深，有些厚达二十厘米。偌小范围内降雪就如此不匀，可见昨日那场强对流天气的乖张。脚受累，湿雪变湿脚，冷的不行。丘陵之间的谷地充斥着沼泽，由于雪覆盖，很难分辨，最长的一段沼泽初探时还是大雪全封，刚探完路便融了很多，水溢，泥沙也软下来。不再是湿脚，而是鞋子灌水泡脚了。过了沼泽后绕自行车跑了几分钟，把脚找回来。自前天湿雪开始，灌水鞋泡脚就一直延续到出无人区，中间只有几天幸免，最初还倒倒水拧拧袜子抖掉泥沙，到最后就麻木了。整天都这样水路，一遍遍的无用功罢了，却为后期脚疾早早埋下了祸根。小风暴团一天几个，无视，应付不过来。但大风暴团就不行了，尤其临近晚上的风暴团，基本就地扎营，否则浑身湿透晚上很难熬。下午四点进入一片平坦湖床，经历了一个超强风暴团，先是天空黑如夜色，闪电闷雷不断，随后风头夹着冰雹涌来。第二次用救生毯把自己裹起来蜷缩在车子后面。没法测风速，太大了，冰雹密度也是罕见。找词汇形容当时的场景很难，那种感受只有亲历才能明白，真是天地间鬼哭狼嚎。很担心头顶滚过的闷雷击中自行车殃及自己，但实在没地方躲，也来不及躲，手都伸不出来。虽没测风速，但体感上绝对是最大的一次。十多分钟结束，雷声远去，此时地面被冰雹完全覆盖，真疯狂。不久离开平坦湖区，进入草地，冰雹稀落不堪，估计那场风暴团里的冰雹大部分都砸在我头上了。离风暴团四十分钟后遇见一头棕熊，非常有意思，近处才发现，对方似乎也如此，双方都有点催眠状态。棕熊慢腾腾的斜插一会，然后径直朝我走来，停车致敬，那熊便走到车前面，晃悠悠的，我也没绕行，前方不远就是双湖至阿尔金的南北线，便跟在后面慢慢推。那熊走一段回头等我一段，我默契的与之保持一定距离。那熊忽在坡顶停下，用脚掌拍鼠洞玩，我趁势休息。过了一会，熊不见了，我推到坡顶后发现他还趴在地上候着，却没了继续往前走的意思。没有理睬，但也万不敢超越他，便放倒车子，斜插向前方去找南北线，不过百米，就发现了南北方向的深车印。再看那熊，慢腾腾的起身走了。这几天怪事多，谜一般的迷路，搞不懂的牦牛，光砸我脑袋的冰雹，带路的熊。算下来，我和这头熊前后同行了近半个小时。以前就听人说过，熊会给人带路脱离险境，估计也就是这种夸张放大的巧合。到了南北线需要做一个很大的抉择，就是该往哪里走？当下，不存在什么逃生路线了，北上，南下，东进都差不多，只剩下选择。顺着南北线各探了几公里路（探路过程中一直担心那熊会把干粮给偷吃了），车印很清晰，至于前往何方难以决断，因素太多，轻重难辨。晚上想了很久，也没明白，反而乱了心智，就这么迷迷糊糊睡去。 过这片沼泽折腾死 破鞋子成了最大的障碍，那种灌水后的湿冷难以忍受，鞋子的轻便性更无存了 小冰雹团很多，在荒野四处游荡 一场超强风暴团，想测风速，手伸不出来，同时也担心会成为引雷体 很玩味的棕熊，彼此相见时都有点催眠状态 见他径直走来，一紧张，手一抖，跑焦了 D54（6-12），0K，宿营4830M昨夜迷迷糊糊睡去，中途迷迷糊糊被闷醒多次，胸口如压巨石，喘不过气来。再次被闷醒时，见天亮了，但帐篷上明下黑，用手一推才知被大雪埋了。这是此行遭遇的最大一场雪，深度三十至四十厘米，帐篷周边更深些。后怕，帐篷下面被大雪完全封死，内部只有一个小透气窗，半掩着，冰雪又封了一些。简单计算，夜里帐内氧气含量比珠峰峰顶还低，这还不算二氧化碳的致命影响。半夜被闷醒多次居然浑然不觉大雪，熊都不理我，若被闷死这可怎么跟自己交代。上午都被困在帐篷里，远处有牦牛在雪里扒草，这过得什么日子。下午往东探了一段路，然后回来仔细研究，最终确定了行往何方，答案是南下。且听三个方向当时的分析，一是东进，计划沿沱沱河从唐古拉乡出来，直线340公里，直线150公里可能有牧民，200公里可确定有牧民，就算解脱了，然后顺大路出去。二是南下至双湖，直线250公里，由于南北线南端牧民非常深入，所以直线90公里就可确定遇到牧民，算是解脱了。三是北上阿尔金，没研究，只有两个模糊的信息，有硬路和在直线200公里的阿奇克库勒湖可能会有个“小饭店”。（以上均直线距离，和实际行路有差别，仅是技术分析，当下方位多格错仁强错西北角。）不选东进，是因为要穿越多格错仁强错和可可西里山脉最高峰岗扎日之间的泽水地带，（注意多格错仁强和多格错仁强错是两个不同的湖，一南一北，相距90公里），之后还有一片相连的低洼湖区，此季可以想象一片沼泽，如果遭阻没有方向可遁只能退回，这就需要足够的食物做保障，以及心态和装备状况，显然做不到了。不选北上，是因为对阿尔金没多大兴趣，就像罗布泊，觉得过分热闹了。阿尔金资讯很丰富，探矿的，捞卤虫的，自驾穿越的，后勤保障徒步的，包括丁丁和老苟去年的首次羌塘穿越……因压根就没想到会从阿尔金出来，所以即没做这方面功课，也没设计线路。两个有用信息，一个硬路早知，二是阿奇克库勒湖可能会有个小饭店，丁丁游记中记载。（实际上“小饭店”是风尘口大阪下面的回民帐篷，为淘金探矿人服务的，一直以为在阿奇克库勒湖附近。）选南下，因为一周左右就能遇到牧民，获得补给，然后从设计的长峡河路线翻过冬布勒山沿沱沱河出来。即便外星人把所有牧民掠走了，也可相对轻松的从双湖出无人区。从三个方向分析可知，南下安全容易，伸展性大，北上未知风险多线路长，东进季节因素影响太大，没有回旋余地。最终结果，大家已知，是走了最纠结的北上路线出来。人生，往往最后走的路都是最不想选择的路。 夜里大雪差点闷死，太不光荣了 下午天气依旧不稳定 这就是可可西里山脉最高峰冈扎日，也是西藏和青海的行政分界 D55（6-13），6K，宿营4803M晨，穿上湿鞋子，需要一点勇气。决定南下前往多格错仁强寻找牧民，除了想获得补给，还希望能搞件裤子和一双鞋子。大雪还封着路，困难的不是雪，而是薄雪下的冰水，所以每一步都很揪心，水直接渗进鞋子里。脚冷的厉害，身体也是，整天微颤颤的。小沼泽遍布，有些露头，有些被薄雪完全覆盖，所以确定前路非常重要，尽量控制鞋子在渗水状态，若是灌一鞋水，便是最煎熬的体感。天气阴冷，下午五点坚持不住，扫了一片雪地扎营。吃糌粑粉，拼命的吃，把最后几瓣大蒜消灭掉，撑得人很难受。多天来都是这样，无法控制，一直撑到人弯不了腰。早期糌粑的吃法是做成糌粑粥，目的是可撑大肚子，减少饥饿感，流食也易于消化，另外，热腾腾的加了辣子的糌粑粥，能给身体快速提供额外热量。现在不行了，不仅得有热粥，得有货真价实的干货，还得有填补欲望的零食。 稍低洼处便成了积水沼泽 雪地推车，冰雪会粘住制动，但要比软泥好清理 薄雪下是层冰水，每一步都很揪心 五点便难支撑，扎营暖身 最后几瓣大蒜，留影纪念 D56（6-14），6.5K，宿营4805M上午，一片泽国，以及一条条不知何时冒出的小河，走的很艰辛，下午两点多进入多格错仁强错东岸的草地，状况才稍微缓解些，大车印也重新出现。回望来路，河水中央有一条红带，是刚被冲入河湖中的红泥水。彼岸岗扎日左侧的三座奇特山峰清晰可见，分别是天台山，白象山，还有一座火山残骸，没有名字，但自从三天前初见到八天后都一直围着它绕圈，缘分颇深。这三座山就是北上阿尔金的必经之路，也是可可西里山脉最典型的一段火山地貌。顺着车印沿湖南下，途中被一头牦牛尾随，也是难以揣度，不细说。没多久就被宽阔的五泉河挡住了去路，车印戛然止住。河畔有许多未开封的矿泉水，对岸隐约有几个油桶，用望远镜还能看见水中有一个红色车顶，推测是东风六驱卡车，行话叫“炮车”。四月份一定有越野车队穿越双湖至阿尔金，事后得知，的确有两支越野车队分别对穿了双湖至阿尔金。这条羌塘东部的南北线所谓第一次汽车穿越是2005年，两支队伍，也是对穿，一支民间队，由北向南，旗帜“人类首次无后援穿越中国四大无人区”，一支中科队（CCTV全程媒体），由南向北，旗帜“人类首次穿越可可西里核心地带”。这就撞车了，两支队伍同时对穿可可西里核心地带，谁是第一了？自然是拥有话语权的，当然民间的也可以申请吉尼斯（民间队的确先到达双湖完成穿越）。闲说瑞典人Corax 和Nadine早在2003年就用自行车的方式穿越了此线，47天，37天无人，美国国家地理频道为此做了个纪录片，名字叫《太累了》。2009年，丁丁和老苟作为中国人首次用自行车方式穿越此线，36天，18天无人，获得当年《户外探险》金犀牛奖。这条线之所以走的人多，因为相对易，还能戴上若干无人区的帽子。我最初也是设计此线，见热闹了就放弃。沿五泉河往西寻找早期地图上的过河点，一路泥泞，旱獭和鼠兔却是四处乱窜，多如牛毛，从未见过如此景象，可能是被大雪憋了两天全出来晒太阳了。到了地图上的过河点，水的深度和宽度不足以推车泅渡，更重要的是河底冻土化开，两脚陷人。再往西探了一段，是河湖沼泽，更难逾越。当时没带丁丁去年的穿越轨迹，不知他们怎么过河的，事后查看，他们就是从之前的过河点通过的，日子只比我早23天而已。更恨了耽搁二十天进羌塘。被淹没车顶的车子于四月五号遇难，那时河面还是厚冰，只是运气不够好。晚上考量许久，两天来只推行了十多公里，这路没法走。眼前又是条大河，如果豁命也不是没有过去的可能，但是过去之后了？至少还要横切汇入多格错仁强措的三条大河以及大片的湖盆沼泽。除非弃车徒步（当日探路就走了二十公里，徒步通过性要强很多），当时还非底限，便很快打消这个念头。不过雨季羌塘的确超出预测，加上今年雨水多，更是一副吃人面孔。最后决定掉头北上，从阿尔金出去，这是最后一个选择，没法拒绝。从地理上分析，或许北上是条出路，因为要翻越数道山脉，属山地貌，沼泽大河会少很多。 喜欢这种小冰雹云，也是荒原游荡，随意江湖 没有名字的火山残骸，和它缘分颇深，半个月绕它240度。 白象山，一块突兀的岩石体，很美 没法逾越的五泉河 东眺多格错仁强错，冷暖色调相宜 车印旁扎营，做起拦路收费的营生 D57（6-15），15.2K，宿营4860M掉头北上，再无选择，所以定下心，再难都得坚持下去，时间也禁不起反复折腾了。轻车熟路，很快进入天台河谷，眼前景象，大吃一惊，宽阔的河床充斥泥水，而四天前到此探路时还是清水山涧，河岔跳脚就可逾越。之后四个小时，在泛滥的河床里只推行了两公里，看来北上也被理想化了，甚至更糟。还是心存幻想，顺着天台河翻上可可西里山脉就好了，如此继续坚持。过河的主要问题是无法看清河底面貌，只能用脚一步步踩，从而确定是稀泥、软沙、石砾。河道中间的滩涂同样无法凭借外貌分辨软硬，有些看似石砾硬底，却是比稀泥还软，有些看似漫水稀泥，却是硬如水泥，当然，有时又和外貌完全吻合。一切没了逻辑和规律，每步都要用脚踩探。泥似胶水，粘性大，车子被陷几次，把驮包卸了都很难把轮胎从陷泥里拔出。宝贝似的拖鞋先后殉职，一次过大河道，水急，脚一抬，鞋子被冲走了。一次陷在稀泥里，脚一拨鞋子留在原地，顾不得，赶紧把车给弄出去，回来捞鞋子，连影都摸不着。拖鞋丢了，对过河打击是非常大的，这才刚开始。 前轮陷死，驮包取下都难拔出来 没有逻辑和规律，这稀泥状硬如水泥 河谷往上变窄 D58（6-16），6K，宿营4872M河道满溢，无法通行，只能推上山依河而行。山顶俯瞰河道一片红色血腥，传说中的正宗红泥河，想要过此河，首选要克服半米厚的淤积泥沙。当时，已经意识到途径错误，（地图和地貌都有误导），应该在河道左侧前行，所以一直寻找河道窄处过河（窄，水流大，淤泥少）。就像某个朋友看照片时说，水没有想象的大。高处俯瞰的视野的确容易迷惑人，我也因此从山上两下河道，皆有被骗之感。第一次下山，近七十度推下，很爽。用光脚探河，深度，河底面貌。探河又出现几个新问题，一是狭道里的水流更急，河水皆雪水融化很冷，急水如风寒效应放大了水的冷度，每次探河也就几分钟必须上岸暖脚。有过惨痛教训，某些淘金者过浅河，因脚冻麻无法站立，竟被过膝的水活活淹死。二是光脚在石砾河底无法发力，跟碎玻璃似的，这也是拖鞋非常重要的作用。三是“混凝土”，一旦陷到膝盖深就很难拔出来了，等着被冷水终结吧。《可可西里》中流沙是被艺术化的，可怕的是那种泥沙混合体，类似混凝土，轮胎陷20厘米就很难拔，更何况人。并未探到对岸，水至大腿基本就无法站稳，失温更快。尝试一次性推车过河，很冒险，豁出去，被水流冲翻，十来米，脚踩到硬底赶紧上岸，宣告失败。然后再七十度推上山，寻找下一个两山之间的窄道。第二次下山，又是被迷惑，到了河道近处看了一眼就觉得胜算不大。探了半个小时河，没有通路，光人都过不去。最后一次还是冒险策略，推车强渡，豁出去，也许就成功。一直循着先前探路的轨迹过河，撑到离对岸几米的地方，接着水底是一道沟壑，自行车瞬间失控，侧翻，人被斜压着，一脚一脚的撑，撑到硬地，赶紧上岸暖身，宣告失败。接着再上山，难度最大的一次，局部八十坡度，推到三十米高处垂直无法再上，也不想回绕山顶，便横切山坡到缓处。横切前，休息了很长时间，心中不断默念，小心，万分小心。近八十度，坡面是一层松散的片岩碎石，脚下几十米即是河了，若一失脚基本就控制不住了，所以小心，万分小心。横切最难的一段后，好很多，连着切过两座山，下到另一谷底。河道非常窄，试探一下还是过不了河，心情很糟糕，身上冷，天气坏下来，天色也渐晚，便扎营，等着明天早晨低水位时再过河。很累，找水很尴尬，身依大河却不能饮用，太浑浊。滩涂上找到一洼水，清澈，估计是积水沉淀，烧开后竟是碱水，苦涩不已。推测洼地原本就盐碱渍沉积，水被污染，于是又找了一处洼地，淡水，却有些混。晚上吃很多，积蓄力量明晨过河，谁知…… 眺望天台河谷，血腥一片，远处就是天台山，很像千层雪雪糕 与此山平视了，由南向北，很远就能看见这座山，朝他走，进入河谷，翻越可可西里山脉 白象山近影，很优雅 两座喜欢的山的合影 D59（6-17），0K，宿营4872M晨醒，听见帐外一片流水声，出来一看，大惊，昨天的窄道不复，扎营的滩涂被洪水围困，赶紧收拾装备推出水域。这个打击太意外了，河道在一夜间扩宽四倍，还险些把帐篷冲走。让晨水位低时过河的想法见鬼去吧。天气倒是很好，把驮包里湿透的东西拿出来晾晒，也是盘点。辣椒酱彻底没了，茶叶剩两小块，盐也剩一小把了，其余的紫菜什么的早就没了，（搞不明白，怎么一下子消耗这么快。）压缩饼干剩五包（2.5斤），可恨当天又吃掉两包。闲说这压缩饼干很有故事，2006年6月20号生产，保质期4年，意味着3天后饼干就过期了。先前就发现这个问题，找老板，他说阿里干燥，饼干没事，我也就没再纠缠。快过期，饼干确实没事，但结块严重，有些需要用铲子才能砸碎吃，有些漏气，稍许变味，总体来说，没出多大乱子。下午携带GPS、地图轻装上山前往天台河上游探路。地图很有意思，天台河上游有个近九十度的拐弯，直行是条季节河百流河。到了两河交叉处才发现，所谓的长流河天台河很小，季节河百流河则一片宽阔滩涂，望而生畏。先前判断是正确的，百流河是岗扎日等数座高大雪山的汇流，怎么可能会小于可可西里山脉为源的天台河了。但此时已经更难过河了，顺着天台河翻越可可西里山脉。（地势上，对岸草坝，此岸山地死角。）从百流河源头绕过又绝无可能。在山顶上坐了很久，这才深刻意识到此时的羌塘才是绝对无人区，没有探矿的，自驾穿越的，淘金的，盗猎的，出风头的……回到营地，继续不停的吃糌粑粉，虽然食物如此匮乏了，但还是控制不住内心的欲望。往往打自己一巴掌后没多久又忍不住抓出半碗糌粑粉舔吃，此时的状态接近本能，就是吃，像猪一样的思维。至于过河，我还是幻想着明天水位会退去，这是唯一的选择，便是等待。 晾晒饼干，当天又吃了两包 晾晒茶叶，最后两小坨 辣椒粉（酱）彻底没了，很怀念辣的味道 纠结，烂裤子和倒数第二双袜子 红河水，刺痛感 水位标示，每一小时更新，最后逃脱和详细的水文记录有很大关系 D60（6-18），0K，宿营4872M水未退，反而又涨很多，典型的雪融性洪水，跟降雨无关。等待，继续等待，谁也不知要等到何时，非常煎熬，那种感觉就是日记上的N个感叹号。为了抵挡食物的诱惑，时而爬上山顶睡觉，晒太阳，走神，眺望，听歌。有时也会走远些，没有目标，只有让自己动起来，才能分化低落的情绪。天气总体好，但几场冰雹还是难免。能平地活动的地方就是半个足球场大小的峡谷死角，铺垫着很多火山石，有许多土红色的，还有些硬草根，对植物了解不多，但藏北很多牧民会用它引火。 背倚可可西里最高峰岗扎日，至山脚直线距离约25公里。 红色的火山石，块头比黑色的都稍大 夕阳漫步，顺着河水一趟又一趟 被冲刷下没多久的沙尘 D61（6-19），0K，宿营4872M第四天了，堵在峡谷死角里。等待就像抽烟，让人难以在恰当的时候放手。如果有足够的食物和香烟，这或许是一场不错的度假。如果可随意的抽身，旅行也许就没那么深刻了。的确，对前路失去信心，觉得走不出去了，但在生死存亡的问题上从未动摇。很矛盾，即觉得走不出去了，又不认为会消亡于荒野，那是一种什么状态了？就是混吃等死。（本来想形而上的描述这段心理，觉得又把简单的东西复杂化了，就是混吃等死、胡思乱想而已。在搞不明白宇宙边界和量子空间前，我们总是会将世界复杂化。）下午开始为突围做准备，将世界简单化，就是此岸到彼岸。将车子调整一番，清理掉两个驮包，使之轻便快键。在清理其中一个驮包时，居然在夹板里发现一块德芙巧克力，哦的神啊，吃完巧克力，又把包装纸给舔了个遍，那“牛奶香浓，丝般感受”原来是有前提的。肚子闹得厉害，再次欣赏水波星空，然后整夜失眠，胡思乱想，很危险的情绪。 从山坡眺望帐篷，每天N次随意溜达 清理掉两个驮包，简装准备 如果不在山上和河边，那一定在帐篷里舔食糌粑粉 黄昏中河流，只涨不落 壮观云柱 D62（6-20），5.4K，宿营4891M河水一直未退，已不抱希望，这样的等，逐渐失去了意义。必须有所行动，不然真混吃等死了。有了几天的水文资料，虽然水一直在涨，但有其自身的小规律，就是下午5点钟左右是水位最低期。这似乎不符合逻辑，但事实大于臆测。中午开始在下游的一段河道里踩探，首先沿河每隔一米左右距离放块石头，目的是要确定河水中的位置，岸边石头就像经度，而维度靠相邻步数记录，确定河流硬底、水旋、沟槽、软泥的准确位置非常重要，光靠记忆是不行的，也是致命的。岸边再置一锚点，身系绳子，顺流斜切。到下午四点左右，终于像下跳棋似的到了对岸，极度狂兴奋，太不容易了。赶紧打包装备过河，这时发现自行车爆胎了，见鬼，这几天根本就没用过车。顾不得，先将驮包一一渡河，最后推自行车时还是被水冲翻，好在有惊无险。未先补胎，换上备用的，谁知走了不到百米又爆了。只好补胎，再查看外胎，发现触地的地方有一道四厘米的裂口，没带备用外胎（有点不可思议），只好用那副不曾用过的护腕加铁丝包扎外胎，勉强能用。装上轮胎，没走多远，又漏气了……先前极度亢奋的心情再难寻觅，臆想着羌塘真要留人啊。之前的62天里就补过一次胎，两个裂口，而今天两个小时内补了四次胎，六个漏气点。这才刚开始，自行车轮胎正步入崩溃的边缘。晚上，终于来到天台河通往可可西里山脉的谷地入口，累得没心思想明天，但情绪不再低落，总算动起来了，只要上山就好走了。 轮胎步入崩溃的边缘 没有备用外胎，如此外科包扎 D63（6-21），14.5K，宿营5013M早晨切过天台河沿右首走，左岸是沙漠化地貌。没多久下起大雪，湿雪，一大早的，没法理会，只希望下午能有好天气，只要扎营时不浑身湿漉漉就行。深入河谷，堆砌着密密的黑色火山石，棱角尖利，随处积水，主河道又把谷地割成一段段，因此只能推上山坡前行。路烂雪湿，一片蒙蒙，遭遇几只棕熊，都是在逃窜时发现，包括野牦牛。很有意思，视野模糊，动物混杂在黑色的火山石中，随着我的脚步临近，冷不丁的，东一头西一头逃窜，怪猥琐的样子。到了山嘴尽头，转下河谷切到对岸，过了数次河道，淤泥少，水急，不深，乱石河底，扎脚。赤脚探路很纠结，表面凹凸的火山石和稀疏的针茅草与人为难，天气又十分的糟糕。过了下午四点，天气才好起来，上游河谷大涨，只能沿岸湿地推行，沼泽坑遍布，期间淌过N条小河，很杯具的发现，只要是条沟，就一定大水泛滥，这些沟只算是次流的次流。轮胎又慢漏气，补了几次胎，心情沉重。六点半，撑不住，趁太阳大好扎营晒鞋。 晨，切过天台河 迷雾般的推行在河谷湿雪烂泥中 铺满黑色火山石的河谷 到处山涧，只要是条沟，就一定凶水 六点半就扎营暖身 D64（6-22），0.8K，宿营5020M凌晨大雪，一直到早晨九点停，百般聊赖，很难控制情绪。趁太阳出来，又去处理轮胎，刚补好一个，另一个地方又漏气了……差点崩溃。这是没有想到的，轮胎老化的如此严重，瞬间似的走向衰亡。只带了十三四片补胎片，三天时间就剩最后一片了，补胎胶水也危在旦夕。解决的办法就是轮胎充一点点气，只要不干瘪就行，生怕又触及轮胎脆弱的神经。中午把最后一块压缩饼干吃了，坚守了四年，只过期两天，吃的时候笑出来。决定继续往前，不能再这样耗着。一路冰水，比多格错仁强错湖盆区的严重多了，坚持了不到一公里又遇大河阻挡。此河是天台河上游和一条支系的汇合处，堵得人哪里也去不了。赤脚探河数小时，上上下下，主河次河，太急了，水底大石多，到大腿就没法站稳，水寒的也厉害。到了六点钟，停止折腾，抓绒裤湿的厉害，随便一绞两碗水。躺在帐篷里状态不好，担心又似前几日，水只会一天天的涨，所谓的晨时水位低的想法彻底见鬼。查看轨迹，离十天前扎营的地方直线距离只有24公里。反而清醒了，这是场持久战，像高手对决，活得长的人才是最终胜利者。再次清点粮食，只剩下五斤左右糌粑，比乒乓球体积还少的盐巴，一点茶叶，三两左右的酥油。计划吃十天，撑到鲸鱼湖，想象着那里游人如织，牧民如星，牛奶做成的湖，糌粑堆成的山。十天到底能走多远？真的没底，但心态忽然好的过分了，走一天是一天，实在不行就弃装备。现在回顾，那天是个很重要的心态转折，破罐子摔到底的耍泼。 大雪，大雪，大雪，虎，虎，虎 处理自行车，差点崩溃，人 不到一公里又遇洪水，纠结 沿岸来回探河，脚印相逢 D65（6-23），10.6K，宿营5024M昨夜，身体非常不适，熬到凌晨两点入睡。醒得较晚，八点，见大地冻得非常硬，令人无法相信的是河水退去的只剩底子，青石裸露，溪水潺潺，冰凌充斥，轻松踮脚就可以过河，神助。没吃饭，趁着水退地硬赶路。走在硬邦邦的河床上，对比过去几日，太不可思议了。硬地坚持一个多小时就开化了，前两小时走了3.5公里，剩下6公里耗到晚上，一直跟沼泽挣扎。中午到了可可西里山脉“山口”？连绵的大丘陵，杀机四伏。见过烂地，没见过如此烂的，那种烂不在视觉上，而在每一次落脚之后。看似正常的地面，一脚下去就像踩在豆腐渣里。这难道就是传说中的冻土消融？见过，但没见过这种。整片大地都是外焦里嫩的豆腐渣，野生动物也仿佛瞬间消失，不见一个，很恐怖的感觉。经验归纳，表面有碎石的沙砾地最陷，反而看上去水汪汪的稀草地是硬底，如果遇上表面有龟裂的红土就得小心了，它可能是妆术高明的稠性泥沼，陷过膝盖就难以逃脱了。过冻土消融地带，必须先用脚探，太软的不行，稠性大的反而有过去的可能，以前山地经验发挥了作用，就是短距离冲刺，飘脚，胆大心细。重点是控制距离和身体瞬间的平衡性，如果一口气没冲过去，不好意思，有的折腾了。（无路绕的情况下尝试，有危险。）有个案例，羌塘之前和朋友去林芝，一道浸水沼泽，四米左右吧，我在前轻松过去，鞋面都未沾泥，并告诫后来者要快，不要思前想后的。一个朋友很勇敢的做了反面教材，陷在沼泽里，人拉不出，后被木板搭出。这个案例说明什么？沼泽里没有支点，低头找下脚点是大忌，挑来挑去都一样，时间稍长就加速了重力下陷，再一挣扎，完了，形成重力怪圈，两脚越陷越深。车子屡次被陷，说严重的一次，纠结到底。绕陷地，见一块干硬的平坦地表，迅速把车推过去，完了，一脚陷脚踝，二脚陷半小腿，三脚弃车撤人，粘性太大了，再不撤来不及了。随后试着靠近拖车，无效，反而把地越踩越烂，地下水都踩了出来。再试着靠近自行车连边都摸不上了，周边也被踩得走样。折腾够呛，都考虑弃车了。但装备要弄出来，找了那十块钱的救生毯和两个防雨罩铺在地上，一番折腾，好歹把包弄出来了。再看垫脚物早没影了，光救生毯铺开就两平方。这时，自行车远远的就不能靠近了，放驮包的地方踩了几脚后也无法立足。转移驮包后，用铁丝套上绳子圈在自行车上，拉拽，车子移动了，后轮却被拖出……总算把自行车弄出来。遇到大面积深度沼泽就没办法了，没有技巧可言。途中两次大洼地，都对自己说过不去了，等明天上冻再走吧。经过反复试探，还是稀里糊涂过去了。遇过几次险，总之一陷到膝盖，利马倒地匍匐出来。这种沼泽是典型的冻土消融加雪水浸泡，其冻土表层融化，深处依然是常年冻土，所以那种《可可西里》流沙性质的很难存在，但一样致命，陷过膝盖就不要挣扎了，伏地出来。过了五点开始下山，真正到了可可西里山脉另一端，依然是条混浊的河，岸边、山野极度陷人，顺着一条野牦牛安全通道才下来。天色晚了，扎营地难觅，地太软太烂，不经踩。 大折腾，弄出自行车，还能发现之前的垫脚物吗？ D66（6-24），18.7K，宿营4886M收拾好东西，帐篷下是一个窝，地软人压。上午阴雪，下午四点钟后天气全面转好。上午唯一半小时太阳很神奇，那是顺着一条漫河进入一个山谷，此谷名曰兔子沟，兔子未见，却是小花绿草硬地，河水清澈，山石有型，非典型羌塘地貌，是一段难以忘却的行路。太阳也神奇的露出来，似乎在补偿上午的水泽蹂躏。快捷而舒畅的出了山谷，进入向阳湖的领地。北上阿尔金就是翻越数道山脉和其间的湖盆区，先后是可可西里山，向阳湖区，红泥岗，围山湖区，长蛇岭，桃湖区，昆仑山，从而进入阿尔金鲸鱼湖区。从向阳湖西侧环绕，路不再是想象的软烂，除去探路行程差一点就到20公里，很久没有这个速度了。湖西侧是水坑类型的沼泽地，边缘很硬，但难绕圈，方位需要把握的很准。很多旱獭，冷不丁的从土窝里窜出，也有狼，或许狐狸，均没看清脸，速度太快。湖西北侧通往围山湖的方向，再度出现大量的黑色火山石地貌，其中发生一件趣事，在一片火山石窝里，蓦然看见一只奇异动物，第一反应是火鸟，火鸡，总之是鸟类，再仔细一看，是只直立站着的肥大灰兔，吓他一下，玩什么COSPLAY扮鸟。顺着一条清水河进入宽阔谷地，一个完美营地，帐篷正对岗扎日背面，终于逃脱他的雪融洪水，可惬意观瞻了。本想以庆祝的借口舔点糌粑粉，被控制住。中午路餐自昨天被取消后，的确更加力不从心，整天就靠不到八百大卡的糌粑热量维系。控制的代价就是晚上开始失眠，满脑袋都是美食，想的流口水，想的凌晨前必然无法安然入睡。 记忆深刻的一段行路，非典型羌塘地貌 战争与和平，车轮与野花 回望可可西里山脉和向阳湖 逃脱岗扎日的雪融洪水，终可惬意观瞻 D67（6-25），10.5K，宿营4958M天气和昨天一样，上午阴雪，下午大晴，如果掉个个会很痛苦。今天行路就做了一件事，捷径，翻个大土坡。冻土消融状态好很多，还是有了可可西里山脉做参考，就没谁敢称霸了？中午又补了三次胎，其中，从另一个轮胎上撕下两片旧的补胎片。后来补胎液彻底没了，所以就连撕旧补胎片救急都不行了。没过多久，两条轮胎都没气了，打气，气筒断了。对于自行车而言，真真的穷途末路了。压着钢圈推车很费力，便尝试改装成一辆独轮车，减少轮阻。独轮车，就是前轮+车把+前叉。拆车挺麻烦，此生第一次补胎和拆车等等都是在无人区里完成的，我的车龄两年，第一次玩车羌塘，第二次玩车羌塘，所以对车的经验并不多，都是实践中学习。当下，独轮车装好后发现车把不灵光，这才发现车把套前叉的两端都有转盘。独轮车弄好了，看似不错，未等欣赏够，一阵大风将地上散物吹走，此行最麻烦的一次，主要是睡袋和防潮垫同在行列，奔跑着先找块石头把睡袋压住，接着追防潮垫，那家伙轻，追了近一公里，回程揍了防潮垫几拳。右脚在这次奔跑中恶化，肌肉劳损什么的变成了筋拉伤，脚踝不能垂直地面，歪着走才行。又丢弃一些装备，把两个驮包捆绑在前轮两侧货架上，还有相机包，背包，睡垫什么的，试着推两步，不爽，拉两步，还是不爽，样子也很滑稽，主要问题是重心无法掌握，独轮车拉杆必须从轮轴延伸才行，显然我的独轮车过于浪漫主义了。还是坚持着，推了三百多米，猛然把车一摞，骂了句，还真以为我是玩杂技的啊！然后回头去找拆散的车架。把车拼好，能拆的零件都拆掉，剩链条搞不掂，又回头找拆炼器，第一次用，兴奋，以为很精密很技术，很快捷的把链条拆了。这时又发现，后货架一侧断了，其实也没什么大不了的了。6MM钢筋，在螺丝间都加了橡胶垫片，避免硬连接的金属疲劳，极端的环境下还是不行。前货架也是用6MM钢筋焊接的，除了绣，一切都好，负重不多了，驮包置前，轻物置后，够用了。今天，是自行车的崩溃之日，最具崩溃代表性的不是轮胎或钢货架，而是脚撑。很有故事，道来。因为去年羌塘之行深刻意识到拍照很辛苦，原因之一就是要把自行车放倒、再扶起，看似简单，却极耗体力精力，流失很多拍照机会。一般的单脚撑基本上瞬间弯，钢制的无法保持大负重的自行车平衡，所以特地寻了一款类似摩托车的双叉中架脚撑，试验很不错，可羌塘实际地貌是不适合的，地太软，脚撑难以平衡，所以一次未用，但又拆不下来，（由于其固定结构很顽固，又没带匹配大扳手，尝试无数次无用）。每每看着这脚撑，觉得委屈，两斤多重的无用货，早知换成备用鞋。也是在今天，奇迹发生，脚撑松动，两端螺丝用手就拎开了，终于卸了这负担。晚上又失眠，除了想吃的流口水外，还想着脚撑的重量可以换些什么好吃的带。 把车子拆散架 传说中的独轮车，需要杂技演员才能推稳或拉稳，有点恶搞了 后货架断了，能拆的拆了，最后配置 D68（6-26），19K，宿营4898M依旧上午，阴冷，湿雪横飞，中午天气短暂好，下午是频繁的冰雹团，七点撑不住扎营，除去探路轨迹重叠，离实际推行至20公里还差那么一点。几个插曲简说，一是近距离遇狼，很近，河沟遭遇，蓦然撞上，双方都诧异了那么一会儿便各自淡定，各走各的。掏出相机，一通猛拍，很爽，超近。到近处，狼的眼神有点飘，可能觉得我的第三只眼太大（镜头），又死盯着他。交汇不到三米时，收起相机，提高警惕，狼也是。我们四目对视为中心点，错肩，头颅转动，这个距离太近，彼此都很提防。感觉有点像江湖仇人陌路相逢，却又不知对方几年来的身手，不敢贸然行事。狼转到身后面对站立，我也是，谁也不敢轻易相背直行，恐遭背后黑手。相持那么一会，狼忽然伏地，用下巴蹭土，打转，矫情似宠物，这才放心推车直行。过了转弯，倒车探路，见狼还在自顾玩，但眼神始终瞟我。无视，探路回来，狼不见了，觉得有点寂寞。十二点，来到到围山湖东侧的烂泥河，看了一眼，便又对自己说，过不去了。此泥河宽约一公里，烂泥泽，其间夹杂着十几道河叉，看一眼就头晕。查看地图，此烂泥河长约三十公里，并行于红泥岗，绕过去不可能。最后花了几个小时还是过去了。记忆真是不多，就是不断挣扎、探路，事后翻照片发现在河中拍了两张，往前按下快门，朝后按下快门。有点要说，就是这种宽阔河床，视野角度很重要，平视根本无法辨析河叉和滩涂分布，必须高处俯瞰。思维也得像只鸟，翱翔高空，指引前行，这或许就是直觉。过河后天气就转坏，过水难以计数，又两次较大的阻隔，一段粘泥滩，一条沼泽沟壑。话说轮胎干瘪，压钢圈阻力大，但过软地却不那么陷了，可能胎面宽幅了吧，就是体力多耗些。七点不到扎营，晾鞋子，只要不滴水就成，抖泥沙。尤其裤子，夹层里像是沙绑腿。风大，依一条河扎营，睡袋被吹，慌忙中赤脚追，扎脚，疼得够呛。晚上又失眠很晚，想吃的，已经无法摆脱这种情绪了。想着回拉萨吃多拉同学的菜，这丫天生厨艺细胞，又是川人，说好，回拉萨三个喜欢的菜管够，一是清炖羊肉，二是西红柿炒蛋，三是凉拌莴笋，当下又加了两个，青菜炖豆腐和回锅肉。如此，五碟菜像魔咒似地在脑袋里转个不停。实然，这也是一种巨大的幸福感，若每天晚上想着四万一平米的内环房子，一定是极其痛苦感的，但只要走出去，那几个菜就一定能够满足，从而成就了巨大的幸福感。真正的幸福感，是触手可及的，真实的。 挑两张狼猥琐的样子，后一张勉强有威势 泥沼河中间，前拍一张 泥沼河中间，后拍一张独轮车用后轮也许会好些？刚回北京两天就受凉发烧了，躺在床上一天一夜，产生各种幻觉，有人要杀我。。。在那种恶劣天气下生病的概率会不会更大些？ 这个你有考虑过么？一旦生病，可能耽误行程，体力，信心，自持力。。。 甚至性命？后轮和前叉不匹配。人没有想象的脆弱，都是工业化惹得祸，把本能丢了。 D69（6-27），19K，宿营4976M从路的角度上说，今天不错，天气的角度就极其糟糕。一整天冻得手脚发麻，脸斜嘴歪，就拍了一张照片。早晨，壮观的天象，东方天际一束红彤彤的光柱斜射出来，背景是暗黑的云，从未见过此景，可惜脑子犯浑，钻进帐篷准备取相机时却收起了睡袋，美景不得分享。顺着似无边际的沙滩进入逼仄河谷，两岸怪石非常有特点。激流充溢，基本泡在水里推行，好在河底硬沙砾，否则够喝一壶。过了山口照例顺河而下，同时接受大风和冰雹的洗礼，时间尚早，就一直撑着，到了五点看不行了，冰雹变成漫天飞雪，再也撑不到太阳出来暖身，赶紧扎营。失温太多，帐篷弄了半天才搭好，再次裹在睡袋里烧水热身。果真，雪越下越大，那个冷，牙打牙，睡袋也湿乎乎的，还一堆泥沙。 很冷，今天就拍了这张营地照 D70（6-28），16.7K，宿营4890M昨天按了一下快门，今天则一张照片都没，太冷，脚疼，泡水，所以放了一段前期吃饼干和缝补的视频，娱乐下，算是弥补当日无片。今天的目标是下到桃湖，过了桃湖就是翻昆仑了，肥羊正在大锅旁等着我往下跳。雪一直飘到上午八点，昨天的衣服还湿漉漉的，要命的是鞋子，没勇气再穿。想着多啦同学的炖羊肉已端上了桌，咬牙穿鞋走人。（现代人多没吃过食物的苦，再怎么琢磨也无法切身感受。）顺条大河而下，河滩被割成一段段，今天立下个目标，就是鞋不灌水，遇水就脱鞋。脚再被沙水蹂躏就真的要废了。但没过多久，过条小河叉时推车没跳过去，还是鞋子灌水了，于是改了目标，尽量少灌水。下午很晚的时候拐上一个山坡，发现结实的大车印，许多小车印都汇了进来，更可喜是硬草地，车印也硬，加之下坡，便尝试着顺坡溜一段，没了刹车，摔一跤，乖乖推到山下。桃湖风景极美，草茂湖绿，臆想着的应该会有牧民。如果没有牧民，等我老了，就来此放牧，霸了这地盘。身体出现新问题，小腿起满红斑，龟裂，肿胀，刺痛感，碰着内衣都剧痛，估计冰水泡的。脚也肿的厉害，脱不下鞋子，最后一咬牙脱了鞋子，有点像电影里点燃火药消毒伤口。感觉脚冷飕飕的，低头一看，还有半截袜子留在鞋子里。身体状态没法细说，但心态尚可。最糟糕的两个阶段已经过去，一次是进羌塘前，压力大，任何一个环节出现问题都是致命的，每天脑袋里就是上百个问题转圈，是不是真的没问题了？怎么可能会没问题，这或许就是旅行的乐趣，尽自己的能力周全，去面对未知。第二次就是被堵在天台河的几天，类似禁闭。西方有句名言，已经最糟了，还能怎么糟？再套句葛优的台词，看未来。再闲扯三个问题，第一是关于人的问题，现代人越发依赖机器，这不是什么坏事，却丢了很多本能。人的本能足以让一个健康的成年人完成无数艰苦的旅行，我们的祖先不就是这样吗，最近也不过几千年前石器时代的事。一时抛弃不了社会属性、羁绊太多也没关系，一场艰苦的旅行也证明不了什么，只要尽兴就好，在别的领域一样是探索，毕竟时代不同了。第二个问题，装备。装备很重要，但不能保证一场旅行的顺利，就羌塘而言，谁也不知道装备最后会溃败到什么程度，也不可能准备的让装备不出问题，除非有后援车。羌塘腹地的雨季又是怎样骇颜，没有多少资料可以参考应对。问题是有没有做好最坏的打算（不是生死问题，这种问题想多了，哪里也去不了），做到了心理坦然，而非临场马后炮满腹怨艾。最后一个问题，心态。很对人对此关心，我想说的是心态是很个人化的东西，没有答案，也没有借鉴意义，比如有些人不敢看贞子，有些人还觉得不够恐怖，没法衡量。至于我最基本的旅行心态是，不过度标榜，不吓唬没去过的人，不区分强弱，人与人区别并不大，只是生活的方向不一样。预告：今天琐碎多，更新少，剩下内容两天更完。抱歉，视频搞不定，看原址吧：http://v.youku.com/v_show/id_XMjE0NDAyNDky.htmlD3天吃饼干，有点像阿甘的巧克力，永远不知道下一块饼干是漏气的还是结块的。购买地址，狮泉河红绿灯劳保店，小心过期。 抱歉，视频搞不定，看原址吧：http://v.youku.com/v_show/id_XMjE0NDAzMzIw.htmlD21天左右，缝补衣服，很贤惠，娱乐下 D71（6-29），16.7K，宿营4916M顺着车印进入峡谷，逆水而上，车印都被冲了或在水底沉寂着。终于开始翻越昆仑山，没有想象的高伟，最高海拔也5016M，山口也是浑圆，过了山口也不知。昆仑山西陡东缓，克里雅山口是西昆仑山进入羌塘的一个重要通道，也是老外最早用自行车方式穿越，特别说的是国内杜一，带了几个馕九天时间就翻过了克里雅山口，体能和气魄都令人惊羡，这也是国内最早用自行车方式穿越羌塘。另说克里雅山口也是我十分向往的地方，那里有羌塘仅存的活火山，（上世纪中叶冒过烟，最早的新藏线因此被迫改道。）昆仑山北坡，峡谷里的水增大，过河遇到些麻烦，但比预想的好很多，水也不是那么浑浊。天气越发糟糕，迎面，密集的雪子和大风，不支，扎帐篷。到了下午八点，天气神奇的晴朗，昆仑山完全是另一副模样了。回首来处，感叹进入阿尔金地界了。如果运气非常好的话，明天就能到达阿尔金最大的湖——鲸鱼湖，在当时的臆想中，那里可能会遇到人，过去几天所有的动力都来源于此。即便遇不到人，也会有传说中的硬路。糌粑就剩一斤左右，为最后的冲刺多吃了点，又多加了些盐。在荒原中控制食物，的确很难，尤其四五十天后，那种食物的欲望非常折磨人。所以前期控制非常重要，是为了留给失控期一个较大的空间。如何控制食物？最简单、最重要的就是知道自己每顿吃多少，这靠记忆和感觉是不行的。有个舀糌粑的碗，能装多少糌粑精准到克数，大蒜按瓣数买，盐按每天十多克的标准配，酥油用刀划线……所有的食物是按理论极限80天配置的，（最大携带量，提供基本热量）。虽然未达到理论值，但也非常满意了，算是一次有益的尝试。（每个人的食物理论值都不一样，仅供参考。）为什么没有达到食物的理论极限值？关键就在于节奏乱了，若非深入羌塘雨季，若每天都保持有节奏的运动状态，那么对食物的消耗会少很多。节奏看似作用于身体，其实是对心态的控制，这就像在打游戏的最紧张关头，忽然被贾君鹏妈妈喊回家吃饭，你说恼不恼。动了气，乱心智，没过关，下次打游戏一定要找家贾妈妈找不到的网吧。再延伸，一次艰苦的旅行前，越少人知道越好，否则随便被谁过度关心下，在心态上都可能有微妙的变化，失去了勇往直前的节奏。很多被赞助登山遇难的就如此，条件不允许上，可后面有眼睛盯着，再则失败了以后赞助商也不好找了……一想到这些，完了，节奏没了，脱离了旅行的心态，那注定难以维持在旅行的路上。 翻越昆仑，一天都很糟糕的天气，黄昏，天气蓦然转好 D72（6-30），32K，宿营4816M晨，大地冻得真硬，喜出望外，昆仑山就是昆仑山。打好装备就过河，记忆深刻，不过三四米宽，脚冻得想骂人，这是此行从未有的。一直沿着平缓河谷，为了绕河时而要上软草地，有些周折。快出河谷时一次探路，发现前面溪水中有一块大牛粪，有这么大的吗？再仔细看，牛粪会微微晃动，这就更奇了，走近……忽然牛粪一转身，是头熊。他很淡定，瞥了我一眼继续泡屁股。我赶紧跑回车处取相机，创作欲望空前。再到溪边，端起相机，熊起身，不敢造次，避免惹怒。和熊隔着溪水并行了一段路，他见我死跟着便直行去了，终于让熊给我让路了。我没直追上去，曲线救国，绕了一段溪水去找它，见熊混进一群牦牛，再找，彻底不见了，熊混牛群、熊不见，两者都很诡异。出了河谷，再也不受水流困扰，沿着潜出河水的大车印朝鲸鱼湖推去。心情格外好，对面小崖顶三头牦牛吃草，向他们不停招手看其反应，他们很迷茫，很不淡定。天气好，路好，心情好，随后两件趣事。一是看见了祥云，科学解释是光折射，但还是过于奇妙，不免唯心起来，无非神佛之类的臆想。总之好兆头，终于结束了，祥云迎之。二是……远远见一条蓝带，鲸鱼湖是也，上世纪五十年代才被飞机发现，是阿尔金最核心区域。不时用望远镜搜寻牧民痕迹，很失望。又见一黑点，用望远镜看之，端稳，光线抖得厉害，只见……吓得我差点扔掉望远镜，心率倍增。整个行程只有两次惊吓，一次噩梦，不表，一次就这了。同学们，我看到了ET！！！正朝我走来！！！缓了口气，冷静下来，再仔细观察，原来是一头直面的野驴，太不淡定了，哈哈。遇到鲸鱼湖西侧一条汇河，原来的大车印早早被淹了，路烂的连水边都近不了。绕上游数百米，过河，心想，这是最后一次过大河了。过河后戈壁路，好走，虽没遇牧民，但毕竟硬路，迟早遇车。当日超三十公里，非常鼓舞人心，有点昏头了。开始矛盾的设想，如果遇人，是先讨烟还是先讨吃的？ 出昆仑，海阔天空 泡屁股的熊，很有绅士风度 熊混进这群野牦牛中消失，诡异 祥云？一通唯心主义乱想 鲸鱼湖西侧汇河 D73（7-1），33K，宿营4715M晨醒，雪，头大。推了半小时三百米，决定弃车，这路一天最多走十多公里。背挡风雪，匆忙收拾必带品，睡袋、帐篷、炉子……尽量极简，大概十五斤。没背负是最大问题，背包，斜挎睡袋，腰夹GPS、DV、望远镜，像个先锋队员去革命世界。为什么这才弃车？有很多问题，最重要三个原因，一是压根没想从阿尔金出来，功课全无，前途未知，光靠臆想不行。二是没一个好的背负系统，这需要舍弃很多基础装备，万一遇到紧急状况，风险太大。三是还未到底线，不到万不得已不能最后一搏，要向武林高手似地，被人砍了N刀，最后一刻出其不意甩个暗器。此时，弃车机缘到了，不得不弃。我已完全从昨日梦中醒来，这路哪会有车进来，见鬼。那祥云？浮云，浮云，都是浮云。最后一个目标，阿其克库勒湖，丁丁游记中的“饭店”，代替了鲸鱼湖成为新的精神寄托。路比预测的还烂，昨日之路不是常态，特殊地质而已，就像后天的白石山之路，他们是被沼泽烂地遗忘的一段，却迷惑人。眼下路，连炮车也进不来。走了小段路，扔了望远镜，走了小段路，扔了水袋，然后调整节奏不停的走。到了下午，腿脚随步伐巨痛，腿伸不直，膝盖不能弯曲，脚尖不能超前，脚板不能平展，可能是长期不良推车姿势，猛然变成正步加速了肌腱损伤。以往徒步中，膝盖容易受伤，但整条腿都似肌腱损伤还真第一次。腿部的皮肤红斑更重，随步伐摩擦着衣服火辣般，至于鞋子问题导致的摩擦痛基本被掩盖了。此时，保持节奏很重要，包括与痛感的磨合，不停的走，慢而有频率。下午三点半，经遇一条河，车印方向和纸质地图脱节。（只有一张西藏地图的边角，有部分阿尔金区域，上面路线多是象征意义，但大方向值得参考。）所以，生怕跟进一个无人矿就糟糕了。查看GPS，这条车印似乎通往贝勒克湖，湖被昆仑山分支阿尔喀山围堵，等高线显示其中有些平缓的小山口，加之阿其克库勒湖至祁曼塔格乡之间有条路（完全被边角地图误导），这条车印是不是前去交汇的？如果不是，翻过阿尔喀山右转也比GPS线路近。（根据早期地图描了一条鲸鱼湖到土拉牧场的线，经过阿其克库勒湖，也是阿尔金区域唯一触及的设计路线。）因此决定跟着车印进山。一半误判，一半准确，误打误撞走了最正确的一条线，差之毫厘都将是极其严重的后果，后说。见一群盘旋乌鸦，走过去，是一头死藏羚羊，刚腐烂没多久，恶臭，眼睛被乌鸦啄了，下身被撕开，很想弄块稍干净的羊腿吃。想想，自己真到食腐动物的份上了吗？坚定的回答，否。下午七点半遇贝勒克湖东北侧的河，再也折腾不起脱鞋过河，决定扎营。查看轨迹，走了33公里，整九个小时，基本无休。弃车是对的，否则这路要推两三天。晚上空腹，未脱鞋，脱不下来。想吃的难受，忽然想起下午看见的那头被啄了眼珠的死羊，莫名悲伤起来。他“羊”，我也杨，小时候就抄过一篇作文，叫《绵绵羊》，“我姓杨，同学们都叫我绵绵羊……”有种同病相怜的宿命感，非常的感伤。 晨雪，头大 推了几百米后决定弃车，告别公爵，他没过过几天好日子 阿尔金的荒原，他仍是青藏高原的一部分 贝勒克湖，湖边貌似牧场，一般地图上找不到这个湖 宿营地，除了地上的和手中相机，最后徒步之物另补充：当天下午看见飞机往返，唉。 阿尔金，唯一纸质地图，西藏地图的边角，给了很大的误导 被乌鸦啄去的眼睛的死藏羚羊 D74（7-2），36K，宿营4288M很早起来，上午翻越阿尔喀山口，先前昆仑山未留一影，此昆仑分支多拍了几张（后才知此昆仑分支是阿尔喀山，地图上就是昆仑山脉）。简说下昆仑走势，西源帕米尔高原，巍巍壮观，东至阿尔金时开始分支，形似龙爪，南支延伸为巴彦喀拉山脉，最终与横断山脉并行。北支延伸为祁连山脉和秦岭，成为中国南北气候分界线。昆仑的含义对中国人不必多说，但古人的昆仑不是无人区里绵延两千公里的山峦，而是秦岭或祁连山。下了山口进入峡谷，再度找到被雪覆盖的车印，然后一直顺河走，进入一片宽阔的扇形冲击河床。两侧是典型的喀斯特地貌，这便是绵延200公里的白石山。若论什么景致才是阿尔金无人区的标志？官方民间都是鲸鱼湖，我觉得喀斯特地貌的白石山更具张力。随后一段走得很纠结，宽阔河床比可可西里山脉那段路还糟糕，皆是泡水严重的沙粒，尤其中途一场大雪，极度迷失感。再次庆幸，如果推车，完了。出河床，是烂草地，混水坑，回归的车印则成了泥浆河，一直到了六点，路才稍微好些。晚上扎营在深车印里，一场冻雨袭来，雨水汇在低洼的车印，好在帐篷坚强，否则再无法忍受。一天没吃，最后一棒糌粑要留在最后时刻，这是猎人传授的经验，一定要把最后一口粮食藏在饿死之前的一刻才能记起的地方。没有脱鞋，脚肿得有些呻吟了，腿放直痛，弯着痛，反正怎么搁都痛。看地图，明天赶不到阿其克库勒湖的“饭店”了。今天走了11小时，36公里，比昨天多走两小时，距离则只多3公里。36公里，看来是此般身体状态、路况下的极限了。而离阿其克库勒湖的“饭店”还有四十公里左右，它真的存在吗？ 走向昆仑山口，好寻，坡缓路短 地图上也是昆仑山脉，是其分支 山口俯瞰，进入峡谷 最窄一段峡谷，过后一片坦荡 右侧有型山 左侧有型山，但还未到最喀斯特的一段，明天路上 D75（7-3），30+XK，宿营4792M八点半出发，没法走，用了半个多小时磨合最佳痛感。脚心窝着，单侧受力，膝盖直，大腿右撇，有点像范伟的卖拐，但没那么夸张。没过一会，左腿也弯不了，脚掌无法平展受力，走路姿势右瘸一下左撑一下。话说睡袋，湿气太多，重，斜跨在左侧，时间长了勒肩，便左手挽抱，貌似上了年纪的阿婆挽着一篓鸡蛋赶集。早晨曾考虑丢弃睡袋，当下必须集中所有能量赶到“饭店”。可想想，睡袋是朋友的，好借好还，要是自己的就扔了。路好，天气好，一直并行白石山。最后十几天只摄取相当高度饥饿程度的热量，最近两三天基本没吃，但并无强烈的饥饿感，再加上“饭店”的诱惑，心态还算坦然，但这脚令我万分担心，这样走下去，明天还能不能动是个问题。如果脚废了，一切都完了。过了中午，难再支撑，休息次数略多，坐下、站起，腿都没法打弯。风景一直很美，手解脱了，倒是拍了不少照片。除此之外，一种类似深度催眠的状态行走，风景和疼痛，飘渺且不真实。下午出现幻觉，或许只是眼花，看见前方有两辆摩托车快速移动，很快不见，便急切的吹起哨子，吹啊吹，不见摩托车。到了坡顶，也不见有岔路，之前看见的是什么？然后坏天气，然后天晴，然后上了一段大长坡，坐下休息，看GPS，走了三十一公里，时间四点半，想着至少还能撑好几公里，但肯定赶不到“饭店”，便想好，明天一大早什么也不带轻装徒步找饭店，然后找辆摩托车回头取随身物品。休息时间较长，起身没走几步，蓦然回头（不知道为什么要回头），见一辆越野车在身后十几米处，极缓慢的速度，没有一点声音。以为这下真幻觉了，休息这么长时间难道发现不了车接近？再看，果真是车，跑上去，敲车窗，要吃的。从司机黄哥角度看这场相遇：路中间有头牦牛，放慢车速，渐渐觉得牦牛没这么小，便是狗熊，再近，怎么狗熊还会弯腰捡东西？再近，是人！不可能啊……车上四个人，很明显都紧张了一会，车门没打开迹象。我说从西藏过来的，车丢在鲸鱼湖，旅行的……他们以为“车”是汽车，最后才明白是一个人推辆自行车在荒原里晃了70多天。赶紧开车门给了一袋方便面和一瓶矿泉水。交流中得知，所谓的“饭店”子虚乌有，现在除了他们一家矿（还在中探阶段），再无其他人，淘金者也都在白水河一带，遇见他们真是命大。而我们相叠的路段只有几公里，早一点不遇，晚一点分道扬镳，他们往风尘口大坂，我往阿其克库勒湖找“饭店”，所以，一直称黄哥为救命恩人。按他的玩笑话，此生就是为了此刻此地等我。当然没回头找弃车，此季没有车能过阿尔喀山，深入鲸鱼湖一带，黄哥在阿尔喀山北侧探矿，是此季唯一还在阿尔金腹地的单位。他们一行四人，三个工人，其中一老者，昨天下山，当夜陷沼泽，下午遇我。三天一百公里的徒步逃生结束，上了车后以为解脱，干吃方便面和抽烟，但故事并未结束。过了白石山好路后，就开始频繁陷车，一路挖车，推车，三个工人很辛苦。晚上陷在一泥坑里，只能等明天上冻脱困，和他们昨夜深陷沼泽一样。晚上，和黄哥聊得很晚，很兴奋，似乎我的经历勾起了他的江湖漂泊梦。对于他这种有无人区工作经历的人来说，我的旅行更加具有梦幻性。聊天中还得知，他们没有多少补给，就带了一箱方便面和矿泉水就匆匆下山，也没想到路这么烂，但想着随后矿上有炮车下来就没回头，希望能冲过风尘口大坂，到达山脚下的回民帐篷，（平时半天时间到回民帐篷），随后就是大路了。这才明白，为淘金者和探矿人提供服务的回民帐篷就是丁丁游记中的“饭店”，如果步行还需三天，还得保证不走错路，显然，我对风尘口一带无半点了解。黄哥敢单车下山，也是因为后有炮车，如果出现问题可以救援，这是他的底线。 两张白石山近景 两张白石山远景 遇人，拍照，先前坏天气，镜头有水，便这样了 拍了几张挖车照，后面再无拍过，越来越糟糕，麻木 D76/77（7-4/5）整天，汽车走了九公里。上冻，车子冲出泥坑，人徒步，车子轻装冲向山口。路太烂了，坐过墨脱的车，那是小巫（有季节因素）。一小时后候车陷死，随后用了十个小时，靠人力将车移动了八百米——难以回首的八百米。三个工人一直淌在水里挖车，挖路，我没法再吃这种苦了，只在稠密的烂泥里推车，那也是够呛。看不下去了，也撑不住了，只想安静地待在车上，等待炮车，客观上，仅凭我们几个人也没法将车弄出去，就一直劝黄哥，别折腾了。中午方便面就快没了，所谓的炮车一直不见，所以黄哥有些着急，希望车能撑过山口下到回民帐篷，所以对我的建议充耳不闻。老头失控，对我态度极差，老是用话戳我，说不能把包扔在车上就当大爷了，说没眼力不会找活，说抽这么多烟，说好吃懒做……这点承认，一直吃方便面调料包，都是没人吃的，都知道是TM味精+胡椒粉，可对我来说是天上美味了。老头不时把铁锹扔给我去挖车，没办法，被说的也不好意思，偷懒，随便挖几下。没法挖，手连铁锹都握不紧，问题是要穿鞋跳进水里挖，工人们至少还有双鞋换，我的鞋已经两天脱不下来了，没法再跳进水里。重要的是心态变了，都遇人得救了，再吃不了这苦。一瘸一拐的姿态，并未从老头那里获得同情。话说黄哥一直照顾我，这也可能让他很不舒服，的确，太艰辛了，五个人就三个人挖车，老板不敢支使，就只好我了。下午，有辆淘金车经过，从附近白水河撤出来，他们有一辆炮车，但要钱才帮忙拖车。600元，黄哥还价400元，价格淡不拢。主要是黄哥掷气，不在乎几百块钱，他们矿上车不知救助了多少淘金客。（淘金客大都XX，名声不好，确实不该在这种环境谈钱，虽然知道我们可能有后援）。当时，我很想掏那600元钱，就像有网友说的，几十天没用钱了，憋得难受，只要晚上能吃口热的，不要说600，1800也给（身上现金数），但是，这场交易演变成不是钱的问题，而是立场，所以忍了，还忍了搭乘淘金者车出去的想法。毕竟一辆车上的人了，如果不是他们，我现在可能精神崩溃，那有什么“饭店”，荒原里只有浮云。老头对我态度越发差，我不乏乞色说，这种路我走了几十天，真的不行了，脚痛，连铁锹都握不住。老头一句话：你脑袋里有虫！激得我拿起铁锹就往泥浆水里跳，挖挖挖。“脑袋里有虫”，随后成为我们的语录，拿它开心。一直快到天黑，两个年轻工人中体力最好的垮下来，头发热，昏睡。天气也差，飘着阴雪，冷风，只好在车上再熬一夜。非常冷，没吃的，继续吃调料包，老头又看不惯，（弄得我吃调料包都偷偷摸摸的）。一会儿又用身体挤我，一会儿说我踩了他脚，淡定，淡定！！！心里真是抓狂啊。很理解，这种环境下人都很脆弱，他们虽在无人区里探矿，但毕竟每天有白馍肉蔬菜，有人交流，有工作时间，除了海拔不同，和一般内地工人并无太大区别。十一点多，有灯光从后面打来，炮车终于来了。准备拖车，大家都不想下车系钢缆，推辞中不知怎么把那昏睡的工人给弄下去了。系好钢缆，车动，问题是那工人没上车，我们车又没喇叭，无法和前面大车交流，就这样把工人丢在夜色中。气氛非常凝重，十分钟后，有人敲车门，原来那工人一直跟在车后追，很难想象，那十足烂路，那恶劣天气，那漆黑麻乌的，工人追车的心态。杯具的是，他敲得那扇车门是坏的，打不开，车窗也摇不下来，车里车外无法交流，只见工人边跑边敲窗。随后，他又消失在茫茫夜色里，几分钟后，工人又出现，在我这侧车门，拉上车，之后一直昏睡。话说，炮车来了，司机给了我们两张饼，一包烟。那饼摆在面前真想吃啊，老头以大家还没吃的借口不让我吃，而他们显然远未达到猪的吃食状态。老头一直用眼睛盯着我，像防贼，有一刻，真想冲过去一口把饼吞了，要打要骂随你老头。抽烟吧，第二根又被老头骂，说是只有司机能抽……坡陡路烂，拖车危险，解除牵引，但陷车依然频繁，三人下车推（那个昏睡工人至少当夜彻底没劳动力了），也管不了脚下是泥浆还是河，头上是风还是雪。数次过后，大车上的人实在看不下去了，顾不得危险，一直系上钢缆将车拖下山至回民帐篷处，此时，凌晨两点左右。回民帐篷前一道浅滩，漫水，淌水过去。见黄哥一直在众人面前吹嘘我，这才看清大车上至少有七人。此后，他们都对我非常照顾，尤其司机，没事就围着我聊天，还把最后一根烟给我，然后自己去讨烟。用他的话说，自己每进一次山都觉得掉层皮，无法想象一个人从那边怎么过来的。有了商业，我就可以用钱势轰老头，抢着买单，谁怕谁啊。的确，老头自此后对我态度好很多。简单吃碗面条赶夜路，临走前，问老板，去年是不是有两个逃犯也推车从里面出来？老板半听懂似的，恩恩，一个坐车走了，一个骑车走了。算是为那莫须有的“饭店”解气了，实则是我没做功课。随后，大路，连夜赶往花土沟，睡觉。路上还有很多杯具故事，但相比之前，已无味了，不表。下午四点到达石棉矿，抄近路，从矿区里走，更加显露生存的悲哀，如果让我在此处工作，我情愿在羌塘里永不出来。（去过石棉矿的人都知道，生存环境的问题。）进入家属区吃饭，跟着路人翻院墙方便，是所学校，不知是不是怕被学生撞见，很紧张，几经挣扎，才知硬了，还秘……我想，这才是旅行的彻底终结。随后油路花土沟，找了家宾馆，脱鞋，带出几片碎布，剩下的袜子成泥沙了。一瘸一拐的去买换洗衣服，生活用品，徐福记系零食，吃饭，回宾馆洗澡，躺在干净的床上吃零食。手无力撕开食品塑料袋，一一用牙齿咬开。吃了N多零食，喝了两升果汁，睡去。翌日开机，报平安。请救命恩人吃饭，开始挤兑老头脑袋里有虫。很多追贴的朋友关心身体状况，简说下后面行程。D1-3，请恩人吃饭，理发，打电话，寄还友人物品。D4-8，庸医说脚养一月，不得下地，随即前往新疆找羊肉吃。D9-20，舟车劳顿，新疆小玩，身上已难寻羌塘印记。先是巴音布鲁克草原，被蚊子追咬，与一家四口挤睡敖包，逃跑，去吐鲁番热死，敦煌一瞥，辗转回拉萨。第十天朋友角度描述，“气色不佳，略微浮肿，笑容淡定，思绪游移。”D22-35，坐车，陪朋友下林芝，上珠峰大本营，挤雪顿节。其间，一直想借道拉萨去克里雅山口看火山，谁知出羌塘舟车未停过，说真的，心很累，很想找个安静地方小憩几天，坐火车离开拉萨，打道回府。舟车劳顿中，第十一天恢复走姿，但赶路快走会有抽筋感。内器官只夜间呼吸重，胸口压迫感，出拉萨好。豁出去了，老脸游街，附出羌塘后第一张照片，第十九天车上，窥斑知豹以度身体状态。另外，实际生活中很不淡定，那样多无趣。生命是一条贯通的河流，一切皆是没有开始的复始。我们所期望的终点并不存在。更完。 出羌塘最近照，第十九天要表明的熟识的朋友希望我更新完毕做个总结，不知说什么。或许每个人心中都有一个江湖梦，像侠一样自在漂泊。若此贴暗合了内心，心绪飘荡，那么我想有必要再表明下观点，以免误导，传递错误的信息。【装备】此行装备看似简陋，但够用了，事后发生的事不能推翻前面，就像孙子不可以穿越时光杀死爷爷。但，这只是我个人的装备习惯，不想给朋友们一个错误的信号。譬如，当我第一次三个月时间穿坏一双进口登山鞋时就明白，有些路注定是消耗品，所以在一千块鞋子和提升了5%性能的三千块鞋子之间，我选前者。如果，我只是偶尔出来旅行，三年穿不坏一双鞋子，那我选择后者。这年头赚钱不容易，还是省着点。另外，基础装备和技术装备有着本质区别，红军可以穿草鞋过雪山，但绝无可能在没有冰镐的帮助下攀上雪壁。【本能】旅行即不是奥林匹克，也非奥数，他不能说明体能与智力的问题。不要过度迷信道听途说，不要被小说似的探险故事吓着，从未有过游泳经历的人，经过训练，虽然超不过菲利普斯，但至少能狗刨。从漫步陆地到畅游水里的巨大飞跃，不是潜能的问题，而是本能。所以，只要不是极限之地，大部分人都能去，没什么大不了。有种高反，不是生理上的，是心理上的。随时保持清醒，知道极限和本能之间的界限，可以在海拔五千米的地方走上一辈子，但在海拔一万米的地方活不过五分钟。【成长】即使对比去年的旅行，我对生活的态度也有了新的体悟。如果再回逆十年，差异性就更大了，即便翻阅不久前的文字，都觉得无法入目，当初为何有那样的想法？所以尽量不要标榜，不要给自己贴标签，我们随时都在成长，都有新的认知，只需一个记录就行，反思和展望。【如果准备尝试一次艰苦的旅行】不会吓唬没有去过的人，这样会抹杀探索精神，但并不说明因冲动就可以踏上旅程，那是冒险，不是旅行。所以，尝试一次艰苦的旅行前，首先要问自己几个问题。一、为什么？如果热爱那就去，如果想证明什么那还是好自为之。二、准备好了没有？如果买了一堆昂贵的装备只能说明你有钱或有赞助，如果你花很多时间了解那片热爱的土地，装备配置才会有实际意义，一根水泥钉或许都是最强装备之一。三、艰苦的定义？如果宅了十年，第一次就走羌塘显然是不现实的。从未有长途骑行经历的人，走了青藏线就是蓝波湾，爬三楼都喘的人爬了黄山，那是超蓝波湾。不要和人比较，每个人的艰苦旅行都不一样，只要超越了自己，超越了当下，就是当之无愧的蓝波湾。四、有完美吗？没有完美的装备，完美的计划，完美的旅行，要有包容，对人对事。五、一定要去探索吗？旅行不是生活的全部，还得养家糊口、求学就业、升官发财，做科学家也是探索，玩高难度杂技也是探索，抑制房价也是探索，讨暗恋女生欢心也是探索。不要羡慕无氧登珠峰的人，坐在大本营看他们上跳下窜也很幸福，尽兴就好。一切问题都解决了，最后才是意志力和运气的问题，说不清，但很真实，这才是探索的开始。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于word合并、分割、转换问题]]></title>
    <url>%2Fposts%2F51428.html</url>
    <content type="text"><![CDATA[最近项目中有个这样的需求：要把word 按章节(大纲)拆分多个word,然后再将这些word能合并成一个整体。看到这个需要，其实也是头疼，100个程序员中应该100位都没有做过类似的开发，最多的就是poi 读取、生成word,那么接下来，我会将最近研究的word切割、转换、合并以笔记的形式记录，也算做为积累吧！ word 分割 ： word 分割，使用的 poi，这个还真有点难，如果不是同事给国帮助，分割这块，还是很难搞定，不过合并用的第三方插件，很快就搞定了，上代码吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297package com.sysware.soft603.util.backUp; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.List; import org.apache.poi.xwpf.usermodel.BodyElementType;import org.apache.poi.xwpf.usermodel.IBodyElement;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.apache.poi.xwpf.usermodel.XWPFParagraph;import org.apache.poi.xwpf.usermodel.XWPFRun;import org.apache.poi.xwpf.usermodel.XWPFStyles;import org.dom4j.Element;import org.dom4j.io.OutputFormat;import org.dom4j.io.SAXReader;import org.dom4j.io.XMLWriter; import com.sysware.fai.entity.BookMarkInfo; public class POItest1 &#123; public static void main(String[] args) throws IOException &#123; splitWord(); &#125; private static void splitWord() &#123; String path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.docx"; InputStream is = null; List&lt;BookMarkInfo&gt; bookMarkInfos = new ArrayList&lt;BookMarkInfo&gt;(); try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; XWPFDocument doc = null; try &#123; doc = new XWPFDocument(is); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 获取段落 List&lt;XWPFParagraph&gt; paras = doc.getParagraphs(); // 获取bodyElements List&lt;IBodyElement&gt; bodyElements = doc.getBodyElements(); // 获取doc样式 XWPFStyles styles = doc.getStyles(); int j = 0; // /切割成的word 文件存储位置 String patha = "d:\\poi\\"; // 根据大纲定义分割成的段落 ArrayList&lt;Integer&gt; al_duanLuo = new ArrayList&lt;Integer&gt;(); // 大纲名称 ArrayList al2_name = new ArrayList&lt;&gt;(); // 大纲级别 ArrayList&lt;Integer&gt; al3_jiBie = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; al5 = new ArrayList&lt;Integer&gt;(); // 存放生成wordId ArrayList&lt;String&gt; al6_wordId = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; bodyElements.size(); i++) &#123; IBodyElement bodyElement = bodyElements.get(i); try &#123; if (j == 0) &#123; al_duanLuo.add(i); j++; al2_name.add("首页"); al3_jiBie.add(1); // al5.add(1); al6_wordId.add(java.util.UUID.randomUUID().toString()); &#125; if (bodyElement.getElementType() == BodyElementType.PARAGRAPH) &#123; XWPFParagraph para = (XWPFParagraph) bodyElement; if (styles.getStyle(para.getStyle()).getCTStyle().getName() .getVal().contains("heading")) &#123; // 以标题创建第一个文件 al_duanLuo.add(i); j++; al2_name.add(para.getParagraphText()); // System.out.println(al2); String temps = styles.getStyle(para.getStyle()) .getCTStyle().getName().getVal() .split("heading")[1].trim(); al3_jiBie.add(Integer.parseInt(temps)); // al5.add(Integer.parseInt(para.getStyleID())); al6_wordId.add(java.util.UUID.randomUUID().toString()); // System.out.println("a2======" + al2_name); // System.out.println("a3======" + al3_jiBie); // System.out.println("al======" + al_duanLuo); // System.out.println("a5======" + al5); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // 定义存放父新id ArrayList al4_parentId = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; al_duanLuo.size(); i++) &#123; if (al3_jiBie.get(i) &gt; 1) &#123; int k; for (k = i; k &gt;= 0; k--) &#123; if ((int) al3_jiBie.get(k) &lt; (int) al3_jiBie.get(i)) &#123; break; &#125; &#125; al4_parentId.add(al6_wordId.get(k)); &#125; else &#123; al4_parentId.add(" "); &#125; &#125; // for (int i = 0; i &lt; al_duanLuo.size(); i++) &#123; // System.out.println("==================="); // System.out.println("al2=" + al2_name.get(i)); // System.out.println("al3=" + al3_jiBie.get(i)); // System.out.println("all4=" + al4_parentId.get(i)); // System.out.println("==================="); // // 根据关系创建拼接组装xml文件 // &#125; System.out.println("al_duanLuo" + al_duanLuo); System.out.println("al2_name=" + al2_name); System.out.println("al3_jiBie=" + al3_jiBie); // System.out.println(al6_wordId); System.out.println("al4_parentId=" + al4_parentId); XWPFDocument newDoc = doc; int max = 0; max = bodyElements.size() - 1; al_duanLuo.add(max); try &#123; for (int k = 0; k &lt; al_duanLuo.size() - 1; k++) &#123; path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.docx"; is = null; try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; doc = null; try &#123; doc = new XWPFDocument(is); // 移除多级列表，移除前面的编号，这里分割后是有编号的，不过这里如果你不移除的话，直接把代码注释掉即可 if (k != 0) &#123; XWPFParagraph para1 = (XWPFParagraph) doc .getBodyElements().get(al_duanLuo.get(k)); String str1 = para1.getStyleID(); doc.getStyles().getStyle(str1).getCTStyle().getPPr() .unsetNumPr(); &#125; &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 移除前0－－14， int temp = al_duanLuo.get(k); int tempCount = al_duanLuo.get(k + 1); for (int u = max; u &gt; tempCount - 1; u--) &#123; doc.removeBodyElement(u); &#125; // 进行移除之前 for (int l = temp - 1; l &gt;= 0; l--) &#123; doc.removeBodyElement(l); &#125; // XWPFParagraph tempDuan = paras.get(temp); // paras.get(7).setStyle(paras.get(1).getStyle()); // XWPFRun run = paras.get(7).insertNewRun(0); // run.setText("10086"); OutputStream out = null; out = new FileOutputStream("d:\\poi\\" + al6_wordId.get(k) + ".docx"); BookMarkInfo bookMarkInfo = new BookMarkInfo(); bookMarkInfo.setId(al6_wordId.get(k)); bookMarkInfo.setPid(al4_parentId.get(k).toString()); bookMarkInfo.setName(al2_name.get(k).toString()); bookMarkInfo.setLevel(al3_jiBie.get(k)); bookMarkInfos.add(bookMarkInfo); try &#123; doc.write(out); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("over"); CreateXml(bookMarkInfos); //遍历xml文件 &#125; public static void CreateXml(List&lt;BookMarkInfo&gt; bookMarkInfos) &#123; String target = "d:/MyXml.xml"; SAXReader reader = new SAXReader(); try &#123; org.dom4j.Document document = reader.read(new File(target)); Element root = document.getRootElement(); List&lt;Element&gt; list = root.elements(); for (Element element : list) &#123; root.remove(element); &#125; //给xml加上标号, int j=0; for (int i=0;i&lt; bookMarkInfos.size();i++) &#123; BookMarkInfo bookMarkInfo =bookMarkInfos.get(i); //判断是否为第一级 if(bookMarkInfo.getLevel()==1)&#123; //为了是第一个不用加编号 if(i!=0)&#123; j++ ; &#125; &#125; if (bookMarkInfo.getLevel() == 1) &#123; Element element = root.addElement("item"); element.addAttribute("id", bookMarkInfo.getId()); //加上编号 if(j==0)&#123; element.addAttribute("name", bookMarkInfo.getName()); &#125;else&#123; element.addAttribute("name", j+bookMarkInfo.getName()); &#125; element.addAttribute("filename", bookMarkInfo.getId() + ".docx"); GetXElement(element, bookMarkInfo, bookMarkInfos,j+"",0); &#125; &#125; saveXml(target, document); //遍历xml &#125; catch (org.dom4j.DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void saveXml(String target, org.dom4j.Document document) &#123; try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator("\r\n"); OutputStreamWriter outputStreamWriter = new OutputStreamWriter( new FileOutputStream(target), "UTF-8"); XMLWriter xmlWriter = new XMLWriter(outputStreamWriter, outputFormat); xmlWriter.write(document); xmlWriter.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void GetXElement(Element parent, BookMarkInfo item, List&lt;BookMarkInfo&gt; bookMarkInfos,String j,int k) &#123; k=0; for (BookMarkInfo bookMarkInfo : bookMarkInfos) &#123; if (bookMarkInfo.getLevel() == item.getLevel() + 1 &amp;&amp; bookMarkInfo.getPid() == item.getId()) &#123; k++ ; Element element = parent.addElement("item"); element.addAttribute("id", bookMarkInfo.getId()); element.addAttribute("name", j+"."+k+bookMarkInfo.getName()); element.addAttribute("filename", bookMarkInfo.getId() + ".docx"); GetXElement(element, bookMarkInfo, bookMarkInfos,j+"."+k,k); &#125; &#125; &#125;&#125; 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;item id="1" name="1" filename="a.docx" author="杨稳" publishtime="2017-02-03" keywords="关键词" abstract="摘要" journal="" issn="" Implementation="2017-04-01" groupname="国标" phase="研制阶段" content="内容分类"&gt; &lt;!-- id=编号（标准规范）,name=名称,filename=文件名称,author=作者,publishtime="发表时间",keywords="关键词",abstract="摘要",journal="所属期刊",issn=ISSN,Implementation="实施日期",groupname="国标",phase="研制阶段",content="内容分类"--&gt; &lt;item id="1.1" name="1.1" filename="a.docx"/&gt; &lt;item id="1.2" name="1.2" filename="a.docx"&gt; &lt;item id="1.2.1" name="1.2.1" filename="a.docx"/&gt; &lt;item id="1.2.2" name="1.2.2" filename="a.docx"/&gt; &lt;/item&gt; &lt;item id="1.3" name="1.3" filename="a.docx"&gt; &lt;item id="1.3.1" name="1.3.1" filename="a.docx"/&gt; &lt;/item&gt; &lt;item id="1.4" name="1.4" filename="a.docx"/&gt;&lt;/item&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;item id="1" name="1" filename="a.docx" author="杨稳" publishtime="2017-02-03" keywords="关键词" abstract="摘要" journal="" issn="" Implementation="2017-04-01" groupname="国标" phase="研制阶段" content="内容分类"&gt; &lt;!-- id=编号（标准规范）,name=名称,filename=文件名称,author=作者,publishtime="发表时间",keywords="关键词",abstract="摘要",journal="所属期刊",issn=ISSN,Implementation="实施日期",groupname="国标",phase="研制阶段",content="内容分类"--&gt; &lt;item id="cdc88f18-a024-4e88-9ba1-3d5c5a7a0c58" name="首页" filename="cdc88f18-a024-4e88-9ba1-3d5c5a7a0c58.docx"/&gt; &lt;item id="d6cd51f4-b16f-4d25-860f-d102d01f4d79" name="1范围" filename="d6cd51f4-b16f-4d25-860f-d102d01f4d79.docx"/&gt; &lt;item id="250b91c9-986e-4ad8-ad21-2008331d07ec" name="2引用文件" filename="250b91c9-986e-4ad8-ad21-2008331d07ec.docx"/&gt; &lt;item id="7e54f054-3880-4087-bde6-ec423bc0a3ad" name="3术语和定义" filename="7e54f054-3880-4087-bde6-ec423bc0a3ad.docx"&gt; &lt;item id="0b9dfec5-a484-4092-a8a3-0f1c0c4caeae" name="3.1一级定委 first-class committee for finalization of military products" filename="0b9dfec5-a484-4092-a8a3-0f1c0c4caeae.docx"/&gt; &lt;item id="0192d8d5-fdc7-4f8d-8a6e-bb88a53f5395" name="3.2二级定委 second-class committee for finalization of military products" filename="0192d8d5-fdc7-4f8d-8a6e-bb88a53f5395.docx"/&gt; &lt;item id="1e172285-5b97-4da0-98be-60a90bd245b8" name="3.3军工产品 military products" filename="1e172285-5b97-4da0-98be-60a90bd245b8.docx"/&gt; &lt;item id="a255bca2-9380-485c-8c43-43bfb6c19a62" name="3.4军工产品定型 finalization of military products" filename="a255bca2-9380-485c-8c43-43bfb6c19a62.docx"/&gt; &lt;item id="d1df3277-4895-4282-b1b1-52cf9fe48a3c" name="3.5设计定型 design finalization of military products" filename="d1df3277-4895-4282-b1b1-52cf9fe48a3c.docx"/&gt; &lt;item id="70709984-ba90-40cc-b4ad-e29a025cb9ab" name="3.6生产定型 manufacture finalization of military products" filename="70709984-ba90-40cc-b4ad-e29a025cb9ab.docx"/&gt; &lt;item id="f27b646b-bdf6-4fa9-aa78-c9dab72450ce" name="3.7一级军工产品 first-class military products" filename="f27b646b-bdf6-4fa9-aa78-c9dab72450ce.docx"/&gt; &lt;item id="d80e9425-6502-46db-9251-43a06fa8a164" name="3.8二级军工产品 second-class military products" filename="d80e9425-6502-46db-9251-43a06fa8a164.docx"/&gt; &lt;item id="6d217bdf-a7c6-4751-8a64-0a16026d6e52" name="3.9军工产品鉴定 assessment of military products" filename="6d217bdf-a7c6-4751-8a64-0a16026d6e52.docx"/&gt; &lt;/item&gt; &lt;item id="bd43a101-a948-4efc-ab33-cdb1bf324a6b" name="4总则" filename="bd43a101-a948-4efc-ab33-cdb1bf324a6b.docx"&gt; &lt;item id="43463950-f7f8-459c-9a62-65ef8021027a" name="4.1定型工作的依据" filename="43463950-f7f8-459c-9a62-65ef8021027a.docx"/&gt; &lt;item id="fd4614c6-c00e-4244-ae25-0d9fdb3c5e51" name="4.2定型分类" filename="fd4614c6-c00e-4244-ae25-0d9fdb3c5e51.docx"/&gt; &lt;item id="2ccfe33a-c864-41ac-89af-91a05075eda1" name="4.3定型原则" filename="2ccfe33a-c864-41ac-89af-91a05075eda1.docx"/&gt; &lt;item id="b58bb7c0-cebf-45f6-8c86-30658ec89ca4" name="4.4定型分级" filename="b58bb7c0-cebf-45f6-8c86-30658ec89ca4.docx"/&gt; &lt;/item&gt; &lt;item id="afc9af0e-9074-4dc6-be3b-6632f20135b8" name="5设计定型" filename="afc9af0e-9074-4dc6-be3b-6632f20135b8.docx"&gt; &lt;item id="0ed6ad9a-34f1-427a-bf7e-70e1ec8717e0" name="5.1设计定型程序" filename="0ed6ad9a-34f1-427a-bf7e-70e1ec8717e0.docx"/&gt; &lt;item id="8634212f-0ec7-45b8-9596-69e7e6b3db78" name="5.2申请设计定型试验的条件" filename="8634212f-0ec7-45b8-9596-69e7e6b3db78.docx"/&gt; &lt;item id="f1ab75a0-def4-4058-ab36-df14ee4081d6" name="5.3申请设计定型试验" filename="f1ab75a0-def4-4058-ab36-df14ee4081d6.docx"/&gt; &lt;item id="d205e3ac-aa79-414f-8817-0bf693cb950c" name="5.4制定设计定型试验大纲" filename="d205e3ac-aa79-414f-8817-0bf693cb950c.docx"&gt; &lt;item id="7659923a-d274-4ae2-b882-dbce090457cc" name="5.4.1试验大纲的制定" filename="7659923a-d274-4ae2-b882-dbce090457cc.docx"/&gt; &lt;item id="7d3ca588-771d-4b93-b3d9-fbaa7b60066a" name="5.4.2试验大纲内容和要求" filename="7d3ca588-771d-4b93-b3d9-fbaa7b60066a.docx"/&gt; &lt;item id="3fb7579f-23b0-47e5-95fb-02115726d4cb" name="5.4.3试验大纲编制说明" filename="3fb7579f-23b0-47e5-95fb-02115726d4cb.docx"/&gt; &lt;item id="a864a195-3fcc-40c8-8854-8521603144a3" name="5.4.4试验大纲变更" filename="a864a195-3fcc-40c8-8854-8521603144a3.docx"/&gt; &lt;/item&gt; &lt;item id="67b5e4c2-16ac-4023-a215-d650f86d2d06" name="5.5组织设计定型试验" filename="67b5e4c2-16ac-4023-a215-d650f86d2d06.docx"&gt; &lt;item id="fb17fdd6-def8-4219-b780-bdcb8fcf34f5" name="5.5.1试验要求" filename="fb17fdd6-def8-4219-b780-bdcb8fcf34f5.docx"/&gt; &lt;item id="fff01927-27c5-4e27-bfd9-8356846c64a9" name="5.5.2试验组织实施" filename="fff01927-27c5-4e27-bfd9-8356846c64a9.docx"/&gt; &lt;item id="e02e40c4-c1a9-42da-bf91-923e46f49ca3" name="5.5.3试验顺序" filename="e02e40c4-c1a9-42da-bf91-923e46f49ca3.docx"/&gt; &lt;item id="8428ba02-bda0-43f3-898a-cb61a0bffebb" name="5.5.4试验中断处理" filename="8428ba02-bda0-43f3-898a-cb61a0bffebb.docx"/&gt; &lt;item id="0f8ee823-1b3b-4357-9821-5b6c23bb1c9e" name="5.5.5试验恢复处理" filename="0f8ee823-1b3b-4357-9821-5b6c23bb1c9e.docx"/&gt; &lt;item id="008c1546-45d5-4bfd-96c5-d4150054d547" name="5.5.6承研承制单位的责任" filename="008c1546-45d5-4bfd-96c5-d4150054d547.docx"/&gt; &lt;item id="f19db0de-1e2f-47dd-b82f-173ae5a7acab" name="5.5.7试验记录" filename="f19db0de-1e2f-47dd-b82f-173ae5a7acab.docx"/&gt; &lt;item id="2c6df7ba-53ec-45c5-95f7-4be37e5b7406" name="5.5.8试验报告" filename="2c6df7ba-53ec-45c5-95f7-4be37e5b7406.docx"/&gt; &lt;/item&gt; &lt;item id="8262e0da-b543-45da-b289-380cf43fab59" name="5.6申请设计定型" filename="8262e0da-b543-45da-b289-380cf43fab59.docx"&gt; &lt;item id="ded722e3-4c04-4fe3-a8e4-bf30b73bcda2" name="5.6.1提出申请报告" filename="ded722e3-4c04-4fe3-a8e4-bf30b73bcda2.docx"/&gt; &lt;item id="45d1a9ed-01ed-46c5-a81a-1a0822627833" name="5.6.2申请报告内容" filename="45d1a9ed-01ed-46c5-a81a-1a0822627833.docx"/&gt; &lt;item id="3038774c-ddd7-440a-b172-ab758192dd8a" name="5.6.3申请报告附件" filename="3038774c-ddd7-440a-b172-ab758192dd8a.docx"/&gt; &lt;item id="ec05b70d-07c6-4f21-b5b0-f61fa08db313" name="5.6.4产品模型" filename="ec05b70d-07c6-4f21-b5b0-f61fa08db313.docx"/&gt; &lt;/item&gt; &lt;item id="a9c7cf2a-48be-46c5-aef4-8c93e138db00" name="5.7设计定型审查" filename="a9c7cf2a-48be-46c5-aef4-8c93e138db00.docx"&gt; &lt;item id="ea6c4556-a3fe-4177-a24b-d05ecc8b9054" name="5.7.1设计定型审查组和检查组" filename="ea6c4556-a3fe-4177-a24b-d05ecc8b9054.docx"/&gt; &lt;item id="b448feb3-4731-4344-bf27-a29309b4dded" name="5.7.2设计定型标准和要求" filename="b448feb3-4731-4344-bf27-a29309b4dded.docx"/&gt; &lt;item id="72e2b383-83ad-4699-ad07-23b6c29da944" name="5.7.3审查意见书" filename="72e2b383-83ad-4699-ad07-23b6c29da944.docx"/&gt; &lt;/item&gt; &lt;item id="8f480f8a-cee6-4bb0-8a82-23c01b368f7c" name="5.8审批设计定型" filename="8f480f8a-cee6-4bb0-8a82-23c01b368f7c.docx"&gt; &lt;item id="b5c7d912-9f6f-4660-beb3-57e19f5d4e95" name="5.8.1审批一级军工产品设计定型" filename="b5c7d912-9f6f-4660-beb3-57e19f5d4e95.docx"&gt; &lt;item id="89fc14e1-09af-4537-915a-3fca40f7aa1d" name="5.8.1.1二级定委根据产品设计定型审查意见，审议一级军工产品设计定型有关事宜，符合设计定型标准和要求的，向一级定委呈报批准设计定型的请示；不符合设计定型标准和要求的，提出处理意见，连同原提交的军工产品设计定型申请文件一并退回申请单位。" filename="89fc14e1-09af-4537-915a-3fca40f7aa1d.docx"/&gt; &lt;item id="b47935da-32fd-4ff7-b1a2-8ffa74d69dba" name="5.8.1.2一级定委专家咨询委员会对二级定委报送的军工产品设计定型请示进行审核，审核后向一级定委提出定型咨询意见。专家咨询一委员会可参加二级定委组织的试验试用大纲评审、试验试用、定型审查等活动。" filename="b47935da-32fd-4ff7-b1a2-8ffa74d69dba.docx"/&gt; &lt;item id="1d7edc11-e6f2-4513-8268-ccf2de55e1ba" name="5.8.1.3一级定委对符合规定标准和要求的产品，按照规定的权限批准设计定型或报国务院、中央军委审批，下发批复；对不符合规定标准和要求的产品，提出处理意见，连同原报送的有关文件一并退回报送的二级定委。" filename="1d7edc11-e6f2-4513-8268-ccf2de55e1ba.docx"/&gt; &lt;item id="dd662740-de4a-4dee-9b05-afe92b3a020a" name="5.8.1.4产品批准设计定型后，由一级定委颁发产品设计定型证书，由二级定委对有关设计定型文件加盖设计定型专用章。" filename="dd662740-de4a-4dee-9b05-afe92b3a020a.docx"/&gt; &lt;/item&gt; &lt;item id="e3da11b1-6637-4e06-adfd-191614132859" name="5.8.2审批二级军工产品设计定型" filename="e3da11b1-6637-4e06-adfd-191614132859.docx"/&gt; &lt;/item&gt; &lt;/item&gt; &lt;item id="248e1e89-f829-4e89-b4d7-9420dacc13b8" name="6生产定型" filename="248e1e89-f829-4e89-b4d7-9420dacc13b8.docx"&gt; &lt;item id="90f82375-bf17-4d44-86b5-581bcce5ec2d" name="6.1生产定型条件和时间" filename="90f82375-bf17-4d44-86b5-581bcce5ec2d.docx"/&gt; &lt;item id="7a197dae-20e4-4ba7-abce-86d6ce6ced72" name="6.2生产定型程序" filename="7a197dae-20e4-4ba7-abce-86d6ce6ced72.docx"/&gt; &lt;item id="21da9766-d333-41cf-abc9-933006b59799" name="6.3部队试用产品与生产定型试验产品" filename="21da9766-d333-41cf-abc9-933006b59799.docx"&gt; &lt;item id="2c96287b-3f41-4fb5-9ee5-71a4b3a763ee" name="6.3.1部队试用产品" filename="2c96287b-3f41-4fb5-9ee5-71a4b3a763ee.docx"/&gt; &lt;item id="f96c66e4-6279-4bd5-a52a-2948e7ec580e" name="6.3.2生产定型试验产品" filename="f96c66e4-6279-4bd5-a52a-2948e7ec580e.docx"/&gt; &lt;/item&gt; &lt;item id="5f252b0e-7785-4d08-9d74-a85081c9dc5f" name="6.4组织工艺和生产条件考核" filename="5f252b0e-7785-4d08-9d74-a85081c9dc5f.docx"/&gt; &lt;item id="6ff6d59f-1711-42a1-beb9-cf8c96208049" name="6.5申请部队试用" filename="6ff6d59f-1711-42a1-beb9-cf8c96208049.docx"/&gt; &lt;item id="5fb9ca65-9ed9-426c-adb0-82c3c8a42d9f" name="6.6制定部队试用大纲" filename="5fb9ca65-9ed9-426c-adb0-82c3c8a42d9f.docx"/&gt; &lt;item id="7017ddc5-456f-470c-a73b-284704415106" name="6.7组织部队试用" filename="7017ddc5-456f-470c-a73b-284704415106.docx"&gt; &lt;item id="d2b30828-a09a-4534-bdcd-4eda8aba8e90" name="6.7.1部队试用的实施" filename="d2b30828-a09a-4534-bdcd-4eda8aba8e90.docx"/&gt; &lt;item id="2d83ebef-af67-4ff7-8b2c-d61bcface34e" name="6.7.2部队试用报告" filename="2d83ebef-af67-4ff7-8b2c-d61bcface34e.docx"/&gt; &lt;/item&gt; &lt;item id="eedd399f-0d47-42c0-b954-20b532a05340" name="6.8申请生产定型试验" filename="eedd399f-0d47-42c0-b954-20b532a05340.docx"/&gt; &lt;item id="a2f3b8ab-5fdf-44cd-8694-a020dbed6fe2" name="6.9制定生产定型试验大纲" filename="a2f3b8ab-5fdf-44cd-8694-a020dbed6fe2.docx"/&gt; &lt;item id="c35fa5ab-ba11-451a-bbf5-043add4496c1" name="6.10组织生产定型试验" filename="c35fa5ab-ba11-451a-bbf5-043add4496c1.docx"/&gt; &lt;item id="f5ad80a9-fdc2-4bab-a460-2da497dfca68" name="6.11申请生产定型" filename="f5ad80a9-fdc2-4bab-a460-2da497dfca68.docx"&gt; &lt;item id="25783469-78ff-4400-b39c-795e72ed33b0" name="6.11.1提出申请报告" filename="25783469-78ff-4400-b39c-795e72ed33b0.docx"/&gt; &lt;item id="0344cbf0-1595-4124-b030-20a9ace0941c" name="6.11.2申请报告内容" filename="0344cbf0-1595-4124-b030-20a9ace0941c.docx"/&gt; &lt;item id="6862ca2d-b646-4eba-af5c-150de9055301" name="6.11.3申请报告附件" filename="6862ca2d-b646-4eba-af5c-150de9055301.docx"/&gt; &lt;/item&gt; &lt;item id="a12aaeb2-2615-437a-aeb4-2ce7fc172657" name="6.12组织生产定型审查" filename="a12aaeb2-2615-437a-aeb4-2ce7fc172657.docx"&gt; &lt;item id="e5987e7d-5a37-4906-961e-6ee839dfc743" name="6.12.1生产定型审查组 " filename="e5987e7d-5a37-4906-961e-6ee839dfc743.docx"/&gt; &lt;item id="b9c74941-650a-4f8f-a92c-8578e60c072b" name="6.12.2生产定型标准和要求" filename="b9c74941-650a-4f8f-a92c-8578e60c072b.docx"/&gt; &lt;item id="fa286bb9-27e0-4d50-ac57-78773dfbded3" name="6.12.3审查意见书" filename="fa286bb9-27e0-4d50-ac57-78773dfbded3.docx"/&gt; &lt;/item&gt; &lt;item id="0346afa0-ca37-46e8-89c5-eaaec86a8898" name="6.13审批生产定型" filename="0346afa0-ca37-46e8-89c5-eaaec86a8898.docx"/&gt; &lt;/item&gt; &lt;item id="6472b4ba-fbf8-4b8b-bf3a-7d0412edade2" name="7定型文件" filename="6472b4ba-fbf8-4b8b-bf3a-7d0412edade2.docx"&gt; &lt;item id="f79e1d11-fb56-45cb-8529-fba7eac33185" name="7.1定型文件种类" filename="f79e1d11-fb56-45cb-8529-fba7eac33185.docx"/&gt; &lt;item id="07fce1f4-d186-42f1-ab89-1f9db5d65e0b" name="7.2定型文件清单" filename="07fce1f4-d186-42f1-ab89-1f9db5d65e0b.docx"&gt; &lt;item id="cece5585-cf2f-4891-a4df-e1e5c2e57508" name="7.2.1设计定型文件" filename="cece5585-cf2f-4891-a4df-e1e5c2e57508.docx"/&gt; &lt;item id="45350173-17a8-4357-bb2c-540e5184c6b5" name="7.2.2生产定型文件" filename="45350173-17a8-4357-bb2c-540e5184c6b5.docx"/&gt; &lt;/item&gt; &lt;item id="9d8ebba1-513a-4eea-ade1-8629e3d5ea60" name="7.3定型文件制作要求" filename="9d8ebba1-513a-4eea-ade1-8629e3d5ea60.docx"&gt; &lt;item id="2ea2bd5a-fb02-4ffa-b219-4261f8232b42" name="7.3.1技术文件格式" filename="2ea2bd5a-fb02-4ffa-b219-4261f8232b42.docx"/&gt; &lt;item id="a6d486b7-c3ae-4109-adf7-54270879bdb8" name="7.3.2产品图样绘制" filename="a6d486b7-c3ae-4109-adf7-54270879bdb8.docx"/&gt; &lt;item id="1a9b9795-7469-4fd6-92be-ff43c9cf454e" name="7.3.3产品照片和录像片" filename="1a9b9795-7469-4fd6-92be-ff43c9cf454e.docx"/&gt; &lt;item id="ba1e384c-e16e-4b3a-a125-0575f38d3a1e" name="7.3.4文件整理" filename="ba1e384c-e16e-4b3a-a125-0575f38d3a1e.docx"/&gt; &lt;/item&gt; &lt;item id="50c13504-32c3-4a6d-ae96-f9a35cfd6c9e" name="7.4定型文件汇总上报" filename="50c13504-32c3-4a6d-ae96-f9a35cfd6c9e.docx"/&gt; &lt;item id="3cca6d6b-13a2-495b-ba9d-bd21b8584917" name="7.5定型文件盖章" filename="3cca6d6b-13a2-495b-ba9d-bd21b8584917.docx"/&gt; &lt;item id="a7381eb0-fc6a-48f0-8fe1-236d63401a41" name="7.6定型文件的使用" filename="a7381eb0-fc6a-48f0-8fe1-236d63401a41.docx"/&gt; &lt;item id="a77fbb37-dc8d-489e-a29f-0fe414ee4c43" name="7.7定型文件的修改" filename="a77fbb37-dc8d-489e-a29f-0fe414ee4c43.docx"/&gt; &lt;/item&gt;&lt;/item&gt; 不过poi 分割.docx没问题，但是分割.doc 文件就会有问题 所以中间如果是.doc 文件的话，所以中间还得进行转换，这里我使用的技术是aspose for java,这个特别简单只要把jar 包引入即可两步，不过这个玩艺是收费的，所以有点扯，不过，最后在csdn花了10分，下载了一个license.xml(破解)： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.sysware.soft603.util.backUp;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import com.aspose.words.Document;import com.aspose.words.License;public class WordToPDF &#123; public static boolean getLicense() &#123; boolean result = false; try &#123; // InputStream is = // Test.class.getClassLoader().getResourceAsStream("\\license.xml"); InputStream is = Test.class.getClassLoader().getResourceAsStream( "com\\sysware\\soft603\\util\\backUp\\license.xml"); // InputStream is = // Test.class.getClassLoader().getResourceAsStream("testpackage/license2.xml"); // InputStream is = // Test.class.getClassLoader().getResourceAsStream("subpackage/license3.xml"); License aposeLic = new License(); aposeLic.setLicense(is); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; public static void main(String[] args) &#123; // 验证License if (!getLicense()) &#123; return; &#125; String path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.doc"; InputStream is = null; try &#123; is = new FileInputStream(path); Document doc = new Document(is); doc.save("d:\\1028.pdf");//转pdf、docx都可以 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 以下是合并的代码：使用的是docx4j 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282package com.sysware.soft603.util.backUp;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.apache.commons.io.IOUtils;import org.apache.poi.xwpf.usermodel.BodyElementType;import org.apache.poi.xwpf.usermodel.IBodyElement;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.apache.poi.xwpf.usermodel.XWPFParagraph;import org.apache.poi.xwpf.usermodel.XWPFStyles;import org.docx4j.jaxb.Context;import org.docx4j.openpackaging.exceptions.Docx4JException;import org.docx4j.openpackaging.packages.WordprocessingMLPackage;import org.docx4j.openpackaging.parts.PartName;import org.docx4j.openpackaging.parts.WordprocessingML.AlternativeFormatInputPart;import org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart;import org.docx4j.relationships.Relationship;import org.docx4j.wml.CTAltChunk;public class MargeDoc &#123; public void mergeDocx(List&lt;String&gt; list, String path) &#123; List&lt;InputStream&gt; inList = new ArrayList&lt;InputStream&gt;(); for (int i = 0; i &lt; list.size(); i++) try &#123; inList.add(new FileInputStream(list.get(i))); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; InputStream inputStream = mergeDocx(inList); saveTemplate(inputStream, path); &#125; catch (Docx4JException | IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public InputStream mergeDocx(final List&lt;InputStream&gt; streams) throws Docx4JException, IOException &#123; WordprocessingMLPackage target = null; final File generated = File.createTempFile("generated", ".docx"); int chunkId = 0; Iterator&lt;InputStream&gt; it = streams.iterator(); while (it.hasNext()) &#123; InputStream is = it.next(); if (is != null) &#123; if (target == null) &#123; // Copy first (master) document OutputStream os = new FileOutputStream(generated); os.write(IOUtils.toByteArray(is)); os.close(); target = WordprocessingMLPackage.load(generated); &#125; else &#123; // Attach the others (Alternative input parts) insertDocx(target.getMainDocumentPart(), IOUtils.toByteArray(is), chunkId++); &#125; &#125; &#125; if (target != null) &#123; target.save(generated); return new FileInputStream(generated); &#125; else &#123; return null; &#125; &#125; // 鎻掑叆鏂囨。 private void insertDocx(MainDocumentPart main, byte[] bytes, int chunkId) &#123; try &#123; AlternativeFormatInputPart afiPart = new AlternativeFormatInputPart( new PartName("/part" + chunkId + ".docx")); // afiPart.setContentType(new ContentType(CONTENT_TYPE)); afiPart.setBinaryData(bytes); Relationship altChunkRel = main.addTargetPart(afiPart); CTAltChunk chunk = Context.getWmlObjectFactory().createCTAltChunk(); chunk.setId(altChunkRel.getId()); main.addObject(chunk); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void saveTemplate(InputStream fis, String toDocPath) &#123; FileOutputStream fos; int bytesum = 0; int byteread = 0; try &#123; fos = new FileOutputStream(toDocPath); byte[] buffer = new byte[1444]; while ((byteread = fis.read(buffer)) != -1) &#123; bytesum += byteread; // 瀛楄妭鏁� 鏂囦欢澶у皬 fos.write(buffer, 0, byteread); &#125; fis.close(); fos.close(); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Docx4JException, IOException &#123; MargeDoc wordUtil = new MargeDoc(); String template = "D:/poinew"; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(template + "/0.docx"); list.add(template + "/1.docx"); list.add(template + "/2.docx"); list.add(template + "/3.docx"); list.add(template + "/3.1.docx"); list.add(template + "/3.2.docx"); list.add(template + "/3.3.docx"); list.add(template + "/3.4.docx"); list.add(template + "/3.5.docx"); list.add(template + "/3.6.docx"); list.add(template + "/3.7.docx"); list.add(template + "/3.8.docx"); list.add(template + "/3.9.docx"); list.add(template + "/4.docx"); list.add(template + "/4.1.docx"); list.add(template + "/4.2.docx"); list.add(template + "/4.3.docx"); list.add(template + "/4.4.docx"); list.add(template + "/5.docx"); list.add(template + "/5.1.docx"); list.add(template + "/5.2.docx"); list.add(template + "/5.3.docx"); list.add(template + "/5.4.docx"); list.add(template + "/5.4.1.docx"); list.add(template + "/5.4.2.docx"); list.add(template + "/5.4.3.docx"); list.add(template + "/5.4.4.docx"); list.add(template + "/5.5.docx"); list.add(template + "/5.5.1.docx"); list.add(template + "/5.5.2.docx"); list.add(template + "/5.5.3.docx"); list.add(template + "/5.5.4.docx"); list.add(template + "/5.5.5.docx"); list.add(template + "/5.5.6.docx"); list.add(template + "/5.5.7.docx"); list.add(template + "/5.5.8.docx"); list.add(template + "/5.6.docx"); list.add(template + "/5.6.1.docx"); list.add(template + "/5.6.2.docx"); list.add(template + "/5.6.3.docx"); list.add(template + "/5.6.4.docx"); list.add(template + "/5.7.docx"); list.add(template + "/5.7.1.docx"); list.add(template + "/5.7.2.docx"); list.add(template + "/5.7.3.docx"); list.add(template + "/5.8.docx"); list.add(template + "/5.8.1.docx"); list.add(template + "/5.8.1.1.docx"); list.add(template + "/5.8.1.2.docx"); list.add(template + "/5.8.1.3.docx"); list.add(template + "/5.8.1.4.docx"); list.add(template + "/5.8.2.docx"); list.add(template + "/6.docx"); list.add(template + "/6.1.docx"); list.add(template + "/6.2.docx"); list.add(template + "/6.3.docx"); list.add(template + "/6.3.1.docx"); list.add(template + "/6.3.2.docx"); list.add(template + "/6.4.docx"); list.add(template + "/6.5.docx"); list.add(template + "/6.6.docx"); list.add(template + "/6.7.docx"); list.add(template + "/6.7.1.docx"); list.add(template + "/6.7.2.docx"); list.add(template + "/6.8.docx"); list.add(template + "/6.9.docx"); list.add(template + "/6.10.docx"); list.add(template + "/6.11.docx"); list.add(template + "/6.11.1.docx"); list.add(template + "/6.11.2.docx"); list.add(template + "/6.11.3.docx"); list.add(template + "/6.12.docx"); list.add(template + "/6.12.1.docx"); list.add(template + "/6.12.2.docx"); list.add(template + "/6.12.3.docx"); list.add(template + "/6.13.docx"); list.add(template + "/7.docx"); list.add(template + "/7.1.docx"); list.add(template + "/7.2.docx"); list.add(template + "/7.2.1.docx"); list.add(template + "/7.2.2.docx"); list.add(template + "/7.3.docx"); list.add(template + "/7.3.1.docx"); list.add(template + "/7.3.2.docx"); list.add(template + "/7.3.3.docx"); list.add(template + "/7.3.4.docx"); list.add(template + "/7.4.docx"); list.add(template + "/7.5.docx"); list.add(template + "/7.6.docx"); list.add(template + "/7.7.docx"); wordUtil.mergeDocx(list, template + "/out.docx"); //splitWord(); &#125; private static void splitWord() &#123; String path = "d:\\poinew\\out.docx"; InputStream is = null; try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; XWPFDocument doc = null; try &#123; doc = new XWPFDocument(is); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 获取bodyElements List&lt;IBodyElement&gt; bodyElements = doc.getBodyElements(); // 获取doc样式 XWPFStyles styles = doc.getStyles(); System.out.println(doc.getParagraphs().size()); for (int i = 0; i &lt; bodyElements.size(); i++) &#123; IBodyElement bodyElement = bodyElements.get(i); try &#123; if (bodyElement.getElementType() == BodyElementType.PARAGRAPH) &#123; XWPFParagraph para = (XWPFParagraph) bodyElement; System.out.println(styles.getStyle(para.getStyle()).getCTStyle().getName().getVal()); System.out.println(para.getText()); if (styles.getStyle(para.getStyle()).getCTStyle().getName().getVal().contains("heading")) &#123; XWPFParagraph para1 = (XWPFParagraph) doc.getBodyElements().get(i); String str1 = para1.getStyleID(); doc.getStyles().getStyle(str1).getCTStyle().getPPr().unsetNumPr(); System.out.println("test"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; XWPFDocument newDoc = doc; int max = 0; path = "d:\\poinew\\out.docx"; OutputStream out = null; try &#123; out = new FileOutputStream("d:\\poinew\\newOut.docx"); try &#123; doc.write(out); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("over"); &#125;&#125; 使用jacob合并多个word为单个word1导入jar 包,我使用的是1.7,dil文件一定要和jar包匹配 使用前操作 1、把dll文件放在%JAVA_HOME%\bin下（注意系统是32位还是64位）， 也可以放在C:\Windows\System32下，如果是64位应该放在C:\Windows\SysWOW64 下。建议放在jdk的bin目录下 2、如果是在eclipse下开发，需要重新引入jdk（Preference/Java/Installed JREs） 3、开发时将jacab.jar包放在项目lib下并add到liabraries中即可。 测试用例: 我在我两台电脑上都部署了,但不知为啥,一台运行出现异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.dyz.test; import java.util.ArrayList;import java.util.List; import com.jacob.activeX.ActiveXComponent;import com.jacob.com.Dispatch;import com.jacob.com.Variant; public class TestWord &#123; public static void main(String[] args) &#123; List list = new ArrayList(); String file1 = "D:\\file1.doc"; String file2 = "D:\\file2.doc"; //String file3 = "D:\\file3.doc"; list.add(file1); list.add(file2); //list.add(file3); // System.out.println(System.getProperty("java.library.path")); uniteDoc(list, "d:\\file.doc"); &#125; public static void uniteDoc(List fileList, String savepaths) &#123; if (fileList.size() == 0 || fileList == null) &#123; return; &#125; // 打开word ActiveXComponent app = new ActiveXComponent("Word.Application");// 启动word try &#123; // 设置word不可见 app.setProperty("Visible", new Variant(false)); // 获得documents对象 Object docs = app.getProperty("Documents").toDispatch(); // 打开第一个文件 Object doc = Dispatch .invoke((Dispatch) docs, "Open", Dispatch.Method, new Object[] &#123; (String) fileList.get(0), new Variant(false), new Variant(true) &#125;, new int[3]).toDispatch(); // 追加文件 for (int i = 1; i &lt; fileList.size(); i++) &#123; Dispatch.invoke(app.getProperty("Selection").toDispatch(), "insertFile", Dispatch.Method, new Object[] &#123; (String) fileList.get(i), "", new Variant(false), new Variant(false), new Variant(false) &#125;, new int[3]); &#125; // 保存新的word文件 Dispatch.invoke((Dispatch) doc, "SaveAs", Dispatch.Method, new Object[] &#123; savepaths, new Variant(1) &#125;, new int[3]); Variant f = new Variant(false); Dispatch.call((Dispatch) doc, "Close", f); &#125; catch (Exception e) &#123; throw new RuntimeException("合并word文件出错.原因:" + e); &#125; finally &#123; app.invoke("Quit", new Variant[] &#123;&#125;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要自称为程序员]]></title>
    <url>%2Fposts%2F34625.html</url>
    <content type="text"><![CDATA[每年都有无数年轻程序员，加入软件行业。 他们在学校里学过编程，但是对这个行业的现实一无所知。Patrick McKenzie 是美国一家小软件公司的老板，他写了一篇长文，介绍这个行业的一些实际情况。我看了以后很感慨，有些地方很受启发。我选择了一部分，翻译如下。 一、90%的编程工作来自内部软件计算机专业的学生，可能有一种印象，觉得大部分程序员，都在编写公开出售的软件或者通用软件。 这种看法是不对的。大部分程序员，实际上编写的是不公开的企业内部软件，比如追踪费用的软件、优化装运成本的软件、帮助记账的软件、设计新部件的软件、计算保单价格的软件、识别恶意订单的软件等等。各种各样的商业公司，开发内部软件，解决它们自己的问题。市场上对程序员的大部分需求来源于此，只有极少数程序员直接编写面向外部顾客的软件。 内部软件的开发，通常非常乏味，令人厌倦。因为它们的技术复杂性低、技术决策非常保守、预算很少、缺乏长远考虑。但是，世界上大部分编程工作都是这种。 二、别人雇你的目的，是让你创造利润，不是让你编程商业公司最关心的（或者说唯一在乎的）事情，就是增加收入、降低成本。因此，它们实际上需要的不是程序员，而是能够帮助它们增加收入、降低成本的人。 开发优美的软件，解决技术难题，编写没有 bug 的代码，这些都不是商业公司的目的。它们雇佣你，是为了让你帮它们完成某个可以增加收入、降低成本的项目，而不是为了让你追求个人的软件成就。 你对于公司的唯一价值，就在于能多大程度上为它们增加收入、降低成本。 三、不要自称为程序员很多公司的经理不懂计算机，在他们心目中，程序员就是一群高成本的劳动力，只会在一台复杂的机器上干一些难懂的事情。 如果你自称为”程序员”，当公司需要压缩成本的时候，某些经理首先就会想到解雇你，因为你的工资高。有一家公司叫 Salesforce，口号是”没有软件”，意思就是如果经理们购买了他们的服务，就不再需要别的软件管理销售业务了，也就是说，不再需要自己雇佣程序员了。 正确的做法是，你应该把自己描述成与增加收入、降低成本有关系的人，比如”xx产品的开发者”或”改进者”。有一个 Google Adsense 程序员的自我介绍，是这样写的：”Google 公司97%的收入，与我的代码有关。” 四、不要限定自己年轻学生经常会问，应该选择哪种语言或平台？Java 是不是比 .NET 容易找工作？ 过分强调某一种语言或平台，都是不必要的。如果你把自己限定为 Java 程序员或 .NET 程序员，你就已经输了，因为首先你不应该自称为程序员（理由见上一点），其次这种限定使得你自动被排除在世界上大多数编程工作之外。 现实生活中，学会一种新语言，只需要几个星期，然后再过半年到一年，你就会变成老手。那时，根本没人在乎你以前用什么语言。 天才程序员是很少的，可是需要天才程序员的工作机会却很多很多，大多数场合都是需求远远大于供给。这意味着，即使你不是天才程序员，只要你是一个优秀工程师，那些招聘公司也会立刻录用你，因为它们知道招聘到天才程序员的机会微乎其微。（重复一遍，所谓”优秀工程师”，就是你的履历上有一连串增加收入、降低成本的记录。） 某些公司的人事部门，会根据某个关键词（比如 Java 或 .NET）过滤简历。虽然这样的公司根本不值得去，但是如果你真的想过这一关，也很容易：投入几个晚上和周末，在你当前的项目中设法用到这个关键词，然后再把它写进简历就行了。 五、如何提高求职时的谈判能力？（1）记住你不是在求职，不是在展示编程技巧，而是在推销某种商业问题（增加收入或降低成本）的解决方案。 （2）面试时，要有自信，要平等的对话。你要的是一个互利的录用合同，不要每次对方提出要求，你都说Yes。 （3）雇主可能会问”你的上一份工资是多少”，他们其实在说”给我一个理由，压低你的报酬”。你要想好如何适当地回答这个问题。 （4）要还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。 （5）在对方决定录用你以后，才开始讨论薪水。因为那时，他们已经在你身上，投入了大量的时间和金钱，产生了一定的成本，此时他们可能觉得一些小问题已经不值得再纠缠了，比如每年的工资增加几千元。 六、创业公司是否适合应届毕业生？如果你一毕业就加入创业公司，最可能的结果是，接下来几年你都工作得非常辛苦，然后公司悲惨地失败了，你失业了，不得不又去另一家创业公司工作。 如果你真的想去创业公司，应该首先找一家大公司干上两年，攒一点钱，积累一些经验，然后精心挑选一家创业公司，再去实现自己的梦想。 在创业公司工作，一般情况下，你遇到的都是创业者。他们大多数人没有能力在两年后雇佣你；而在大公司工作，你遇到的都是其他大公司的人，他们中很多人将来有能力雇用你或者帮你介绍工作。 七、沟通技能是最重要的职业技能前面说过，工程师被雇佣，不是因为会编程，而是因为能够创造商业价值。所以，你得让人们相信你能创造价值，这是帮助你找到工作的最重要的能力。这种能力与你真的能创造多少价值，实际上联系不是很紧密。 我认识的一些最优秀的程序员，往往拙于表达。因此，别人不是不想与他们一起工作，就是低估了他们的价值。相反地，如果你看上去很会编程，并且很善于表达，别人就会真的这样看待你。 （完）]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 获取音视频文件的大小、以及播放时长]]></title>
    <url>%2Fposts%2F54695.html</url>
    <content type="text"><![CDATA[简介The JAVE (Java Audio Video Encoder) library is Java wrapper on the ffmpeg project. Developers can take take advantage of JAVE to transcode audio and video files from a format to another. In example you can transcode an AVI file to a MPEG one, you can change a DivX video stream into a (youtube like) Flash FLV one, you can convert a WAV audio file to a MP3 or a Ogg Vorbis one, you can separate and transcode audio and video tracks, you can resize videos, changing their sizes and proportions and so on. Many other formats, containers and operations are supported by JAVE.看介绍这么强大，其实我的需求只是想要获取视频、语音的长度而已。使用 总共只有一个jar包，API也非常简单，不说了，贴代码 首先引入jave-1.0.2.jar， 写了个demo 仅供参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.readVideo.test; public class VideoName &#123; private int id; private String name; private String time; private String size; private String leaf; private String url; private String brief; private int VIDEO_DETAIL_ID; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getTime() &#123; return time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public String getSize() &#123; return size; &#125; public void setSize(String size) &#123; this.size = size; &#125; public String getLeaf() &#123; return leaf; &#125; public void setLeaf(String leaf) &#123; this.leaf = leaf; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getBrief() &#123; return brief; &#125; public void setBrief(String brief) &#123; this.brief = brief; &#125; public int getVIDEO_DETAIL_ID() &#123; return VIDEO_DETAIL_ID; &#125; public void setVIDEO_DETAIL_ID(int vIDEO_DETAIL_ID) &#123; VIDEO_DETAIL_ID = vIDEO_DETAIL_ID; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.readVideo.test; import it.sauronsoftware.jave.Encoder;import it.sauronsoftware.jave.MultimediaInfo;import java.io.File;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.List; public class ReadVideoMessages &#123; /** * 得到视频的大小 * * @param f * 文件 * @return 视频的大小 */ public static String getFileSize(File f) &#123; // 保留两位小数 DecimalFormat df = new DecimalFormat(".##"); // 得到视频的长度 Long long1 = f.length(); String size = ""; long G = 1024 * 1024 * 1024; long M = 1024 * 1024; long K = 1024; // 视频大小超过G、超过M不超过G、超过K不超过M if (long1 / G &gt;= 1) &#123; size = df.format((double) long1 / G) + "G"; &#125; else if (long1 / M &gt;= 1) &#123; size = df.format((double) long1 / M) + "M"; &#125; else if (long1 / K &gt;= 1) &#123; size = df.format((double) long1 / K) + "K"; &#125; else &#123; size = long1 + "B"; &#125; // System.out.println(time); return size; &#125; /** * 得到视频的长度 * * @param f * 文件 * @return 视频的长度 */ public static String getVideoTime(File f) &#123; String time = ""; //新建编码器对象 Encoder encoder = new Encoder(); try &#123; //得到多媒体视频的信息 MultimediaInfo m = encoder.getInfo(f); //得到毫秒级别的多媒体是视频长度 long ls = m.getDuration(); //转换为分秒 time = ls / 60000 + "分" + (ls - (ls / 60000 * 60000)) / 1000 + "秒"; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return time; &#125; // 显示目录的方法 /** * 得到视频所有的信息 * * @param file * 文件夹 or 文件 * @return 视频的信息 */ public static List&lt;VideoName&gt; getAllMessage(File file) &#123; List&lt;VideoName&gt; videoNames = new ArrayList&lt;VideoName&gt;(); // System.out.println( file.getAbsolutePath()); String time = ""; String size = ""; // 判断传入对象是否为一个文件夹对象 if (!file.isDirectory()) &#123; System.out.println("你输入的不是一个文件夹，请检查路径是否有误！！"); &#125; else &#123; File[] f = file.listFiles(); for (int i = 0; i &lt; f.length; i++) &#123; // 判断文件列表中的对象是否为文件夹对象，如果是则执行tree递归，直到把此文件夹中所有文件输出为止 if (f[i].isDirectory()) &#123; System.out.println(f[i].getName() + "\tttdir"); // getAllMessage(f[i]); &#125; else &#123; time = getVideoTime(f[i]); if (time.equals("")) &#123; time = "未知"; &#125; size = getFileSize(f[i]); VideoName videoName = new VideoName(); int j = f[i].getName().indexOf("-", 1); videoName.setName(f[i].getName().substring(0, j)); videoName.setSize(size); videoName.setTime(time); videoName.setBrief(f[i].getName().substring(j + 1, f[i].getName().length())); videoName.setUrl("F:/Resource/video/硬件/AltiumDesigner/" + f[i].getName()); videoNames.add(videoName); System.out.println(time + "---" + size + "---" + f[i].getName().substring(0, j) + "---" + f[i].getName().substring(j + 1, f[i].getName().length()) + "---" + "F:/Resource/video/硬件/AltiumDesigner/" + f[i].getName()); &#125; &#125; &#125; return videoNames; &#125; public static void main(String[] args) &#123; File f = new File("F:\\Resource\\video\\软件\\LabView"); List&lt;VideoName&gt; videoMessages = getAllMessage(f); System.out.println(videoMessages.size()); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Listener实现在线统计人数和总访问量]]></title>
    <url>%2Fposts%2F61929.html</url>
    <content type="text"><![CDATA[监听器用于监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当范围对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计在线人数和在线用户，系统加载时进行信息初始化，统计网站的访问量等等。 分类： 按监听的对象划分，可以分为 ServletContext对象监听器HttpSession对象监听器ServletRequest对象监听器 按监听的事件划分 对象自身的创建和销毁的监听器对象中属性的创建和消除的监听器session中的某个对象的状态变化的监听器 示例：用监听器统计网站在线人数 原理：每当有一个访问连接到服务器时，服务器就会创建一个session来管理会话。那么我们就可以通过统计session的数量来获得当前在线人数。 监听器应用一般统计在线人数,闲着没事，写个笔记，我们项目中是这样做的 首先定义一个servlet 这个servelt 在服务器启动时，就会调用，初始化： 实现累计访问量的一个方法1.web.xml的配置1234567&lt;!-- added by li'n for 登陆页面自动读取访问数 on 2013-04-15 the beginning --&gt; &lt;servlet&gt; &lt;servlet-name&gt;VisitCounts&lt;/servlet-name&gt; &lt;servlet-class&gt;com.sysware.framework.login.VisitCounts&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- added by li'n for 登陆页面自动读取访问数 on 2013-04-15 the end --&gt; ２.项目登录页面可以获取访问本项目的总人数（init方法）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.sysware.framework.login; import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException; import javax.servlet.http.HttpServlet; /** * @version 1.0 * @author li'n on 系统工程部 * @since 2013-04-15 17:00 * */public class VisitCounts extends HttpServlet&#123; /** * */ private static final long serialVersionUID = -6737156348721467846L; //累计访问量 public static int counts = 0; public static void setCounts(int counts) &#123; VisitCounts.counts = counts; &#125; /** * * @return 历史访问量 */ public int getCounts() &#123; return counts; &#125; /** * 服务器启动时读取文件中的历史访问量 */ public void init() &#123; //获取visitCount.txt的文件路径 String p = this.getClass().getClassLoader().getResource("").getPath(); File file = new File(p+File.separator +"visitCount.txt"); //读取文件中的数字，即系统的历史访问量 if (file.exists()) &#123; readFile(file); &#125; else &#123; try &#123; file.createNewFile(); readFile(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 读取文件file中的访问量数据 */ @SuppressWarnings("static-access") public void readFile(File file)&#123; BufferedReader reader = null; String tempString = null; try &#123; reader = new BufferedReader(new FileReader(file)); while((tempString = reader.readLine()) != null) &#123; VisitCounts.counts = Integer.parseInt(tempString); System.out.println(); this.setCounts(counts); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; ３.在用户登录时，数量加１并用流写到文件里面（doLogin方法里面处理）123456789if(loginInfo.isSuccess()) &#123; //added by li'n for 访问量统计 on 2013-04-19 the beginning //登录成功，访问量加1 VisitCounts.setCounts(VisitCounts.counts + 1); //将访问量更新到文件visitCount.txt writeFile(); //added by li'n for 访问量统计 on 2013-04-19 the end &#125;&lt;br&gt;/**&lt;br&gt; * 将访问量更新到文件visitCount.txt&lt;br&gt; * @return 历史访问量&lt;br&gt; * @author li'n on 系统工程部&lt;br&gt; * @since 2013-04-19 &lt;br&gt; */&lt;br&gt; public void writeFile()&#123;&lt;br&gt; &lt;br&gt; FileWriter filewrite = null;&lt;br&gt; try &#123;&lt;br&gt; &lt;br&gt; //获得文件路径&lt;br&gt; filewrite = new FileWriter(this.getClass().getClassLoader().getResource("").getPath()+File.separator +"visitCount.txt");&lt;br&gt; &lt;br&gt; //将访问量写入文件&lt;br&gt; int o = VisitCounts.counts;&lt;br&gt; filewrite.write(o + "\r\n");&lt;br&gt; filewrite.flush();&lt;br&gt; filewrite.close();&lt;br&gt; &#125; catch (Exception e) &#123;&lt;br&gt; e.printStackTrace();&lt;br&gt; &#125;&lt;br&gt;&lt;br&gt; &#125; 以上，是实现累计访问量的一个方法； 下面说说实现在线人数，这个就要用到监听器的方式 实现在线人数首先还是在 web.xml中配置你所写的监听器1234&lt;!-- 在线用户session监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;com.sysware.framework.login.OnlineSessionListener&lt;/listener-class&gt; &lt;/listener&gt; ２.监听器类1234567891011121314151617181920212223242526272829303132333435363738394041package com.sysware.framework.login; import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent; import com.sysware.framework.commons.SystemConstants; /** * * * 在线session监听器 * * @version : 1.0 * @since : 2012-5-21下午08:46:02 * @team : 系统管理 * @author : liuxj */public class OnlineSessionListener implements HttpSessionAttributeListener &#123; @Override public void attributeAdded(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().addSession(event.getSession()); &#125; &#125; @Override public void attributeRemoved(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().removeSession(event.getSession()); &#125; &#125; @Override public void attributeReplaced(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().replaceSession(event.getSession()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.sysware.framework.login;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import javax.servlet.http.HttpSession;import com.sysware.framework.commons.SystemConstants;import com.sysware.framework.eobs.commons.ObjectCloneUtils;import com.sysware.utils.SyswareUtil;/** * copyright : Sysware Technology Co., Ltd * * 在线用户信息上下文 * * @version : 1.0 * @since : 2012-5-21下午08:31:07 * @team : 系统管理 * @author : liuxj */public class OnlineUserContext &#123; private static OnlineUserContext onlineUserContext; // 用户在线信息 private Map&lt;String, HttpSession&gt; onlineUserMap; private OnlineUserContext() &#123; onlineUserMap = new HashMap&lt;String, HttpSession&gt;(); &#125; /** * 获取在线用户上下文实例 * * @since : 2012-5-23:下午05:47:55 * @return 在线用户上下文实例 */ public static OnlineUserContext getInstance() &#123; return onlineUserContext == null ? onlineUserContext = new OnlineUserContext() : onlineUserContext; &#125; /** * 加入session触发 * * @since : 2012-5-21:下午09:02:26 * @param session * session对象 */ synchronized void addSession(HttpSession session) &#123; onlineUserMap.put(session.getId(), session); &#125; /** * 移除Session * * @since : 2012-5-21:下午09:02:56 * @param session * session对象 */ synchronized void removeSession(HttpSession session) &#123; if (onlineUserMap.containsKey(session.getId())) &#123; onlineUserMap.remove(session.getId()); &#125; &#125; /** * 替换Session * * @since : 2012-5-21:下午09:03:18 * @param session * session对象 */ synchronized void replaceSession(HttpSession session) &#123; addSession(session); &#125; /** * 根据用户ID判断是否登录 * * @since : 2013-1-28:下午02:01:31 * @param userId * 用户ID * @return true已经登录|false未登录 */ public boolean isLogged(String userId) &#123; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for (OnlineUserInfo info : list) &#123; if (info.isLogged() &amp;&amp; info.getUserId().equals(userId)) &#123; return true; &#125; &#125; return false; &#125; /** * 根据sessionId获取session * @since : 2012-12-17:下午01:06:11 * @param sessionId sessionId * @return session */ public HttpSession getSession(String sessionId) &#123; return onlineUserMap.containsKey(sessionId) ? onlineUserMap.get(sessionId) : null; &#125; /** * 根据sessionId移除session * @since : 2012-12-17:下午01:05:39 * @param sessionId sessionId */ public void removeSession(String sessionId) &#123; HttpSession session = getSession(sessionId); if(!SyswareUtil.isEmpty(session)) &#123; session.invalidate(); session = null; &#125; &#125; /** * 获取当前登录操作用户数量 * * @since : 2012-5-21:下午09:20:54 * @return 登录操作用户数量 */ public int getLoginUserCount() &#123; int num = 0; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for(OnlineUserInfo info : list) &#123; if(info.isLogged()) &#123; num ++; &#125; &#125; return num; &#125; /** * 获取当前未登录的操作用户数量 * * @since : 2012-5-21:下午09:21:14 * @return 未登录的操作用户数量 */ public int getNoLoginUserCount() &#123; int num = 0; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for(OnlineUserInfo info : list) &#123; if(!info.isLogged()) &#123; num ++; &#125; &#125; return num; &#125; /** * 获取当前操作用户总数 * * @since : 2012-5-21:下午09:22:16 * @return 操作用户总数 */ public int getOperatorCount() &#123; return getOnlineUserInfoList().size(); &#125; /** * 获取当前操作用户列表 * * @since : 2012-5-22:上午10:11:39 * @return 操作用户列表 */ public synchronized List&lt;OnlineUserInfo&gt; getOnlineUserInfoList() &#123; List&lt;OnlineUserInfo&gt; list = new ArrayList&lt;OnlineUserInfo&gt;(); Iterator&lt;Entry&lt;String, HttpSession&gt;&gt; iterator = onlineUserMap .entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;String, HttpSession&gt; entry = iterator.next(); OnlineUserInfo info = ObjectCloneUtils.clone(getOnlineUserInfo(entry.getKey())); info.setSessionId(entry.getKey()); list.add(info); &#125; return list; &#125; /** * 获取在线用户信息 * * @since : 2012-5-21:下午09:14:01 * @param sessionId * session的ID * @return 在线用户信息 */ private OnlineUserInfo getOnlineUserInfo(String sessionId) &#123; HttpSession session = getSession(sessionId); return SyswareUtil.isEmpty(session) ? null : (Operator) session.getAttribute(SystemConstants.SESSION_KEY); &#125;&#125; 上面的方法，一个是在线统计人数，一个是实现总访问量，自己项目中运用的，做个笔记。 页面12&lt;div class="visit"&gt;当前访问数：&lt;span id="nowVisitCount" style="color:#5374B1;"&gt;&lt;%=OnlineUserContext.getInstance().getLoginUserCount() %&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="count"&gt;累计访问数：&lt;span id="historyVisitCount" style="color:#5374B1;"&gt;&lt;%=new LoginServiceImpl().getCounts()%&gt;&lt;/span&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北方的空地]]></title>
    <url>%2Fposts%2F11881.html</url>
    <content type="text"><![CDATA[第二次穿越大羌塘无人区已过三月，期间不少志同道合者询问事宜，今儿便呈一贴，简叙过往。 此次穿越从青藏高原的西端至高点界山大阪开始，时间4月20日，一路向东经邦达错、羊湖、若拉错、岗扎日，横穿整个藏北无人区后改由北上进入阿尔金无人区，经可可西里山脉、昆仑山脉、鲸鱼湖……在阿奇克库勒湖遇人，再三天车程至花土沟镇，时间七月五号，总历时77天。在离开界山大阪至阿奇克库勒湖的74天里独处无人区，此间行程1400公里左右，跨度四个月。 大羌塘藏语“羌塘”意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用可可西里代替了这片广袤的荒原，实际上，可可西里不论是行政疆域还是地理疆域都只是大羌塘这片土地的一小部分。 大羌塘，他是自由最后追逐之地…… 一、羌塘杨柳松穿越的羌塘位于西藏的北部，藏语的意思是”北方的未知之地”。它的北面是昆仑山脉和可可西里山脉，南面是冈底斯山脉和念青唐古拉山脉，属于高山之间的一块高原盆地。 ……南北最宽760公里，东西长约1200公里。面积59.70万平方公里，占青藏高原总面积的1/4。 行政上属西藏自治区的那曲与阿里两地区管辖。 羌塘高原日照强烈，天气变化无常，风力强劲，十一级大风是家常便饭。冬季极寒缺水，雨季沼泽遍布，是地球上最大的无人区之一。 （图片说明：杨柳松的实际路线） 没有后援，没有补给，与外界断绝联系，几十天不遇人，一个人徒步横穿羌塘，谈何容易。此前，还没有人完成过。 最大困惑有三个方面。一是食物补给，在如此长的天数里完全靠自给确无先例，我到底能承受怎样的饥饿状态？二是体能，在海拔五千米的恶劣环境中超负重推行能坚持多久？三是心理状态，孤身荒原中，面对周而复始的困顿何以应对？ 由于太多天没有消息，杨柳松的朋友都以为他遇难了。2014年，另一个网友沿着这条路线进入羌塘，就失踪了，没有走出来。 二、物资准备1400公里的路程，预计80天左右完成，平均每天推进20公里左右。 我必须达到均速二十公里才有可能完成计划中的旅行。二十公里是理想值，比较安全。但算上大雪封路、地貌巨糟、无端生病、洪水卷地、偷懒睡觉、外星人突访等事件，所以每天行距必须超过二十公里才稳妥。十八公里是危险值，最低均速，底线，咬咬牙能接受。低于十八公里，马克思会很想念我。回顾，在遇人救助前的七十五天独行中，每天均速差那么一点到十八公里，悬而又悬的速度。 20公里看上去并不快，但不要忘记这是在5000米的高原。 有过高原经历的人就知道，每天近二十公里的速度是怎么来的。除了极少的路可小骑过个瘾，其余路况很少能一次推百米不停下喘口气的。硬草地一般推个五十米喘口气，寒漠土二十米喘口气，沙土路十米喘口气，重沙地三五米喘口气，陡坡半个轮圈喘口气。这羌塘就是这么一口口气喘过来的。 既然预计80天，那么就需要准备足够的食物。 此行，食物约有一百斤，其中主食七十七斤，包括五十斤糌粑、二十五斤压缩饼干、二斤麦片，实际使用七十五斤，前期糟蹋了二斤主食。辅食二十五斤，大蒜、酥油、花生米三样就占了一半。其余是少量的盐、紫菜、辣椒粉、茶叶等，以及一点打牙祭的奶粉和白糖。全程无肉，吃过一次蔬菜，微量元素靠金施尔康药片。 这些食物根本不够提供足够的热量和营养，但也没法带更多了。 前四十五天日均摄取热量在一千四百大卡左右，大致四两多糌粑和二点五两压缩饼干，一些汤料为辅。热量摄取水平属于联合国认定的中度饥饿状态，下午四点以后基本就无力了。 为了加热食物和取暖，还需要携带汽油。 此行带了8.6升93号汽油，两个锅，1.5升的大锅主要用于烧水。经过几天实测，烧水需时如下：液体水，早晨要用十六分钟左右烧开，晚上则快些；化冰三十五至四十分钟；化雪耗时最长，四十五至五十分钟。为了节省汽油，所以在雪和轻度盐碱水同存的情况下，我多数会选择后者作为饮用水。汽油同样计划八十天用量，理论上是够了，但实际环境中无法准确计算，它包括化冰雪的次数、高原缺氧对汽油燃烧效率的影响，低温下的散温系数、炉头积碳导致的热量损耗等等。唯一有利因素就是低压环境中水的沸点低，只有80℃左右。因此，汽油使用非常节约，每天就是烧两锅水，早晚各一锅，便是所有生活所需了。 除了这些，其他的物品还有许多。 就拿此行束缚类装备来说，就有六毫米登山辅力绳、四毫米登山辅力绳、一点五毫米魔术贴捆扎带、一米魔术贴捆扎带、二十厘米魔术贴捆扎带、硅胶弹力带、普通松紧绳、红头风筝绳、凯夫拉鱼线、两色缝补线、五号铁丝、二号铁丝、大号长尾夹、小号长尾夹、橡皮筋、别针、小快扣、主锁……所有装备乱七八糟地加起来，到底有多少，我现在也没法记清了。 三、自行车所有行李一共200斤，背是背不动的，必须带上自行车。 从徒步角度看，推行速度确实太低了，一半都达不到。选择自行车作为穿越工具并非为骑，它只是一个驮货工具。四个驮包分别置于前后轮两侧，相机包挂在车头，一个二十五升的骑行包随身背着。后货架上还有一个六十升防水驮包，用弹性松紧绳捆绑，其间夹塞着防潮垫、水袋、拖鞋等。驮包总容量一百八十五升左右，不包括外置的盛水容器、闲杂物品等，所有装备总重二百斤左右。试想，推着一辆二百斤的自行车在海拔五千米的沙地里推行，实在是一件令人沮丧的事情。 大部分路段，自行车没法骑，只能推着走。为了提速，杨柳松用伞做了一个帆，利用风力推动自行车。可惜风太大了，只用了两天，伞就被吹坏了。 为了解决用电问题，他带了太阳能电池。 由于单独采用了一块轻薄的太阳能板给GPS供电，使得GPS高耗电成为历史，七十多天里只因故障换过一次电池，节省了需携带的大量干电池。同时备了一块功率5.4瓦的太阳能板，给7.4伏的相机、DV及其他数码设备供电，路上没缺过电只缺过水。 四、出发原定4月1日进入荒原。这个日期是精心选择的。 太早过于寒冷与干旱，人扛不住，水的问题也没法解决。太晚会推迟进入东羌塘的时间，雨季来临，冻土消融，几乎没有通过的可能性。所以四月初进入荒原是个最折中选择，可以使我吃一个半月的西风和冻土路面，剩下时间则在雨季变得强势前迅速撤离。 但是遇到了许多意外，比如在江孜县丢了一个包，不得不重回拉萨采购装备，导致比预定日期推迟了20天，注定后期遭遇雨季，几乎困死于沼泽。 2010年4月20日，他进入羌塘。 五、无人区羌塘是无人区，地理和气候都不适合人类生存。首先，高海拔对生理产生巨大影响。 在海拔五千米荒原行路，相当于在平原地区背负十五公斤物品。高海拔对身体的伤害，首先是视力衰退，所以把狼看成外星人，不仅只是端不稳望远镜。其次是听力，海拔越高影响越大，不仅听力急剧减弱，连声音方位也难辨别，这也是高海拔登山容易发生事故的原因之一。高海拔对大脑的伤害尤为大，记忆力会明显下降，譬如，刚向你借钱就忘了，真不是我想赖账。甚者，导致严重的思维障碍。 然后，终日大风，风声足以致聋。 风大到只敢以屁股相对。风，也是羌塘唯一的声音。时常一整天，耳畔都是巨大的轰鸣声，即便饿狼贴着后脑勺，大声喊”我想你”，也决然感觉不到半点危机。曾经有位边防战士，独自巡逻两天，被荒原大风吹得失聪。 遇到暴风雪，只能躲在自行车后面。 我猥琐地蜷缩在自行车后面，躲避着狂风冰雹。这是标准姿势，面对恶劣天气，将自行车横风倒下，整个人团成个肉球，趴在隆起的驮包后面。远处看，则脑袋不见，屁股半撅，有如鸵鸟。 ……狂风大作，沙尘滚滚，眼前一片昏黄，视野近无。测量，瞬间最高风速达到了27.8m/s，接近十一级。蜷缩在自行车后面，用一个防雨罩把脑袋完全包住，蓦然，不知什么东西击中了屁股，被人踢了一脚似的。理智思量，不会有人路过，并这么无聊地踢我屁股吧。过了一会儿，屁股又被踢了一下，又一下……后背有点发凉，决定用手摸摸，到底何物。摸到屁股位置有根带子，噼里啪啦地风中乱抽。胡思乱想，难不成恶人不是用脚，而是用鞭子抽我屁股？顺着摸，是车首包的背带。 气候极度寒冷，有时帐篷搭得慢一点就没命了。 搭好帐篷去打水，溪流表面已结了薄冰，破之取水。格外酷寒，水杯捞起转瞬间，杯壁上便结了冰。手冷得不行，几秒钟就冻僵。……羌塘冻死，唯雨季风险最大，因为来不及防范，就可能在一场猛烈的冻雨湿雪中失尽体温。 长时间野外行走，手指和脚趾都会冻伤。 一只手握在车座下的竖管上，使劲地往前拉，这也是手指关节处裂口长达几十天不愈的原因。有几次拉车，感觉不到手指，以为被拉断了。脱下手套看看，还在，继续拉。 遇到大雪，甚至会不知不觉窒息而死。 昨夜，睡得很不踏实，中途迷迷糊糊闷醒多次，胸口如压巨石，喘不过气来。再次被闷醒时，见天亮了，但帐篷上明下黑，难道陷到沼泽里了？用手一推才知被大雪埋了。这是此行遭遇的最大一场雪，深度四十厘米左右，最深处一米。后怕，帐篷被大雪完全封死，内部只有一个小透气窗，半掩着，且冰雪又封了一些。简单计算，夜里帐内氧气含量比珠峰峰顶还低，这还不算体内呼出的二氧化碳的致命影响。半夜闷醒多次，居然浑然不觉大难临头。 六、野生动物荒原里面有很多危险的野生动物，遇到狼是家常便饭。 此次遇狼七次，其中五次是直面。这是指看清脸的，幽魂般闪烁的不配我记录在案。 ……先是一只狼从前方沿着土埂小跑，又觉得眼花，土埂后有一黑物闪烁，果然也是只狼，便盯着隐狼看它去向。隐狼完全现身一会儿后又不见了，再看前狼朝我直奔而来。先是放倒车子，故意和车保持一点距离，是想传达我可不是一个人孤军奋战。这招貌似不管用，如果自行车能弯弯车把，向狼打个招呼就好了。我又扶起车子，用身体靠住，万一时刻还能充当下防弹衣。 有时早上起床，发现帐篷外面都是狼的脚印。 帐篷周边发现了一些兽迹，应该是狼的。脚印从戈壁深处来，围了帐篷一圈，在头部位置零散纷乱，估计在判断我的气息，然后脚印沿着湖岸远去。 其他比较危险的，主要是棕熊和野牦牛。 此次旅行遇熊五次，同样，那些小脸都不让我看清的不配记录在案。 有两次刻骨地与野牦牛对峙的经历，距离之近，仿若能看见牛眼里的红血丝，我脊背上的寒气也足以给一间客厅降温避暑了。 再怎么防备，都难以保证百分之百的安全。 晚上宿营没有过任何防范，觉得实在没有必要，睡在哪里不是睡在黑夜里？白天遇野兽连贴身小刀也没摸过，徒步探路时基本无防范。羌塘真的很大，有什么东西早发现了。如果棕熊、野牦牛之类的真攻击你，恐怕带枪也不行，所以说心态最重要，学会相处比学会打架管用。 比野生动物更危险的，其实是人。荒原遇到人，比遇狼还令人担心。 凡是能进入荒原的人，大半我都惹不起，譬如杀人灭口的盗猎者，见财起意的淘金人，恪尽职守的巡山队…… 七、断水二分之一的路段都缺水，即使有水，也是盐碱水，不喝渴死，喝了毒死。 晚上，唯一的水就是前日为以防万一、灌在保温杯里的碱水。一打开盖子，恶臭扑鼻，捂了几天，水质更恶化了。喝是不喝，是个问题。 整个旅程最危险的时候是第40天，已经连续三天断水，滴水不存。必须在一天内找到水。 找水有几个方向，一是附近可能有水的地方，二是回到两天前的营地，三是标准求生方式—-挖坑蒸水。先排除最后一点，挖坑蒸水对地貌要求极高，我周遭环境至少挖坑半米才能见到湿土。假使挖坑还没把我累死，假使一整天都是艳阳高照，我所得到的水够不够我继续挖下一个坑的力气都不好说。回到两天前的地方，往返八十公里寻水太纠结了，且以当下身体状态，这不是一件靠意志力就能胜任的工作，远水解不了近渴。 他不得不停止行程，专程找水，依然一无所获，只能用尿液解渴。 用尿液伴着饼干，勉强吃了一点，明天还得要有体力继续找水。 眼看即将渴死在这个极旱的盐碱地，所幸第41天早上下雪了。 听见打在帐篷上的沙沙声，以为又是风沙作祟，一整夜都是这样。微明，掀开帐篷一角，地上散落着小雪籽，再看了眼天际，灰云铺顶。不喜不悲，白天下雪很难积蓄，雪落无痕。心中也并无打算今天如何找水，身体透支太多，再难强打精神。也无祈祷，该怎样怎样。再次醒来，掀开帐门，雪越下越大，才清醒些，认为是生机。随后，三两分钟掀帐查看一下雪情，生怕老天赏赐的大礼会长脚溜走。待雪稍有积淀，便赶紧用纸片掠雪盛在锅里，沾上的沙土也舍不得丢弃。 八、雨季六月以后，雨季到来，雪水融化，冻土变成沼泽和湖泊。对于旅行者来说，这时才是真正的噩梦开始。 鞋子早就破了，虽然尽量控制不要灌水，但依然是最煎熬的体感。试想，脚上套着两坨沉重的冰行路是何等苦楚，而这种苦楚将一直伴随我走出荒原。 第57天 原定的南下路线被雪水汇成的大河阻断，走不过去了。 晚上考量许久，何去何从？两天来只推行了十多公里，这沼泽路没法走。眼前又是条大河阻挡，豁命也不是没有过去的可能，但过去之后呢？至少还要横切汇入多格错仁强错的三条大河以及大片湖盆沼泽。 最后决定走回头路，掉头北上，穿越阿尔金无人区求生，因为那里的地势高，不易积水。但是，粮食是肯定不够了，只能寄望于路上遇到人。 从阿尔金出去，这是最后一个选择，没法拒绝。从地理上分析，或许北上是条出路，因为要翻越数道山脉，属山地貌，沼泽大河会少很多。北上的最大障碍是线路太长，食物肯定是不够了，且又是”未知”区域。我的打算是尽量赶到鲸鱼湖，传说，那里有获得补给的可能。 九、弹尽粮绝第55天，蔬菜只剩下最后四瓣大蒜，吃光。 第59天，盐和粮食所剩无几 第64天，吃光了最后一包压缩饼干。 再次清点粮食，只剩下五斤左右糌粑，比乒乓球大小还少的盐，一点茶叶，三两左右酥油，再无其他了。 后面的路，都是冻土融化的沼泽地带。 一陷到膝盖，立马倒地匍匐爬出来。不能往前倒，而是后仰，往前倒，如果沼泽过稠，速度过快会折断小腿，如果沼泽过稀，会一下子把脸给埋住，无法呼吸，错失转身时机。后仰的好处是安全，抽腿也容易。 自行车也惨遭灭顶。 自行车再度陷入沼泽，一脚陷脚踝，二脚陷半小腿，三脚弃车跑人。黏性太大了，再不撤来不及了。随后试着拖车，地越踩越烂，地下水都踩了出来，最后连自行车的边都摸不上了。都考虑弃车了，但装备总得要弄出来。用那十块钱的救生膜和两个防雨罩铺在烂泥上，人趴在上面，一番折腾，好歹把驮包给弄了出来。再看垫脚物早没影了，光救生膜铺开可就两平方米。再一会儿，放驮包的地方也无法立足了。也就是说，即便很硬实的地，多踩上几脚，也变成了沼泽嘴脸。转移驮包后，思量着怎么把自行车弄出来，现在弃车毕竟很不理智。用铁丝套上绳子圈在自行车上，拉拽，车子勉强移动一点，再用力，居然把后轮生生地拽掉了，最终和沼泽打了个平手。 第73天，丢弃自行车，徒步逃生。为了减轻负重，把望远镜和水袋也扔了。 第75天，只剩最后一口粮食。幸运的是，在这一天遇见了探矿者。 第77天，走出荒原。 十、动机很多人都有这样的问题：他究竟为什么要进入荒原，如此危险，难道只是为了探险吗？ 杨柳松这样解释，对于城市生活，他始终不太适应。 身体每天都被什么东西紧紧束缚似的，那种感觉就像每天衣服都小一号，每天都必须换上大一号衣服，身体才会舒畅。 每年春天，只要在西藏，他都要去雅鲁藏布江大峡谷看桃花。最喜欢的是下面这样的景色。 最喜孤立的某处，一树粉红桃花与世无争地怒放。 三年前，他第一次见到荒原，就下决心要深入这片土地。这个刹那的闪念，让他长久酝酿，一定要付诸行动。荒原更适合那一颗自由自在的心。 始终没有逃离荒原的心，这样一片神奇土地，怎舍得轻易离去。只要不是毫无生机的绝境，在我的意识里，荒原彼端将是没有尽头的远方。远方，依然是那永远也到达不了的地方。 旅途中，每一次艰难时刻，选择继续前进还是放弃，他都选择前进，始终没有放弃。 事实上，选择北上的真正原因，是自己还没玩够。如果，世界上再无有意思的事，为之无条件追求的事，那活着多没趣。如果真得撑不住了，我就南下徒步逃命去了，三四天时间就可找到牧民，终结这痛苦的旅程。甚至，过河办法都想好了，就是抱着那空油桶，漂啊漂过河，像八仙成员之一似的。 那是一种从骨头里，对喧嚣的平庸生活的厌倦。 这是一个浮躁的时代，很拥挤，很冷漠，不管你愿不愿意，都必须随流而动，因此旅行成了一部分人变相的逃离，而非遵循内心的渴望。就我而言，为何旅行，同样没有一个靠谱的答案，热爱是最接近的答案，去追寻荒野的旷寂。 人生就像没有尽头的荒原，如果不找到一点乐趣，如何坚持着走完？ 人生就是一场漫无目的的旅行，之所以茫然，是因生与死限定了旅行的终与结。有些人乐此不疲地怀揣梦想继续前行，没有目标，没有问题，只是收获一路感受。 他写道，自己很享受在荒野中看云。 困守的唯一好处，就是有足够时间凝视一朵云的万般变化，生成，绚烂，湮灭。 人生难道不是这样吗？我们都是飘荡在天空中的云，匆匆涌起，转眼消散得无影无踪，那么为什么不索性飘荡得远一点呢？ 十一、未来许多友人问，走出荒原是什么感觉？ 事实上，走出荒原没有想象的幸福感，或是什么成就感，甚至是一种轻度的抑郁和迷茫。巨大的幸福并未如期而至，偶尔的幸福也是短暂。生命是一条贯通的河流，一切皆是没有开始的复始。我们所期望的终点并不存在。 如果我拥有足够的热情，如果这片荒原对我有足够的诱惑，那我就继续往前。如果激情退却，诱惑不再，我就哪来哪回。如果激情与诱惑从未真实存在，所有问题也就不是问题了。暮色中，面对荒原，我必须做出抉择，明日之路是前行，还是后退。这个抉择其实从未存在，只是一个矫情的过程，从心底深处再次认识到自己究竟在做些什么。 虽然，路的尽头什么也没有，但不能因此停止步履，因为你就是路本身。 （完）]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时任务框架]]></title>
    <url>%2Fposts%2F35236.html</url>
    <content type="text"><![CDATA[ScheduleIterator接口 import java.util.Date;public interface ScheduleIterator { public Date next();//获取下一个触发的时间点} Scheduler类 import java. 定时任务框架代码。整个框架就3个类： ScheduleIterator.java 12345import java.util.Date;public interface ScheduleIterator &#123; Date next();&#125; Scheduler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class Scheduler &#123; class SchedulerTimerTask extends TimerTask &#123; private SchedulerTask schedulerTask; private ScheduleIterator iterator; public SchedulerTimerTask(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; this.schedulerTask = schedulerTask; this.iterator = iterator; &#125; public void run() &#123; schedulerTask.run(); reschedule(schedulerTask, iterator); &#125; &#125; private final Timer timer = new Timer(); public Scheduler() &#123; &#125; public void cancel() &#123; timer.cancel(); &#125; public void schedule(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; Date time = iterator.next(); if (time == null) &#123; schedulerTask.cancel(); &#125; else &#123; synchronized (schedulerTask.lock) &#123; if (schedulerTask.state != SchedulerTask.VIRGIN) &#123; throw new IllegalStateException("Task already scheduled or cancelled"); &#125; schedulerTask.state = SchedulerTask.SCHEDULED; schedulerTask.timerTask = new SchedulerTimerTask(schedulerTask, iterator); timer.schedule(schedulerTask.timerTask, time); &#125; &#125; &#125; private void reschedule(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; Date time = iterator.next(); if (time == null) &#123; schedulerTask.cancel(); &#125; else &#123; synchronized (schedulerTask.lock) &#123; if (schedulerTask.state != SchedulerTask.CANCELLED) &#123; schedulerTask.timerTask = new SchedulerTimerTask(schedulerTask, iterator); timer.schedule(schedulerTask.timerTask, time); &#125; &#125; &#125; &#125;&#125; SchedulerTask.java 1234567891011121314151617181920212223242526272829303132333435import java.util.TimerTask;public abstract class SchedulerTask implements Runnable &#123; final Object lock = new Object(); int state = VIRGIN; static final int VIRGIN = 0; static final int SCHEDULED = 1; static final int CANCELLED = 2; TimerTask timerTask; protected SchedulerTask() &#123; &#125; public abstract void run(); public boolean cancel() &#123; synchronized (lock) &#123; if (timerTask != null) &#123; timerTask.cancel(); &#125; boolean result = (state == SCHEDULED); state = CANCELLED; return result; &#125; &#125; public long scheduledExecutionTime() &#123; synchronized (lock) &#123; return timerTask == null ? 0 : timerTask.scheduledExecutionTime(); &#125; &#125;&#125; 自己写的ScheduleIterator 实现类 以及一个测试类 SimpleScheduleIterator.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import com.jeecms.common.task.scheduling.ScheduleIterator;/** * 时间进度迭代器 &lt;li&gt;返回 月/周/天/小时/分钟/秒 计划的下一次执行时间&lt;/li&gt; &lt;li&gt;约定：参数以逗号分隔,*号表示无值&lt;/li&gt; &lt;li&gt; * 参数解释： &lt;br&gt; * 第一位：每个月的第几周&lt;/br&gt; &lt;br&gt; * 第二位：每周的第几天&lt;/br&gt; &lt;br&gt; * 第三位：天(几号)&lt;/br&gt; &lt;br&gt; * 第四位：小时(24小时制)&lt;/br&gt; &lt;br&gt; * 第五位：分钟&lt;/br&gt; &lt;br&gt; * 第六位：秒&lt;/br&gt;&lt;/li&gt; &lt;li&gt;参数样例： &lt;br&gt; * 1,6,4,15,20,30 表示 从今天的15:20:30开始，每隔一个月执行一次,即下次执行时间是 下个月的第一周的第6天的15:20:30&lt;/br&gt; * &lt;br&gt; * *,6,4,15,20,30 表示 从今天的15:20:30开始，每隔一周执行一次,即下次执行时间是 下一周的第6天的15:20:30&lt;/br&gt; &lt;br&gt; * *,*,4,15,20,30 表示 从今天的15:20:30开始，每隔一天执行一次,即下次执行时间是 下一天的15:20:30&lt;/br&gt; &lt;br&gt; * *,*,*,15,20,30 表示 从今天的15:20:30开始，每隔一小时执行一次,即下次执行时间是 16:20:30&lt;/br&gt; &lt;br&gt; * *,*,*,*,20,30 表示 从这个小时的20:30开始，每隔一分钟执行一次,即下次执行时间是 *:21:30&lt;/br&gt; &lt;br&gt; * *,*,*,*,*,30 表示 从当前时间的30秒开始，每隔一秒执行一次,即下次执行时间是 *:*:31&lt;/br&gt;&lt;/li&gt; * * @author javacoo * @since 2011-11-03 */public class SimpleScheduleIterator implements ScheduleIterator &#123; private final ScheduleParamBean scheduleParamBean; private final Calendar calendar = Calendar.getInstance(); private final Calendar orginCalendar = Calendar.getInstance(); public SimpleScheduleIterator(final ScheduleParamBean scheduleParamBean) &#123; this(scheduleParamBean, new Date()); &#125; public SimpleScheduleIterator(final ScheduleParamBean scheduleParamBean, Date date) &#123; this.scheduleParamBean = scheduleParamBean; orginCalendar.setTime(date); calendar.setTime(date); if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.set(Calendar.WEEK_OF_MONTH, scheduleParamBean.getWeekOfMonth()); &#125; // 如果设置了每周的第几天和一个月的第几天，则忽略一个月的第几天 if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.set(Calendar.DAY_OF_WEEK, scheduleParamBean.getDayOfWeek()); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.set(Calendar.DAY_OF_MONTH, scheduleParamBean.getDayOfMonth()); &#125; if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.set(Calendar.HOUR_OF_DAY, scheduleParamBean.getHourOfDay()); &#125; if (null != scheduleParamBean.getMinute()) &#123; calendar.set(Calendar.MINUTE, scheduleParamBean.getMinute()); &#125; if (null != scheduleParamBean.getSecond()) &#123; calendar.set(Calendar.SECOND, scheduleParamBean.getSecond()); &#125; calendar.set(Calendar.MILLISECOND, 0); if (!calendar.getTime().before(date)) &#123; System.out.println(calendar.getTime() + "大于当前时间：" + date); if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.add(Calendar.MONTH, -1); &#125; else if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.add(Calendar.DAY_OF_WEEK, -6); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, -1); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, -1); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, -1); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, -1); &#125; &#125; else &#123; System.out.println(calendar.getTime() + "小于当前时间：" + date); if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, orginCalendar.get(Calendar.DAY_OF_MONTH) - scheduleParamBean.getDayOfMonth()); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, orginCalendar.get(Calendar.HOUR_OF_DAY) - scheduleParamBean.getHourOfDay()); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, orginCalendar.get(Calendar.MINUTE) - scheduleParamBean.getMinute()); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, orginCalendar.get(Calendar.SECOND) - scheduleParamBean.getSecond()); &#125; &#125; &#125; public Date next() &#123; if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.add(Calendar.MONTH, 1); &#125; else if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.add(Calendar.DAY_OF_WEEK, 6); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, 1); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, 1); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, 1); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, 1); &#125; System.out.println("下次执行时间:" + calendar.getTime()); return calendar.getTime(); &#125;&#125; ScheduleParamBean.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 时间计划参数bean * * @author javacoo * @since 2011-11-04 */public class ScheduleParamBean &#123; /** 每个月的第几周,每周的第几天,每个月的第几天,小时(24小时制),分钟,秒 */ private Integer weekOfMonth, dayOfWeek, dayOfMonth, hourOfDay, minute, second; public ScheduleParamBean() &#123; &#125; public ScheduleParamBean(Integer weekOfMonth, Integer dayOfWeek, Integer dayOfMonth, Integer hourOfDay, Integer minute, Integer second) &#123; super(); this.weekOfMonth = weekOfMonth; this.dayOfWeek = dayOfWeek; this.dayOfMonth = dayOfMonth; this.hourOfDay = hourOfDay; this.minute = minute; this.second = second; &#125; public Integer getWeekOfMonth() &#123; return weekOfMonth; &#125; public void setWeekOfMonth(Integer weekOfMonth) &#123; this.weekOfMonth = weekOfMonth; &#125; public Integer getDayOfWeek() &#123; return dayOfWeek; &#125; public void setDayOfWeek(Integer dayOfWeek) &#123; this.dayOfWeek = dayOfWeek; &#125; public Integer getDayOfMonth() &#123; return dayOfMonth; &#125; public void setDayOfMonth(Integer dayOfMonth) &#123; this.dayOfMonth = dayOfMonth; &#125; public Integer getHourOfDay() &#123; return hourOfDay; &#125; public void setHourOfDay(Integer hourOfDay) &#123; this.hourOfDay = hourOfDay; &#125; public Integer getMinute() &#123; return minute; &#125; public void setMinute(Integer minute) &#123; this.minute = minute; &#125; public Integer getSecond() &#123; return second; &#125; public void setSecond(Integer second) &#123; this.second = second; &#125; @Override public String toString() &#123; return "ScheduleParamBean [dayOfMonth=" + dayOfMonth + ", dayOfWeek=" + dayOfWeek + ", hourOfDay=" + hourOfDay + ", minute=" + minute + ", second=" + second + ", weekOfMonth=" + weekOfMonth + "]"; &#125;&#125; TestSchedule.java 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 测试 * * @author javacoo * @since 2011-11-03 */public class TestSchedule &#123; private final Scheduler scheduler = new Scheduler(); private final ScheduleParamBean scheduleParamBean; public TestSchedule(final ScheduleParamBean scheduleParamBean) &#123; this.scheduleParamBean = scheduleParamBean; &#125; public void start() &#123; scheduler.schedule(new SchedulerTask() &#123; public void run() &#123; execute(); &#125; private void execute() &#123; System.out.println("任务执行"); &#125; &#125;, new SimpleScheduleIterator(scheduleParamBean)); &#125; public static void main(String[] args) &#123; ScheduleParamBean scheduleParamBean = new ScheduleParamBean(); scheduleParamBean.setWeekOfMonth(1); scheduleParamBean.setDayOfWeek(6); scheduleParamBean.setDayOfMonth(4); scheduleParamBean.setHourOfDay(16); scheduleParamBean.setMinute(22); scheduleParamBean.setSecond(0); TestSchedule test = new TestSchedule(scheduleParamBean); test.start(); &#125;&#125; 以下是整合到JEECMS采集器多线程版的代码片段 12345678910111213141516171819202122232425262728293031323334/** * 开始执行采集任务 */ public boolean start(Integer id) &#123; CmsAcquisition acqu = cmsAcquisitionMng.findById(id); if (acqu == null || acqu.getStatus() == CmsAcquisition.START) &#123; return false; &#125; TaskSchedulerManage taskManage = new TaskSchedulerManage(this,acqu); taskManage.start(); return true; &#125; private class TaskSchedulerManage &#123; private final Scheduler scheduler = new Scheduler(); private final MultiThreadAcquisitionSvcImpl multiThreadAcquisitionSvc; private final CmsAcquisition acqu; public TaskSchedulerManage(MultiThreadAcquisitionSvcImpl multiThreadAcquisitionSvc,CmsAcquisition acqu) &#123; this.multiThreadAcquisitionSvc = multiThreadAcquisitionSvc; this.acqu = acqu; &#125; public void start() &#123; scheduler.schedule(new SchedulerTask() &#123; public void run() &#123; processer(); &#125; private void processer() &#123; System.out.println("============开始执行计划任务================="); new Thread(new MainThreadProcesser(multiThreadAcquisitionSvc,acqu)).start(); &#125; &#125;, new SimpleScheduleIterator(new ScheduleParamBean(1,6,4,17,24,30))); &#125; &#125; 注：关键是 ScheduleIterator实现类了，框架有多强大 完全取决于你的ScheduleIterator实现类了。]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring任务调度之Spring-Task]]></title>
    <url>%2Fposts%2F19157.html</url>
    <content type="text"><![CDATA[在工作中有用到spring task作为定时任务的处理，spring通过接口TaskExecutor和TaskScheduler这两个接口的方式为异步定时任务提供了一种抽象。这就意味着spring容许你使用其他的定时任务框架，当然spring自身也提供了一种定时任务的实现：spring task。spring task支持线程池，可以高效处理许多不同的定时任务。同时，spring还支持使用Java自带的Timer定时器和Quartz定时框架。限于篇幅，这里将只介绍spring task的使用。 其实，官方文档已经介绍地足够详细，只不过都是英文版，所以为了更好地理解并使用spring task，首先会对spring task的实现原理做一个简单的介绍，然后通过实际代码演示spring task是如何使用的。这里会涉及到一个很重要的知识点：cron表达式。 TaskExecutor和TaskSchedulerTaskExecutor是spring task的第一个抽象，它很自然让人联想到jdk中concurrent包下的Executor，实际上TaskExecutor就是为区别于Executor才引入的，而引入TaskExecutor的目的就是为定时任务的执行提供线程池的支持，那么，问题来了，为什么spring不直接使用jdk自带的Executor呢？TaskExecutor源码如下？ 123public interface TaskExecutor extends Executor &#123; void execute(Runnable var1);&#125; 那么，答案很显然，TaskExecutor提供的线程池支持也是基于jdk自带的Executor的。用法于Executor没有什么不同。 TaskScheduler是spring task的第二个抽象，那么从字面的意义看，TaskScheduler就是为了提供定时任务的支持咯。TaskScheduler需要传入一个Runnable的任务做为参数，并指定需要周期执行的时间或者触发器，这样Runnable任务就可以周期性执行了。传入时间很好理解，有意思的是传入一个触发器（Trigger）的情况，因为这里需要使用cron表达式去触发一个定时任务，所以有必要先了解下cron表达式的使用。 在spring 4.x中已经不支持7个参数的cronin表达式了，要求必须是6个参数（具体哪个参数后面会说）。cron表达式的格式如下： 1&#123;秒&#125; &#123;分&#125; &#123;时&#125; &#123;日期（具体哪天）&#125; &#123;月&#125; &#123;星期&#125; 秒：必填项，允许的值范围是0-59，支持的特殊符号包括, - /，,表示特定的某一秒才会触发任务，-表示一段时间内会触发任务，表示每一秒都会触发，/表示从哪一个时刻开始，每隔多长时间触发一次任务。分：必填项，允许的值范围是0-59，支持的特殊符号和秒一样，含义类推时：必填项，允许的值范围是0-23，支持的特殊符号和秒一样，含义类推日期：必填项，允许的值范围是1-31，支持的特殊符号相比秒多了?，表示与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起冲突和混乱。月：必填项，允许的值范围是1-12（JAN-DEC），支持的特殊符号与秒一样，含义类推星期：必填项，允许值范围是1~7 (SUN-SAT),1代表星期天（一星期的第一天），以此类推，7代表星期六，支持的符号相比秒多了?，表达的含义是与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义。比如下面这个cron表达式： 12// 表达的含义是：每半分钟触发一次任务30 * * * * ? spring提供了一个CronTrigger，通过传入一个Runnable任务和CronTrigger，就可以使用cron表达式去指定定时任务了，是不是非常方面。实际上，在工程实践上，cron表达式也是使用很多的。实际上，是执行了下面的代码： 1scheduler.schedule(task, new CronTrigger(&quot;30 * * * * ?&quot;)); TaskScheduler抽象的好处是让需要执行定时任务的代码不需要指定特定的定时框架（比如Timer和Quartz）。TaskScheduler的更简单的实现是ThreadPoolTaskScheduler,它实际上代理一个jdk中的SchedulingTaskExecutor，并且也实现了TaskExecutor接口，所以需要经常执行定时任务的场景可以使用这个实现（Spring推荐）。我们再来看一下TaskExecutor和TaskScheduler的类继承关系：spring-task 通常而言，使用spring task实现定时任务有两种方式：注解和xml配置文件。这里使用xml配置文件的方式加以说明。 实战创建Maven工程，pom.xml:1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.rhwayfun&lt;/groupId&gt; &lt;artifactId&gt;sring-task-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 开发需要执行定时任务的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.rhwayfun.task;import org.springframework.stereotype.Component;import java.time.LocalDateTime;/** * @author ZhongCB * @date 2016年09月10日 14:30 * @description */@Componentpublic class App &#123; public void execute1()&#123; System.out.printf("Task: %s, Current time: %s\n", 1, LocalDateTime.now()); &#125; public void execute2()&#123; System.out.printf("Task: %s, Current time: %s\n", 2, LocalDateTime.now()); &#125; public void execute3()&#123; System.out.printf("Task: %s, Current time: %s\n", 3, LocalDateTime.now()); &#125; public void execute4()&#123; System.out.printf("Task: %s, Current time: %s\n", 4, LocalDateTime.now()); &#125; public void execute5()&#123; System.out.printf("Task: %s, Current time: %s\n", 5, LocalDateTime.now()); &#125; public void execute6()&#123; System.out.printf("Task: %s, Current time: %s\n", 6, LocalDateTime.now()); &#125; public void execute7()&#123; System.out.printf("Task: %s, Current time: %s\n", 7, LocalDateTime.now()); &#125; public void execute8()&#123; System.out.printf("Task: %s, Current time: %s\n", 8, LocalDateTime.now()); &#125; public void execute9()&#123; System.out.printf("Task: %s, Current time: %s\n", 9, LocalDateTime.now()); &#125; public void execute10()&#123; System.out.printf("Task: %s, Current time: %s\n", 10, LocalDateTime.now()); &#125; public void execute11()&#123; System.out.printf("Task: %s, Current time: %s\n", 11, LocalDateTime.now()); &#125;&#125; spring配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd"&gt; &lt;!-- 配置注解扫描 --&gt; &lt;context:component-scan base-package="com.rhwayfun.task"/&gt; &lt;task:scheduler id="taskScheduler" pool-size="100" /&gt; &lt;task:scheduled-tasks scheduler="taskScheduler"&gt; &lt;!-- 每半分钟触发任务 --&gt; &lt;task:scheduled ref="app" method="execute1" cron="30 * * * * ?"/&gt; &lt;!-- 每小时的10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute2" cron="30 10 * * * ?"/&gt; &lt;!-- 每天1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute3" cron="30 10 1 * * ?"/&gt; &lt;!-- 每月20号的1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute4" cron="30 10 1 20 * ?"/&gt; &lt;!-- 每年10月20号的1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute5" cron="30 10 1 20 10 ?"/&gt; &lt;!-- 每15秒、30秒、45秒时触发任务 --&gt; &lt;task:scheduled ref="app" method="execute6" cron="15,30,45 * * * * ?"/&gt; &lt;!-- 15秒到45秒每隔1秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute7" cron="15-45 * * * * ?"/&gt; &lt;!-- 每分钟的每15秒时任务任务，每隔5秒触发一次 --&gt; &lt;task:scheduled ref="app" method="execute8" cron="15/5 * * * * ?"/&gt; &lt;!-- 每分钟的15到30秒之间开始触发，每隔5秒触发一次 --&gt; &lt;task:scheduled ref="app" method="execute9" cron="15-30/5 * * * * ?"/&gt; &lt;!-- 每小时的0分0秒开始触发，每隔3分钟触发一次 --&gt; &lt;task:scheduled ref="app" method="execute10" cron="0 0/3 * * * ?"/&gt; &lt;!-- 星期一到星期五的10点15分0秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute11" cron="0 15 10 ? * MON-FRI"/&gt; &lt;/task:scheduled-tasks&gt;&lt;/beans&gt; 编写测试代码：12345678910111213141516package com.rhwayfun.task;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author ZhongCB * @date 2016年09月10日 14:55 * @description */public class AppTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("classpath:/app-context-task.xml"); &#125;&#125; 运行测试代码，控制台会定时输出每个定时任务的日志信息，说明测试通过。 小插曲由于项目使用jdk 1.8进行开发，所以初始的时候每次pom文件发生修改，编译器的版本又变成了jdk 1.5，后面发现需要在pom文件中添加build便签那部分才能将默认的编译器进行修改。也算一个小收获了。 附：前一段时间，在工作中要使用定时器功能1、首先web.xml中配置123456&lt;!-- 配置spring核心servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 2、开 启定时启开 关在spring-servlet.xml 中开启 12345678910111213141516171819202122232425&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:task="http://www.springframework.org/schema/task" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd"&gt; &lt;task:annotation-driven /&gt; &lt;!-- 定时器开关 --&gt; &lt;!-- 自动扫描的包名 --&gt; &lt;context:component-scan base-package="com.zxl78585.springtask.task" /&gt; &lt;bean id="myTask" class="com.zxl78585.springtask.task.MyTask"&gt;&lt;/bean&gt; &lt;task:scheduled-tasks&gt; &lt;!-- 这里表示的是每隔五秒执行一次 --&gt; &lt;task:scheduled ref="myTask" method="show" cron="*/10 * * * * ?" /&gt; &lt;/task:scheduled-tasks&gt; &lt;/beans&gt; 3、写自己的定时器123456public class MyTask &#123; public void show()&#123; System.out.println(new Date().getTime()); &#125;&#125; 需要注意的几点： 1、spring的@Scheduled注解 需要写在实现上、 2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true、具体就去百度google吧） 3、实现类上要有组件的注解@Component 剩下的就是corn表达式了、具体使用以及参数请百度google、 下面只例出几个式子 123456789101112CRON表达式 含义 &quot;0 0 12 * * ?&quot; 每天中午十二点触发 &quot;0 15 10 ? * *&quot; 每天早上10：15触发 &quot;0 15 10 * * ?&quot; 每天早上10：15触发 &quot;0 15 10 * * ? *&quot; 每天早上10：15触发 &quot;0 15 10 * * ? 2005&quot; 2005年的每天早上10：15触发 &quot;0 * 14 * * ?&quot; 每天从下午2点开始到2点59分每分钟一次触发 &quot;0 0/5 14 * * ?&quot; 每天从下午2点开始到2：55分结束每5分钟一次触发 &quot;0 0/5 14,18 * * ?&quot; 每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发 &quot;0 0-5 14 * * ?&quot; 每天14:00至14:05每分钟一次触发 &quot;0 10,44 14 ? 3 WED&quot; 三月的每周三的14：10和14：44触发 &quot;0 15 10 ? * MON-FRI&quot; 每个周一、周二、周三、周四、周五的10：15触发]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码去除编号小技巧]]></title>
    <url>%2Fposts%2F58012.html</url>
    <content type="text"><![CDATA[从网上或者哪里拷贝下来的代码前面总有编号，如何去掉呢，网上有说用程序的太麻烦，于是，我找到了下面两种方法，share 一下~1.使用正则表达式：在editorplus（notepad++）里按ctrl+h，弹出框里勾选上“正则表达式（regular expression）”，然后第一个框里写 ^[0-9]*.第二个框里敲一个空格 2.这个是notepad++特有的，而editorplus没有的将代码拷进去，按住ctrl+alt的同时，按住鼠标左键不放，将需要的代码部分截取出来，复制、黏贴即可]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOA组件模型和系统间数据传输]]></title>
    <url>%2Fposts%2F9382.html</url>
    <content type="text"><![CDATA[面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。SOA，即service-oriented architecture，面向服务架构。 是一种面向通用集成服务的、松耦合的架构实现方式，是web时代服务发展的产物； 使用”分层”理念，比传统的”观察者”模式更高级且更有优势，主要体现在易扩展性和可灾； 适用于大型复杂业务系统的数据共享。 其中的服务平台可以用不同语言实现，比如php,python,java等，比较通用的是RESTFUL接口模式，对于user端，只需明确接口定义，既可以使用HTTP/HTTPS进行通讯，理论上是无限量的。 SOA对于客户端来说极大的简化了开发周期。对于一个特殊需求的出现不会措手不及，更不会大动干戈重构底层，开发者不需要知道具体底层原理即可快速开发实现功能。 SOA定义 它是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。 这种具有中立的接口定义(没有强制绑定到特定的实现上)的特征称为服务之间的松耦合。松耦合系统的好处有两点，一点是它的灵活性，另一点是，当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。而另一方面，紧耦合意味着应用程序的不同组件之间的接口与其功能和结构是紧密相连的，因而当需要对部分或整个应用程序进行某种形式的更改时，它们就显得非常脆弱。 对松耦合的系统的需要来源于业务应用程序需要根据业务的需要变得更加灵活，以适应不断变化的环境，比如经常改变的政策、业务级别、业务重点、合作伙伴关系、行业地位以及其他与业务有关的因素，这些因素甚至会影响业务的性质。我们称能够灵活地适应环境变化的业务为按需(On demand)业务，在按需业务中，一旦需要，就可以对完成或执行任务的方式进行必要的更改。 SOA是传统的面向对象架构模型的替代模型，面向对象的模型是紧耦合的，已经存在二十多年了。虽然基于 SOA 的系统并不排除使用面向对象的设计来构建单个服务，但是其整体设计却是面向服务的。由于它考虑到了系统内的对象，所以虽然 SOA 是基于对象的，但是作为一个整体，它却不是面向对象的。不同之处在于接口本身。SOA 系统原型的一个典型例子是通用对象请求代理体系结构(Common Object Request Broker Architecture，CORBA)，它已经出现很长时间了，其定义的概念与 SOA 相似。 然而，现在的 SOA 已经有所不同了，因为它依赖于一些更新的进展，这些进展是以可扩展标记语言(eXtensible Markup Language，XML)为基础的。通过使用基于 XML 的语言(称为 Web 服务描述语言(Web Services Definition Language，WSDL))来描述接口，服务已经转到更动态且更灵活的接口系统中，非以前 CORBA 中的接口描述语言(Interface Definition Language，IDL)可比了。 Web 服务并不是实现 SOA 的惟一方式。前面刚讲的 CORBA 是另一种方式，这样就有了面向消息的中间件(Message-Oriented Middleware)系统。但是为了建立体系结构模型，您所需要的并不只是服务描述。您需要定义整个应用程序如何在服务之间执行其工作流。您尤其需要找到业务的操作和业务中所使用的软件的操作之间的转换点。因此，SOA 应该能够将业务的商业流程与它们的技术流程联系起来，并且映射这两者之间的关系。例如，给供应商付款的操作是商业流程，而更新您的零件数据库，以包括进新供应的货物却是技术流程。因而，工作流还可以在 SOA 的设计中扮演重要的角色。 此外，动态业务的工作流不仅可以包括部门之间的操作，甚至还可以包括与不为您控制的外部合作伙伴进行的操作。因此，为了提高效率，您需要定义应该如何得知服务之间的关系的策略，这种策略常常采用服务级协定和操作策略的形式。 最后，所有这些都必须处于一个信任和可靠的环境之中，以同预期的一样根据约定的条款来执行流程。因此，安全、信任和可靠的消息传递应该在任何 SOA 中都起着重要的作用。 SOA用途 对 SOA 的需要来源于需要使业务 IT 系统变得更加灵活，以适应业务中的改变。通过允许强定义的关系和依然灵活的特定实现，IT 系统既可以利用现有系统的功能，又可以准备在以后做一些改变来满足它们之间交互的需要。 改变和 SOA 系统适应改变的能力是最重要的部分。对于开发人员来说，这样的改变无论是在他们工作的范围之内还是在他们工作的范围之外都有可能发生，这取决于是否有改变需要知道接口是如何定义的以及它们相互之间如何进行交互。与开发人员不同的是，架构师的作用就是引起对 SOA 模型大的改变。这种分工，就是让开发人员集中精力于创建作为服务定义的功能单元，而让架构师和建模人员集中精力于如何将这些单元适当地组织在一起。 SOA技术SOA 本身是应该如何将软件组织在一起的抽象概念。它依赖于用 XML 和 Web 服务实现并以软件的形式存在的更加具体的观念和技术。此外，它还需要安全性、策略管理、可靠消息传递以及会计系统的支持，从而有效地工作。您还可以通过分布式事务处理和分布式软件状态管理来进一步地改善它。 SOA 服务和 Web 服务之间的区别在于设计。SOA 概念并没有确切地定义服务具体如何交互，而仅仅定义了服务如何相互理解以及如何交互。其中的区别也就是定义如何执行流程的战略与如何执行流程的战术之间的区别。而另一方面，Web 服务在需要交互的服务之间如何传递消息有具体的指导原则;从战术上实现 SOA 模型是通过 HTTP 传递的 SOAP 消息中最常见的 SOA 模型。因而，从本质上讲，Web 服务是实现 SOA 的具体方式之一。 尽管我们觉得 Web 服务是实现 SOA 的最好方式，但是 SOA 并不局限于 Web 服务。其他使用 WSDL 直接实现服务接口并且通过 XML 消息进行通信的协议也可以包括在 SOA 之中。正如在别处指出的，CORBA 和 IBM 的 MQ 系统通过使用能够处理 WSDL 的新特征也可以参与到 SOA 中来。如果两个服务需要交换数据，那么它们还会需要使用相同的消息传递协议，但是数据接口允许相同的信息交换。 既为了建立所有这些信息的适当控制，又为了应用安全性、策略、可靠性以及会计方面的要求，在 SOA 体系结构的框架中加入了一个新的软件对象。这个对象就是企业服务总线(Enterprise Service Bus，ESB)，它使用许多可能的消息传递协议来负责适当的控制、流甚至还可能是服务之间所有消息的传输。虽然 ESB 并不是绝对必需的，但它却是在 SOA 中正确管理您的业务流程至关重要的组件。ESB 本身可以是单个引擎，甚至还可以是由许多同级和下级 ESB 组成的分布式系统，这些 ESB 一起工作，以保持 SOA 系统的运行。在概念上，它是从早期比如消息队列和分布式事务计算这些计算机科学概念所建立的存储转发机制发展而来的。 SOA 可以与许多其他技术结合在一起使用，然而，组件的封装和聚合在其中扮演着重要的角色。如前所述，SOA 可以是一个简单对象、复杂对象、对象的集合、包含许多对象的流程、包含其他流程的流程，甚至还可以是输出单一结果的应用程序的整体集合。在服务之外，它可以看作是单个实体，但是在其自身中，它可以具有任何级别的复杂性(如果必要的话)。出于性能方面的考虑，大多数 SOA 服务并没有下降到单一对象的粒度，并且更适合于大中型组件。 除了可能离不开 XML 和 WSDL 之外，SOA 并不是特定于语言的。可以用任何编程语言来实现服务，只要这种编程语言可以生成服务并且可以与 WSDL 结合在一起使用就可以了。SOAP 本身并不是绝对需要的，但它是通用的消息传递系统。因此，可以使用几乎任何一种编程语言和支持 WSDL 的平台来实现 SOA 中的成员服务。 SOA 和 Web 服务是独立于编程语言的，但 Java 是主要的开发语言之一。可以使用定义良好的 Java 接口以及各种协议丰富的 Java 实现为正在构建这个模型的开发人员提供了优势。Java 在此担当了开发每个服务的功能、管理数据对象和与其他在逻辑上封装在服务内的对象进行交互的角色。 SOA 与 Web 的另一个重要的关系是自主计算和网格计算的概念。自主计算的概念应用于管理分布式服务体系结构的范围，具体来说，就是帮助维护策略和服务级协议以及 SOA 系统的总稳定性。 另外，网格计算可以以两个级别与 SOA 系统一起使用。网格是分布式计算的一种形式，它利用分布式特性和服务之间的交互来为 SOA 应用程序提供计算支持。在这种情况下，网格起到了框架的作用，其中实现了一些或所有单独的服务。因此，SOA 应用程序可以是网格服务的消费者。 在另一方面，网格本身也可以构建在 SOA 之上。在这种情况下，每个操作系统服务都是构成整个 SOA 应用程序的成员，而 SOA 应用程序就是网格本身。因此，单独的网格组件既可以使用 Web 服务进行通信，又可以以 SOA 的方式进行交互。总而言之，网格系统可以是 SOA 本身，也可以提供服务来在其上构建应用程序级 SOA 模型。 随着近年来SOA（面向服务技术架构）的兴起，越来越多的应用系统开始进行分布式的设计和部署。系统由原来单一的技术架构变成面向服务的多系统架构。原来在一个系统之间可以完成的业务流程，通过多系统的之间多次交互来实现。这里不打算介绍如何进行SOA架构的设计，而是介绍一下应用系统之间如何进行数据的传输。 应用系统之间数据传输有三个要素：传输方式，传输协议，数据格式 数据传输方式一般无非是以下几种： socket方式Socket方式是最简单的交互方式。是典型才c/s 交互模式。一台客户机，一台服务器。服务器提供服务，通过ip地址和端口进行服务访问。而客户机通过连接服务器指定的端口进行消息交互。其中传输协议可以是tcp/UDP 协议。而服务器和约定了请求报文格式和响应报文格式。如图一所示： 目前我们常用的http调用，java远程调用，webserivces 都是采用的这种方式，只不过不同的就是传输协议以及报文格式。 这种方式的优点是： 易于编程，目前java提供了多种框架，屏蔽了底层通信细节以及数据传输转换细节。 容易控制权限。通过传输层协议https，加密传输的数据，使得安全性提高 通用性比较强，无论客户端是.net架构，java，python 都是可以的。尤其是webservice规范，使得服务变得通用 而这种方式的缺点是： 服务器和客户端必须同时工作，当服务器端不可用的时候，整个数据交互是不可进行。 当传输数据量比较大的时候，严重占用网络带宽，可能导致连接超时。使得在数据量交互的时候，服务变的很不可靠。 2.ftp/文件共享服务器ftp/文件共享服务器方式对于大数据量的交互，采用这种文件的交互方式最适合不过了。系统A和系统B约定文件服务器地址，文件命名规则,文件内容格式等内容，通过上传文件到文件服务器进行数据交互。 最典型的应用场景是批量处理数据：例如系统A把今天12点之前把要处理的数据生成到一个文件，系统B第二天凌晨1点进行处理，处理完成之后，把处理结果生成到一个文件，系统A 12点在进行结果处理。这种状况经常发生在A是事物处理型系统，对响应要求比较高，不适合做数据分析型的工作，而系统B是后台系统，对处理能力要求比较高，适合做批量任务系统。 以上只是说明通过文件方式的数据交互，实际情况B完成任务之后，可能通过socket的方式通知A，不一定是通过文件方式。 这种方式的优点： 在数据量大的情况下，可以通过文件传输，不会超时，不占用网络带宽。 方案简单，避免了网络传输，网络协议相关的概念。这种方式的缺点： 不太适合做实时类的业务 必须有共同的文件服务器，文件服务器这里面存在风险。因为文件可能被篡改，删除，或者存在泄密等。 必须约定文件数据的格式，当改变文件格式的时候，需要各个系统都同步做修改。 3. 数据库共享数据方式系统A和系统B通过连接同一个数据库服务器的同一张表进行数据交换。当系统A请求系统B处理数据的时候，系统A Insert一条数据，系统B select 系统A插入的数据进行处理。 这种方式的优点是 相比文件方式传输来说，因为使用的同一个数据库，交互更加简单。 由于数据库提供相当做的操作，比如更新，回滚等。交互方式比较灵活,而且通过数据库的事务机制，可以做成可靠性的数据交换。这种方式的缺点： 当连接B的系统越来越多的时候，由于数据库的连接池是有限的，导致每个系统分配到的连接不会很多，当系统越来越多的时候，可能导致无可用的数据库连接 一般情况，来自两个不同公司的系统，不太会开放自己的数据库给对方连接，因为这样会有安全性影响 4. message方式Java消息服务（Java Message Service）是message数据传输的典型的实现方式。系统A和系统B通过一个消息服务器进行数据交换。系统A发送消息到消息服务器，如果系统B订阅系统A发送过来的消息，消息服务器会消息推送给B。双方约定消息格式即可。目前市场上有很多开源的jms消息中间件，比如 ActiveMQ, OpenJMS 。 这种方式的优点 由于jms定义了规范，有很多的开源的消息中间件可以选择，而且比较通用。接入起来相对也比较简单 通过消息方式比较灵活，可以采取同步，异步，可靠性的消息处理，消息中间件也可以独立出来部署。 这种方式的缺点 学习jms相关的基础知识，消息中间件的具体配置，以及实现的细节对于开发人员来说还是有一点学习成本的 在大数据量的情况下，消息可能会产生积压，导致消息延迟，消息丢失，甚至消息中间件崩溃。 下面具体来分析一个场景，来看看系统之间数据传输的应用场景 目前业务人员需要导入一个大文件到系统A，系统A保存文件信息，而文件里面的明细信息需要导入到系统B进行分析，当系统B分析完成之后，需要把分析结果通知系统A。A 系统A先保存文件到文件服务器。B 系统A 通过webservice 调用系统B提供的服务器，把需要处理的文件名发送到系统B。由于文件很大，需要处理很长时间，所以B不及时处理文件，而是保存需要处理的文件名到数据库，通过后台定时调度机制去处理。所以B接收请求成功，立刻返回系统A成功。C 系统B定时查询数据库记录，通过记录查找文件路径，找到文件进行处理。这个过程很长。D 系统B处理完成之后发送消息给系统A，告知系统A文件处理完成。E 系统A 接收到系统B请求来的消息，进行展示任务结果 4种系统间交互方法比较 附录 MVC、RPC、SOA框架单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SOA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMS源码解读]]></title>
    <url>%2Fposts%2F63673.html</url>
    <content type="text"><![CDATA[CMS是”Content Management System”的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。· 基于java技术开发，继承其强大、稳定、安全、高效、跨平台等多方面的优点· 采用SpringMVC3+Spring3+Hibernate3+Freemarker主流技术架构· 懂html就能建站，提供最便利、合理的使用方式· 强大、灵活的标签，用户自定义显示内容和显示方式· 在设计上自身预先做了搜索引擎优化,增强对搜索引擎的友好性· 完全生成全站静态页面,可自定义路径结构，全面提高页面访问速度· 轻松建设大规模网站，可通过次级域名建立子站群，各子站后台管理权限分离，全站实现单点登录 jeeCms源码安装时出现的问题及解决装MySQL数据库装不上因为以前本机上装过MySQL,而在卸载时有文件残留，故MySQL会安装失败，失败的表现有两种：一个是安装时未响应，一个是未弹出配置MySQL的界面。 解决办法： 你可以安装MySQL的时候在这一步时它默认的服务名是“MySQL” 只需要把这个名字改了就可以了。 ​ 卸载MySQL 删除安装目录及数据存放目录 在注册表(regedit)查询mysql，全部删除 在c盘查询MySQL，全部删除 重新安装就好了 注意的是注册表 cmd -&gt; regedit，删除以下目录下的MySQL目录 HKEY_LOCAL_MACHINE\SYSTEM\\Eventlog\Application\MySQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL\www.xuanzequan.com\目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl001t\Services\MYSQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl002\Services\MYSQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MYSQL 目录 删除C:\Documents and Settings\All Users\Application Data\MySQL 目录 数据库连接不上的问题错误提示： An attempt by a client to checkout a Connection has timed out. 原因： 配置文件中目标数据库的名字错误 （区分大小写） 配置文件中的目标数据库用户名和密码错误。 缺少数据库的驱动jar包（如mysql-connector-5.1.8.jar 包）。缺这个包的原因是在解瘊MySQL连接不上的问题时，会在C盘中查找所有“mysql”的文件。而你的jeeCms源码包正好又放在桌面上，于是你会把所有带mySQL的文件删除，进而误删了源码包中的mySQL连接包（mysql-connector-5.1.8.jar）。当你在把页面上的源码包放到项目中时就少了这个包，故连接不上。 解决办法：删除除mysql安装残留信息时一定要谨慎再谨慎src包中报错的问题：错误提示：所有带HttpServletRequest或HttpServletResponse的类全部显示错误 原因：没有找到servlet包。因为你安装源码包时，没有配置tomcat环境。解决办法：安装源码包时，先在eclipse中配置tomcat环境，再建动态web项目，然后再在web项目中覆盖src和webContent文件夹。 源码解析之一 (web.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;JeeCmsV7&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 --&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 --&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 打印执行时间与访问路径过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.ProcessTimeFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 编码设置 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 解决Hibernate session延迟加载的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--@分隔--&gt; &lt;filter&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.XssFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;excludeUrls&lt;/param-name&gt; &lt;param-value&gt;/member/contribute@/jeeadmin/jeecms@/flow_statistic&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;SplitChar&lt;/param-name&gt; &lt;param-value&gt;@&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FilterChar&lt;/param-name&gt; &lt;param-value&gt;'@"@\@#@:@%@&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ReplaceChar&lt;/param-name&gt; &lt;param-value&gt;‘@“@＼@＃@：@％@＞&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 后台控制 DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点， 而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处 DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下： 1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析； 2、通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）； 3、通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)； 4、通过ViewResolver解析逻辑视图名到具体视图实现； 5、本地化解析； 6、渲染具体的视图等； 7、如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-admin.xml /WEB-INF/config/plug/**/*-servlet-admin-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 前台控制 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-front.xml /WEB-INF/config/plug/**/*-servlet-front-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Jcaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.common.captcha.JcaptchaServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 验证码图片 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Jcaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/captcha.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DbFile&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.core.action.front.DbFileServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SnapScreen&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.core.action.front.SnapScreenServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SnapScreen&lt;/servlet-name&gt; &lt;url-pattern&gt;/snapscreen.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;url-pattern&gt;/jeeadmin/jeecms/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DbFile&lt;/servlet-name&gt; &lt;url-pattern&gt;/dbfile.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。 因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器， 启动容器时，就会默认执行它实现的方法。 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 它是一个在web应用关闭的时候,清除JavaBeans Introspector的监听器. 在web.xml中注册这个listener.可以保证在web 应用关闭的时候释放与掉这个web 应用相关的class loader 和由它管理的类 防止内存泄露 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.shtml&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jhtml&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;error-page&gt; &lt;error-code&gt;403&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error/403.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error/500.html&lt;/location&gt; &lt;/error-page&gt; &lt;mime-mapping&gt; &lt;extension&gt;rar&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;doc&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;wps&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;et&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt;&lt;/web-app&gt; 源码解析之二（application-context.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!--xml进入路径web.xml/application-context.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd" default-lazy-init="true"&gt; &lt;!-- 加载数据库属性文件，以便动态获取 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;/WEB-INF/config/jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 加载其它属性文件 --&gt; &lt;bean id="properties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!-- 其中包话数据库连接，hbm文件和连接池信息 --&gt; &lt;value&gt;/WEB-INF/config/jdbc.properties&lt;/value&gt; &lt;!-- 暂时未知 --&gt; &lt;value&gt;/WEB-INF/config/jeecms/jeecms.properties&lt;/value&gt; &lt;!-- 暂时未知 --&gt; &lt;value&gt;/WEB-INF/config/plug/**/*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;qualifier value="main"/&gt; &lt;/bean&gt; &lt;!-- 通过PropertyUtils包操作properties属性文件中的属性，以便动态获取 --&gt; &lt;bean id="propertyUtils" class="com.jeecms.common.util.PropertyUtils"&gt; &lt;property name="properties" ref="properties"/&gt; &lt;/bean&gt; &lt;!-- 根据已加载的数据库属性文件，连接数据库 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; &lt;property name="autoCommitOnClose" value="true"/&gt; &lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间， 超时后将抛出 SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; &lt;property name="checkoutTimeout" value="$&#123;cpool.checkoutTimeout&#125;"/&gt; &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name="initialPoolSize" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;!--连接池中保留的最小连接数。--&gt; &lt;property name="minPoolSize" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name="maxPoolSize" value="$&#123;cpool.maxPoolSize&#125;"/&gt; &lt;!--最大空闲时间,maxIdleTime秒内未使用则连 接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name="maxIdleTime" value="$&#123;cpool.maxIdleTime&#125;"/&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name="acquireIncrement" value="$&#123;cpool.acquireIncrement&#125;"/&gt; &lt;!-- default : 0 单位 s 这个配置主要是为了减轻连接池的负载，比如连接池中连接数因为某次数据访问高峰导致创建了很多数据连接 但是后面的时间段需要的数据库连接数很少，则此时连接池完全没有必要维护那么多的连接，所以有必要将 断开丢弃掉一些连接来减轻负载，必须小于maxIdleTime。配置不为0，则会将连接池中的连接数量保持到minPoolSize。 为0则不处理。 --&gt; &lt;property name="maxIdleTimeExcessConnections" value="$&#123;cpool.maxIdleTimeExcessConnections&#125;"/&gt; &lt;/bean&gt; &lt;!-- 设置数据库session工厂 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 动态地通过properties文件加载映射的hbm文件 --&gt; &lt;property name="mappingLocations" value="#&#123;propertyUtils.getList('hibernate.hbm')&#125;"/&gt; &lt;!-- 配置hibernate属性 --&gt; &lt;property name="hibernateProperties"&gt; &lt;value&gt; &lt;!-- 指定数据库方言 --&gt; hibernate.dialect=$&#123;hibernate.dialect&#125; &lt;!-- 输出所有SQL语句到控制台 --&gt; hibernate.show_sql=false &lt;!-- 格式化输出sql语句 --&gt; hibernate.format_sql=false &lt;!-- 这个配置意思是当你在Hibernate里面输入true的时候，Hibernate会转化为0插入数据库， 当你在Hibernate里面输入false的时候，Hibernate会转化为1插入数据库， --&gt; hibernate.query.substitutions=true 1, false 0 &lt;!-- 指定每次提交SQL的数量。参数值越大，读数据库的次数越少，速度越快。 --&gt; hibernate.jdbc.batch_size=20 &lt;!-- 允许查询缓存,对经常使用的List查询方式，只有在使用查询缓存时， 才会从缓存中通过id去get缓存的值；查询缓存一般缓存查询语句和查询结果的id --&gt; hibernate.cache.use_query_cache=true &lt;/value&gt; &lt;/property&gt; &lt;property name="entityInterceptor"&gt; &lt;ref local="treeInterceptor"/&gt; &lt;/property&gt; &lt;property name="cacheProvider"&gt; &lt;ref local="cacheProvider"/&gt; &lt;/property&gt; &lt;property name="lobHandler"&gt; &lt;ref bean="lobHandler" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 处理 LOB 数据,CLOB 类型,BLOB 类型 --&gt; &lt;bean id="lobHandler" class="org.springframework.jdbc.support.lob.DefaultLobHandler" lazy-init="true"/&gt; &lt;!-- 缓存 --&gt; &lt;bean id="cacheProvider" class="com.jeecms.common.hibernate3.SpringEhCacheProvider"&gt; &lt;property name="configLocation"&gt; &lt;value&gt;/WEB-INF/config/ehcache-hibernate.xml&lt;/value&gt; &lt;/property&gt; &lt;property name="diskStoreLocation"&gt; &lt;value&gt;/WEB-INF/cache/hibernate&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 栏目等树形结构 --&gt; &lt;bean id="treeInterceptor" class="com.jeecms.common.hibernate3.TreeIntercptor"/&gt; &lt;!-- 定义事务管理器（声明式的事务） --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 是隐式地向 Spring 容器注入 --&gt; &lt;context:annotation-config/&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 源码解析之三（ehcache-hibernate.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;!-- 其为hibernate 二级缓存的配置 xml进入路径web.xml/application-context.xml/ehcache-hibernate.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"&gt; &lt;!-- 磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存 path:指定在硬盘上存储对象的路径 --&gt; &lt;!--&lt;diskStore path="java.io.tmpdir/jeecms/hibernate"/&gt; --&gt; &lt;!-- defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理 maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象 eternal:代表对象是否永不过期 timeToIdleSeconds:最大的发呆时间 timeToLiveSeconds:最大的存活时间 overflowToDisk:是否允许对象被写入到磁盘 diskSpoolBufferSizeMB：磁盘缓冲区的大小 diskExpiryThreadIntervalSeconds:清理过期缓存120秒 --&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" diskSpoolBufferSizeMB="30" maxElementsOnDisk="10000000" diskPersistent="false" diskExpiryThreadIntervalSeconds="120" /&gt; &lt;!-- cache:为指定名称的对象进行缓存的特殊配置 name:指定对象的完整名 --&gt; &lt;cache name="org.hibernate.cache.StandardQueryCache" maxElementsInMemory="50" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="org.hibernate.cache.UpdateTimestampsCache" maxElementsInMemory="5000" eternal="true" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.Sys" maxElementsInMemory="20" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.DbTpl" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.Ftp" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentType" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUserSite" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUserExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ChannelTxt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentTag" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentTxt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsRole" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsModel" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentCount" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSiteCompany" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ChannelExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentCheck" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsConfig" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.viewGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup.contriChannels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsRole.perms" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser.channels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.pictures" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.txt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.child" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.cfg" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.contentCheckSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.users" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser.userExtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.attachments" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup.viewChannels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.contriGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.viewGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.tags" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsConfig.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.contentTxtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.channelTxtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteTopic.items" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsKeyword" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsCommentExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbookExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsSensitivity" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteTopic" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbookCtg" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteRecord" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteItem" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbook" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsComment" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsJobApply" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; 源码解析之四（cache-context.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;pre name="code" class="java"&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" default-lazy-init="true"&gt; &lt;!--缓存--&gt; &lt;bean id="cacheManager" class="com.jeecms.common.web.WebEhCacheManagerFacotryBean"&gt; &lt;property name="configLocation"&gt; &lt;value&gt;/WEB-INF/config/ehcache-application.xml&lt;/value&gt; &lt;/property&gt; &lt;property name="diskStoreLocation"&gt; &lt;value&gt;/WEB-INF/cache/application&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--SESSION缓存--&gt; &lt;bean id="ehSessionCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.common.web.Session&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="session"/&gt; &lt;/bean&gt; &lt;!--内容计数缓存--&gt; &lt;bean id="ehContentCountCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.ContentCount&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="contentCount"/&gt; &lt;/bean&gt; &lt;!--栏目计数缓存--&gt; &lt;bean id="ehChannelCountCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.ChannelCount&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="channelCount"/&gt; &lt;/bean&gt; &lt;!--微信token缓存--&gt; &lt;bean id="ehWeixinTokenCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.weixin.token&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="tokenCache"/&gt; &lt;/bean&gt; &lt;!--站点流量缓存--&gt; &lt;bean id="ehCmsSiteFlowCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSiteFlow&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsSiteFlow"/&gt; &lt;/bean&gt; &lt;!--一次会话访问缓存--&gt; &lt;bean id="ehCmsSiteAccessCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsAccess&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsAccessCache"/&gt; &lt;/bean&gt; &lt;!--最新会话访问缓存--&gt; &lt;bean id="ehCmsSiteLastAccessCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsLastAccess&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsLastAccessCache"/&gt; &lt;/bean&gt; &lt;!--每次访问页面缓存--&gt; &lt;bean id="ehCmsSiteAccessPagesCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsAccessPage&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsAccessPageCache"/&gt; &lt;/bean&gt; &lt;!--pv总量计数缓存--&gt; &lt;bean id="ehPvTotalCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSitePvTotal&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsPvTotalCache"/&gt; &lt;/bean&gt; &lt;!--访问者总量计数缓存--&gt; &lt;bean id="ehVisitorTotalCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSiteVisitorTotal&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsVisitorTotalCache"/&gt; &lt;/bean&gt; &lt;!--搜索词汇缓存--&gt; &lt;bean id="ehSearchWordsCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSearchWords&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsSearchWords"/&gt; &lt;/bean&gt; &lt;!--shiro缓存 &lt;bean id="ehShiroCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.shiro.shiroCache&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="shiroCache"/&gt; &lt;/bean&gt; --&gt;&lt;/beans&gt; 源码解析之五（Spring + FreeMarker的集成）共四步 加载属性文件 application-context.xml下的jeecms.properties，会在第四步用到。12345678910111213141516171819202122232425&lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;JeeCmsV7&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 --&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; ... &lt;/web-app&gt; 前台配置：配置FreeMarkerConfigurer123456789101112131415161718192021222324&lt;!-- 配置freemaker --&gt; &lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;!--获取标签配置--&gt; &lt;property name="freemarkerVariables" value="#&#123;propertyUtils.getBeanMap('directive.')&#125;"/&gt; &lt;property name="templateLoaderPath" value=""/&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="tag_syntax"&gt;auto_detect&lt;/prop&gt; &lt;prop key="template_update_delay"&gt;5&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;!--空值处理&lt;prop key="classic_compatible"&gt;true&lt;/prop&gt;--&gt; &lt;!--定义FreeMaker引入文件，index.ftl前缀为p,spring.ftl的前缀为s，这样在饮用ftl模版的宏定义时，可以简略使用--&gt; &lt;prop key="auto_import"&gt;/WEB-INF/ftl/jeecms/index.ftl as p,/WEB-INF/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 解析 FreeMarker 视图12345678910&lt;!-- 解析freemaker视图 --&gt; &lt;bean id="freemarkerViewResolver" class="com.jeecms.common.web.springmvc.SimpleFreeMarkerViewResolver"&gt; &lt;property name="contentType" value="text/html; charset=UTF-8"/&gt; &lt;!-- 请求属性不暴露给freemaker使用 --&gt; &lt;property name="exposeRequestAttributes" value="false"/&gt; &lt;!-- 会话属性不暴露给freemaker使用 --&gt; &lt;property name="exposeSessionAttributes" value="false"/&gt; &lt;!-- 使用宏 --&gt; &lt;property name="exposeSpringMacroHelpers" value="true"/&gt; &lt;/bean&gt; 后台配置配置FreeMarkerConfigurer12345678910111213141516171819202122232425262728293031&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF"/&gt; &lt;property name="freemarkerVariables"&gt; &lt;map&gt; &lt;!--在FCK编辑器中需要用到appBase，以确定connector路径。--&gt; &lt;entry key="appBase" value="/jeeadmin/jeecms"/&gt; &lt;!--后台管理权限控制--&gt; &lt;entry key="cms_perm" value-ref="cms_perm"/&gt; &lt;entry key="text_cut" value-ref="text_cut"/&gt; &lt;entry key="html_cut" value-ref="html_cut"/&gt; &lt;entry key="cms_content_list" value-ref="cms_content_list"/&gt; &lt;entry key="cms_content_page" value-ref="cms_content_page"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;!--定义FreeMaker引入文件，index.ftl前缀为p,spring.ftl的前缀为s，这样在饮用ftl模版的宏定义时，可以简略使用--&gt; &lt;prop key="auto_import"&gt;/ftl/jeecms/index.ftl as p,/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 解析 FreeMarker 视图1234567891011121314&lt;!-- 视图解析器 --&gt; &lt;bean id="freemarkerViewResolver" class="com.jeecms.common.web.springmvc.RichFreeMarkerViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/jeecms_sys/"/&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".html"/&gt; &lt;property name="contentType" value="text/html; charset=UTF-8"/&gt; &lt;!-- 请求属性不暴露给freemaker使用 --&gt; &lt;property name="exposeRequestAttributes" value="false"/&gt; &lt;!-- 会话属性不暴露给freemaker使用 --&gt; &lt;property name="exposeSessionAttributes" value="false"/&gt; &lt;!-- 使用宏 --&gt; &lt;property name="exposeSpringMacroHelpers" value="true"/&gt; &lt;/bean&gt; 注入freeMarkerConfigurer（jeecms-context.xml）1234567891011121314151617181920212223242526&lt;bean id="staticPageSvc" class="com.jeecms.cms.staticpage.StaticPageSvcImpl"&gt; &lt;property name="tplMessageSource" ref="tplMessageSource"/&gt; &lt;property name="freeMarkerConfigurer"&gt; &lt;bean class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;!-- 从jeecms.properties中获取标签：directive.前缀的 --&gt; &lt;property name="freemarkerVariables" value="#&#123;propertyUtils.getBeanMap('directive.')&#125;"/&gt; &lt;property name="templateLoaderPath" value=""/&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="tag_syntax"&gt;auto_detect&lt;/prop&gt; &lt;prop key="template_update_delay"&gt;5&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;prop key="auto_import"&gt;/WEB-INF/ftl/jeecms/index.ftl as p,/WEB-INF/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 源码解析之六（前台页面初始化）项目启动，初始化配置文件123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 ，freemaker的使用--&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; 浏览器输入http://localhost:8070/jeeCms/1&lt;bean id="dynamicAct" class="com.jeecms.cms.action.front.DynamicPageAct"/&gt; 通过过滤器进入1234567891011121314151617181920212223/** * TOMCAT的默认路径 * * @param request * @param model * @return */ @RequestMapping(value = "/", method = RequestMethod.GET) public String index(HttpServletRequest request,HttpServletResponse response, ModelMap model) &#123; CmsSite site = CmsUtils.getSite(request); FrontUtils.frontData(request, model, site); //带有其他路径则是非法请求 String uri=URLHelper.getURI(request); if(StringUtils.isNotBlank(uri)&amp;&amp;!uri.equals("/"))&#123; return FrontUtils.pageNotFound(request, response, model); &#125; //使用静态首页而且静态首页存在 if(site.getStaticIndex()&amp;&amp;new File(realPathResolver.get(site.getStaticDir()+INDEX)).exists())&#123; return FrontUtils.getTplPath("", site.getStaticDir(), INDEX); &#125;else&#123; return site.getTplIndexOrDef(); &#125; &#125; 返回一个url并 进入主页。123456&lt;!-- 当输入localhost:8080/jeeCms时，会先找第一个欢迎页，没有的话找第二个，依次类推，如果存在，就不找了 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.shtml&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jhtml&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 通过标签进入指定的类，并调用期execute()方法（以前台@cms_content_list为例）前台标签：123456789101112131415&lt;div class="cl"&gt; &lt;ul class="slideshow" id="slidesImgs"&gt; [@&lt;strong&gt;cms_content_list&lt;/strong&gt; count='5' orderBy='4' typeId='3' titLen='18' channelOption='1' channelId='1'] [#list tag_list as a] &lt;li&gt; &lt;a href="$&#123;a.url&#125;" target="_blank"&gt; &lt;img src="$&#123;a.typeImg!site.defImg&#125;" alt="$&#123;a.title&#125;" width="100%" /&gt; &lt;/a&gt; &lt;span class="title"&gt; [@text_cut s=a.title len=titLen /] &lt;/span&gt; &lt;/li&gt; [/#list] [/@cms_content_list] &lt;/ul&gt; &lt;/div&gt; 在web.xml—&gt;jeecms-contextxml 配置中找到相关的处理类1&lt;bean id="cms_content_list" class="com.jeecms.cms.action.directive.ContentListDirective"/&gt; 调用其execute（）方法对其进行处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 模板名称 */ public static final String TPL_NAME = "content_list"; /** * 输入参数，文章ID。允许多个文章ID，用","分开。排斥其他所有筛选参数。 */ public static final String PARAM_IDS = "ids"; @SuppressWarnings("unchecked") public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; //获取站点 CmsSite site = FrontUtils.getSite(env); //获取内容列表，可通过此处进行更改，获取自己数据库中的数据 List&lt;Content&gt; list = getList(params, env); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;(params); //OUT_LIST 的值是tag_list，在DirectiveUtils中声名，将内容列表放入其中 paramWrap.put(OUT_LIST, DEFAULT_WRAPPER.wrap(list)); //将params的值复制上到ariable中 Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); //获取的是参数PARAM_TPL，是否调用模板及调用的模板类型 InvokeType type = DirectiveUtils.getInvokeType(params); //获取模板的传入参数，列表样式，根据不两只的参数获取不同的样式列表 String listStyle = DirectiveUtils.getString(PARAM_STYLE_LIST, params); if (InvokeType.sysDefined == type) &#123; if (StringUtils.isBlank(listStyle)) &#123; throw new ParamsRequiredException(PARAM_STYLE_LIST); &#125; //列表样式模板 env.include(TPL_STYLE_LIST + listStyle + TPL_SUFFIX, UTF8, true); &#125; else if (InvokeType.userDefined == type) &#123; if (StringUtils.isBlank(listStyle)) &#123; throw new ParamsRequiredException(PARAM_STYLE_LIST); &#125; //列表样式模板的路径 FrontUtils.includeTpl(TPL_STYLE_LIST, site, env); &#125; else if (InvokeType.custom == type) &#123; //这个模板是自己声明的，即content_list.html,如果采用自定义模板的话，页面中可以只写上标签，并添加上标签内需要的几个参数不需要写标签的内容，会去自动调用模板中的标签体。 FrontUtils.includeTpl(TPL_NAME, site, params, env); &#125; else if (InvokeType.body == type) &#123; body.render(env.getOut()); &#125; else &#123; throw new RuntimeException("invoke type not handled: " + type); &#125; //将variable中的params值移除 DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; @SuppressWarnings("unchecked") protected List&lt;Content&gt; getList(Map&lt;String, TemplateModel&gt; params, Environment env) throws TemplateException &#123; Integer[] ids = DirectiveUtils.getIntArray(PARAM_IDS, params); if (ids != ) &#123; //根据ID数组获取文章列表 return contentMng.getListByIdsForTag(ids, getOrderBy(params)); &#125; else &#123; return (List&lt;Content&gt;) super.getData(params, env); &#125; &#125; 前台通过标签循环取出数据123456789101112131415&lt;ul class="slideshow" id="slidesImgs"&gt; [@cms_content_list count='5' orderBy='4' typeId='3' titLen='18' channelOption='1' channelId='1'] &lt;!-- 将OUT_LIST 即tag_list中的值遍历出来 --&gt; [#list tag_list as a] &lt;li&gt; &lt;a href="$&#123;a.url&#125;" target="_blank"&gt; &lt;img src="$&#123;a.typeImg!site.defImg&#125;" alt="$&#123;a.title&#125;" width="100%" /&gt; &lt;/a&gt; &lt;span class="title"&gt; [@text_cut s=a.title len=titLen /] &lt;/span&gt; &lt;/li&gt; [/#list] [/@cms_content_list] &lt;/ul&gt; 源码解析之七（前台页面初始化是request赋值）问题：当输入http://localhost:8070/jeeCms/时，通过拦截器“/”后台时，request 中包含了很多值是哪里来的？ 回答：加载web.xml12345678910111213&lt;!-- 前台控制 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-front.xml /WEB-INF/config/plug/**/*-servlet-front-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; 其初使化方法中 进入jeecms-servlet-front.xml，初使化：1&lt;bean id="frontContextInterceptor" class="com.jeecms.cms.web.FrontContextInterceptor"/&gt; 为reques和中放入值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * CMS上下文信息拦截器 * * 包括登录信息、权限信息、站点信息 */ public class FrontContextInterceptor extends HandlerInterceptorAdapter &#123; public static final String SITE_COOKIE = "_site_id_cookie"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException &#123; CmsSite site = ; List&lt;CmsSite&gt; list = cmsSiteMng.getListFromCache(); int size = list.size(); if (size == 0) &#123; throw new RuntimeException("no site record in database!"); &#125; else if (size == 1) &#123; site = list.get(0); &#125; else &#123; String server = request.getServerName(); String alias, redirect; for (CmsSite s : list) &#123; // 检查域名 if (s.getDomain().equals(server)) &#123; site = s; break; &#125; // 检查域名别名 alias = s.getDomainAlias(); if (!StringUtils.isBlank(alias)) &#123; for (String a : StringUtils.split(alias, ',')) &#123; if (a.equals(server)) &#123; site = s; break; &#125; &#125; &#125; // 检查重定向 redirect = s.getDomainRedirect(); if (!StringUtils.isBlank(redirect)) &#123; for (String r : StringUtils.split(redirect, ',')) &#123; if (r.equals(server)) &#123; try &#123; response.sendRedirect(s.getUrl()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return false; &#125; &#125; &#125; &#125; if (site == ) &#123; throw new SiteNotFoundException(server); &#125; &#125; &lt;span style="background-color: rgb(204, 153, 51);"&gt;CmsUtils.setSite(request, site);&lt;/span&gt; CmsThreadVariable.setSite(site); Subject subject = SecurityUtils.getSubject(); if (subject.isAuthenticated()|| subject.isRemembered()) &#123; String username = (String) subject.getPrincipal(); CmsUser user = cmsUserMng.findByUsername(username); CmsUtils.setUser(request, user); // Site加入线程变量 CmsThreadVariable.setUser(user); &#125; createJsessionId(request, response, site); return true; &#125; 源码解析之八（jeeCms整合webservice）第一步：在jeeCms .添加jar包第二步：增加webservice相关配置。web.xml 1234567891011121314151617181920212223&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 ，freemaker的使用--&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;!-- 配置webservice --&gt; &lt;span style="color:#ff6666;"&gt; /WEB-INF/config/webservice/cxf-service.xml&lt;/span&gt; &lt;/param-value&gt; &lt;/context-param&gt; 12345678910&lt;!-- CXF webservice --&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; cxf-service.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:http-conf="http://cxf.apache.org/transports/http/configuration" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd http://cxf.apache.org/transports/http/configuration http://cxf.apache.org/schemas/configuration/http-conf.xsd"&gt; &lt;http-conf:conduit name="*.http-conduit"&gt; &lt;http-conf:client ConnectionTimeout="60000" ReceiveTimeout="60000"/&gt; &lt;/http-conf:conduit&gt; &lt;!-- 这两个xml文件来源cxf jar包 --&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;!-- 这个文件中用来配置webservice服务器 --&gt; &lt;import resource="action-cxf.xml" /&gt; &lt;/beans&gt; action-cxf.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;!-- &lt;jaxws:endpoint id="ActPromWebService" implementor="#bizActPromWebService" address="/ActPromWebService" /&gt; --&gt;&lt;/beans&gt; 第三步 创建webService 接口类，用来存放调用webService 的方法1234567891011121314151617181920212223package com.jeecms.cms.action.directive; import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebService; @WebService(targetNamespace="http://webservice.cus.biz.cbp.cj.com/") public interface countInfoInterfaceNpl &#123; public static final String SERVICE_NAME = "FindAllCustWebSerrvice"; /** * 根据客户ID查询客户的详细信息 * * @param traT * @param custB * @return */ @WebMethod String findByIdCustB(@WebParam(name = "partnerId") String partnerId, @WebParam(name = "traT") String traT, @WebParam(name = "custB") String custB, @WebParam(name = "orderId") String orderId,@WebParam(name = "verifyCode") String verifyCode); &#125; 第四步 java类中调用webservice1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.jeecms.cms.action.directive; import static com.jeecms.common.web.freemarker.DirectiveUtils.OUT_BEAN; import static freemarker.template.ObjectWrapper.DEFAULT_WRAPPER; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import javax.jws.WebService; import org.apache.cxf.interceptor.LoggingInInterceptor; import org.apache.cxf.interceptor.LoggingOutInterceptor; import org.apache.cxf.jaxws.JaxWsProxyFactoryBean; import com.jeecms.common.web.freemarker.DirectiveUtils; import freemarker.core.Environment; import freemarker.template.TemplateDirectiveBody; import freemarker.template.TemplateDirectiveModel; import freemarker.template.TemplateException; import freemarker.template.TemplateModel; /** * 总计信息 */ public class CountInfoNpl implements TemplateDirectiveModel &#123; @SuppressWarnings("unchecked") public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; try &#123; int i=1; if(i==1)&#123; JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); factory.getInInterceptors().add(new LoggingInInterceptor()); factory.getOutInterceptors().add(new LoggingOutInterceptor()); factory.setServiceClass(countInfoInterfaceNpl.class);//调用的接口类 factory.setAddress("http://127.0.0.1:8060/ws/FindAllCustWebSerrvice"); Object cInstance = factory.create(); Method invokeMethod = ; //循环接口类的所有方法，并与实际调用的方法比较，若不存在，则给出错误信息 for(Method m : (countInfoInterfaceNpl.class).getDeclaredMethods())&#123; if(!m.getName().equalsIgnoreCase(""))&#123; invokeMethod = m; break; &#125; &#125; if(invokeMethod == ) throw new Exception("ERROR:method not found"); //为webService添加参数 Object[] params1 = new Object[5]; params1[0] = ; params1[1] = "aaaa"; params1[2] = "bbnn"; params1[3] = ; params1[4] = ; //调用webService接口，并用CustNpl接收返回值 CustBNpl res = (CustBNpl) invokeMethod.invoke(cInstance, params1); System.out.println("aaa"); &#125;else&#123; Map&lt;String,String&gt; cmsVoteInfo=new HashMap&lt;String,String&gt;(); cmsVoteInfo.put("publicInfo", "加薪宝涨息"); cmsVoteInfo.put("totalCaptial","20000001"); cmsVoteInfo.put("goldCaptial","5555555"); cmsVoteInfo.put("getMoney","6666666"); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;( params); paramWrap.put(OUT_BEAN, DEFAULT_WRAPPER.wrap(cmsVoteInfo)); Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); body.render(env.getOut()); DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse部署Web项目到tomcat根路径下]]></title>
    <url>%2Fposts%2F50748.html</url>
    <content type="text"><![CDATA[Step1：项目右键-&gt;属性-&gt;web project settings修改程序的Properties下的Web Project Settings将Context root 例如 “/WebSample”修改为“/”。 Step2: 修改services-&gt;modules-&gt;edit-&gt;path 修改path为“/”。 重启tomcat即可。]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Freemaker开发学习笔记]]></title>
    <url>%2Fposts%2F39074.html</url>
    <content type="text"><![CDATA[Freemaker是一个强大的模板引擎，相比velocity而言，其强大的过程调用、递归和闭包回调功能让freemaker可以完成几乎所有我们所想的功能。从个人看法而言，freemaker完全有能力作为MDA的代码辅助生成工具。本文试图越过传统的概念性介绍，通过一组例子直接把读者带入到Freemaker应用的较高层阶。 大家看文章标题就应该知道，我想用一篇文章，把大家从对freemaker的陌生直接带入到比较深入的境界，所以不想说一些基础性的东西，如果大家不习惯我的表达方法，大可通过google去找习惯于自己阅读方式的相关文章。我用过velocity，最近才用freemaker，才知道我以前的选择是错了，因为velocity不支持过程的调用，所以我为velocity增加了很多的东西，写了很多代码，而且脚本也累赘得要命。freemaker首先吸引我的是它强大的过程调用和递归处理能力，其次则是xml风格的语法结构有着明显的边界，不象velocity要注意段落之间要留空格。所以我建议大家直接使用Freemaker，虽然freemaker没有.net版本，我想不嵌入程序中使用的话，freemaker是绝对的首选。（题外话，谁有兴趣移植一个NFreeMaker？）在使用之前我们先要设置运行环境，在使用Freemaker的时候，我们需要下载相关的程序： freemaker: http://freemarker.sourceforge.net/ fmpp: http://fmpp.sourceforge.net/ 其中fmpp是一个freemaker的辅助工具，有了它，我们可以实现更多的功能。以下例子必须fmpp辅助。这里我们首先提出问题。大家看如下的一个xml文件，虽然freemaker的能力不仅在于处理xml文件，但是用xml作为例子更直观一些： 12345678910111213141516171819202122232425&lt;?xml version='1.0' encoding="gb2312" ?&gt;&lt;types xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:DruleForm-Lite.xsd"&gt; &lt;type name="Type1" &gt; &lt;labels&gt; &lt;label lang="zh-CN" value="投保单"/&gt; &lt;/labels&gt; &lt;field name="Field11" type="Float" lbound="1" ubound="1" &gt; &lt;labels&gt; &lt;label lang="zh-CN" value="投保单ID"/&gt; &lt;/labels&gt; &lt;/field&gt; &lt;field name="Field12" type="String" lbound="1" ubound="*"/&gt; &lt;field name="Field13" type="Integer" lbound="1" ubound="*"/&gt; &lt;field name="Field14" type="Type2" lbound="1" ubound="*"&gt; &lt;type name="Type2"&gt; &lt;field name="Field21" type="String" lbound="1" ubound="*"/&gt; &lt;field name="Field22" type="Integer" lbound="1" ubound="*"/&gt; &lt;/type&gt; &lt;/field&gt; &lt;field name="Field15" type="InsuranceProduct" lbound="1" ubound="*"/&gt; &lt;type&gt; &lt;type name="Type3"&gt; &lt;field name="Field31" type="Type1" lbound="1" ubound="*" /&gt; &lt;/type&gt; &lt;/types&gt; freemaker的基本语法 &lt;# … &gt; 中存放所有freemaker的内容，之外的内容全部原样输出。 &lt;@ … /&gt; 是函数调用两个定界符内的内容中，第一个符号表示指令或者函数名，其后的跟随参数。 freemaker提供的控制包括如下：freemaker的基本语法 &lt;# … &gt; 中存放所有freemaker的内容，之外的内容全部原样输出。 &lt;@ … /&gt; 是函数调用两个定界符内的内容中，第一个符号表示指令或者函数名，其后的跟随参数。 freemaker语句：1234&lt;#if condition&gt; &lt;#elseif condition&gt; &lt;#else&gt;&lt;/#if&gt; 条件判断 12&lt;#list hash_or_seq as var&gt;&lt;/#list&gt; 遍历hash表或者collection（freemaker称作sequence）的成员 123&lt;#macro name param1 param2 ... &gt;&lt;#nested param&gt;&lt;/#macro&gt; 宏，无返回参数 123&lt;#function name param1 param2&gt;&lt;#return val&gt;&lt;/#function&gt; 函数，有返回参数 1var?member_function(...) 用函数对var进行转换，freemaker称为build-ins。实际内部实现类似 1member_function(var, ...) stringA[M .. N] 取子字符串，类似 12substring(stringA, M, N)&#123;key:value, key2:value2 ...&#125; 直接定义一个hash表 1[item0, item1, item2 ...] 直接定义一个序列 1hash0[key0] 存取hash表中key对应的元素 1seq0[5] 存取序列指定下标的元素 1&lt;@function1 param0 param1 ... /&gt; 调用函数function1 12&lt;@macro0 param0 param1 ; nest_param0 nest_param1 ...&gt; nest_body &lt; /@macro&gt; 调用宏，并处理宏的嵌套 1&lt;#assign var = value &gt; 定义变量并初始化 1&lt;#local var = value&gt; 在 macro 或者 function 中定义局部变量并初始化 1&lt;#global var = value &gt; 定义全局变量并初始化 1$&#123;var&#125; 输出并替换为表达式的值 1&lt;#visit xmlnode&gt; 调用macro匹配xmlnode本身及其子节点 1&lt;#recurse xmlnode&gt; 调用macro匹配xmlnode的子节点 freemaker–设计指导一个ftl标记不能放在另外一个ftl标记里面，但是注释标记能够放在ftl标记里面。 系统预定义指令采用&lt;#…&gt;&lt;/#&gt; 用户自定义指令采用&lt;@…&gt;&lt;/@&gt; hash片段可以采用： products[10..19] or products[5..] 的格式。 序列也可以做加法计算：passwords + {“joe”:”secret42”}缺省值: name!”unknown” 或者 (user.name)!”unknown” 或者 name! 或者 (user.name)!null值检查: name?? or (user.name)?? 转义列表： Escape sequence Meaning \” Quotation mark (u0022) \’ Apostrophe (a.k.a. apostrophe-quote) (u0027) \ Back slash (u005C) \n Line feed (u000A) \r Carriage return (u000D) \t Horizontal tabulation (a.k.a. tab) (u0009) \b Backspace (u0008) \f Form feed (u000C) \l Less-than sign: &lt; \g Greater-than sign: &gt; \a Ampersand: &amp; { Curly bracket: { \xCode Character given with its hexadecimal Unicode code (UCS code) 如果想打印${，则需要将{转义，可以写成”${user}”，或者可以用生字符（r指令）：$(r “${xx}”} 序列构成：1&lt;#list ["winter", "spring", "summer", "autumn"] as x&gt;$&#123;x&#125;&lt;/#list&gt; 不同的对象可以存放在一个序列里面，比如：[2 + 2, [1, 2, 3, 4], “whatnot”]. 第一个是数字，第二个是序列，第三个是字符串。 可用采用start..end的方式来定义一个数字序列，start可以小于end，同时，end也可以省略。 hash取值支持一下四种模式： 1234book.author.name, book["author"].name, book.author.["name"], book["author"]["name"]. 特殊变量是指freemaker引擎本身定义的变量。访问时，以.variable_name的语法访问。 变量表达式支持嵌套模式，比如：${“Hello ${user}!”}。 变量表达式在指令中的使用情况：变量表达式可以在指令中，用“”的方式存在，不如：&lt;#include “/footer/${company}.html”&gt;.但是不允许下面的方式存在： &lt;#if ${isBig}&gt;Wow!&lt;/#if&gt; 正确写法1&lt;#if isBig&gt;Wow!&lt;/#if&gt; 而且 &lt;#if “${isBig}”&gt;Wow!&lt;/#if&gt;写法也不正确，因为”${isBig}”返回的是字符串，不是boolean类型。 字符串中取字符或字符串采用以下语法：1$&#123;user[0]&#125;,$&#123;user[0..2]&#125; $&#123;user[4..]&#125;,$&#123;user?string(4)&#125; 序列操作： 加法：&lt;#list [“Joe”, “Fred”] + [“Julia”, “Kate”] as user&gt; 但要注意串联之后的读取速度变慢。 子序列：seq[1..4] 序列和hash的串联都只能用于两个相加，不能有多个相加的模式，hash相加，如果两个相加的hash存在相同的key，则后面会覆盖前面的。 在使用&gt;=或者&gt;时，需要注意一些问题，因为freemaker会将&gt;解释成标记的关闭符，为了解决这个问题，需要在表达式加上括号，比如： &lt;#if (x &gt; y)&gt;. 或者使用 &gt; and &amp;lt符号来代替。 无值变量（包括无该变量，null，返回void，无属性等）：unsafe_expr!default_expr or unsafe_expr! or (unsafe_expr)!default_expr or (unsafe_expr)!缺省值可以是任何类型，不一定是数字，比如：hits!0 或者 colors![“red”, “green”, “blue”]. 如果缺省值忽略，那么将会默认为空串、空序列或者空hash，因为freemarker支持多类型的值。不过要让默认值为0或false，则不能省略缺省值。 非顶层变量的无值处理： product.color!”red”：只处理product不为空，color为空的缺省值处理，如果product为空，则freemaker会抛出异常。(product.color)!”red”：则会处理product为空，color为空，或者没有color属性的无值情况。 无值变量的判断操作：unsafe_expr?? or (unsafe_expr)??判断变量是否是无值。 普通变量插入方式:${expression},${3+5); 数字变量插入方式:#{expression} or #{expression; format}：过期。变量只能用于文本区或者是字符串里面，比如：Hello ${name}!以及 &lt;#include “/footer/${company}.html”&gt; 数字值的插入：根据缺省的number_format输出，以及可以通过setting来达到设置数字格式的目的，也可以通过内置函数string来改变输出格式。 日期类型的格式设置：date_format, time_format 和 datetime_format 定义宏： 不带参数：&lt;#macro 宏名&gt;…&lt;/#macro&gt;，引用&lt;@宏名 /&gt; 带参数：&lt;#macro 宏名 参数…&gt;…&lt;/#macro&gt;，引用&lt;@宏名 参数1=值1…/&gt;，带有参数的宏，调用是参数的值必须和参数的个数相同。当然也可以在宏定义时给参数一些默认值。比如：&lt;#macro greet person color=”black”&gt; 宏里面的嵌套内容：&lt;#macro border&gt; &lt;#nested&gt; &lt;/#macro&gt;在宏的定义body中加入&lt;#nested&gt;指令。嵌套的内容可以是任何正确的ftl块。 宏的本地变量在嵌套内容中是不可见的。 宏定义时，&lt;#nest&gt;指令相当于调用定义的内容，而使用宏时，nest body相当于定义。&lt;#macro repeat count&gt; &lt;#list 1..count as x&gt; &lt;#nested x, x/2, x==count&gt; &lt;/#list&gt;&lt;/#macro&gt;&lt;@repeat count=4 ; c, halfc, last&gt; ${c}. ${halfc}&lt;#if last&gt; Last!&lt;/#if&gt;&#x2f;&#64;&#114;&#x65;&#112;&#101;&#x61;&#116; 定义变量： 在模板中定义的变量将会隐藏（不是更改）数据模型根下面的同名的变量。 模板中的3种类型变量： 1：plain variables，能够在模板中的任何地方访问，一个模板include另外一个模板，也可以访问被包含模板的变量。可以通过assign或者macro指令产生或替换变量。 如果要访问数据模型中的变量，则可以通过.global来访问： &lt;#assign user = “Joe Hider”&gt; ${user} &lt;#– prints: Joe Hider –&gt; ${.globals.user} &lt;#– prints: Big Joe–&gt; 2：Local variables，宏定义body中用local指令创建或者替换。 3：Loop variables:由list指令产生。 namespaces:&lt;#import “/lib/my_test.ftl” as my&gt; &lt;#– the hash called “my” will be the “gate” –&gt;&lt;@my.copyright date=”1999-2002”/&gt;${my.mail} 设置命名空间里面的变量：&lt;#assign mail=”jsmith@other.com” in my&gt;命名空间与数据模型：命名空间的ftl可以访问数据模型的变量。同样命名空间的变量也会隐藏数据模型中同名的变量。空白问题： 1：White-space stripping，默认为enabled，清除ftl标记带来的空白以及缩进。处理模板的空白。 2：t, rt, lt指令。 3：ftl的参数strip_text. 用compress directive或者transform来处理输出。&lt;#compress&gt;…&lt;/#compress&gt;：消除空白行。&lt;@compress single_line=true&gt;…/@compress将输出压缩为一行。 可替换语法：freemarker可用”[“代替”&lt;”.在模板的文件开头加上[#ftl]. Spring MVC 使用 Freemarker• Freemaker是取代JSP的又一种视图技术，和Velocity非常类似，但是它比Velocity多了一个格式化的功能，因此使用上较Velocity方便一点，但语法也稍微复杂一些。将Velocity替换为Freemarker只需要改动一些配置文件，同样，在Spring中使用Freemarker也非常方便，根本无须与Freemarker的API打交道。我们将Spring_Velocity工程复制一份，命名为Spring_Freemarker 修改dispatcher-servlet.xml，将velocityConfig删除，修改viewResolver为FreeMarker ViewResolver，并添加一个freemarkerConfig。 123456789101112&lt;!-- 使用Freemarker视图解析器 --&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view. freemarker.FreeMarkerViewResolver"&gt; &lt;property name="contentType" value="text/html;charset=UTF-8" /&gt; &lt;property name="prefix" value="/" /&gt; &lt;property name="suffix" value=".html" /&gt;&lt;/bean&gt;&lt;!-- 配置Freemarker --&gt;&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view. freemarker.FreeMarkerConfigurer"&gt; &lt;!-- 视图资源位置 --&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt;&lt;/bean&gt; 模板test.html可以稍做修改，加入Freemarker内置的格式化功能来定制Date类型的输出格式。 123456789&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Spring_Freemarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello, $&#123;name&#125;, it is $&#123;time?string("yyyy-MM-dd HH:mm:ss")&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 添加freemarker.jar到web/WEB-INF/lib目录后，启动Resin，可以看到由Freemarker渲染的页面 FreeMarker入门：快速入门模板 + 数据模型 = 输出 FreeMarker基于设计者和程序员是具有不同专业技能的不同个体的观念 他们是分工劳动的：设计者专注于表示——创建HTML文件、图片、Web页面的其它可视化方面；程序员创建系统，生成设计页面要显示的数据 经常会遇到的问题是：在Web页面（或其它类型的文档）中显示的信息在设计页面时是无效的，是基于动态数据的 在这里，你可以在HTML（或其它要输出的文本）中加入一些特定指令，FreeMarker会在输出页面给最终用户时，用适当的数据替代这些代码 下面是一个例子： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href="$&#123;latestProduct.url&#125;"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt; &lt;/html&gt; 这个例子是在简单的HTML中加入了一些由${…}包围的特定代码，这些特定代码是FreeMarker的指令，而包含FreeMarker的指令的文件就称为模板（Template）至于user、latestProduct.url和latestProduct.name来自于数据模型（data model） 数据模型由程序员编程来创建，向模板提供变化的信息，这些信息来自于数据库、文件，甚至于在程序中直接生成 模板设计者不关心数据从那儿来，只知道使用已经建立的数据模型 下面是一个可能的数据模型： 123456789(root) | +- user = &quot;Big Joe&quot; | +- latestProduct | +- url = &quot;products/greenmouse.html&quot; | +- name = &quot;green mouse&quot; 数据模型类似于计算机的文件系统，latestProduct可以看作是目录，而user、url和name看作是文件，url和name文件位于latestProduct目录中（这只是一个比喻，实际并不存在） 当FreeMarker将上面的数据模型合并到模板中，就创建了下面的输出： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome Big Joe!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href="products/greenmouse.html"&gt;green mouse&lt;/a&gt;! &lt;/body&gt; &lt;/html&gt; 数据模型典型的数据模型是树型结构，可以任意复杂和深层次，如下面的例子： 123456789101112131415161718192021222324252627(root) | +- animals | | | +- mouse | | | | | +- size = &quot;small&quot; | | | | | +- price = 50 | | | +- elephant | | | | | +- size = &quot;large&quot; | | | | | +- price = 5000 | | | +- python | | | +- size = &quot;medium&quot; | | | +- price = 4999 | +- test = &quot;It is a test&quot; | +- whatnot | +- because = &quot;don&apos;t know&quot; 类似于目录的变量称为hashes，包含保存下级变量的唯一的查询名字 类似于文件的变量称为scalars，保存单值 scalars保存的值有两种类型：字符串（用引号括起，可以是单引号或双引号）和数字（不要用引号将数字括起，这会作为字符串处理） 对scalars的访问从root开始，各部分用“.”分隔，如animals.mouse.price 另外一种变量是sequences，和hashes类似，只是不使用变量名字，而使用数字索引，如下面的例子： 1234567891011121314151617181920212223242526272829303132333435(root) | +- animals | | | +- (1st) | | | | | +- name = "mouse" | | | | | +- size = "small" | | | | | +- price = 50 | | | +- (2nd) | | | | | +- name = "elephant" | | | | | +- size = "large" | | | | | +- price = 5000 | | | +- (3rd) | | | +- name = "python" | | | +- size = "medium" | | | +- price = 4999 | +- whatnot | +- fruits | +- (1st) = "orange" | +- (2nd) = "banana" 这种对scalars的访问使用索引，如animals[0].name 模板 在FreeMarker模板中可以包括下面三种特定部分： ${…}：称为interpolations，FreeMarker会在输出时用实际值进行替代 FTL标记（FreeMarker模板语言标记）：类似于HTML标记，为了与HTML标记区分，用#开始（有些以@开始，在后面叙述） 注释：包含在&lt;#--和--&gt;（而不是&lt;!--和--&gt;）之间 下面是一些使用指令的例子： if指令12345&lt;#if animals.python.price &lt; animals.elephant.price&gt; Pythons are cheaper than elephants today. &lt;#else&gt; Pythons are not cheaper than elephants today. &lt;/#if&gt; list指令We have these animals: ``html NamePrice &lt;#list animals as being&gt; ${being.name}${being.price} Euros &lt;/#list&gt;1234567891011 输出为： &lt;p&gt;We have these animals: ```html&lt;table border=1&gt; &lt;tr&gt;&lt;th&gt;Name&lt;th&gt;Price &lt;tr&gt;&lt;td&gt;mouse&lt;td&gt;50 Euros &lt;tr&gt;&lt;td&gt;elephant&lt;td&gt;5000 Euros &lt;tr&gt;&lt;td&gt;python&lt;td&gt;4999 Euros &lt;/table&gt; include指令12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Test page&lt;/h1&gt; &lt;p&gt;Blah blah... &lt;#include "/copyright_footer.html"&gt; &lt;/body&gt; &lt;/html&gt; 一起使用指令We have these animals: 1234567891011&lt;table border=1&gt; &lt;tr&gt;&lt;th&gt;Name&lt;th&gt;Price &lt;#list animals as being&gt; &lt;tr&gt; &lt;td&gt; &lt;#if being.size = "large"&gt;&lt;b&gt;&lt;/#if&gt; $&#123;being.name&#125; &lt;#if being.size = "large"&gt;&lt;/b&gt;&lt;/#if&gt; &lt;td&gt;$&#123;being.price&#125; Euros &lt;/#list&gt; &lt;/table&gt; 常用语法EG.一个对象BOOK 1.输出1$&#123;book.name&#125; 空值判断：123$&#123;book.name?if_exists &#125;,$&#123;book.name?default(‘xxx’)&#125;//默认值xxx$&#123; book.name!"xxx"&#125;//默认值xxx 日期格式：1$&#123;book.date?string('yyyy-MM-dd')&#125; 数字格式：123$&#123;book?string.number&#125;--20$&#123;book?string.currency&#125;--&lt;#-- $20.00 --&gt;$&#123;book?string.percent&#125;—&lt;#-- 20% --&gt; 插入布尔值： 12&lt;#assign foo=ture /&gt;$&#123;foo?string("yes","no")&#125; &lt;#-- yes --&gt; 2．逻辑判断a: 1234&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;......&lt;#else&gt;... 其中空值判断可以写成1&lt;#if book.name?? &gt; b: 12345678910111213&lt;#switch value&gt;&lt;#case refValue1&gt;...&lt;#break&gt;&lt;#case refValue2&gt;...&lt;#break&gt;...&lt;#case refValueN&gt;...&lt;#break&gt;&lt;#default&gt;... 3．循环读取12&lt;#list sequence as item&gt;... 空值判断1234&lt;#if bookList?size = 0&gt;e.g.&lt;#list employees as e&gt;$&#123;e_index&#125;. $&#123;e.name&#125; 输出: 121. Readonly2. Robbin freemarker中Map的使用 12345&lt;#list testMap?keys as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap[testKey]&#125; &lt;/option&gt; &lt;/#list&gt; 解析FreeMarker视图声明一个针对FreeMarker的视图解析器： 1234&lt;bean id="viewResolver" class="org.springframework. ➥web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="suffix"&gt;&lt;value&gt;.ftl&lt;/value&gt;&lt;/property&gt; &lt;/bean&gt; FreeMarkerViewResolver和VelocityViewResolver或InternalResourceViewResolver的工作机制相同。模板资源是通过在视图的逻辑名上增加prefix属性的值作为前缀，以及增加suffix属性的值作为后缀进行解析的。和VelocityViewResolver一样，在这里我们又一次只设置suffix属性，因为模板的路径已经在FreeMarkerConfigurer的templateLoaderPath属性中定义了。暴露请求和会话属性。你看到如何告诉VelocityViewResolver将请求和会话属性复制到模型map中，从而它们能够在模板中作为变量使用。采用同样的方式配置FreeMarkerViewResolver，可以将请求和会话属性作为变量暴露给FreeMarker模板使用。要做到这一点，可以设置exposeRequestAttributes或者exposeSessionAttributes为true： 12345678910&lt;bean id="viewResolver" class="org.springframework. web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; … &lt;property name="exposeRequestAttributes"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property name="exposeSessionAttributes"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 这里，两个属性都被设置为true。结果是请求和会话属性都被复制到模板的属性集中，可以使用FreeMarker的表达式语言来访问并显示。 数据源+freemarker+servlet生成xml文件一.步骤:1.在server.xml文件中建立数据源.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;Service name="Cms"&gt; &lt;Connector debug="0" enableLookups="false" port="8084" protocol="AJP/1.3" redirectPort="8443"/&gt; &lt;Connector acceptCount="100" connectionTimeout="20000" debug="0" disableUploadTimeout="true" enableLookups="false" maxSpareThreads="75" maxThreads="150" minSpareThreads="25" port="8081" redirectPort="8443"/&gt; &lt;Engine defaultHost="localhost_Cms" name="Catalina_Cms"&gt; &lt;Logger className="org.apache.catalina.logger.FileLogger" prefix="localhost_cmt_log." suffix=".txt" timestamp="true"/&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"/&gt; &lt;Host autoDeploy="true" debug="0" name="localhost_Cms" unpackWARs="true" xmlNamespaceAware="false" xmlValidation="false"&gt; &lt;Context debug="0" docBase="D:WorkspaceCMSweb" path="/" reloadable="true" workDir="D:WorkspaceCMSj2src"&gt; &lt;Resource name="jdbc/news_DB" auth="Container" type="javax.sql.DataSource"/&gt; &lt;ResourceParams name="jdbc/news_DB"&gt; &lt;parameter&gt; &lt;name&gt;factory&lt;/name&gt; &lt;!-- DBCP Basic Datasource Factory --&gt; &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxActive&lt;/name&gt; &lt;value&gt;1000&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;validationQuery&lt;/name&gt; &lt;value&gt;select 1+1&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxIdle&lt;/name&gt; &lt;value&gt;100&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxWait&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;removeAbandoned&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;removeAbandonedTimeout&lt;/name&gt; &lt;value&gt;60&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;logAbandoned&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;username&lt;/name&gt; &lt;value&gt;aaaa&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;password&lt;/name&gt; &lt;value&gt;bbbbbb&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;driverClassName&lt;/name&gt; &lt;value&gt;net.sourceforge.jtds.jdbc.Driver&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;url&lt;/name&gt; &lt;value&gt;jdbc:jtds:sqlserver://111.111.111.111:1433/cms&lt;/value&gt; &lt;/parameter&gt; &lt;/ResourceParams&gt; &lt;/Context&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; 2.在web.xml文件中配置servlet12345678910&lt;servlet&gt; &lt;description&gt;generate xml file&lt;/description&gt; &lt;servlet-name&gt;NewsXmlServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;xml.NewsXmlServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;NewsXmlServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/xmlServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; 3.newsXmlServlet.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package xml; import java.io.*; import java.nio.charset.Charset; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.sql.DataSource; import freemarker.template.Configuration; import freemarker.template.Template; import freemarker.template.TemplateException; import java.util.Locale; public class NewsXmlServlet extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub try &#123; Connection conn=null; Context ctx = new InitialContext(); DataSource ds=(DataSource)ctx.lookup("java:comp/env/jdbc/news_DB"); conn=ds.getConnection(); Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery("select url,updatetime,tpf_edu_contentTitle,tpf_edu_contentneirong,tpf_edu_contentlaiyuan,tpf_edu_contentkeyword from tp5__edu_content where url&lt;&gt;'' and url is not null and dateDiff(d,updatetime,getDate())=1 order by updatetime desc"); Configuration cfg=new Configuration(); cfg.setDirectoryForTemplateLoading(new File("E:/wwwroot/CMS/web/WEB-INF/classes/xml")); Template tem=cfg.getTemplate("news.ftl"); List list=new ArrayList(); OutputStreamWriter out=new OutputStreamWriter(System.out); while(rs.next())&#123; Map item=new HashMap(); item.put("title",rs.getString(3)); item.put("link","http://test.com.cn"+rs.getString(1)); item.put("pubdate",rs.getTimestamp(2)); item.put("content",DelHtml(rs.getString(4))); item.put("source",rs.getString(5)); item.put("keywords",DelHtml(rs.getString(6))); list.add(item); &#125; Map data=new HashMap(); data.put("items",list); StringWriter writer=new StringWriter(); tem.process(data,writer); String content=writer.toString(); writer.close(); createXml(content); out.close(); //resp.setContentType("text/xml; charset=utf-8"); //resp.getWriter().write(content); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (TemplateException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public String DelHtml(String content)&#123; String contents=content.replaceAll("&lt;\/?\s*(\S+)(\s*[^&gt;]*)?\s*\/?&gt;",""); contents=contents.replaceAll("&amp;ldquo;", "”"); contents=contents.replaceAll("&amp;rdquo;","”"); contents=contents.replaceAll("&amp;ldquo;", "‘"); contents=contents.replaceAll("&amp;rdquo;","’"); contents=contents.replaceAll("&amp;middot;","•"); contents=contents.replaceAll("&amp;mdash;","—"); contents=contents.replaceAll("&amp;hellip;","…"); contents=contents.replaceAll("&amp;nbsp;",""); contents=contents.replaceAll(","," "); return contents; &#125; public void createXml(String fileContent)&#123; try &#123; String filePath="E:/wwwroot/cmsHtml/education/news.xml"; File fileXml=new File(filePath); if(!fileXml.exists())&#123; fileXml.createNewFile(); &#125; /*FileWriter fileWriter=new FileWriter(fileXml); fileWriter. fileWriter.write(fileContent); fileWriter.close();*/ OutputStreamWriter writer=new OutputStreamWriter(new FileOutputStream(fileXml), Charset.forName("utf-8")); writer.write(fileContent); writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public void destroy() &#123; // TODO Auto-generated method stub super.destroy(); &#125; public void init() throws ServletException &#123; // TODO Auto-generated method stub super.init(); &#125; &#125; 4.news.ftl1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;document&gt; &lt;webSite&gt;edu.aweb.com.cn&lt;/webSite&gt; &lt;webMaster&gt;webmaster@aweb.com.cn&lt;/webMaster&gt; &lt;updatePeri&gt;1440&lt;/updatePeri&gt; &lt;#list items as it&gt; &lt;item&gt; &lt;title&gt;&lt;![CDATA[$&#123;it.title&#125;]]&gt;&lt;/title&gt; &lt;link&gt;$&#123;it.link&#125;&lt;/link&gt; &lt;pubDate&gt;$&#123;it.pubdate&#125;&lt;/pubDate&gt; &lt;text&gt;&lt;![CDATA[$&#123;it.content&#125;]]&gt;&lt;/text&gt; &lt;image/&gt; &lt;source&gt;$&#123;it.source&#125;&lt;/source&gt; &lt;keywords&gt;&lt;![CDATA[$&#123;it.keywords&#125;]]&gt;&lt;/keywords&gt; &lt;/item&gt; &lt;/#list&gt; &lt;/document&gt; Spring中使用FreeMaker或Vilocity模板发送邮件 本文以用户注册后为用户发送一封邮件为例子，讲述如何在Spring中使用FreeMaker或Vilocity发送邮件。 Spring配置文件：xml 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt; &lt;property name="host" value="smtp.163.com"/&gt; &lt;property name="username" value="test"/&gt; &lt;property name="password" value="123456"/&gt; &lt;property name="javaMailProperties"&gt; &lt;props&gt; &lt;prop key="mail.smtp.auth"&gt;trueprop&gt; props&gt; property&gt; bean&gt; &lt;bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/freemakertemplate/" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0prop&gt; &lt;prop key="default_encoding"&gt;GBKprop&gt; &lt;prop key="locale"&gt;zh_CNprop&gt; props&gt; property&gt; bean&gt; &lt;bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"&gt; &lt;property name="resourceLoaderPath" value="/WEB-INF/vilocitytemplate/" /&gt; &lt;property name="velocityProperties"&gt; &lt;props&gt; &lt;prop key="velocimacro.library"&gt;*.vmprop&gt; &lt;prop key="default.contentType"&gt;text/html; charset=utf-8prop&gt; &lt;prop key="output.encoding"&gt;utf-8prop&gt; &lt;prop key="input.encoding"&gt;utf-8prop&gt; props&gt; property&gt; bean&gt; &lt;bean id="mailMessage" class="org.springframework.mail.SimpleMailMessage" singleton="false"&gt; &lt;property name="from" value="test@163.com"/&gt; bean&gt; &lt;bean id="mailEngine" class="test.MailEngine"&gt; &lt;property name="mailSender" ref="mailSender"/&gt; &lt;property name="velocityEngine" ref="velocityEngine"/&gt; &lt;property name="freeMarkerConfigurer" ref="freeMarkerConfigurer" /&gt; bean&gt; java 代码MailEngine类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class MailEngine &#123; protected static final Log log = LogFactory.getLog(MailEngine.class); // private FreeMarkerConfigurer freeMarkerConfigurer; private VelocityEngine velocityEngine; private MailSender mailSender; // public void setFreeMarkerConfigurer( // FreeMarkerConfigurer freeMarkerConfigurer) &#123; // this.freeMarkerConfigurer = freeMarkerConfigurer; // &#125; public void setMailSender(MailSender mailSender) &#123; this.mailSender = mailSender; &#125; public void setVelocityEngine(VelocityEngine velocityEngine) &#123; this.velocityEngine = velocityEngine; &#125; /** * 通过模板产生邮件正文 * @param templateName 邮件模板名称 * @param map 模板中要填充的对象 * @return 邮件正文（HTML） */ public String generateEmailContent(String templateName, Map map) &#123; //使用FreeMaker模板 // try &#123; // Configuration configuration = freeMarkerConfigurer.getConfiguration(); // Template t = configuration.getTemplate(templateName); // return FreeMarkerTemplateUtils.processTemplateIntoString(t, map); // &#125; catch (TemplateException e) &#123; // log.error("Error while processing FreeMarker template ", e); // &#125; catch (FileNotFoundException e) &#123; // e.printStackTrace(); // //log.error("Error while open template file ", e); // &#125; catch (IOException e) &#123; // log.error("Error while generate Email Content ", e); // &#125; // 使用Vilocity模板 try &#123; return VelocityEngineUtils.mergeTemplateIntoString(velocityEngine, templateName, map); &#125; catch (VelocityException e) &#123; log.error("Error while processing Vilocity template ", e); &#125; return null; &#125; /** * 发送邮件 * @param emailAddress 收件人Email地址的数组 * @param fromEmail 寄件人Email地址, null为默认寄件人web@vnvtrip.com * @param bodyText 邮件正文 * @param subject 邮件主题 * @param attachmentName 附件名 * @param resource 附件 * @throws MessagingException */ public void sendMessage(String[] emailAddresses, String fromEmail, String bodyText, String subject, String attachmentName, ClassPathResource resource) throws MessagingException &#123; MimeMessage message = ((JavaMailSenderImpl) mailSender) .createMimeMessage(); // use the true flag to indicate you need a multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(emailAddresses); if(fromEmail != null)&#123; helper.setFrom(fromEmail); &#125; helper.setText(bodyText, true); helper.setSubject(subject); if(attachmentName!=null &amp;&amp; resource!=null) helper.addAttachment(attachmentName, resource); ((JavaMailSenderImpl) mailSender).send(message); &#125; /** * 发送简单邮件 * @param msg */ public void send(SimpleMailMessage msg) &#123; try &#123; ((JavaMailSenderImpl) mailSender).send(msg); &#125; catch (MailException ex) &#123; //log it and go on log.error(ex.getMessage()); &#125; &#125; /** * 使用模版发送HTML格式的邮件 * * @param msg 装有to,from,subject信息的SimpleMailMessage * @param templateName 模版名,模版根路径已在配置文件定义于freemakarengine中 * @param model 渲染模版所需的数据 */ public void send(SimpleMailMessage msg, String templateName, Map model) &#123; //生成html邮件内容 String content = generateEmailContent(templateName, model); MimeMessage mimeMsg = null; try &#123; mimeMsg = ((JavaMailSenderImpl) mailSender).createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMsg, true, "utf-8"); helper.setTo(msg.getTo()); if(msg.getSubject()!=null) helper.setSubject(msg.getSubject()); if(msg.getFrom()!=null) helper.setFrom(msg.getFrom()); helper.setText(content, true); ((JavaMailSenderImpl) mailSender).send(mimeMsg); &#125; catch (MessagingException ex) &#123; log.error(ex.getMessage(), ex); &#125; &#125; &#125; //发送邮件： SimpleMailMessage message = (SimpleMailMessage) getBean("mailMessage"); message.setTo(user.getName() + "&lt;" + user.getEmail() + "&gt;"); Map model = new HashMap(); model.put("user", user); MailEngine engine = (MailEngine)getBean("mailEngine"); //Vilocity模板 engine.send(message, "notifyUser.vm", model); //FreeMaker模板 //engine.send(message, "NotifyUser.ftl", model); 以上的User为用户类。 xml 代码模板： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;title&gt;用户注册通知title&gt; head&gt; &lt;body&gt; &lt;p&gt;$&#123;user.name&#125; 您好，恭喜您，已经成为本站会员！p&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名：td&gt;&lt;td&gt;$&#123;user.name&#125;td&gt;tr&gt; &lt;tr&gt;&lt;td&gt;密码：td&gt;&lt;td&gt;$&#123;user.password&#125;td&gt;tr&gt; table&gt; body&gt; html&gt;]]></content>
      <categories>
        <category>Freemaker</category>
      </categories>
      <tags>
        <tag>Freemaker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三目运算详解]]></title>
    <url>%2Fposts%2F44114.html</url>
    <content type="text"><![CDATA[三目运算符，又称条件运算符，指的是计算机语言的重要组成部分。它是唯一有3个操作数的运算符，所以有时又称为三元运算符。一般来说，三目运算符的结合性是右结合的。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。[1] &lt;表达式1&gt; ? &lt;表达式2&gt; : &lt;表达式3&gt;; “?”运算符的含义是：先求表达式1的值，如果为真，则执行表达式2，并返回表达式2的结果；如果表达式1的值为假，则执行表达式3，并返回表达式3的结果。 可以理解为条件 ? 结果1 : 结果2 里面的？号是格式要求。也可以理解为是不是条件成立，条件成立为结果1否则为结果2。 注意：在C语言中，结果1 和 结果2的类型必须一致。 a ? b : c简单理解方式为: 12345if(a) &#123; return b;&#125; else &#123; return c; &#125; 对于有些选择分支结构,可以使用简单的条件运算符来代替. 如: 1234if(a&lt;b) min=a;else min=b; 可以用下面的条件运算符来处理 1min=(a&lt;b)?a:b; 其中”(a&lt;b)?a:b”是一个”条件表达式”,它是这样执行的: 如果a&lt;b为真,则表达式取a值,否则取b值. 条件运算符由两个符号组成”?”和”:”,要求有3个操作对象,所以也叫它三目运算符,它是C语言中唯一的三目运算符. 它的一般形式为: 表达式1?表达式2:表达式3; 以下是关于条件运算符的几点说明: 通常情况下,表达式1是关系表达式或逻辑表达式,用于描述条件表达式中的条件,表达式2和表达式3可以是常量,变量或表达式.例如: 123(x==y)?'Y':'N'(d=b*b-4*a*c)&gt;=0?sqrt(d):sqrt(-d)ch=(ch&gt;='A'&amp;&amp;ch&lt;='Z')?(ch+32):ch 以上均为合法的条件表达式. 条件表达式的执行顺序为:先求解表达式1,若值为非0,表示条件为真,则求解表达式2,此时表达式2的值就作为整个条件表达式的值; 若表达式1的值为0,表示条件为假,则求解表达式3,表达式3的值就是整个条件表达式的值.例如: (a&gt;=0)?a:-a 执行结果是a的绝对值. 在程序中,通过把条件表达式的值直接赋予某个变量.例如: min=(a&lt;b)?a:b 执行结果就是将条件表达式的值赋予变量min,即将a和b二者中较小的数赋给min. 条件表达式的优先级别仅高于赋值运算符,而低于前面遇到过的所有运算符. 因此,min=(a&lt;b)?a:b括号可以不要,可直接写成,min=a&lt;b?a:b如果有x&lt;y?x+1:y-1等效于x&lt;y(x+1):(y-1)而不等效于(x&lt;y?x+1:y)-1 条件运算符的结合方向为”自右至左”. 条件表达式允许嵌套,即允许条件表达式中的表达式2和表达式3又是一个条件表达式.例如: 1x&gt;0?1:x&lt;0?-1:0 上述条件表达式中,表达式3部分又是一个条件表达式.根据条件表达式的结合性,上述条件表达式等价于: x&gt;0?1:(x&lt;0?-1:0) 其作用是判断x的符号情况.当x为正数时,该条件表达式的值为1;当x为负数时,该条件表达式的值为-1;当x为0时,该条件表达式的值为0. 条件表达式不能取代一般的if语句,仅当if语句中内嵌的语句为赋值语句(且两个分支都给同一变量赋值)时才能代替if语句.例如: 1234if(a%2==0) printf("even/n"); else printf("odd/n" ); 不能写成: 1(a%2==0)?printf("even/n"):printf("odd/n"); 但可以用下面语句代替: 1printf("%s/n",(a%2==0?"even":"o dd”); 该语句的作用是:若 a 为偶数,输出 even;若 a 为奇数,输出odd. 表达式1,表达式2,表达式3的类型可以不同.此时条件表达式的值的类型为它们中较高的类型.例如: 1234567891011main() &#123; char c1, ch; ch = getchar(); c1 = ch &lt;= 'Z' &amp;&amp; ch &gt;= 'A' ? ' @ ' : ch ; putchar(c1); &#125; 该程序的作用是从键盘输入任意一个字符,判别它们是否大写字母,如果是,输出一个@;否则按原样输出 dot 上例中,程序第6行是关键语句,该语句实现输入字符的判断,选择与更换工作. 其执行过程为:先由此语句中的赋值号右侧的条件运算符对输入的字符进行判断和选择,若ch&gt;=’A’&amp;&amp;ch&lt;=’Z’成立,说明ch是大写英文字母,此时选@;否则仍选原字符ch,然后把选择的结果赋值给原变量ch 。]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>三目运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch 4.0.0批处理框架]]></title>
    <url>%2Fposts%2F31932.html</url>
    <content type="text"><![CDATA[Spring Batch 4.0.0 已发布，Spring Batch 是一个轻量级的，完全面向 Spring 的批处理框架，可以应用于企业级大量的数据处理系统。Spring Batch 以 POJO 和 Spring 框架为基础，使开发者更容易的访问和利用企业级服务。Spring Batch 可以提供大量的，可重复的数据处理功能，包括日志记录/跟踪，事务管理，作业处理统计工作重新启动、跳过，和资源管理等重要功能。Spring Batch 4.0 是自2014年 3.0 发布以来的又一个主要版本。3.0 发布至今，Spring 生态系统发生了很大变化，4.0 版本旨在让 Spring Batch 更新这些变化。 New Baseline Spring Batch 3 基于 Spring Framework 4 ，Spring Batch 4 重新审视了它的依赖关系树，将它与即将到来的 Spring Boot 2 依赖关系树进行了更新，包括将 Spring Framework 5 和 Java 8 作为基线要求。 改进的 Java 配置如前所述，Spring Batch 4 是 Spring Boot 发布以来的第一个主要版本。在这个版本中，改善了让用户的 Java 配置体验。所有 ItemReader 和 ItemWriter 实现现在都可以使用构建器。使用 Spring Batch 3 的 Java 配置功能，将需要如下所示： 1234567891011121314151617181920212223242526@Beanpublic FlatFileItemReader&lt;Foo&gt; reader(Resource resource) throws Exception &#123; FlatFileItemReader&lt;Foo&gt; reader = new FlatFileItemReader&lt;&gt;(); reader.setName(“fooReader”); reader.setResource(resource); BeanWrapperFieldSetMapper&lt;Foo&gt; fieldSetMapper = new BeanWrapperFieldSetMapper&lt;&gt;(); fieldSetMapper.setTargetType(Foo.class); fieldSetMapper.afterPropertiesSet(); DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); tokenizer.setNames(new String[] &#123;“first”, “second”, “third”&#125;); tokenizer.afterPropertiesSet(); DefaultLineMapper lineMapper = new DefaultLineMapper(); lineMapper.setLineTokenizer(tokenizer); lineMapper.setFieldSetMapper(fieldSetMapper); reader.setLineMapper(lineMapper); return reader; &#125; 使用 Spring Batch 4，配置简化如下： 12345678910@Beanpublic FlatFileItemReader&lt;Foo&gt; reader(Resource resource) &#123; return new FlatFileItemReaderBuilder&lt;Foo&gt;() .name(“fooReader”) .resource(resource) .delimited() .names(new String[]&#123;“first”, “second”, “third”&#125;) .targetType(Foo.class) .build();&#125; 开始创建批处理服务本指南将引导您完成创建基本批处理驱动解决方案的过程。 你要建什么您将构建一个服务，该服务从CSV电子表格中导入数据，用自定义代码对其进行转换，并将最终结果存储在数据库中。 你需要什么大约15分钟 最喜欢的文本编辑器或IDEJDK 1.8或以后 Gradle 2.3或Maven 3.0+ 您还可以直接将代码导入IDE中： Spring Tool Suite (STS) IntelliJ IDEA 如何完成本指南像大多数Spring一样入门指南，您可以从头开始并完成每个步骤，也可以绕过您已经熟悉的基本设置步骤。无论哪种方式，你最终都会得到工作代码。 到白手兴家，继续前进用Gradle建造… 到跳过基础，做以下工作： 下载并解压缩本指南的源存储库，或用Git:1git clone https://github.com/spring-guides/gs-batch-processing.git cd into gs-batch-processing/initial 跳到创建一个business类… 当你完成中的代码检查结果，gs-batch-processing/complete. 用Gradle创建首先，您设置了一个基本的构建脚本。在使用Spring构建应用程序时，您可以使用任何您喜欢的构建系统，但是您需要使用的代码用Gradle和Maven包括在这里。如果您对这两种情况都不熟悉，请参阅用Gradle构建Java项目或使用Maven构建Java项目… 创建目录结构在您选择的项目目录中，创建以下子目录结构；例如，使用mkdir-p src/main/java/hello关于*nix系统： 1234└── src └── main └── java └── hello 创建一个Gradle构建文件下面是initial Gradle build file…. build.gradle 1234567buildscript&#123;repositories&#123;mavenCentral() &#125;dependencies&#123;classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.9.RELEASE") &#125;&#125;apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'idea'apply plugin: 'org.springframework.boot'jar&#123;baseName= 'gs-batch-processing'version= '0.1.0'&#125;repositories&#123;mavenCentral()&#125;sourceCompatibility= 1.8targetCompatibility= 1.8dependencies&#123;compile("org.springframework.boot:spring-boot-starter-batch")compile("org.hsqldb:hsqldb")testCompile("junit:junit")&#125; Spring Boot gradle plugin提供了许多方便的功能： 它收集类路径上的所有JAR，并构建一个可运行的“über-jar”，这使得执行和传输服务更加方便。 它搜索public static void main()方法标记为可运行的类。 它提供了一个内置的依赖项解析器，它将版本号设置为匹配。Spring Boot dependencies您可以覆盖任何版本，但它将默认为Boot所选的一组版本。 用Maven构建首先，您设置了一个基本的构建脚本。在使用Spring构建应用程序时，您可以使用任何您喜欢的构建系统，但是您需要使用的代码马文包括在这里。如果您不熟悉Maven，请参阅使用Maven构建Java项目… 创建目录结构在您选择的项目目录中，创建以下子目录结构；例如，使用mkdir-p src/main/java/hello关于*nix系统： 1234└── src └── main └── java └── hello pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0"encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;gs-batch-processing&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 大Spring Boot Maven插件提供了许多方便的功能： 它收集类路径上的所有JAR，并构建一个可运行的“über-jar”，这使得执行和传输服务更加方便。 它搜索public static void main()方法标记为可运行的类。 它提供了一个内置的依赖项解析器，它将版本号设置为匹配。Spring Boot dependencies您可以覆盖任何版本，但它将默认为Boot所选的一组版本。 用IDE构建 阅读如何将本指南直接导入Spring Tool Suite… 阅读如何使用本指南IntelliJ IDEA… 业务数据通常，您的客户或业务分析师提供电子表格。在这种情况下，你自己编出来的。 SRC/Main/Resources/Sample-data.csv 12345Jill,DoeJoe,DoeJustin,DoeJane,DoeJohn,Doe 此电子表格包含每行的名称和姓氏，以逗号分隔。正如您所看到的，这是Spring处理的一个非常常见的模式。 接下来，编写一个SQL脚本来创建一个表来存储数据。 SRC/main/resources/schema-all.sql 12DROP TABLE people IF EXISTS;CREATE TABLE people(person_id BIGINT IDENTITY NOT NULL PRIMARY KEY,first_name VARCHAR(20),last_name VARCHAR(20)); Spring Boot模式schema-@@platform@@.sql启动时自动。-all是所有平台的默认设置。 创建一个business类现在您已经看到了数据输入和输出的格式，您可以编写代码来表示一行数据. 12345678910111213141516171819202122232425262728293031323334353637packagehello;public class Person &#123; private StringlastName; private StringfirstName; public Person() &#123; &#125; public Person(StringfirstName, StringlastName) &#123; this.firstName=firstName; this.lastName=lastName; &#125; public voidsetFirstName(StringfirstName) &#123; this.firstName=firstName; &#125; public StringgetFirstName() &#123; returnfirstName; &#125; public StringgetLastName() &#123; returnlastName; &#125; public voidsetLastName(StringlastName) &#123; this.lastName=lastName; &#125; @Override public StringtoString() &#123; return "firstName: " +firstName+ ", lastName: " +lastName; &#125;&#125; 您可以实例化person通过构造函数，或通过设置属性，使用姓和名初始化。 创建中间处理器（ intermediate processor）批处理中的一个常见范例是摄取数据，转换数据，然后将其输送到其他地方。在这里，您将编写一个简单的转换器，将名称转换为大写。 SRC/main/java/hello/PersonItemProcessor.java 12345678910111213141516171819202122packagehello;importorg.slf4j.Logger;importorg.slf4j.LoggerFactory;importorg.springframework.batch.item.ItemProcessor;public class PersonItemProcessor implements ItemProcessor&lt;Person, Person&gt; &#123; private static final Loggerlog= LoggerFactory.getLogger(PersonItemProcessor.class); @Override public Personprocess(final Personperson) throws Exception &#123; final StringfirstName=person.getFirstName().toUpperCase(); final StringlastName=person.getLastName().toUpperCase(); final PersontransformedPerson= new Person(firstName,lastName);log.info("Converting (" +person+ ") into (" +transformedPerson+ ")"); returntransformedPerson; &#125;&#125; PersonItemProcessor器实现Spring批处理ItemProcessor接口。这使代码很容易连接到一个批处理作业中，您可以在本指南中进一步对其进行定义。根据接口，您将收到一个传入的person对象，然后将其转换upper-cased Person. 不需要输入和输出类型相同。事实上，在读取一个数据源之后，有时应用程序的数据流需要不同的数据类型。 把一批工作放在一起现在，您将实际的批处理作业组合在一起。SpringBatch提供了许多实用程序类，这些类减少了编写自定义代码的需要。相反，您可以专注于业务逻辑。 SRC/main/java/hello/BatchConfiguration.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980packagehello;importjavax.sql.DataSource;importorg.springframework.batch.core.Job;importorg.springframework.batch.core.JobExecutionListener;importorg.springframework.batch.core.Step;importorg.springframework.batch.core.configuration.annotation.EnableBatchProcessing;importorg.springframework.batch.core.configuration.annotation.JobBuilderFactory;importorg.springframework.batch.core.configuration.annotation.StepBuilderFactory;importorg.springframework.batch.core.launch.support.RunIdIncrementer;importorg.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;importorg.springframework.batch.item.database.JdbcBatchItemWriter;importorg.springframework.batch.item.file.FlatFileItemReader;importorg.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;importorg.springframework.batch.item.file.mapping.DefaultLineMapper;importorg.springframework.batch.item.file.transform.DelimitedLineTokenizer;importorg.springframework.beans.factory.annotation.Autowired;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;importorg.springframework.core.io.ClassPathResource;importorg.springframework.jdbc.core.JdbcTemplate;@Configuration@EnableBatchProcessingpublic class BatchConfiguration &#123; @Autowired public JobBuilderFactoryjobBuilderFactory; @Autowired public StepBuilderFactorystepBuilderFactory; @Autowired public DataSourcedataSource; // tag::readerwriterprocessor[] @Bean public FlatFileItemReader&lt;Person&gt;reader() &#123; FlatFileItemReader&lt;Person&gt;reader= new FlatFileItemReader&lt;Person&gt;();reader.setResource(new ClassPathResource("sample-data.csv"));reader.setLineMapper(new DefaultLineMapper&lt;Person&gt;() &#123;&#123;setLineTokenizer(new DelimitedLineTokenizer() &#123;&#123;setNames(new String[] &#123; "firstName", "lastName" &#125;); &#125;&#125;);setFieldSetMapper(new BeanWrapperFieldSetMapper&lt;Person&gt;() &#123;&#123;setTargetType(Person.class); &#125;&#125;); &#125;&#125;); returnreader; &#125; @Bean public PersonItemProcessorprocessor() &#123; return new PersonItemProcessor(); &#125; @Bean public JdbcBatchItemWriter&lt;Person&gt;writer() &#123; JdbcBatchItemWriter&lt;Person&gt;writer= new JdbcBatchItemWriter&lt;Person&gt;();writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;Person&gt;());writer.setSql("INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)");writer.setDataSource(dataSource); returnwriter; &#125; // end::readerwriterprocessor[] // tag::jobstep[] @Bean public JobimportUserJob(JobCompletionNotificationListenerlistener) &#123; returnjobBuilderFactory.get("importUserJob") .incrementer(new RunIdIncrementer()) .listener(listener) .flow(step1()) .end() .build(); &#125; @Bean public Stepstep1() &#123; returnstepBuilderFactory.get("step1") .&lt;Person, Person&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build(); &#125; // end::jobstep[]&#125; 首先，@EnableBatchProcessing注释添加了许多支持作业的关键bean，并为您节省了大量的腿工作。此示例使用基于内存的数据库(由@EnableBatchProcessing)，这意味着当它完成时，数据就会消失。 把它分解： SRC/main/java/hello/BatchConfiguration.java 12345678910111213141516171819@Beanpublic FlatFileItemReader&lt;Person&gt;reader() &#123; FlatFileItemReader&lt;Person&gt;reader= new FlatFileItemReader&lt;Person&gt;();reader.setResource(new ClassPathResource("sample-data.csv"));reader.setLineMapper(new DefaultLineMapper&lt;Person&gt;() &#123;&#123;setLineTokenizer(new DelimitedLineTokenizer() &#123;&#123;setNames(new String[] &#123; "firstName", "lastName" &#125;); &#125;&#125;);setFieldSetMapper(new BeanWrapperFieldSetMapper&lt;Person&gt;() &#123;&#123;setTargetType(Person.class); &#125;&#125;); &#125;&#125;); returnreader;&#125;@Beanpublic PersonItemProcessorprocessor() &#123; return new PersonItemProcessor();&#125;@Beanpublic JdbcBatchItemWriter&lt;Person&gt;writer() &#123; JdbcBatchItemWriter&lt;Person&gt;writer= new JdbcBatchItemWriter&lt;Person&gt;();writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;Person&gt;());writer.setSql("INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)");writer.setDataSource(dataSource); returnwriter;&#125; 第一个代码块定义输入、处理器和输出。—reader()创建ItemReader.它查找一个名为sample-data.csv并使用足够的信息解析每一行项，从而将其转换为person…processor()创建我们的PersonItemProcessor您在前面定义，目的是大写数据。—write(DataSource)创建ItemWriter。此对象针对JDBC目标，并自动获取由@EnableBatchProcessing它包括插入单个person由Javabean属性驱动。 下一部分重点关注实际的作业配置。SRC/main/java/hello/BatchConfiguration.java 12345678910111213141516171819@Beanpublic JobimportUserJob(JobCompletionNotificationListenerlistener) &#123; returnjobBuilderFactory.get("importUserJob") .incrementer(new RunIdIncrementer()) .listener(listener) .flow(step1()) .end() .build();&#125;@Beanpublic Stepstep1() &#123; returnstepBuilderFactory.get("step1") .&lt;Person, Person&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build();&#125; 第一个方法定义作业，三定义一个步骤。作业是由步骤构建的，每个步骤都可以包含一个阅读器、一个处理器和一个编写器。 在此作业定义中，您需要一个增量器，因为作业使用数据库来维护执行状态。然后列出每个步骤，其中此作业只有一个步骤。作业结束，JavaAPI生成一个配置完美的作业。 在步骤定义中，定义一次写入多少数据。在这种情况下，它一次最多写十条记录。接下来，使用前面注入的位来配置读取器、处理器和写入器。 chunk()是前缀&lt;Person,Person&gt;因为这是一个通用的方法。这表示处理的每个“块”的输入和输出类型，并与ItemReader和ItemWriter... SRC/main/java/hello/JobCompletionNotificationListener.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546packagehello;importjava.sql.ResultSet;importjava.sql.SQLException;importjava.util.List;importorg.slf4j.Logger;importorg.slf4j.LoggerFactory;importorg.springframework.batch.core.BatchStatus;importorg.springframework.batch.core.JobExecution;importorg.springframework.batch.core.listener.JobExecutionListenerSupport;importorg.springframework.beans.factory.annotation.Autowired;importorg.springframework.jdbc.core.JdbcTemplate;importorg.springframework.jdbc.core.RowMapper;importorg.springframework.stereotype.Component;@Componentpublic class JobCompletionNotificationListener extends JobExecutionListenerSupport &#123; private static final Loggerlog= LoggerFactory.getLogger(JobCompletionNotificationListener.class); private final JdbcTemplatejdbcTemplate; @Autowired public JobCompletionNotificationListener(JdbcTemplatejdbcTemplate) &#123; this.jdbcTemplate=jdbcTemplate; &#125; @Override public voidafterJob(JobExecutionjobExecution) &#123; if(jobExecution.getStatus() == BatchStatus.COMPLETED) &#123;log.info("!!! JOB FINISHED! Time to verify the results"); List&lt;Person&gt;results=jdbcTemplate.query("SELECT first_name, last_name FROM people", new RowMapper&lt;Person&gt;() &#123; @Override public PersonmapRow(ResultSetrs, introw) throws SQLException &#123; return new Person(rs.getString(1),rs.getString(2)); &#125; &#125;); for (Personperson:results) &#123;log.info("Found &lt;" +person+ "&gt; in the database."); &#125; &#125; &#125;&#125; 此代码监听作业为BatchStatus.COMPLETED，然后使用JdbcTemplate检查结果。 使应用程序可执行虽然批处理可以嵌入到Web应用程序和WAR文件中，但下面演示的更简单的方法创建了一个独立的应用程序。您将所有东西打包到一个可执行的JAR文件中，该文件由一个好的旧Java驱动。main()方法。 src/main/java/hello/Application.java 123456789101112packagehello;importorg.springframework.boot.SpringApplication;importorg.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static voidmain(String[]args) throws Exception &#123; SpringApplication.run(Application.class,args); &#125;&#125; @SpringBootApplication是一个方便的注释，它添加了以下所有内容： @Configuration将类标记为应用程序上下文的bean定义的源。 @EnableAutoConfiguration告诉SpringBoot根据类路径设置、其他bean和各种属性设置开始添加bean。 通常你会添加@EnableWebMvc对于SpringMVC应用程序，但是SpringBoot在看到Springwebmvc在类路径上。这会将应用程序标记为web应用程序，并激活关键行为，例如设置DispatcherServlet… @ComponentScan告诉Spring在hello包，让它找到控制器。 main()方法使用SpringBoot的SpringApplication.run()方法来启动应用程序。您注意到没有一行XML吗？不web.xml也要归档。这个Web应用程序是100%纯Java，您不必处理配置任何管道或基础设施的问题。 出于演示目的，有一些代码可以创建一个JdbcTemplate，查询数据库，并打印批处理作业插入的人员的名称。 构建一个可执行的JAR您可以使用Gradle或Maven从命令行运行应用程序。或者，您可以构建一个包含所有必需的依赖项、类和资源的单个可执行JAR文件，并运行该文件。这使得在整个开发生命周期、跨不同环境等将服务作为应用程序进行发布、版本和部署变得非常容易。 如果使用Gradle则可以使用./gradlew bootRun.或者您可以使用以下方法构建JAR文件./gradlew build然后可以运行JAR文件： 1java -jar build/libs/gs-batch-processing-0.1.0.jar 如果您使用的是Maven则可以使用./mvnw Spring-boot：运行.或者您可以用./mvnw clean package然后可以运行JAR文件： 1java -jar target/gs-batch-processing-0.1.0.jar 上面的过程将创建一个可运行的JAR。你也可以选择构建一个经典的WAR文件相反。 该职务为每个被转换的人打印一行。作业运行后，还可以看到查询数据库的输出。 12345678910Converting (firstName: Jill, lastName: Doe) into (firstName: JILL, lastName: DOE)Converting (firstName: Joe, lastName: Doe) into (firstName: JOE, lastName: DOE)Converting (firstName: Justin, lastName: Doe) into (firstName: JUSTIN, lastName: DOE)Converting (firstName: Jane, lastName: Doe) into (firstName: JANE, lastName: DOE)Converting (firstName: John, lastName: Doe) into (firstName: JOHN, lastName: DOE)Found in the database.Found in the database.Found in the database.Found in the database.Found in the database. 摘要恭喜你！您构建了一个批处理作业，该作业从电子表格中摄取数据，并对其进行处理，并将其写入数据库。 See also The following guides may also be helpful: Building an Application with Spring Boot Accessing Data with GemFire Accessing Data with JPA Accessing Data with MongoDB Accessing data with MySQL]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穷忙族的人生]]></title>
    <url>%2Fposts%2F54997.html</url>
    <content type="text"><![CDATA[穷忙族来自英文单词“working poor”，原指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。但是随着逐渐壮大的“穷忙一族”队伍，主要界定为每周工时低于平均工时的三分之二、收入低于全体平均60%者。这个定义又逐渐发展成一种为了填补空虚生活，而不得不连续消费，之后继续投入忙碌的工作中，而在消费过后最终又重返空虚的“穷忙”。 随着经济的发展和城市化进程的加快，个体的生存压力确实在增强， 但绝对没有“紧张”到要让“穷忙族”同时兼几份职拼命赚钱的程度；盲从、攀比的心理，或许存在于部分人之中，可不会是普遍性的主流心态，至于个人欲望，在现代文明的视野下，为了物质享受不惜放弃一切的人不是没有，但毕竟还是少数。 问题的关键恐怕还是在于，现实社会存在的“结构性危机”——社会结构，原本是一个“流水不腐”的动态机构框架。社会阶层之间，有一条不断流动循环的“河流”。穷人成为富人或者富人再次变得一贫如洗，大众变成精英或者精英沦落为草根，都是很正常的事情。但现实却是，户籍、收入分配、教育等诸多领域体制性的落后甚至是不公正，逐渐导致精英“寡头化”和底层人“固化”，阶层与阶层之间的流动困难。穷人变富越来越难，草根成为精英近乎天方夜谭。 香港曾经有一档电视真人秀，叫做《穷富翁大作战》，专门邀请富人体验穷人的生活。 有一期节目的主人公是田北辰。他的父亲田元灏是香港纺织界的头面人物，人称”一代裤王”。他本科毕业于康奈尔大学电子工程专业，又去读了哈佛大学 MBA，回到香港后创办了服装品牌 G2000 和 U2，是那种很努力的”富二代”。 他崇尚自由竞争和人生奋斗，座右铭是”如果你今天对自己满意，明天就会被淘汰”，一直宣扬 “如果你有斗志，弱者也可以变成强者。” 但是，参加了这次电视节目以后，他的观点发生了180度转变，对着电视镜头公开说： “这个社会在极严厉地惩罚，那些没条件读书的人。穷人一輩子都不可能变有钱人。在強弱悬殊的情况下，只有弱者越弱，越來越慘！” 田北辰为什么改变观点，认为穷人不可能翻身呢？原来，节目组请他体验了两天清洁工的生活，薪资是每小时25港币，每天的生活费只有50港币，住在只有1.6平方米的”笼屋”，月租1350港币。 所谓”笼屋”，外面看着像衣橱，门一拉开，里面只能放下一张床，关上门四面全挨着木板墙，东西都挂在墙上。就是这种条件，房产中介还称它为”豪华笼屋”，因为还有600港币的更低档，就是在马桶上放一块木板睡人。 上班时间是早上五点，地铁头班车还没开，只能坐夜宵巴士，车费是13港币，田北辰惊呼：”每天生活费只有50港币，这怎么坐得起！” 开始工作后，好不容易熬到中午吃饭，但只有15元的预算，大部分的饭要20元，他最后只能坐在街边的楼梯上，就着白开水嚼干粮。 吃完了，还要抓紧时间躺在花坛上休息一会。 做满9个小时，就可以下班了。但是，真正的清洁工为了养家户口，还要去做夜班，一天在外近17个小时，只能睡5、6个小时。田北辰说，因为只有两天，自己才有斗志坚持下去，如果要做一个月，甚至半年，那就太绝望了！ “没有学历、技术的人，为了活下去，不是住笼屋就是要工作到半夜，对于他们，最重要事情是下一顿吃什么，怎么会有时间和精力去思考未来怎么发展？来来去去都在死胡同！” 每天忙于工作，干到累死，但还是很穷，只能租屋住，没有自己的积蓄，一旦停止工作或者生病在床，生活来源顿时就成问题。田北辰体验的这种人生，社会学家早就注意到了，起名为”穷忙族”，百度百科的定义如下。 “穷忙族是指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。最早出现于上世纪90年代的美国，指拼命工作仍然无法摆脱最低水准生活的人们。日本经济学家门仓贵史在《穷忙族》一书中，他对”穷忙族”下的定义是：每天繁忙地工作却依然不能过上富裕生活的人。” 不仅香港有”穷忙族”，内地也越来越多。举例来说，根据报道，2016年上海送外卖最多的送餐员，是一位叫做何文妹的中年女性，至少送出了12214单。即使全年无休，每天平均也要33单，从午饭时间一直送到深夜，一刻不停。电瓶车的电瓶，一天要准备6组。车上插着两个手机，一个导航，一个接单。 这种强度的劳动，每年能有多少收入呢？每单的送餐费是8元，这就是说，何文妹一年的送餐总收入在10万元左右。扣除电瓶费、车辆维护费、通信费等等以后，净收入大概还能剩下8万多元。这是”送餐王”的收入水平，大部分送餐员的收入，应该远不如她，可能只有一半左右。 上海的底层劳动者，收入基本就是这种水平。他们还要用这些钱支付房租。每天下班回到家，累得就想睡觉，睁开眼就要去上班，日复一日，人生的出路在哪里？ 将来的”穷忙族”，不仅是低技能的底层劳动者，还将包括很多受过高等教育、写字楼工作的白领。年轻人如果没有家庭支持，想要靠自己的努力出人头地，会变得越来越难。因为单靠工资收入，已经不足以积累财富了。 有一项统计说： “1993年属于低等收入者的城里人，到了1995年有43%都能向上爬。而相比之下，2011年属于低等收入者的城里人，到了2013年只有20%摘掉最底层的帽子。一个不恰当的比喻，如果上世纪90年代算是城市穷人的黄金时代的话，那今天这种好日子已经结束了。” “一方面，城里穷人越来越难走出贫困；另一方面，城里富人的位置也坐得越来越稳。1993-1995年，城里的高等收入者有64%的概率能一直当富人。而到了2011-2013年，高等收入者竟然有84%的概率能保证自己不被从富人列表中除名。” 上面的数字就是说，如果你是穷人，80%的概率以后你还是穷人；如果你是富人，84%的概率是以后你还是富人。一个台湾人感叹说： “那种奴隶化的生活（长时间工作，却仅能勉强满足温饱）才是历史的常态。过去三十年社会阶层的大幅流动，是历史的不正常，现在开始回归常态。99%的我们，都面临着这种大趋势的吞噬：你的工资不变，但房价和物价却是越来越高，于是你必需花更多时间来挣钱，甚至一天做二份工，最后成为没有自己时间的奴隶。” 总的来看，下一代青年不太可能有上一代那么多机会。经济增长率已经开始放缓，还将继续放缓，人口增长高峰已经过去，老龄化越来越严重，老人的消费远不及年轻人。矿业、制造业、零售业、证券业……除了高科技，几乎所有行业都不会有以前那么高的增长率。上一代人赶上了中国经济起飞，还拥有依靠房地产翻身的机会，但是下一代人不会再有这样的机会。你现在买入一套房子，十年后价值翻上十倍，完全是零可能。 越来越多的人将会发现，即使从小就努力学习，从很好的学校毕业，后来努力工作，但迎接他们的将是”长久的低薪、难升迁的职场、高昂的物价、买不起的房子……”。尽管你很努力，待人友善，有公德心，但就是挣不到钱，只能在社会的底层挣扎。 2015年，社会工作者藤田孝典调查日本的老人问题。 他发现，很多老人年轻时都拿过中产阶级的薪水（400万日元），但是现在已经沦落到社会的底层，过着非常困苦的生活。”七老八十还要在大热天当廉价劳工，因经济拮据而妻离子散，唯有独居烂屋，孤零零度过晚年。” 藤田孝典将这些老人称为”下流老人”（底层老人）。他称，日本的下流老人以后可能会达到1亿人。要知道，日本现在的总人口也只有1.27亿。 下流老人有三大特征。（1）收入极低，即使政府提供补助费，也难以维持健康饮食，以及一般家庭应有的生活；（2）存款不足，老人必须提心吊胆地过活，一旦碰到突发事故或慢性病，日常已经捉襟见肘的生活，就会面临崩溃危险；（3）老无所依，子女连自己都养不起，更遑论赡养老人。日本不少老人因家庭破碎而长期独居，平日缺乏与亲朋邻里的交流，关系疏离，一旦发生意外无人照应。在晚年失去可以依靠的人，是下流老人最悲苦的特征。 下流老人的根源就是，钱花光了，人还没死。日本媒体还发明了一个词”老后破产”，这就是长寿的恶梦。 现代科技如此发达，人的寿命越来越长，可是工作又积累不了财富，于是，”清贫青年，流沙中年，下流老人”就成了大多数人必然的命运归宿。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML脚本学习笔记]]></title>
    <url>%2Fposts%2F2295.html</url>
    <content type="text"><![CDATA[YAML是“另一种标记语言”的外语缩写；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。诞生YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。命名YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种置标语言），功能YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态、。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字符和分行来分隔资料，使的他特别适合用grep、Python、Perl、Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。 YAML预研文档YAML概要YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写，早先YAML的意思其实是：”Yet Another Markup Language”（另外一种置标语言），但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名，YAML的官方定义很简单，即一种人性化的数据格式定义语言，其主要功能用途类似于XML或JSON，YAML使用空白字符和分行来分隔数据，且巧妙避开各种封闭符号，如：引号、括号等，以避免这些符号在复杂层次结构中变得难以辨认。YAML的语法与高阶语言类似，可以很简单地表述序列（java中的list）、杂凑表（java中的map）、标量（java中的基本类型等）数据结构，它重点强调可阅读性。 YAML vs XML与YAML相似的数据格式定义语言是XML，YAML比XML优越性表现在 优势: YAML的可读性好 YAML和脚本语言的交互性好 YAML使用实现语言的数据类型 YAML有一个一致的信息模型 YAML易于实现 上面5条是XML不足的地方，同时，YAML也具有XML的下列优点： YAML可以基于流来处理 YAML表达能力强，扩展性好 YAML类似于XML的数据描述语言，语法比XML简单很多，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。 YAML vs JSONJSON的语法其实是YAML的子集，大部分的JSON文件都可以被YAML的剖析器剖析。虽然大部分的数据分层形式也可以使用类似JSON的格式，不过YAML并不建议这样使用，除非这样编写能让文件可读性增加，更重要的是，YAML的许多扩展在JSON是找不到的，如：进阶资料形态、关系锚点、字串不需要引号、映射资料形态会储存键值的顺序等。 YAML用途脚本语言由于实现简单，解析成本很低，YAML特别适合在脚本语言中使用。列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，OCaml，JavaScript，除了Java，其他都是脚本语言。 序列化YAML比较适合做序列化。因为它是宿主语言数据类型直转的。 配置文件YAML做配置文件也不错。写YAML要比写XML快得多(无需关注标签或引号)，并且比ini文档功能更强。 调试由于其很强的阅读性，用于调试过程中dump出信息供分析也是一种比较方便的做法。 YAML缺陷与不足YAML没有自己的数据类型的定义，而是使用实现语言的数据类型。一个YAML文件，在不同语言中解析后得到的数据类型可能会不同，由于其兼容性问题，不同语言间的数据流转不建议使用YAML。 YAML语法与范例 YAML使用可打印的Unicode字符，可使用UTF-8或UTF-16 使用空白字符（不能使用Tab）分层，同层元素左侧对齐 单行注解由井字号（ # ）开始，可以出现在行中任何位置 每个清单成员以单行表示，并用短杠+空白（- ）起始 每个杂凑表的成员用冒号+空白（: ）分开键和值 杂凑表的键值可以用问号 (?)起始，表示多个词汇组成的键值 字串一般不使用引号，但必要的时候可以用引号框住 使用双引号表示字串时，可用倒斜线（\）进行特殊字符转义 区块的字串用缩排和修饰词（非必要）来和其他资料分隔，有新行保留（使用符号|）或新行折叠（使用符号&gt;）两种方式 在单一档案中，可用连续三个连字号（—）区分多个档案 可选择性的连续三个点号（…）用来表示档案结尾(在流式传输时非常有用，不需要关闭流即可知道到达结尾处) 重复的内容可使从参考标记星号 (*)复制到锚点标记（&amp;） 指定格式可以使用两个惊叹号 ( !! )，后面接上名称 123456789101112131415161718192021222324252627receipt: Oz-Ware Purchase Invoicedate: 2007-08-06customer: given: Dorothy family: Galeitems: - part_no: A4786 descrip: Water Bucket (Filled) price: 1.47 quantity: 4 - part_no: E1628 descrip: High Heeled &quot;Ruby&quot; Slippers price: 100.27 quantity: 1bill-to: &amp;id001 street: | 123 Tornado Alley Suite 16 city: East Westville state: KSship-to: *id001 specialDelivery: &gt; Follow the Yellow Brick Road to the Emerald City. Pay no attention to the man behind the curtain.... 这个文件的的顶层由七个键值组成：其中一个键值”items”，是个两个元素构成的清单，清单中的两个元素同时也是包含了四个键值的杂凑表。文件中重复的部分处理方式：使用锚点（&amp;）和参考（*）标签将”bill-to”杂凑表的内容复制到”ship-to”杂凑表。也可以在文件中加入选择性的空行，以增加可读性。 YAML的JAVA实现YAML已经有了多种语言不少实现，详见YAML官网。一般YAML文件扩展名为.yaml，比如John.yaml，其内容为：12345678910name: John Smithage: 37children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12spouse: name: Jane Smith age: 25 由于yaml的超强可读性，我们了解到：John今年37岁，两个孩子Jimmy 和Jenny活泼可爱，妻子Jane年轻美貌，而且年仅25岁，一个幸福的四口之家。对John.yaml进行java描述，抽象出一个Person类，如下：1234567public class Person &#123; private String name; private int age; private Person sponse; private Person[] children; // setXXX, getXXX方法略.&#125; 现在我们使用java装配一个Jone：12345678910111213Person john = new Person();john.setAge(37);john.setName(&quot;John Smith&quot;);Person sponse = new Person();sponse.setName(&quot;Jane Smith&quot;);sponse.setAge(25);john.setSponse(sponse);Person[] children = &#123;new Person(), new Person()&#125;;children[0].setName(&quot;Jimmy Smith&quot;);children[0].setAge(15);children[1].setName(&quot;Jenny Smith&quot;);children[1].setAge(12);john.setChildren(children); 使用SnakeYAML实现项目主页：http://code.google.com/p/snakeyaml/使用手册：https://code.google.com/p/snakeyaml/wiki/DocumentationSnakeYAML是一个标准的YAML的java实现，它有以下特点： 完全支持YAML 1.1，可以跑通规范中的所有示例 支持YAML的所有类型 支持UTF-8/UTF-16的输入和输出 提供了本地java对象的序列化和反序列化的高层API 提供相对合理的错误提示信息 使用SnakeYAML将john dump出来，如果有引用相同对象，则dump出到yaml文件会自动使用&amp;和*进行锚点和引用：123456DumperOptions options = new DumperOptions();options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);Yaml yaml = new Yaml(options);//Yaml yaml = new Yaml();String dump = yaml.dump(john);System.out.println(dump); 内容如下：1234567891011121314151617!!Personage: 37children:- age: 15 children: null name: Jimmy Smith sponse: null- age: 12 children: null name: Jenny Smith sponse: nullname: John Smithsponse: age: 25 children: null name: Jane Smith sponse: null 现在用SnakeYAML把yaml load进来，如果yaml文件中使用了&amp;和*，则会自动对load出来的对象赋相同的值：1234Yaml yaml = new Yaml();Object load = yaml.load(new FileInputStream(new File(&quot;jhon.yaml&quot;)));System.out.println(load.getClass());System.out.println(yaml.dump(load)); 或123Yaml yaml = new Yaml(options);Person person = yaml.loadAs(inputStream, Person.class);System.out.println(person.getSponse().getChildren().length); 如果一个yaml文件中有多个文档，由—分割，解析如下：123456Yaml yaml = new Yaml(); int counter = 0; for (Object data : yaml.loadAll(input)) &#123; System.out.println(data); counter++; &#125; 保存一个Map对象：1234567891011Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); data.put(&quot;name&quot;, &quot;Silenthand Olleander&quot;); data.put(&quot;race&quot;, &quot;Human&quot;); data.put(&quot;traits&quot;, new String[] &#123; &quot;ONE_HAND&quot;, &quot;ONE_EYE&quot; &#125;); Yaml yaml = new Yaml(); String output = yaml.dump(data); System.out.println(output); // or StringWriter writer = new StringWriter(); yaml.dump(data, writer); System.out.println(writer.toString()); 将多个文档dump出到同一个yaml文件中去：12345678910List&lt;Integer&gt; docs = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt; 4; i++) &#123; docs.add(i); &#125; DumperOptions options = new DumperOptions(); //options.setCanonical(true); options.explicitStart(true); Yaml yaml = new Yaml(options); System.out.println(yaml.dump(docs)); System.out.println(yaml.dumpAll(docs.iterator())); 12345--- [1, 2, 3]--- 1--- 2--- 3 YAML与java类型对照表：YAML | JAVA——– | ——-!null |null!!bool |Boolean!!int |Integer, Long, BigInteger!!float |Double!!binary |String!!timestamp |java.util.Date, java.sql.Date, java.sql.Timestamp!!omap, !!pairs |List of Object[]!!set |Set!!str |String!!seq |List!!map |Map 集合的默认实现是： List: ArrayList Map: LinkedHashMap 使用JYaml实现JYaml（最新版本是2007年的，可以考虑放弃了），使用JYaml把Jone “Dump” 出来：12File dumpfile = new File(&quot;John_dump.yaml&quot;);Yaml.dump(john, dumpfile); 下面我们看看John_dump.yaml是什么样子：12345678910111213--- !yaml.test.internal.Personage: 37children: !yaml.test.internal.Person[] - !yaml.test.internal.Person age: 15 name: Jimmy Smith - !yaml.test.internal.Person age: 12 name: Jenny Smithname: John Smithsponse: !yaml.test.internal.Person age: 25 name: Jane Smith 其中!yaml.test.internal.Person是一些类型的信息。load的时候需要用。现在用JYaml把Jone_dump.yaml load进来：1Person john2 = (Person) Yaml.loadType(dumpfile, Person.class); 还可以用下面的代码dump出没有类型信息的John.yaml：1Yaml.dump(john,dumpfile, true); 我们再来看看JYaml对流处理的支持，为简便起见，我们只是把同一个john写10次：1234567 YamlEncoder enc = new YamlEncoder(new FileOutputStream(dumpfile)); for(int i=0; i&lt;10; i++)&#123; john.setAge(37+i); enc.writeObject(john); enc.flush(); &#125;enc.close(); 下面再把这十个对象一个一个读出来（注意while循环退出的方式）：1234567891011YamlDecoder dec = new YamlDecoder(new FileInputStream(dumpfile));int age = 37;while(true)&#123; try&#123; john = (Person) dec.readObject(); assertEquals(age, john.getAge()); age++; &#125;catch(EOFException eofe)&#123; break; &#125;&#125; 格式多行缩进数据结构可以用类似大纲的缩排方式呈现，结构通过缩进来表示，连续的项目通过减号“-”来表示，map结构里面的key/value对用冒号“:”来分隔。样例如下： 123456789101112131415house: family: name: Doe parents: - John - Jane children: - Paul - Mark - Simone address: number: 34 street: Main Street city: Nowheretown zipcode: 12345 注意：字串不一定要用双引号标识； 在缩排中空白字符的数目并不是非常重要，只要相同阶层的元素左侧对齐就可以了（不过不能使用TAB字符）； 允许在文件中加入选择性的空行，以增加可读性； 在一个档案中，可同时包含多个文件，并用“——”分隔； 选择性的符号“…”可以用来表示档案结尾（在利用串流的通讯中，这非常有用，可以在不关闭串流的情况下，发送结束讯号）。 单行缩写YAML也有用来描述好几行相同结构的数据的缩写语法，数组用’[]’包括起来，hash用’{}’来包括。因此，上面的这个YAML能够缩写成这样: 123house: family: &#123; name: Doe, parents: [John, Jane], children: [Paul, Mark, Simone] &#125; address: &#123; number: 34, street: Main Street, city: Nowheretown, zipcode: 12345 &#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>yml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWFUpload文件上传详解]]></title>
    <url>%2Fposts%2F15202.html</url>
    <content type="text"><![CDATA[SWFUpload是一个客户端文件上传工具，最初由Vinterwebb.se开发，它通过整合Flash与JavaScript技术为WEB开发者提供了一个具有丰富功能继而超越传统input type=”file”标签的文件上传模式。官方站点：http://www.swfupload.org/DEMO地址：http://demo.swfupload.org/ 主要特点 可以同时上传多个文件； 类似AJAX的无刷新上传； 可以显示上传进度； 良好的浏览器兼容性； 兼容其他JavaScript库 (例如：jQuery, Prototype等)； 支持Flash 8和Flash 9； SWFUpload不同于其他基于Flash构建的上传工具，它有着优雅的代码设计，开发者可以利用XHTML、CSS和JavaScript来随心所欲的定制它在浏览器下的外观；它还提供了一组简明的JavaScript事件，借助它们开发者可以方便的在文件上传过程中更新页面内容来营造各种动态效果。 在使用SWFUpload之前，请确认你具备一定的JavaScript和DOM知识。在实际开发中，大部分的错误都是由于错误的设置和低劣的Event Handlers处理程序所造成的。 SWFUpload的文件上传流程： 引入相应的js文件 实例化SWFUpload对象，传入一个配置参数对象进行各方面的配置。 点击SWFUpload提供的Flash按钮，弹出文件选取窗口选择要上传的文件； 文件选取完成后符合规定的文件会被添加到上传的队列里； 调用startUpload方法让队列里文件开始上传； 文件上传过程中会触发相应的事件，开发者利用这些事件来更新ui、处理错误、发出提示等等； SWFUpload包括三部分的内容：SWFUpload.js、swfupload.swf、初始化配置参数及各种事件处理函数。 所以首先在页面引入SWFUpload.js 在页面中实例化一个SWFUpload对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var swfu; window.onload = function () &#123; var settings_object = &#123;//定义参数配置对象 upload_url : "http://www.swfupload.org/upload.php", flash_url : "http://www.swfupload.org/swfupload.swf", file_post_name : "Filedata", post_params : &#123; "post_param_name_1" : "post_param_value_1", "post_param_name_2" : "post_param_value_2", "post_param_name_n" : "post_param_value_n" &#125;, use_query_string : false, requeue_on_error : false, http_success : [201, 202], assume_success_timeout : 0, file_types : "*.jpg;*.gif", file_types_description: "Web Image Files", file_size_limit : "1024", file_upload_limit : 10, file_queue_limit : 2, debug : false, prevent_swf_caching : false, preserve_relative_urls : false, button_placeholder_id : "element_id", button_image_url : "http://www.swfupload.org/button_sprite.png", button_width : 61, button_height : 22, button_text : "&lt;b&gt;Click&lt;/b&gt; &lt;span class="redText"&gt;here&lt;/span&gt;", button_text_style : ".redText &#123; color: #FF0000; &#125;", button_text_left_padding : 3, button_text_top_padding : 2, button_action : SWFUpload.BUTTON_ACTION.SELECT_FILES, button_disabled : false, button_cursor : SWFUpload.CURSOR.HAND, button_window_mode : SWFUpload.WINDOW_MODE.TRANSPARENT, swfupload_loaded_handler : swfupload_loaded_function, file_dialog_start_handler : file_dialog_start_function, file_queued_handler : file_queued_function, file_queue_error_handler : file_queue_error_function, file_dialog_complete_handler : file_dialog_complete_function, upload_start_handler : upload_start_function, upload_progress_handler : upload_progress_function, upload_error_handler : upload_error_function, upload_success_handler : upload_success_function, upload_complete_handler : upload_complete_function, debug_handler : debug_function, &#125;; swfu = new SWFUpload(settings_object);//实例化一个SWFUpload，传入参数配置对象 &#125;; /*定义各种事件监听函数*/ function swfupload_loaded_function()&#123;&#125; function file_dialog_start_function()&#123;&#125; //...等等 ​ 我们看到要实现一个SWFUpload上传功能很简单，就是实例化一个SWFUpload对象。但繁琐的地方就在于实例化实要用到的参数配置对象，以及各种事件的发生时机以和提供的参数。所以重点来了。下面几个表格对开发中要用到的东西列举了出来，虽然已经蛮多了，但并不是SWFUpload的全部，我列出来的只是常用的。要查看完整的文档，请到SWFUpload官网上查询。 配置参数对象中的常用属性及说明 属性 类型 默认值 描述 upload_url String 处理上传文件的服务器端页面的url地址，可以是绝对地址，也可以是相对地址，当为相对地址时相对的是当前代码所在的文档地址 preserve_relative_urls Boolean false 如果为false则SWFUpload会把swfupload.swf用到的相对地址转换为绝对地址，以达到更好的兼容性 file_post_name String Filedata 相当于用普通的文件域上传文件时的name属性，服务器端接收页面通过该名称来获取上传的文件 post_params Object(直接量) 一个对象直接量，里面的键/值对会随着每一个文件一起上传，文件上传要附加一些信息时很有用 use_query_string Boolean false 为false时,post_params属性定义的参数会以post方式上传；为true时，则会以get方式上传（即参数会以查询字符串的形式附加到url后面） file_types String 该属性指定了允许上传的文件类型，当有多个类型时使用分号隔开，比如：.jpg;.png ,允许所有类型时请使用 . file_types_description String 指定在文件选取窗口中显示的文件类型描述，起一个提示和说明的作用吧 file_size_limit String 指定要上传的文件的最大体积，可以带单位，合法的单位有:B、KB、MB、GB，如果省略了单位，则默认为KB。该属性为0时，表示不限制文件的大小。 file_upload_limit Number 指定最多能上传多少个文件，当上传成功的文件数量达到了这个最大值后，就不能再上传文件了，也不能往上传队列里添加文件了。把该属性设为0时表示不限制文件的上传数量。 file_queue_limit Number 指定文件上传队列里最多能同时存放多少个文件。当超过了这个数目后只有当队列里有文件上传成功、上传出错或被取消上传后，等同数量的其他文件才可以被添加进来。当file_upload_limit的数值或者剩余的能上传的文件数量小于file_queue_limit时，则取那个更小的值 flash_url String swfupload.swf文件的绝对或相对地址，相对地址是指相对于当前的页面地址。实例化swfupload后，就不能再改变该属性的值了。 prevent_swf_caching Boolean 为true时会加一个随机数在swfupload.swf地址的后面，以阻止flash影片被缓存，这是为了防止某些版本的IE浏览器在读取缓存的falsh影片时出现的bug button_placeholder_id String 指定一个dom元素的id,该dom元素在swfupload实例化后会被Flash按钮代替，这个dom元素相当于一个占位符 button_placeholder DOMElement 指定一个dom元素,该dom元素在swfupload实例化后会被Flash按钮代替，这个dom元素相当于一个占位符。当button_placeholder_id与button_placeholder都存在时，以button_placeholder_id为优先 button_image_url String 指定Flash按钮的背景图片，相对地址或绝对地址都可以。该地址会受到preserve_relative_urls属性的影响，遵从与upload_url一样的规则。该背景图片必须是一个sprite图片,从上到下包含了Flash按钮的正常、鼠标悬停、按下、禁用这四种状态。因此该图片的高度应该是Flash按钮高度的四倍 button_width Number 指定Flash按钮的宽度 button_height Number 指定Flash按钮的高度，应该为button_image_url所指定的按钮背景图片高度的1/4 button_text String 指定Flash按钮上的文字，也可以是html代码 button_text_style String Flash按钮上的文字的样式，使用方法见示例 button_text_top_padding Number 指定Flash按钮顶部的内边距，可使用负值 button_text_left_padding Number 指定Flash按钮左边的内边距，可使用负值 button_disabled Boolean false 为true时Flash按钮将变为禁用状态，点击也不会触发任何行为 button_cursor 指定鼠标悬停在Flash按钮上时的光标样式，可用值为SWFUpload.CURSOR里定义的常量 button_window_mode 指定Flash按钮的WMODE属性，可用值为SWFUpload.WINDOW_MODE里定义的常量 file_dialog_start_handler Function fileDialogStart事件侦听函数 file_queued_handler Function fileQueued事件侦听函数 file_queue_error_handler Function fileQueueError事件侦听函数 file_dialog_complete_handler Function fileDialogComplete事件侦听函数 upload_start_handler Function uploadStart事件侦听函数 upload_progress_handler Function uploadProgress事件侦听函数 upload_error_handler Function uploadError事件侦听函数 upload_success_handler Function uploadSuccess事件侦听函数 upload_complete_handler Function uploadComplete事件侦听函数 各种事件说明要实现与用户的交互，靠的就是在这些事件上做文章了 fileDialogStart ( ) 在文件选取窗口将要弹出时触发 fileQueued ( file object ) 当一个文件被添加到上传队列时会触发此事件，提供的唯一参数为包含该文件信息的file object对象 fileQueueError ( file object, error code, message ) 当文件添加到上传队列失败时触发此事件，失败的原因可能是文件大小超过了你允许的数值、文件是空的或者文件队列已经满员了等。该事件提供了三个参数。第一个参数是当前出现问题的文件对象，第二个参数是具体的错误代码，可以参照SWFUpload.QUEUE_ERROR中定义的常量 fileDialogComplete ( number of files selected, number of files queued, total number of files in the queued ) 当文件选取完毕且选取的文件经过处理后（指添加到上传队列），会立即触发该事件。可以在该事件中调用this.startUpload()方法来实现文件的自动上传参数number of files selected指本次在文件选取框里选取的文件数量参数number of files queued指本次被添加到上传队列的文件数量参数total number of files in the queued指当前上传队列里共有多少个文件（包括了本次添加进去的文件） uploadStart ( file object ) 当文件即将上传时会触发该事件,该事件给了你在文件上传前的最后一次机会来验证文件信息、增加要随之上传的附加信息或做其他工作。可以通过返回false来取消本次文件的上传参数file object为当前要上传的文件的信息对象 uploadProgress ( file object, bytes complete, total bytes ) 该事件会在文件的上传过程中反复触发，可以利用该事件来实现上传进度条参数file object为文件信息对象参数bytes complete为当前已上传的字节数参数total bytes为文件总的字节数 uploadError ( file object, error code, message ) 文件上传被中断或是文件没有成功上传时会触发该事件。停止、取消文件上传或是在uploadStart事件中返回false都会引发这个事件，但是如果某个文件被取消了但仍然还在队列中则不会触发该事件参数file object为文件信息对象参数error code为错误代码，具体的可参照SWFUpload.UPLOAD_ERROR中定义的常量 uploadSuccess ( file object, server data, received response ) 当一个文件上传成功后会触发该事件参数file object为文件信息对象参数server data为服务器端输出的数据 uploadComplete( file object ) 当一次文件上传的流程完成时（不管是成功的还是不成功的）会触发该事件，该事件表明本次上传已经完成，上传队列里的下一个文件可以开始上传了。该事件发生后队列中下一个文件的上传将会开始 swfupload实例的方法方法中大多数是动态改变参数配置对象的方法 destroy ( ) 当不需要再使用SWFUpload了的时候,可以使用该方法来销毁它的实例和dom元素 startUpload( file_id ) 开始上传队列中指定的文件参数file_id代表要上传的文件的id，如果未填写这个参数，则会上传队列中第一个文件 cancelUpload ( file_id, trigger_error_event ) 取消文件的上传参数file_id为要取消的文件的id,如果该参数为undefined或者未填写，则会取消队列里的第一个文件参数trigger_error_event接受一个布尔值，当为false时取消文件不会触发uploadError事件，默认为true stopUpload ( ) 终止当前正在上传的文件，会触发uploadError事件。如果当前没有文件在上传，则该方法什么都不会做 getStats ( ) 获取队列的stats object setStats ( stats_object ) 修改队列的stats_object，传入修改过的stats_object作为参数 getFile ( file_id, index ) 根据文件id或文件索引来获取一个File Object,当使用文件id时只能获得队列里的文件，当使用文件索引时所有文件（包括队列内和队列外）都可获得 addPostParam ( name, value) 往配置对象中post_params指定的附加信息对象中增加键/值对 removePostParam ( name) 移除置配置对象中的post_params包含的某一个键/值对，参数name为要移除的值的键名 addFileParam ( file_id, name, value) 为某个特定文件增加随之一起上传的附加信息。注意，只有在该指定的文件上传时，附加的信息才会一起上传。而配置对象中post_param设置的附加信息在任一文件上传时都会与之一起发送。参数file_id为要指定的文件id,参数name和value分别为附加信息的名称和值 removeFileParam ( file_id, name) 移除通过addFileParam方法增加的附加信息，两个参数相信就不用我多讲了吧 setUploadURL ( url) 动态设置配置对象中upload_url的值 setPostParams ( param_object) 动态设置配置对象中post_params属性的值，新的值会覆盖旧的值。参数param_object必须为一个对象直接量，且里面的属性和值都只能为字符串 setFileTypes ( types, description) 动态设置配置对象中file_types 和 file_types_description属性的值。两个参数都不能省略 setFileSizeLimit ( file_size_limit) 动态设置配置对象中file_size_limit属性的值 setFileUploadLimit ( file_upload_limit) 动态设置配置对象中file_upload_limit属性的值 setFileQueueLimit ( file_queue_limit) 动态设置配置对象中file_queue_limit属性的值 setFilePostName ( file_post_name) 动态设置配置对象中file_post_name属性的值 setUseQueryString ( use_query_string) 动态设置配置对象中use_query_string属性的值 setButtonImageURL ( url) 动态设置配置对象中button_image_url属性的值 setButtonDimensions ( width, height) 动态设置Flash按钮的宽度和高度，两个参数分别为宽度和高度的值，类型为数字，且不能带单位 setButtonText ( text) 动态设置配置对象中button_text属性的值 setButtonTextStyle ( css_style_text) 动态设置配置对象中button_text_style属性的值 setButtonTextPadding ( left, top ) 动态设置Flash按钮的左边内边距和顶部内边距 setButtonDisabled ( isDisabled ) 动态对Flash按钮进行禁用和不禁用的操作，参数为一个布尔值 setButtonCursor ( buttonCursor ) 动态设置配置对象中button_cursor的值 文件信息对象 File Object在事件监听函数中，经常要用到文件信息对象来获取文件的信息以供下一步的操作 属性 类型 描述 id String SWFUpload定义的文件id,用来控制文件的上传 index Number 文件的索引，用在getFile(i)方法中 name String 文件的原始名称，不包括路径 type String 文件类型 creationdate Date 文件的创建日期 modificationdate Date 文件的最后修改日期 filestatus Number 当前文件的状态，详细的请参照SWFUpload.FILE_STATUS中定义的常量 队列状态对象 Stats Object用来获取当前队列的状况 属性 类型 描述 in_progress Number 得到的值为1或0，表明当前队列是否有文件正在上传中 files_queued Number 目前上传队列中的文件数量 successful_uploads Number 已成功上传(指触发了uploadSuccess事件)的文件数量 upload_errors Number 上传失败的文件数量(包括被取消上传的文件) upload_cancelled Number 被取消上传的文件数量 queue_errors Number 触发了fileQueueError事件的文件数量 一些常量定义的一些常量，便于理解 常量名 描述 SWFUpload.instances 该常量是一个对象，代表一个页面上所有的SWFUpload实例的引用的集合，用SWFUpload实例的movieName属性进行索引 SWFUpload.movieCount 页面上存在的SWFUpload实例的数量 SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED 用户选取的文件超过了允许的数量 SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT 文件的体积超过了允许的大小 SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE 文件是空的 SWFUpload.QUEUE_ERROR.INVALID_FILETYPE 不允许的文件类型 SWFUpload.UPLOAD_ERROR.HTTP_ERROR 服务器返回的状态码不是200 SWFUpload.UPLOAD_ERROR.MISSING_UPLOAD_URL 没有设置 upload_url SWFUpload.UPLOAD_ERROR.IO_ERROR 读取或传输文件时发生错误 SWFUpload.UPLOAD_ERROR.SECURITY_ERROR 上传受到了安全方面的限制 SWFUpload.UPLOAD_ERROR.UPLOAD_LIMIT_EXCEEDED 上传的文件数量超过了允许的最大值 SWFUpload.UPLOAD_ERROR.UPLOAD_FAILED 上传出现错误 SWFUpload.UPLOAD_ERROR.SPECIFIED_FILE_ID_NOT_FOUND 给startUpload()方法传入的文件id不存在 SWFUpload.UPLOAD_ERROR.FILE_VALIDATION_FAILED uploadStart()方法中返回了false SWFUpload.UPLOAD_ERROR.FILE_CANCELLED 上传被取消了 SWFUpload.UPLOAD_ERROR.UPLOAD_STOPPED 上传被终止了 SWFUpload.FILE_STATUS.QUEUED 文件正在队列中等待上传 SWFUpload.FILE_STATUS.IN_PROGRESS 文件正在上传 SWFUpload.FILE_STATUS.ERROR 文件在添加到队列或是上传的时候出现了错误 SWFUpload.FILE_STATUS.COMPLETE 文件已上传成功 SWFUpload.FILE_STATUS. 文件被取消上传 SWFUpload.CURSOR.ARROW 鼠标以箭头显示 SWFUpload.CURSOR.HAND 鼠标以手形显示 SWFUpload.WINDOW_MODE.WINDOW Flash按钮会显示在页面的所有dom元素上面 SWFUpload.WINDOW_MODE.OPAQUE 允许其他dom元素覆盖住Flash按钮 SWFUpload.WINDOW_MODE.TRANSPARENT 允许Flash按钮透明显示 struts2+swfUpload简单例子index.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;link href="&lt;%=basePath%&gt;css/default.css" rel="stylesheet" type="text/css" /&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/swfupload.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/swfupload.queue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/fileprogress.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/handlers.js"&gt;&lt;/script&gt; &lt;!-- 初始化swfupload 对象--&gt; &lt;script type="text/javascript"&gt; var upload1; window.onload = function() &#123; upload1 = new SWFUpload(&#123; //提交路径 upload_url: "upload.action", //向后台传递额外的参数 post_params: &#123;"name" : "kaobian"&#125;, //上传文件的名称 file_post_name: "file", // 下面自己按照字面意思理解 file_size_limit : "102400", // 100MB file_types : "*.*", file_types_description : "All Files", file_upload_limit : "10", file_queue_limit : "0", // 事件处理 file_dialog_start_handler : fileDialogStart, file_queued_handler : fileQueued, file_queue_error_handler : fileQueueError, file_dialog_complete_handler : fileDialogComplete, upload_start_handler : uploadStart, upload_progress_handler : uploadProgress, upload_error_handler : uploadError, upload_success_handler : uploadSuccess, upload_complete_handler : uploadComplete, // 按钮的处理 button_image_url : "images/XPButtonUploadText_61x22.png", button_placeholder_id : "spanButtonPlaceholder1", button_width: 61, button_height: 22, // Flash Settings flash_url : "js/swfupload.swf", custom_settings : &#123; progressTarget : "fsUploadProgress1", cancelButtonId : "btnCancel1" &#125;, // Debug Settings debug: false &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;form action="upload.action" method="post" name="thisform" enctype="multipart/form-data"&gt; &lt;table&gt; &lt;tr valign="top"&gt; &lt;td&gt; &lt;div&gt; &lt;div style="padding-left: 5px;"&gt; &lt;span id="spanButtonPlaceholder1"&gt;&lt;/span&gt; &lt;!--&lt;input type="button" value="上传" onclick="upload1.addPostParam('idname',encodeURI(document.getElementById('myFileName').value));upload1.startUpload();"/&gt; --&gt;&lt;input id="btnCancel1" type="button" value="Cancel Uploads" onclick="cancelQueue(upload1);" disabled="disabled" style="margin-left: 2px; height: 22px; font-size: 8pt;" /&gt; &lt;br /&gt; &lt;/div&gt; &lt;div class="fieldset flash" id="fsUploadProgress1"&gt; &lt;span class="legend"&gt;文件上传&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Upload.action12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.action; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import org.apache.struts2.ServletActionContext; import com.opensymphony.xwork2.ActionSupport; public class FileUploadAction extends ActionSupport &#123; private File file; private String fileFileName; private String fileContentType; private String savePath; public String execute() throws Exception &#123; InputStream is = new FileInputStream(file); String root = getSavePath(); //String tempName = System.currentTimeMillis()+this.getFileFileName().substring(this.getFileFileName().indexOf(".")); File deskFile = new File(root, this.getFileFileName()); OutputStream os = new FileOutputStream(deskFile); byte[] bytefer = new byte[1024]; int length = 0; while ((length = is.read(bytefer)) != -1) &#123; os.write(bytefer, 0, length); &#125; os.close(); is.close(); return "success"; &#125; public String getSavePath() &#123; return ServletActionContext.getServletContext().getRealPath(savePath); &#125; public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; public File getFile() &#123; return file; &#125; public void setFile(File file) &#123; this.file = file; &#125; public String getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; Web.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; Struts.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt; &lt;struts&gt; &lt;!-- 配置struts2.1.8 上传是文件的最大限制为100M --&gt; &lt;constant name="struts.multipart.maxSize" value="104857600" /&gt; &lt;!-- 设置struts2 上传文件时 保存的临时目录 --&gt; &lt;constant name="struts.multipart.saveDir" value="C:\temp"&gt;&lt;/constant&gt; &lt;package name="struts2" extends="struts-default"&gt; &lt;action name="upload" class="com.action.FileUploadAction"&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success"&gt;/index.jsp&lt;/result&gt; &lt;result name="input"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; ​ SWFUpload的上传过程中各个步骤的显示方式要改变；我们需要往服务器传递参数；需要从服务器返回参数；这些问题上面的例子都没有解决。 看下面这个图片，这是我在项目中的SWFUpload上传附件的效果（其实仿的是126邮箱做的）。 上传完成。（上传成功的附件不消失，上传发生错误文件消失。） 删除：删除上传完成的文件（删除后文件逐渐消失）。 SWFUpload如何改upload控件的样式修改上传flash按钮样式SWFUpload Demo文件中提供了一个XPButtonUploadText_61x22.png 图片文件 重新制作一个类似的图片文件替换它。 如果你做的这个图片文件的长款与原图不同，不要忘记修改 12345/ 按钮的处理 button_image_url : "images/XPButtonUploadText_61x22.png", button_placeholder_id : "spanButtonPlaceholder1", button_width: 61, button_height: 22, Java代码 修改上传队列附件样式这个东西的构建是通过fileprogress.js文件和defaut.css来完成的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function FileProgress(file, targetID) &#123; this.fileProgressID = file.id; this.opacity = 100; this.height = 0; this.fileProgressWrapper = document.getElementById(this.fileProgressID); if (!this.fileProgressWrapper) &#123; this.fileProgressWrapper = document.createElement("div"); this.fileProgressWrapper.className = "progressWrapper"; this.fileProgressWrapper.id = this.fileProgressID; this.fileProgressElement = document.createElement("div"); this.fileProgressElement.className = "progressContainer"; var progressCancel = document.createElement("a"); progressCancel.className = "progressCancel"; progressCancel.href = "#"; progressCancel.style.visibility = "hidden"; progressCancel.appendChild(document.createTextNode(" ")); var progressText = document.createElement("div"); progressText.className = "progressName"; progressText.appendChild(document.createTextNode(file.name)); var progressBar = document.createElement("div"); progressBar.className = "progressBarInProgress"; var progressStatus = document.createElement("div"); progressStatus.className = "progressBarStatus"; progressStatus.innerHTML = "&amp;nbsp;"; this.fileProgressElement.appendChild(progressCancel); this.fileProgressElement.appendChild(progressText); this.fileProgressElement.appendChild(progressStatus); this.fileProgressElement.appendChild(progressBar); this.fileProgressWrapper.appendChild(this.fileProgressElement); document.getElementById(targetID).appendChild(this.fileProgressWrapper); &#125; else &#123; this.fileProgressElement = this.fileProgressWrapper.firstChild; this.reset(); &#125; this.height = this.fileProgressWrapper.offsetHeight; this.setTimer(); &#125; //…… &#125; 每当我们选择一个文件上传时它就会new FileProgress(file, this.customSettings.progressTarget); 根据上面的代码分析其实就是在网页中添加了以下html代码 12345678910&lt;div id=file.id class="progressWrapper"&gt; &lt;div class="progressContainer" &gt; &lt;a href="#" class="progressCancel" style="visibility:hidden"&gt; &lt;/a&gt; &lt;div class="progressName"&gt; file.name &lt;/div&gt; &lt;div class="progressBarInProgress"&gt;&lt;/div&gt; &lt;div class="progressBarStatus"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //css文件在defaut.css中。 //file.id 和file.name 选中上传文件的id和name属性的值。 这段代码会被插入下面这段代码里面 123&lt;div class="fieldset flash" id="fsUploadProgress1"&gt; &lt;span class="legend"&gt;文件上传&lt;/span&gt; &lt;/div&gt; 如果你的css和javascrpt能力很强，动态在页面中创建对象改变这个控件的外貌是不是很容易呢。 选择好事件重写事件代码就ok了。 不过提醒一下，不要改变现有的这些对象的顺序，您看下后面的代码就这道了。 12this.fileProgressElement.childNodes[3].className = "progressBarInProgress"; this.fileProgressElement.childNodes[3].style.width = percentage + "%"; 如何控制上传队列中的文件消失（hidden）情况12// Fades out and clips away the FileProgress box. FileProgress.prototype.disappear = function () &#123;//…&#125; 这段代码是FileProgress文件disappear的属性代码。 1) 如果想上传后FileProgress不消失 在fileprogress.js文件找到下面代码，像我一样注释掉最后3行就ok了。当然你也可以在相应的事件中重写函数。 12345678910FileProgress.prototype.setComplete = function () &#123; this.fileProgressElement.className = "progressContainer blue"; this.fileProgressElement.childNodes[3].className = "progressBarComplete"; this.fileProgressElement.childNodes[3].style.width = ""; var oSelf = this; //this.setTimer(setTimeout(function () &#123; // oSelf.disappear(); //&#125;, 10000)); &#125;; ​ 2) 删除的时候让FileProgress消失 在fileprogress.js文件中增加 12345678910FileProgress.prototype.setDelete = function () &#123; this.fileProgressElement.className = "progressContainer"; this.fileProgressElement.childNodes[3].className = "progressBarError"; this.fileProgressElement.childNodes[3].style.width = ""; var oSelf = this; this.setTimer(setTimeout(function () &#123; oSelf.disappear(); &#125;, 0)); &#125;; 在删除事件中调用即可。 SWFUpload向服务器传递参数 SWFUpload传递参数有3中方式： 1、在url后加连接： 1upload_url: "&lt;%=basePath%&gt;upload?action=up", 2、使用swfupload传递参数，在setting中配置 1234567post_params: &#123; "hello" : "Here I Am", "name" : "张三", "ff" : document.getElementById("tf").value &#125;, use_query_string : true,//要传递参数用到的配置 3、采用swfupload的函数： 1addPostParam("myFileName",encodeURI(file.name));//这个是我用来传递文件名称的 ​ 我的方法是修改了一下uploadStart函数 1234567891011121314151617function uploadStart(file) &#123; try &#123; /* I don't want to do any file validation or anything, I'll just update the UI and return true to indicate that the upload should start */ var progress = new FileProgress(file, this.customSettings.progressTarget); //progress.setStatus("Uploading..."); progress.setStatus("上传中..."); progress.toggleCancel(true, this); this.setPostParams(&#123; 'fileName':encodeURIComponent(file.name) &#125;); &#125; catch (ex) &#123; &#125; return true; &#125; SWFUpload接受服务器Action返回的参数 首先我们要了解这个函数 1234567891011function uploadSuccess(file, serverData) &#123; try &#123; var progress = new FileProgress(file, this.customSettings.progressTarget); progress.setComplete(); progress.setStatus("Complete."); progress.toggleCancel(false); &#125; catch (ex) &#123; this.debug(ex); &#125; &#125; file为上传的文件对象，我们可以获得，file.id、file.name、file.type、file.size 等信息。 serverData的意思是服务器返回的数据，如果你指定页面，那服务器返回的应该就是这个jsp的数据了，这里最好用type=json的格式 action 代码 123456789101112//…… //返回页面信息 HttpServletResponse response=ServletActionContext.getResponse(); response.setContentType("text/html; charset=UTF-8"); response.setHeader("Cache-Control", "no-cache"); PrintWriter out = response.getWriter(); out.write(“action返回的参数”); out.flush(); out.close(); return SUCCESS; struts.xml 123456&lt;package name="upload"[color=red] extends="json-default" [/color]namespace=""&gt; &lt;action name="upload" class="com.action.FileUploadAction"&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success" type="json"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 这个配置会出现一个bug（如果你以前没用过json插件的话） 当前使用struts2.23版本，使用了jsonplugin-0.3x.jar报错 引用 java.lang.ClassNotFoundException: com.opensymphony.xwork2.util.TextUtils 解决： 在下载好的Struts2的lib文件夹里找到了以下jar包： 引用 json-lib-2.x.jarstruts2-json-plugin-2.x.x.jarstruts2-junit-plugin-2.x.x.jar 上面三个包加入项目里之后，再删除jsonplugin-0.3x.jar包 SWFUpload中文乱码问题 在网上搜的帖子，关于这个问题的解决方法有很多。 第一种：fileName= new String(fileName.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;);用这种方式能解决大部分乱码，但如果文件名中有特殊字符和标点符号有时候会转不过来。第二种：我使用的是这种办法，测试已经通过 123456789101112131415161718192021/**在设置时需要设置一下上传事件 *upload_start_handler : UploadStart, *动态传参数，解决文件名中文乱码问题 **/ function uploadStart(file) &#123; try &#123; /* I don't want to do any file validation or anything, I'll just update the UI and return true to indicate that the upload should start */ var progress = new FileProgress(file, this.customSettings.progressTarget); //progress.setStatus("Uploading..."); progress.setStatus("上传中..."); progress.toggleCancel(true, this); this.setPostParams(&#123; 'fileName':&lt;span style="color: #ff0000;"&gt;encodeURIComponent(file.name) &lt;/span&gt; &#125;); &#125; catch (ex) &#123; &#125; return true; &#125; 在action中使用 1fileName = URLDecoder.decode(fileName, "UTF-8"); ​ 第三种：配置web.config配置文件这种方法我没试，不知道行不行。 参考：谈web开中几种经典的大文件上传组件]]></content>
      <categories>
        <category>fileupload</category>
      </categories>
      <tags>
        <tag>swfupload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo高级教程SEO优化]]></title>
    <url>%2Fposts%2F180.html</url>
    <content type="text"><![CDATA[hexo高阶教程next主题优化之加入网易云音乐、网易云跟帖、动态背景、自定义主题、统计功能，本着生命就是要折腾的原则，我又做了如下的优化： ● seo优化 ● 多终端修改项目 ● 同时托管到github和coding上 ● 设置google和百度sitemap，让搜索引擎更好的抓取你的网站 ● 使用gulp对css、js进行优化 ● 接入七牛图床 ● 加入打赏功能 ● 加入照片模块我们要做对搜索引擎友好的站点所以我就在想，怎么才能让其他小伙伴搜索到我写的文章呢？于是就想到了对网站进行seo优化，这段时间也一直在做网站的seo优化，对于hexo生成的博客来说，代码其实修改的并不多，主要是要多用心去给各个搜索引擎提交你的sitemap，让搜索引擎的小蜘蛛多来你的站点，这样别人在搜索东西的时候才有更多的可能搜出你的文章，给你的网站带来人气~作为一个前端工作者，对网站的优化肯定还是需要有很多的，奈何时间基本都被工作占用，所以就先把优化功能先放了放，只进行了代码压缩在这半个月的时间，对于hexo搭建搭建的个人博客，虽然没有让我对某一门语言的深度增加，但是却让我对整个建站流程的宽度增加了不少，优化是一件比写出代码的技术难度还要高的事情。seo优化推广是一个烦人的事情啊喂，特别是对于我们搞技术的来说，可能就不擅长推广，那么怎么才能让别人知道我们呢，我们就要想办法让别人通过搜索就可以搜索到你博客的内容，给我们带来自然流量，这就需要seo优化,让我们的站点变得对搜索引擎友好SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。让百度收录你的站点我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 验证网站所有权登录百度站长平台：http://zhanzhang.baidu.com,只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击添加网站然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名 在选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证。html标签验证和cname解析验证，使用哪一种方式都可以，都是比较简单的，但是一定要注意，使用文件验证文件存放的位置需要放在source文件夹下，如果是html文件那么hexo就会将其编译，所以必须要加上的layout:false，这样就不会被hexo编译。（如果验证文件是txt格式的就不需要），其他两种方式也是很简单的，我个人推荐文件验证和cname验证，cname验证最为简单，只需加一条解析就好~ 生成网站地图我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎安装sitemap插件12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 修改博客配置文件在根目录配置文件中修改url为你的站点地址123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults: 执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件，可以通过http://www.cherryblog.site/baidusitemap.xml,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。向百度提交链接然后我们就可以将我们生成的sitemap文件提交给百度，还是在百度站长平台，找到链接提交，这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap如何选择链接提交方式1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。4、手动提交：一次性提交链接给百度，可以使用此种方式。一般主动提交比手动提交效果好，这里介绍主动提交的三种方法从效率上来说：主动推送&gt;自动推送&gt;sitemap 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段12345baidu_url_submit: count: 100 # 提交最新的一个链接 host: www.cherryblog.site # 在百度站长平台中注册的域名 token: 8OGYpxowYnhgVsUM # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 在加入新的deploye12deploy: - type:baidu_url_submitter 这样执行hexo deploy的时候，新的链接就会被推送了设置自动推送在主题配置文件下设置,将baidu_push设置为true：12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true 然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap将我们上一步生成的sitemap文件提交到百度就可以了~ 我记得被百度收录过程还是蛮久的，一度让我以为我的方法有问题，提交链接在站长工具中有显示大概是有两天的时候，站点被百度收录大概花了半个月= =，让大家看一下现在的成果在百度搜索site:cherryblog.site已经可以搜索到结果 在搜索框输入域名也可以找到站点 输入关键字的名字也可以在第二页就找到呢，好开森~ 让google收录你的站点相比于百度，google的效率实在不能更快，貌似十分钟左右站点就被收录了，其实方法是和百度是一样的，都是先验证你的站点所有权，然后提交sitemapgoogle站点平台：https://www.google.com/webmasters/，然后就是注册账号、验证站点、提交sitemap，一步一步来就好，过不了过久就可以被google收录了 让其他搜索引擎收录你的站点除了百度和google两大搜索引擎，还有搜狗、360等其他的搜索引擎，流程都是一样的，大家就自行选择添加哈，这里就不再赘述了~优化你的urlseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults: 其他seo优化seo优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，seo优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so…. 网站外链的推广度、数量和质量 网站的内链足够强大 网站的原创质量 网站的年龄时间 网站的更新频率（更新次数越多越好） 网站的服务器 网站的流量：流量越高网站的权重越高 网站的关键词排名：关键词排名越靠前，网站的权重越高 网站的收录数量：网站百度收录数量越多，网站百度权重越高 网站的浏览量及深度：用户体验越好，网站的百度权重越高同时托管到github和coding上前面已经提到过一个惨绝人寰的消息，那就是github是不允许百度的爬虫爬取内容的，所以我们的项目如果是托管在github上的话基本是不会被百度收录的，所以我又同时托管到了coding上，然后在做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding将你的项目托管在coding上 Coding 是一个面向开发者的云端开发平台[1] ，目前提供代码托管，运行空间，质量控制，项目管理等功能。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。2016年3月CODING宣布收购代码托管平台GitCafe。之前好多小伙伴都是将项目托管在gitcafe上，但是现在gitcafe被coding收购了，于是就转到coding上了，之前好多人说github的服务器在国外，于是就转战国内的coding了，我将代码迁移至coding还有另外一个原因，github不让百度的爬虫爬取啊，让我哭一会，不然也不会这样折腾。coding就是中国版的github（只是打一个比喻），有提供pages服务。在coding上创建仓库首先我们先要创建一个coding账号并且在coding上创建一个项目,必须要是公开项目，私有项目是没有page服务的，项目名称可以随意起 将hexo博客同步到新创建的仓库中第一次使用coding需要使用ssh，方法和之前github是一样一样的，将ssh公钥复制到coding上 在coding中添加过ssh公钥之后我们需要修改hexo根目录下的配置文件,官方要求配置格式如下 123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 所以我的配置就是这样的(我这个配置github和coding都有ssh和https两种方式)： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: #github: git@github.com:sunshine940326/sunshine940326.github.io.git github: https://github.com/sunshine940326/sunshine940326.github.io.git coding: git@git.coding.net:cherry940326/cherry940326.git #coding: https://git.coding.net/cherry940326/cherry940326.git 完成之后在git bash 中输入ssh -T git@git.coding.net ● 1如果得到如图提示就说明配置成功了 然后重新部署hexo就将代码上传至coding上了设置coding的pages服务将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了 设置域名解析然后我们到万网下面设置我们的域名解析，将默认ip解析到coding上（这里要注意，解析到coding时记录值是pages.coding.me，并没有具体的账号名或者仓库名，并且只有设置完成域名解析才可以在coding上设置自定义域名），将海外的ip解析到github上，设置如下： 至此就完成了将你的hexo编译的博客同时部署在github和coding上多终端编辑hexo博客之前就想到了一个问题，如果我想要在公司写博客怎么办，或者说如果我换电脑了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上，这道题的解题思路（哈哈，突然想到这个词了）是，将我们的源文件上传至username.github.io的Hexo分支，并且设置为默认分支（分支需要自己创建），然后对我们的源文件进行版本管理，这样我们就可以在另一台电脑上pull我们的源码，然后编译完之后push上去。更为优雅的方式是使用travis-ci，然后用webhook自动部署。你只需要写markdown，push到github就行了。根本不用关心deploy，只要维护你的markdown就行。详情请参考：http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的）删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 123/.deploy_git/public /_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 12git initgit remote add origin &lt;server&gt; 是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传至Hexo分支依次执行 123git add .git commit -m &quot;...&quot;git push origin hexo 提交网站相关的文件；对B电脑进行的操作假设B电脑现在没有我们的源文件 1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master 日常改动平时我们对源文件有修改的时候记得先pull一遍代码，再将代码push到Hexo分支，就和日常的使用git一样~ 依次执行git add .、git commit -m “…”、git push origin Hexo指令将改动推送到GitHub（此时当前分支应为Hexo）； 然后才执行hexo g -d发布网站到master分支上。使用gulp压缩你的代码当你在你的博客页面右键查看源代码的时候，你会发现你的html页面中会有大段大段的空白，这个时候我们就要使用压缩工具对我们的代码进行压缩，在前一段时间参见的前端开发者大会（FDCon2017）中，携程的框架式就有讲到，在携程，线上的资源是需要申请的（单位具体到k），所以说我们的代码不压缩实在是太奢侈~什么是gulp在2017年的前端中，gulp似乎不是最流行的自动化工具，但是谁让我们公司用的是gulp呢。为了能和公司用一样的构建工具，所以我自己的博客也是使用的gulp。gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器。不仅能对网站的资源进行优化，并且能在开发过程中能够对很多重复的任务使其自动完成。能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。既然gulp是基于node，所以我们就要先有node环境，不过我们本身就是使用hexo构建我们的博客，就已经是基于node环境了~npm小知识npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）使用npm安装插件：npm install [g] [–save -dev]● :node 插件名称● -g:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：C:\Users\Administrator\AppData\Roaming\npm;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的node_modules文件夹● –save：将配置信息保存在node项目配置文件package.json中● -dev：保存至package.json 的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~● 为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是npm install，就可以下载package.json 下所有需要的包。npm install –production则只下载dependencies下的包使用npm卸载插件：npm unstall [-g] [–save-dev]● 在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用npm unstall [-g] [–save-dev] 命令● 删除全部插件:rimraf node_modules（首先你需要先安装rimraf 插件）更新npm插件：npm update [g] [–save-dev]使用cnpm什么是cnpm呢，大家都知道，由于不可描述原因，我们访问国外的资源有时候的速度，大家懂的，所以淘宝除了一个npm镜像，服务器就在中国。c可以理解为China（应该可以这样理解吧）,cnpm使用方法和npm完全相同，只需将npm全部换成cnpm就可以。本文都是使用的npm，如果想要尝试cnpmde的麻烦自行替换~这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。cnpm 官网地址：http://npm.taobao.org；安装命令为npm install cnpm -g –registry=https://registry.npm.taobao.org注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；全局安装gulp言归正传，简单介绍了gulp和npm，我们需要的是使用gulp压缩我们的代码npm install gulp -g,然后npm -v 查看版本号就可以知道我们是不是安装成功了~★,°:.☆(￣▽￣)/$:.°★。撒花！新建package.json使用npm init就可以创建package.json文件 ，然后输入yes之后你就会在文件夹中找到创建好的package.json文件。来贴一下我现在的package.json文件，已经是安装了不少包的了~ 123456789101112131415161718192021222324252627282930313233343536&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.2.2" &#125;, "dependencies": &#123; "gulp": "^3.9.1", "gulp-htmlclean": "^2.7.14", "gulp-htmlmin": "^3.0.0", "gulp-imagemin": "^3.2.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^2.1.2", "hexo": "^3.2.0", "hexo-baidu-url-submit": "0.0.5", "hexo-deployer-git": "^0.2.0", "hexo-generator-archive": "^0.1.4", "hexo-generator-baidu-sitemap": "^0.1.2", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.0", "hexo-generator-sitemap": "^1.1.2", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.2.0", "hexo-renderer-marked": "^0.2.10", "hexo-renderer-stylus": "^0.3.1", "hexo-server": "^0.2.0", "hexo-util": "^0.6.0", "hexo-wordcount": "^2.0.1" &#125;, "devDependencies": &#123; "gulp-babel": "^6.1.2", "gulp-clean": "^0.3.2", "hexo-generator-baidu-sitemap": "^0.1.2" &#125;&#125; 本地安装gulp插件在你的Hexo目录下右键git bash here然后执行npm install –save,和gulp有关的包名称有以下几个，只需将替换一下就好~ 123456"gulp": "^3.9.1", "gulp-htmlclean": "^2.7.14", "gulp-htmlmin": "^3.0.0", "gulp-imagemin": "^3.2.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^2.1.2", 聪明的你是不是觉得有些眼熟，对的，就是我po出来的package.json中dependencies下面对应的包名称和版本号~是不是和刚刚所讲的npm的知识联系到了一块呢~建立gulp.jsgulp.js是gulp的配置文件，需要我们手动创建（应该还会有更高级的方法T T ）我的gulp.js文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 获取 gulp-imagemin 模块var imagemin = require('gulp-imagemin')// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input checked /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type="text/javascript" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type="text/css" minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;)) .on('error', function(err) &#123; console.log('html Error!', err.message); this.end(); &#125;) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src('./photos/*.*') // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest('dist/images'))&#125;);// 执行 gulp 命令时执行的任务gulp.task('build', [ 'minify-html','minify-css','minify-js','images',]); 执行gulp：gulp build 在git bash中执行在git bash中直接输入命令gulp build就可以，这个gulp build是你自己创建的任务，你创建的任务是什么名的就在gulp后面跟什么名字在webstorm中执行webstorm真的太强大，已经帮我们继承了gulp，我们只需要动动鼠标就可以执行gulp 增加七牛图床增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~注册七牛万年不变的第一步，注册。官网：七牛云上传资源在登录成功之后，点击对象存储 上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好~也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以~ 添加水印使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。七牛可以对上传的图片添加图片样式 增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。 在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞~既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了~简直不能太赞~(～￣▽￣)～]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击漏洞修复]]></title>
    <url>%2Fposts%2F26499.html</url>
    <content type="text"><![CDATA[​ 跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。​ XSS攻击分成两类，一类是来自内部的攻击，主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。另一类则是来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。XSS分为：存储型和反射型​ 存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。​ 反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 web.xml里面加入XssFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.XssFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;SplitChar&lt;/param-name&gt; &lt;param-value&gt;@&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FilterChar&lt;/param-name&gt; &lt;param-value&gt;'@"@\@#@:@%@&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ReplaceChar&lt;/param-name&gt; &lt;param-value&gt;\'@\"@＼@＃@：@％@＞&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jeeadmin/jeecms/login.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; XssFilter类源码123456789101112131415161718192021222324252627import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class XssFilter implements Filter &#123; private String filterChar; private String replaceChar; private String splitChar; FilterConfig filterConfig = null; public void init(FilterConfig filterConfig) throws ServletException &#123; this.filterChar=filterConfig.getInitParameter("FilterChar"); this.replaceChar=filterConfig.getInitParameter("ReplaceChar"); this.splitChar=filterConfig.getInitParameter("SplitChar"); this.filterConfig = filterConfig; &#125; public void destroy() &#123; this.filterConfig = null; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request,filterChar,replaceChar,splitChar), response); &#125;&#125; XssFilter实现方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import static com.jeecms.common.web.Constants.UTF8;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import org.apache.commons.lang.StringUtils;/** * @author Tom */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; private String[]filterChars; private String[]replaceChars; public XssHttpServletRequestWrapper(HttpServletRequest request,String filterChar,String replaceChar,String splitChar) &#123; super(request); if(filterChar!=null&amp;&amp;filterChar.length()&gt;0)&#123; filterChars=filterChar.split(splitChar); &#125; if(replaceChar!=null&amp;&amp;replaceChar.length()&gt;0)&#123; replaceChars=replaceChar.split(splitChar); &#125; &#125; public String getQueryString() &#123; String value = super.getQueryString(); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ public String getParameter(String name) &#123; String value = super.getParameter(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; public String[] getParameterValues(String name) &#123; String[]parameters=super.getParameterValues(name); if (parameters==null||parameters.length == 0) &#123; return null; &#125; for (int i = 0; i &lt; parameters.length; i++) &#123; parameters[i] = xssEncode(parameters[i]); &#125; return parameters; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; getHeaderNames 也可能需要覆盖 */ public String getHeader(String name) &#123; String value = super.getHeader(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 将容易引起xss漏洞的半角字符直接替换成全角字符 * * @param s * @return */ private String xssEncode(String s) &#123; if (s == null || s.equals("")) &#123; return s; &#125; //%作为特殊解码字符，get方式提交的汉字+%会解码不了 try &#123; s = URLDecoder.decode(s, UTF8); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch(Exception e)&#123; &#125; for (int i = 0; i &lt; filterChars.length; i++) &#123; if(s.contains(filterChars[i]))&#123; s=s.replace(filterChars[i], replaceChars[i]); &#125; &#125; return s; &#125;&#125; 相关资料：XSS漏洞解析：https://www.secpulse.com/archives/48976.html]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene的Field域和索引维护]]></title>
    <url>%2Fposts%2F40393.html</url>
    <content type="text"><![CDATA[一、Field域1.Field属性Field是文档中的域，包括Field名和Field值两部分，一个文档可以包括多个Field，Document只是Field的一个承载体，Field值即为要索引的内容，也是要搜索的内容。是否分词(tokenized)是：作分词处理，即将Field值进行分词，分词的目的是为了索引。比如：商品名称、商品简介等，这些内容用户要输入关键字搜索，由于搜索的内容格式大、内容多需要分词后将语汇单元索引。 否：不作分词处理比如：商品id、订单号、身份证号等 是否索引(indexed)是：进行索引。将Field分词后的词或整个Field值进行索引，索引的目的是为了搜索。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。 否：不索引。该域的内容无法搜索到比如：商品id、文件路径、图片路径等，不用作为查询条件的不用索引。 是否存储(stored)是：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。 否：不存储Field值，不存储的Field无法通过Document获取比如：商品简介，内容较大不用存储。如果要向用户展示商品简介可以从系统的关系数据库中获取商品简介。 如果需要商品描述，则根据搜索出的商品ID去数据库中查询，然后显示出商品描述信息即可。 2.Field常用类型开发中常用 的Filed类型，注意Field的属性，根据需求选择： Field常用类型.PNG3.Field改进代码图书id： 是否分词：不用分词，因为不会根据商品id来搜索商品是否索引：不索引，因为不需要根据图书ID进行搜索是否存储：要存储，因为查询结果页面需要使用id这个值。图书名称： 是否分词：要分词，因为要将图书的名称内容分词索引，根据关键搜索图书名称抽取的词。是否索引：要索引。是否存储：要存储。图书价格： 是否分词：要分词，lucene对数字型的值只要有搜索需求的都要分词和索引，因为lucene对数字型的内容要特殊分词处理，本例子可能要根据价格范围搜索，需要分词和索引。是否索引：要索引是否存储：要存储图书图片地址： 是否分词：不分词是否索引：不索引是否存储：要存储图书描述： 是否分词：要分词是否索引：要索引是否存储：因为图书描述内容量大，不在查询结果页面直接显示，不存储。不存储是来不在lucene的索引文件中记录，节省lucene的索引文件空间，如果要在详情页面显示描述，思路：从lucene中取出图书的id，根据图书的id查询关系数据库中book表得到描述信息。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void createIndex() throws Exception &#123;// 采集数据BookDao dao = new BookDaoImpl();List&lt;Book&gt; list = dao.queryBooks();// 将采集到的数据封装到Document对象中List&lt;Document&gt; docList = new ArrayList&lt;&gt;();Document document;for (Book book : list) &#123; document = new Document(); // store:如果是yes，则说明存储到文档域中 // 图书ID // 不分词、索引、存储 StringField Field id = new StringField("id", book.getId().toString(), Store.YES); // 图书名称 // 分词、索引、存储 TextField Field name = new TextField("name", book.getName(), Store.YES); // 图书价格 // 分词、索引、存储 但是是数字类型，所以使用FloatField Field price = new FloatField("price", book.getPrice(), Store.YES); // 图书图片地址 // 不分词、不索引、存储 StoredField Field pic = new StoredField("pic", book.getPic()); // 图书描述 // 分词、索引、不存储 TextField Field description = new TextField("description", book.getDescription(), Store.NO); // 设置boost值 if (book.getId() == 4) description.setBoost(100f); // 将field域设置到Document对象中 document.add(id); document.add(name); document.add(price); document.add(pic); document.add(description); docList.add(document);&#125; 二、索引维护需求： 管理人员通过电商系统更改图书信息，这时更新的是数据库，如果使用lucene搜索图书信息需要在数据库表book信息变化时及时更新lucene索引库。 1.添加索引调用 indexWriter.addDocument（doc）添加索引。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Testpublic void createIndex() throws Exception &#123;// 采集数据BookDao dao = new BookDaoImpl();List&lt;Book&gt; list = dao.queryBooks();// 将采集到的数据封装到Document对象中List&lt;Document&gt; docList = new ArrayList&lt;&gt;();Document document;for (Book book : list) &#123; document = new Document(); // store:如果是yes，则说明存储到文档域中 // 图书ID Field id = new TextField("id", book.getId().toString(), Store.YES); // 图书名称 Field name = new TextField("name", book.getName(), Store.YES); // 图书价格 Field price = new TextField("price", book.getPrice().toString(), Store.YES); // 图书图片地址 Field pic = new TextField("pic", book.getPic(), Store.YES); // 图书描述 Field description = new TextField("description", book.getDescription(), Store.YES); // 将field域设置到Document对象中 document.add(id); document.add(name); document.add(price); document.add(pic); document.add(description); docList.add(document);&#125;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);// 指定索引库的地址File indexFile = new File("E:\\11-index\\hm19\\");Directory directory = FSDirectory.open(indexFile);IndexWriter writer = new IndexWriter(directory, cfg);// 通过IndexWriter对象将Document写入到索引库中for (Document doc : docList) &#123; writer.addDocument(doc);&#125;// 关闭writerwriter.close();&#125; 2.删除索引2.1删除指定索引 根据Term项删除索引，满足条件的将全部删除。 Term是索引域中最小的单位。根据条件删除时，建议根据唯一键来进行删除。在solr中就是根据ID来进行删除和修改操作的。 12345678910111213141516171819@Testpublic void deleteIndex() throws Exception &#123;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);Directory directory = FSDirectory .open(new File("E:\\11-index\\hcx\\"));// 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// Termswriter.deleteDocuments(new Term("id", "1"));writer.close();&#125; 2.2删除全部索引（慎用） 将索引目录的索引信息全部删除，直接彻底删除，无法恢复。慎用！ 123456789101112131415161718// 删除索引@Testpublic void deleteIndex() throws Exception &#123;// 1、指定索引库目录Directory directory = FSDirectory.open(new File("E:\\11-index\\0720"));// 2、创建IndexWriterConfigIndexWriterConfig cfg = new IndexWriterConfig(Version.LATEST, new StandardAnalyzer());// 3、 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// 4、通过IndexWriter来删除索引// a)、删除全部索引writer.deleteAll();// 5、关闭IndexWriterwriter.close();&#125; 建议参照关系数据库基于主键删除方式，所以在创建索引时需要创建一个主键Field，删除时根据此主键Field删除。 索引删除后将放在Lucene的回收站中，Lucene3.X版本可以恢复删除的文档，3.X之后无法恢复。 3.修改索引更新索引是先删除再添加，建议对更新需求采用此方法并且要保证对已存在的索引执行更新，可以先查询出来，确定更新记录存在执行更新操作。 123456789101112131415161718192021222324@Testpublic void updateIndex() throws Exception &#123;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);Directory directory = FSDirectory .open(new File("E:\\11-index\\hcx\\"));// 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// 第一个参数：指定查询条件// 第二个参数：修改之后的对象// 修改时如果根据查询条件，可以查询出结果，则将以前的删掉，然后覆盖新的Document对象，如果没有查询出结果，则新增一个Document// 修改流程即：先查询，再删除，在添加Document doc = new Document();doc.add(new TextField("name", "lisi", Store.YES));writer.updateDocument(new Term("name", "zhangsan"), doc);writer.close(); }]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文搜索解析]]></title>
    <url>%2Fposts%2F3536.html</url>
    <content type="text"><![CDATA[一、创建查询对象的方式对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法。类似关系数据库Sql语法一样，Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。可通过两种方法创建查询对象： 使用Lucene提供Query子类Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。 如下代码： Query query = new TermQuery(new Term(“name”, “lucene”));使用QueryParse解析查询表达式QueryParser会将用户输入的查询表达式解析成Query对象实例。如下代码： QueryParser queryParser = new QueryParser(“name”, new IKAnalyzer());Query query = queryParser.parse(“name:lucene”);二、通过Query子类搜索2.1 TermQueryTermQuery项查询，TermQuery不使用分析器，搜索关键词作为整体来匹配Field域中的词进行查询，比如订单号、分类ID号等。 private void doSearch(Query query) {12345678910111213141516171819202122232425262728293031323334353637IndexReader reader = null;try &#123; // a) 指定索引库目录 Directory indexdirectory = FSDirectory.open(new File( "E:\\11-index\\0720")); // b) 创建IndexReader对象 reader = DirectoryReader.open(indexdirectory); // c) 创建IndexSearcher对象 IndexSearcher searcher = new IndexSearcher(reader); // d) 通过IndexSearcher对象执行查询索引库，返回TopDocs对象 // 第一个参数：查询对象 // 第二个参数：最大的n条记录 TopDocs topDocs = searcher.search(query, 10); // e) 提取TopDocs对象中的文档ID，如何找出对应的文档 ScoreDoc[] scoreDocs = topDocs.scoreDocs; System.out.println("总共查询出的结果总数为：" + topDocs.totalHits); Document doc; for (ScoreDoc scoreDoc : scoreDocs) &#123; // 文档对象ID int docId = scoreDoc.doc; doc = searcher.doc(docId); // f) 输出文档内容 System.out.println(doc.get("filename")); System.out.println(doc.get("path")); System.out.println(doc.get("size")); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; } @Testpublic void testTermQuery() throws Exception {1234// 1、 创建查询（Query对象）Query query = new TermQuery(new Term("filename", "apache"));// 2、 执行搜索doSearch(query); }2.2 NumericRangeQueryNumericRangeQuery，指定数字范围查询. @Testpublic void testNumbericRangeQuery() throws Exception {123456789// 创建查询// 第一个参数：域名// 第二个参数：最小值// 第三个参数：最大值// 第四个参数：是否包含最小值// 第五个参数：是否包含最大值Query query = NumericRangeQuery.newLongRange("size", 1l, 100l, true,true);// 2、 执行搜索doSearch(query); }2.3 BooleanQueryBooleanQuery，布尔查询，实现组合条件查询。 @Testpublic void booleanQuery() throws Exception {1234567891011121314BooleanQuery query = new BooleanQuery();Query query1 = new TermQuery(new Term("id", "3"));Query query2 = NumericRangeQuery.newFloatRange("price", 10f, 200f, true, true);//MUST：查询条件必须满足，相当于AND//SHOULD:查询条件可选，相当于OR//MUST_NOT：查询条件不能满足，相当于NOT非query.add(query1, Occur.MUST);query.add(query2, Occur.SHOULD);System.out.println(query);search(query); }组合关系代表的意思如下: 1、MUST和MUST表示“与”的关系，即“交集”。2、MUST和MUST_NOT前者包含后者不包含。3、MUST_NOT和MUST_NOT没意义4、SHOULD与MUST表示MUST，SHOULD失去意义；5、SHOUlD与MUST_NOT相当于MUST与MUST_NOT。6、SHOULD与SHOULD表示“或”的概念。三、通过QueryParser搜索通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。 3.1 QueryParser代码实现： @Testpublic void testQueryParser() throws Exception {123456789// 创建QueryParser// 第一个参数：默认域名// 第二个参数：分词器QueryParser queryParser = new QueryParser("name", new IKAnalyzer());// 指定查询语法 ，如果不指定域，就搜索默认的域Query query = queryParser.parse("lucene");System.out.println(query);// 2、 执行搜索doSearch(query); }查询语法： 1、基础的查询语法，关键词查询： 域名+“：”+搜索的关键字例如：content:java2、范围查询 域名+“:”+[最小值 TO 最大值]例如：size:[1 TO 1000]注意：QueryParser不支持对数字范围的搜索，它支持字符串范围。数字范围搜索建议使用NumericRangeQuery。3、组合条件查询 组合条件查询.PNG1）+条件1 +条件2：两个条件之间是并且的关系and例如：+filename:apache +content:apache 2）+条件1 条件2：必须满足第一个条件，忽略第二个条件例如：+filename:apache content:apache 3）条件1 条件2：两个条件满足其一即可。例如：filename:apache content:apache 4）-条件1 条件2：必须不满足条件1，要满足条件2例如：-filename:apache content:apache 第二种写法：条件1 AND 条件2条件1 OR 条件2条件1 NOT 条件23.2 MultiFieldQueryParser通过MultiFieldQueryParser对多个域查询。 @Testpublic void testMultiFieldQueryParser() throws Exception {12345678910// 可以指定默认搜索的域是多个String[] fields = &#123; "name", "description" &#125;;// 创建一个MulitFiledQueryParser对象QueryParser parser = new MultiFieldQueryParser(fields, new IKAnalyzer());// 指定查询语法 ，如果不指定域，就搜索默认的域Query query = parser.parse("lucene");//等同于name:lucene OR description:lucene// Query query = parser.parse("name:lucene OR description:lucene");// 2、 执行搜索doSearch(query); }四、TopDocsLucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下： topdocs属性.PNG注意： Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)TopDocs.totalHits：是匹配索引库中所有记录的数量TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene实现文档进行全文检索功能]]></title>
    <url>%2Fposts%2F10596.html</url>
    <content type="text"><![CDATA[Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。这里讲一下使用Lucene对doc、docx、pdf、txt文档进行全文检索功能的实现。 涉及到的类一共有两个： LuceneCreateIndex，创建索引： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package com.yhd.test.poi;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Date;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.DateTools;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.store.Directory;import org.apache.lucene.store.SimpleFSDirectory;import org.apache.lucene.util.Version;import org.apache.pdfbox.pdfparser.PDFParser;import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.util.PDFTextStripper;import org.apache.poi.hwpf.extractor.WordExtractor;import org.apache.poi.xwpf.extractor.XWPFWordExtractor;import org.apache.poi.xwpf.usermodel.XWPFDocument;public class LuceneCreateIndex &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; // 保存word文件的路径 String dataDirectory = "D:\\Studying\\poi\\test\\dataDirectory"; // 保存Lucene索引文件的路径 String indexDirectory = "D:\\Studying\\poi\\test\\indexDirectory"; // 创建Directory对象 ，也就是分词器对象 Directory directory = new SimpleFSDirectory(new File(indexDirectory)); // 创建一个简单的分词器,可以对数据进行分词 Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30); // 创建索引实例 // 第1个参数是Directory, // 第2个是分词器, // 第3个表示是否是创建, true代表覆盖原先数据, 如果为false为在此基础上面修改, // 第4个MaxFieldLength表示对每个Field限制建立分词索引的最大数目， // 如果是MaxFieldLength.UNLIMITED，表示长度没有限制; // 如果是MaxFieldLength.LIMITED则表示有限制，可以通过IndexWriter对象的setMaxFieldLength（int // n）进行指定 IndexWriter indexWriter = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED); // 获取所有需要建立索引的文件 File[] files = new File(dataDirectory).listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; // 文件是第几个 System.out.println("这是第" + i + "个文件----------------"); // 文件的完整路径 System.out.println("完整路径：" + files[i].toString()); // 获取文件名称 String fileName = files[i].getName(); // 获取文件后缀名，将其作为文件类型 String fileType = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length()).toLowerCase(); // 文件名称 System.out.println("文件名称：" + fileName); // 文件类型 System.out.println("文件类型：" + fileType); Document doc = new Document(); // String fileCode = FileType.getFileType(files[i].toString()); // 查看各个文件的文件头标记的类型 // System.out.println("fileCode=" + fileCode); InputStream in = new FileInputStream(files[i]); InputStreamReader reader = null; if (fileType != null &amp;&amp; !fileType.equals("")) &#123; if (fileType.equals("doc")) &#123; // 获取doc的word文档 WordExtractor wordExtractor = new WordExtractor(in); // 创建Field对象，并放入doc对象中 // Field的各个字段含义如下： // 第1个参数是设置field的name， // 第2个参数是value，value值可以是文本（String类型，Reader类型或者是预分享的TokenStream）, // 二进制（byet[]）, 或者是数字（一个 Number类型） // 第3个参数是Field.Store，选择是否存储，如果存储的话在检索的时候可以返回值 // 第4个参数是Field.Index，用来设置索引方式 doc.add(new Field("contents", wordExtractor.getText(), Field.Store.YES, Field.Index.ANALYZED)); // 关闭文档 wordExtractor.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("docx")) &#123; // 获取docx的word文档 XWPFWordExtractor xwpfWordExtractor = new XWPFWordExtractor( new XWPFDocument(in)); // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", xwpfWordExtractor.getText(), Field.Store.YES, Field.Index.ANALYZED)); // 关闭文档 xwpfWordExtractor.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("pdf")) &#123; // 获取pdf文档 PDFParser parser = new PDFParser(in); parser.parse(); PDDocument pdDocument = parser.getPDDocument(); PDFTextStripper stripper = new PDFTextStripper(); // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", stripper.getText(pdDocument), Field.Store.NO, Field.Index.ANALYZED)); // 关闭文档 pdDocument.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("txt")) &#123; // 建立一个输入流对象reader reader = new InputStreamReader(in); // 建立一个对象，它把文件内容转成计算机能读懂的语言 BufferedReader br = new BufferedReader(reader); String txtFile = ""; String line = null; while ((line = br.readLine()) != null) &#123; // 一次读入一行数据 txtFile += line; &#125; // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", txtFile, Field.Store.NO, Field.Index.ANALYZED)); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else &#123; System.out.println(); continue; &#125; &#125; // 创建文件名的域，并放入doc对象中 doc.add(new Field("filename", files[i].getName(), Field.Store.YES, Field.Index.NOT_ANALYZED)); // 创建时间的域，并放入doc对象中 doc.add(new Field("indexDate", DateTools.dateToString(new Date(), DateTools.Resolution.DAY), Field.Store.YES, Field.Index.NOT_ANALYZED)); // 写入IndexWriter indexWriter.addDocument(doc); // 换行 System.out.println(); &#125; // 查看IndexWriter里面有多少个索引 System.out.println("numDocs=" + indexWriter.numDocs()); // 关闭索引 indexWriter.close(); &#125;&#125; LuceneSearch，进行搜索： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.yhd.test.poi;import java.io.File;import java.io.IOException;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.Document;import org.apache.lucene.queryParser.ParseException;import org.apache.lucene.queryParser.QueryParser;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;import org.apache.lucene.store.SimpleFSDirectory;import org.apache.lucene.util.Version;public class LuceneSearch &#123; public static void main(String[] args) throws IOException, ParseException &#123; // 保存索引文件的地方 String indexDirectory = "D:\\Studying\\poi\\test\\indexDirectory"; // 创建Directory对象 ，也就是分词器对象 Directory directory = new SimpleFSDirectory(new File(indexDirectory)); // 创建 IndexSearcher对象，相比IndexWriter对象，这个参数就要提供一个索引的目录就行了 IndexSearcher indexSearch = new IndexSearcher(directory); // 创建QueryParser对象, // 第1个参数表示Lucene的版本, // 第2个表示搜索Field的字段, // 第3个表示搜索使用分词器 QueryParser queryParser = new QueryParser(Version.LUCENE_30, "contents", new StandardAnalyzer(Version.LUCENE_30)); // 生成Query对象 Query query = queryParser.parse("百度"); // 搜索结果 TopDocs里面有scoreDocs[]数组，里面保存着索引值 TopDocs hits = indexSearch.search(query, 10); // hits.totalHits表示一共搜到多少个 System.out.println("找到了" + hits.totalHits + "个"); // 循环hits.scoreDocs数据，并使用indexSearch.doc方法把Document还原，再拿出对应的字段的值 for (int i = 0; i &lt; hits.scoreDocs.length; i++) &#123; ScoreDoc sdoc = hits.scoreDocs[i]; Document doc = indexSearch.doc(sdoc.doc); System.out.println(doc.get("filename")); &#125; indexSearch.close(); &#125;&#125; 详细的解释在代码注释里都有了，就不做过多解释了。需要的jar包如下： 读取poi的类到poi官网下载，读取pdf的类到Apache PDFBox官网下载，这里用的1.8.13版本，2.0版本的调用方式与1.0版本已经不太一样了。 项目整体结构如下： 先运行类： LuceneCreateIndex 会读取目录dataDirectory，即： D:\Studying\poi\test\dataDirectory 下的文件，建立索引，索引会保存在目录indexDirectory，即： D:\Studying\poi\test\indexDirectory 下，然后运行： LuceneSearch 使用索引进行查询，就能看到效果了。]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis CI 自动更新 GitHub Pages]]></title>
    <url>%2Fposts%2F32102.html</url>
    <content type="text"><![CDATA[​ 这年头要是没有个博客都不好意思给别人说你是程序员，我用XX笔记呀，不行吗？不行，这玩意儿要么不能公开分享，要么公开分享要会员，现在到处都是开源，自己学到了东西都不能分享给需要帮助的人，真是伤心呀。那么今天就来聊聊当你用Hexo搭建了博客，怎么自动更新呢，大家都知道Hexo是需要手动生成HTML静态网页的，虽然命令很少，但是每次写完博客先得推送到git然后在生成静态文件，再推送到服务器，想想我这个心也是醉了，不过看到知乎上还有人带着U盘，我只能呵呵了~，你们耐心真好~那我们今天就来说说怎么使用Travis CI来自动构建你的博客 什么是Travis CI Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。对于做开源项目或者github的使用者，如果你的项目还没有加入Travis CI构建队列，那么我真的想对你说out了。 我的博客架构 也算是一个框架吧 首先我的博客是使用Hexo来搭建的，托管到Github提供的Gitpage服务上的 每次写完博客git push到github，然后Travis自动构建，构建完成后自动推送到Gitpage服务上 生成后的HTML文件和博客的源文件我是放到一个仓库的，只是使用了不同的分支 master：博客的静态文件，也就是hexo生成后的HTML文件，因为要使用Gitpage服务，所以他规定的网页文件必须是在master分支 blog-source：是博客的源代码 当然这样做有隐私问题，因为任何人都能哪的你的博客源码，当然既然是博客，所以就没有这些问题了 启用要构建的项目 首先如果你要使用Travis CI，你必须要GIthub账号（好像Travis CI只支持构建github的项目）和一个项目 使用Github账号登录Travis CI官网，如下图 登录完后会进入如下界面 当然如果你以前没用使用过，所以你登录完是没有上图红框内的内容的，这里是因为我在写这篇博客前已经使用了，所以会有这些内容 接下来我们点击My Repositories旁边的+，意思是添加一个要自动构建的仓库，如下图： 点击后就会来到如下界面： 可以看到这个界面会显示当前github账号的所以项目，如果没有显示，点击右上角的“Sync account”按钮，就可以同步过来了（ps：上次用windows电脑始终同步不过来项目，最后换成mac可以同步了，最后又换回windows也可以了，汗(⊙﹏⊙)b，不太懂，什么个情况） 居然仓库都同步过来了，那么下一步肯定是要开启你需要构建的仓库，可以看到我开启了lifengsofts.github.io这个项目，当然这个也是我就是我的博客啦 开启后我们还需要进行一些配置，操作如下 点击红框的那个菜单按钮，就会出现这样的下拉菜单，我们选择设置，来到这个界面，我们按照如下勾选 Build only if .travis.yml is present：是只有在.travis.yml文件中配置的分支改变了才构建 Build pushes：当推送完这个分支后开始构建 到这一步， 我们已经开启了要构建的仓库，但是还有个问题就是，构建完后，我们怎么将生成的文件推送到github上呢，如果不能推送那我们就不需要倒腾一番来使用Travis CI服务了，我们要的结果就是，我们只要想github一push，他就自动构建并push静态文件到gitpages呢，那么下面要解决的就是Travis CI怎么访问github了 在Travis CI配置Github的Access Token 标题已经说得很明白了吧，我们需要在Travis上配置Access Token，这样我们就可以在他构建完后自动push到gitpgaes了，到这里肯定有人要问了，咋你把用户名密码直接写文件里呢，如果你真有这样的问题，那我只能说呵呵~，但我要告诉你的是写里面肯定是可以push成功的 在github上生成Access Token 首先我们来到github的设置界面，点击到Personal access tokens页面，点击右上角的Generate new token按钮会重新生成一个，点击后他会叫你输入密码，然后来到如下界面，给他去一个名字，下面是勾选一些权限 生成完后，你需要拷贝下来，只有这时候他才显示，下载进来为了安全他就不会显示了，如果忘了只能重新生成一个了，拷贝完以后我们需要到Travis CI网站配置下 在Travis CI配置 配置界面还是在项目的setting里面，如下图 至于为什么我们要在这里配置，我想大家肯定应该明白了，写在程序里不安全，配置到这里相当于一个环境变量，我们在构建的时候就可以引用他。 到这里我已经配置了要构建的仓库和要访问的Token，但是问题来了，他知道怎么构建，怎么生成静态文件吗，怎么push的gitpages，又push到那个仓库吗，所以这里我们还需要在源代码的仓库里创建一个.travis.yml配置文件，放到源代码的根目录，如下图 其中内容如下： 12345678910111213141516language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name "lifengsofts" - git config user.email "lifengsofts@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: -GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 其中给你需要更换的又git config后面的配置信息 GH_REF的值更改为你的仓库地址 到这一步我们配置已经完成了，现在就是见证奇迹的时候了 Push文章到Github 到这一步，我们可以写一篇文章，添加到你的博客的_posts目录下，如图： 然后commit并push到你的Github上 git push origin blog-source:blog-source 如果不出意外，我们可以就可以在Travis CI网站看到他已经在构建了，如下图： 构建完成后 是不是逼格十足呢 如果我的文章对来带来的帮助，可加我微信，微博，QQ什么啥的交个朋友也是不错的，另外微信，微博都会不定期发一些优质的文章，感谢大家的支持~~，联系方式在我的个人介绍里啦，感谢你的阅读，谢谢~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse报"Building workspace". GC overhead limit exceeded]]></title>
    <url>%2Fposts%2F64632.html</url>
    <content type="text"><![CDATA[eclipse一直报An internal error occurred during: “Building workspace”. GC overhead limit exceeded 最近导入到eclipse里的工程挺大的，每次eclipse启动之后都回update workspace，然后就一直报： An internal error occurred during: “Building workspace”. GC overhead limit exceeded 这个错误。 解决方法： 原因是Eclipse默认配置内存太小需要更改Eclipse安装文件夹下的eclipse.ini文件。 Eclipse.ini默认文件如下： 修改如下： -Xms512m -Xmx1024m 第一个是最小的初始化内存，第二个是最大的占有内存 还可以加上 -XX:MaxPermSize=1024m这个意思是在编译文件时一直占有最大内存，重启Eclipse。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestService和WebService的区别]]></title>
    <url>%2Fposts%2F27499.html</url>
    <content type="text"><![CDATA[什么是WebService？且看百度百科是如何定义： Web service是一个平台独立的，松耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 从定义中可以了解， WebService 主要具备三大特点：平台独立性，松耦合、自包含，分布式互操作。 首先，能称为Web Service的应用，具备平台独立性，所谓平台独立性，在Windows、Linux、Unix平台等等都可以使用，是大家遵守的行业标准或者是某些事实标准，有些虽然不是行业标准，但大家都这么做，也都支持，也就慢慢变成事实了。 那什么不是通用的解决方案呢？如：Windows平台的COM/DCOM技术，只能局限于某个平台，一旦脱离该平台就不可以使用。 基次，具备Web Service应用程序，是松耦合的，自包含的。所谓松耦合，即模块之间的依赖型和制约比较小，更改一个模块不会比较大的影响其他模块，说白了，不用关心模块内部是如何实现的，给你标准的接口，你用大家都用的技术与我互通即可。关于自包含的理解，指在组件重用时不需要包含其他的可重用组件，自己搞掂一切，呵呵。 再次，分布式互操作性，这点大家非常好理解，开发出来的应用，要具备与其它系统之间的互操作，现在系统都不是孤立的，开放出来的接口，可以在任意平台上可调用，不具有依赖性。 Web Service标准早期，软件巨头们定义的Web Service标准，主要由三部分构成： SOAP,WSDL,UDDI。 SOAP 即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。它有三个主要方面：XML-envelope为描述信息内容和如何处理内容定义了框架，将程序对象编码成为XML对象的规则，执行远程过程调用(RPC)的约定。SOAP可以运行在任何其他传输协议上。这里需要注意，SOAP是可以在其他协议上，不仅是HTTP, 可以基于SMTP，消息队列等。 WSDL 是web Service描述语言 就是用机器能阅读的方式提供的一个正式描述文档而基于XML的语言，用于描述Web Service及其函数、参数和返回值。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的。 UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。 UDDI 基本没有实现，这种想法也不现实。可以理解UDDI是个Web Service公共仓库，服务写好注册到UDDI中，以便是其他系统方便调用。 Rest Service随着互联网技术的兴起，XML越来越令人诟病，XML的数据包越来重，SOAP协议方便性和灵活性都有欠缺，尤其兴起的Web2.0发展，由Yahoo、Google 和 Facebook等大型互联网公司的倡导，REST代表性状态传输（Representational State Transfer，REST）在 Web 领域已经得到了广泛的接受，是基于 SOAP 和 Web 服务描述语言（Web Services Description Language，WSDL）的 Web 服务的更为简单的替代方法。如GOOGLE 这些提供者弃用或放弃了基于 SOAP 和 WSDL 的接口，而采用了更易于使用、面向资源的模型来公开其服务。 Rest 服务定义： 即REST(Representational State Transfer表述性状态转移)是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 Rest Service特点： 客户端和服务器结构 连接协议具有无状态性 能够利用Cache机制增进性能 层次化的系统 随需代码 Rest Service 相比Web Service建议的标准更轻量级，甚到用Javascript都可以调用，使用方更方便、高效、简单。REST架构遵循了CRUD原则，CRUD原则对于资源只需要四种行为：Create（创建）、Read（读取）、Update（更新）和Delete（删除）就可以完成对其操作和处理。 Web Service与Rest Service 区别REST 从资源的角度来观察整个网络，分布在各处的资源由URI确定，而客户端的应用通过URI来获取资源的表征。获得这些表征致使这些应用程序转变了其状态。随着不断获取资源的表征，客户端应用不断地在转变着其状态，所谓表征状态转移（Representational State Transfer）。 Rest Service具备Web Service的所有特点：平台独立、松耦合、互操作性。并且，Rest 更轻量级，更简单。可以这么说吧，Rest Service 是Web Service的一种实现，并不是说Rest是Web service替代。]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论工业社会及其未来]]></title>
    <url>%2Fposts%2F16463.html</url>
    <content type="text"><![CDATA[工业革命极大增加了城市规模和城市人口比例，而人群聚集会增加压力与攻击性。 技术变革导致现代社会的变化十分迅速，因此整个社会不存在稳定的框架和价值观。 有些人急于拯救自由却不愿牺牲技术带来的所谓好处，他们会提出天真的新式社会构想来调和自由与技术。 所有人都理所当然地认为，每一个人都必需向技术的需要低头，而且理由十分充分：如果人的需求被摆在了优先于技术需要的地位，就会出现经济问题、失业、短缺甚至更糟。在我们的社会当中，”精神健康”的概念主要被定义为在多大程度一个人能够根据体系的需要行事并且不会流露出承受精神压力的迹象。 经济体系所能容纳的企业数是有限的，我们大多数人只有成为别人的雇员才可以生存。 工业-技术体系可能幸存也可能崩溃。假如该体系幸存下来，可能最终将会降低生理与心理的痛苦水平，但在此之前必须经历一段漫长而痛苦的调整期，而且人类与众多其他生命体也将付出惨重代价，永远沦为社会机器上的齿轮。更有甚者，假如这个体系幸存下来，将会导致不可避免的后果：没有任何方法能够改革或改进这一体系，使之不至于剥夺人的尊严与自主。 假如这一体系崩溃，结果依旧会十分痛苦。但是体系规模越大，崩溃造成的结果就越可怕。因此假如真要崩溃的话最好赶早不赶迟。 所以我们主张发动针对工业体系的革命。这场革命可能使用或不使用暴力，可能突然完成也可能在几十年时间里相对循序渐进地进行。我们无法预测这一点。但是我们的确为那些憎恨工业体系的人们勾勒了一套十分宽泛的方法，从而为反对这一特定社会形式的革命铺平道路。这不是一场政治革命。革命目标并非推翻政府，而是颠覆现存社会的经济与技术基础。 一般来说科学家都是这样。可能其中也有少数例外，但总体而言他们的动机既不是好奇也不是造福人类，而是完成权力过程的需要。其他动机对于许多科学家来说也有作用，例如金钱与地位。 科学技术也构成了群体权力运动，许多科学家都通过认同这一运动来满足自己的权力需求。 因此科学盲目地前进，不考虑人类种族的真正福祉或任何其他标准，仅仅服从科学家以及提供研究资金的政府官员与企业高管的心理需求。 体系需要科学家、数学家与工程师，否则就无法正常运作。 遗传工程的伦理规范事实上将成为管制人类遗传构造的手段。一部分人（多半是上层阶级）将决定如此这般的遗传工程合乎”道德”，如此这般的做法则不道德，因而他们将在实际上将自己的价值观强加于整个人口的遗传构造。即使伦理规范是以完全民主的方式选择出来的，多数族裔也会将他们自己的价值观强加于那些很可能对于如何 “道德地”运用遗传工程另有看法的少数族裔。真正能够保护自由的伦理规范只能是一条，那就是禁止任何人类遗传工程。而我们可以十分有把握地说，这一点恰恰不可能在技术社会中得到实现。任何将遗传工程贬低成配角的规范都不可能维持下去，因为生物技术的巨大力量所产生的诱惑是无法抗拒的。特别是在大多数人看来，大量生物技术的应用显然且肯定是有益的（可以根除身体与精神疾病，赋予人们当今世界所需要的能力）。基因技术必将不可避免地得到大规模应用，但应用方式只能与工业-技术体系的需求相一致。 技术之所以是如此强有力的社会力量的另一个理由是，在给定社会的条件下技术进步只会不可逆地朝一个方向前进。只要某项技术发明被引进，人们就往往会对其产生依赖，除非它被某种更先进的发明所取代。人们不仅仅作为个人依赖这项新技术。甚至体系作为一个整体都会依赖它。（例如请想像一下，如果没有了计算机，今天的体系会怎么样）因此，体系只能朝向更加技术化的方向移动。在不至于颠覆整个技术体系的前提下，技术将会不断地逼迫自由后退。 技术的进步十分迅速并在许多方面威胁自由（拥挤、规章制度、个人对于大型组织越发严重的依赖、宣传与其他心理学技术、遗传工程、通过监视设备和计算机侵犯隐私，等等），阻挡任何一项对于自由的威胁都需要一场单独的社会斗争。那些想要保卫自由的人会被无数的新攻势及其发展速度所压倒，他们会变得微不足道并停止抵抗。分别反击这些威胁是无效的。只有把技术体系作为一个整体来反击才有成功的希望，但这就是革命而不是改革了。 人们倾向于想当然地认为，由于革命带来的变化比改革大，所以革命也就比改革更难发动。实际上，在某些条件下革命比改革容易得多。这是因为一场革命运动能够激发出人们极大的献身热情，而一场改革运动却不能。一场革命运动许诺一下子解决所有问题并创造整个新世界；它提供人民为之甘冒风险、甘作牺牲的理想。由于这些理由，推翻整个技术体系要比对技术的某一部分—-如遗传工程的应用发展—-进行有效、持久的限制容易得多。在适当的条件下，许许多多的人会热情地献身于推翻工业技术体系的革命。正如我们提到的那样，寻求限制技术的某些方面的改革者是为了避免不良后果而工作。然而，革命者是为了获得强力的报偿—-实现其革命理想—-而工作，因此他们比改革者更努力且更执著。 现代社会不是去改变那些使人们抑郁的条件，而是给人们抗抑郁药。 但另一方面，请假设今后几十年的压力超出了体系的承受能力。如果体系崩溃，可能会有一个混乱时期，”动乱年代”，就像在过去各个时代历史所记载的那样。不可能预见动乱年代最后会产生什么结果。但无论如何人类会被赋予一个新机会。最大的危险是工业化社会很可能在崩溃后不几年就开始重组其自身，肯定会有许多人（特别是权力饥渴型的人们）急于重新开动工厂。 工业体系将人类贬低到了被奴役的状态，而憎恨这种被奴役状态的人则面临两个任务。第一，我们必须增强体系内的社会紧张态势，以加快其崩溃或把它弱化到足够程度，使得反对体系的革命成为可能。第二，当体系充分弱化时，我们必须发展并宣传一种反对技术和工业社会的意识形态。当工业社会崩溃时，这种意识形态将有助于保证其残余被粉碎到无法修复的地步，这样体系就无法重组。工厂将被捣毁，技术书籍将被烧掉，等等。 工业体系的崩溃不会纯粹是革命行动的结果，它不会那么难以抵御革命的攻击，除非它自身内部的发展问题导致了极为严重的困难。因此如果体系崩溃，那么它或是自发崩溃，或是部分自发、部分由革命者促发的崩溃。如果崩溃是突如其来的，许多人都会死去，因为世界人口已如此过分膨胀，离开了先进技术就无法养活自己。甚至即使崩溃足够缓慢，人口的减少可以主要通过出生率的降低而不是死亡率的提高而实现，非工业化的过程也多半是极度混乱和极度痛苦的。幻想通过平稳控制的有序方式逐步废除技术是天真的，特别是要考虑到技术爱好者们的负隅顽抗。那么，致力于体系的崩溃是否因此就十分残酷呢？也许是，也许不是。首先，除非体系本来就已经陷入了深重的困难，无论如何都很可能最终自行崩溃，否者单靠革命者是不可能强行使其崩溃的。而且体系发展得规模越大，崩溃的后果就越严重。因此加速体系崩溃的革命者或许反倒控制了灾难的规模。 其次，我们必须权衡斗争与死亡和丧失自由与尊严这两方面的得失。对于我们之中的许多人来说，自由与尊严比长寿和避免肉体痛苦更重要。再者，我们早晚会死，死于为生存或为某一事业而战，强于活得空虚而无目的。 第三，体系的存续所带来的痛苦并不一定就比体系崩溃所带来的痛苦更少。在全世界范围内，体系已经招致、并且正在招致的巨大痛苦曾使人类千百年与他人以及环境和睦相处的古代文化被与其解接触的工业社会所摧毁。其结果就是全方位的经济、环境、社会和心理问题。工业社会的侵扰所产生的影响之一，就是传统的人口控制在全球范围内一下子失去了平衡，因而产生了人口爆炸及其所有连带后果。接着就是心理疾病席卷了整个所谓”幸运”的西方社会。没有人知道臭氧层耗尽、温室效应及其他现在还不能预测的环境问题最终会为这个世界带来怎样的后果。而且就像核扩散已经显示的那样，我们无法防止新技术落入独裁者和不负责任的第三世界国家手中。愿意猜猜伊位克或北朝鲜将用遗传工程来干什么吗? “嗨！”技术爱好者们会说，”科学能解决所有这些问题！我们将征服饥荒、消灭心理病痛，让每一个人都健康而快乐！”是的，是的。他们200年前就是这么说的。人们曾指望工业社会能够消灭贫穷，使每一个人都快乐，等等。实际结果却不是那么回事。技术爱好者对社会问题的理解简直是无可救药地天真（或自欺欺人）。他们没有意识到（或故意视而不见）这样一个事实：当巨大的变化，即使是看上去有利的变化，被引入一个社会时，将会引发一长串其他变化，这些变化之中的大都分是不可预见的其结果则是社会的混乱。因此，技术爱好者们在试图消灭贫穷和疾病，设计制造驯顺、快乐的人格等等时，很可能会创造出比现在还糟糕的社会体系。例如，科学家们吹嘘说他们能够创造出新的、经遗传工程改造的粮食植物以消灭饥荒。然而，这将会允许人口无限膨胀下去，而众所周知，拥挤会导致紧张和攻击性的增强。这仅仅是技术会导致的可预见问题中的一个例子。我们强调指出，历史经验告诉我们，技术进步给社会带来新问题的速度远比它解决旧问题的速度要快。因此技术爱好者们要经过一个漫长的试错时期才能够为他们的美丽新世界排除掉所有的故障（假设他们最终能做到的话）。而与此同时所产生的痛苦将会如此巨大，以至于体系生存下去所带来的痛苦不见得就比体系崩溃更少。技术己将人类带入了一条无法轻易逃脱的死胡同。 更好的办法是把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。 现在的两个主要任务是在工业社会中促进社会紧张与不稳定，以及宣传一种反对技术和工业体系的意识形态。当体系变得足够紧张和不稳定时，一场反对技术的革命就有机会发动了。这一模式将十分类似于法国和俄国革命。在两国各自革命之前的几十年里，法国和俄国社会都显示出了越来越多的紧张与脆弱迹象。同时，提供一个与旧世界完全不同的新世界愿景的意识形态发展了起来。以俄国的情况为例，革命者积极从事于破坏旧秩序的工作。然后当旧体系面临着足够的额外紧张时（法国是财政危机，俄国是军事失败），它就会被革命一扫而光。我们预想的就是这样的道路。 大多数革命都有两个目标，一个目标是摧毁一个旧社会，另一个目标是建立革命者想像的新社会。法国和俄国的革命者没有能够成功地建立他们所梦想的新社会（这是十分幸运的事），但她们非常成功地摧毁了既存社会。 然而，一种意识形态如想争取到热情支持，除了负面理想外必须还有正面理想，决不能只破不立。我们的正面理想是自然，即野生自然，按照其本来面目运行的地球，不依赖于人类管理、摆脱人类干涉和控制的地球生灵。我们的野生自然也包括人类本性，即不受有组织社会管制、自主运行的个人，成为偶然性或自由意志或上帝（由你的宗教或哲学观念）的产物。 一个社会的经济与技术结构在决定一般人的生活方式方面远比政治结构更加重要。 我们不应主张无力或消极，我们应主张打破工业体系的权力，而这将大大增加个人和小群体的权力和自由。 （据称）贯穿整个历史，技术都是进步的，从未退步过，因此技术退步是不可能的。但这并非事实。对于”进步”的热情是现代社会形态的特殊现象，在大约十七世纪之前并不存在。 导言 1.工业革命及其后果对于人类是一场灾难。工业革命大大延长了我们这些“发达”国家的人的预期寿命了，但也使得社会变得不稳定，人类丧尸尊严，导致了广泛的心里痛苦(在第三世界则还包括胜利痛苦)，并给自然界带来严重破坏。技术的持续进步将使情况变得更糟。技术进步将必然导致人类的进一步屈辱和自然界的进一步破坏，技术进步也很可能导致社会的进一步瓦解和人类更深重的心理痛苦，它甚至在“发达”国家也很可能导致生理痛苦。2.工业–技术体系有可能存在下去，也有可能崩溃。如其存在下去，这一体系最终可能达到一个较少造成人类身心痛苦的境界，但这必须经历一个长期而痛苦的调整过程，且其代价是人类及其他许多生命体被贬低到仅仅是设计制造的产品或社会机器上的一个齿轮的地步。尤其是，如其幸存，那么，我们绝无改革或调整以防止其剥夺人类尊严及自治之道。3.如其崩溃，其后果亦将十分痛苦。然而，这一体系发展得越庞大，其崩溃之后果就越可怕，因此，如其必然崩溃，则越早越好。4.因此，我们主张进行革命以推翻工业体系。这一革命可以使暴力的，也可以是非暴力的;可以使突变的，也可以是有一个数十年渐进的过程。我们无法预言。但我们可以大致勾勒出憎恨工业体系的人们为铺平这一革命道路所应采取的行动的大致框架。浙江不是一场政治革命。这场革命的目标将不是推翻政府，而是摒除现存社会的经济及技术基础。5.在本文中，我们将仅仅集中论述工业–技术体系所带来的一部分负面发展。但这并不是说那些我们一大而过或干脆忽略的发展就不重要。为了注重实效，我们须将讨论集中到那些未受公众充分关注或我们另有创见的领域。例如，环境及野生动物保护运动已十分成熟，我们就不再赘言这些问题，尽管我们认为这些问题十分重要。 现代左派心理学 6.我们生活在一个陷入深重困境的社会，几乎没有人怀疑这点。我们这个世界的疯狂病症的最广为传播的表现之一就是左翼思想，因此，有关左派心理学的讨论可以作为讨论现代社会一般问题的入手点。7.然而，什么是左翼思想?20世纪上半叶，左翼思想可以说就是社会主义。今天的左派分裂了，谁是左派也不十分清楚了。在本文中，当我们使用“左派”这个字眼时，我们主要是指社会主义者，集体主义者，“政治正确性”的倡导者，女权主义者，同性恋者、残疾人活动积极分子、动物权益保护主义者等等。但并不是这些活动中的每一个人都是左派。我们在讨论左翼思想时，所指的对象与其说是一种运动或意识形态，不如说是一种心理类型，或者说一组相关的心理类型。(请参看227-230段)8.即使如此，我们关于左派的概念仍旧是模糊不清的，这是没有办法的事情。我们只是想大致指出两类我们认为是现代左派的主要驱动力的心理倾向。我们绝未声称我们涵盖了全部左派心理学。至于在多大程度上我们的讨论适用于19世纪及20世纪前叶的左派，我们暂且不下结论。9.我们将现代左派两种内在心理倾向称为“自卑感”(feelings of inferiority)和“过度社会化”(oversocialization)。自卑感是现代左派的整体特性，而过度社会化则仅仅是其中一部分的特性，但这一部分是影响特别大的一部分。 自卑感 10.我们是在广义上使用“自卑感”这个词的，它意指缺乏自尊心，无力感，抑郁倾向、失败主义、负罪感、自我厌憎等等。我们认为现代左派具有这些心理感觉(有可能多多少少受到一些抑制)，而这些心理感觉决定了现代左派的方向。11.如果某个人把几乎所有涉及到他(或他认同的群体)的表述都解读成贬损，那么我们可以确认，这个人有自卑感或缺乏自尊心。这种倾向在少数民族权利支持者之中特别显著，无论他们本人是否属于少数民族。他们对于标识少数民族的词汇超度敏感。“黑人”(negro)、“东方人”(oriental)、“残废”(handicapped)或“小妞”这些词汇无非是指非洲人、亚洲人、残疾人(disabled)或女人，原本并无贬损的内涵。“娘们”(broad)和“小妞”(chick)只不过是“家伙”(guy)、“汉子”(dude)、“哥们”(fellow)的女性对应词。其负面内涵是那些活动分子们自己加上的。某些动物权益保护主义者居然不准使用“宠物”(pet)这个字眼，而坚持改称“动物伴侣”(animal companion)。左派人类学家在谈及原始民族时费尽心机避免使用任何可作负面解释的字眼。他们要用“不是用文字的”(nonliterate)来取代“原始”(primitive)这个词。他们对任何有可能暗示原始文化比我们低劣的说法害怕到了变态偏执的地步。(我们并不是说原始文化比我们低劣，我们仅仅是指出左派人类学家的超敏感性。)12.那些对于“真智商不正确(politically incorrect)”术语最敏感的人并不是普通的贫民窟里的黑人、亚洲移民、受虐待的妇女或残疾人，而是少数活动分子。他们之中的许多人并不属于任何“受压迫”的群众，而是来自社会的特权阶层。政治正确性(political correctness)在大学教授之中有着牢固的基础，这些教授有着安全的就业保障和可过舒适生活的收入，其中大多数人是异性恋、白人、来自中产阶级家庭。13.许多左派对那些有着弱者(妇女)、失败者(印第安人)、受排斥者(同性恋)等低劣形象的群体的问题高度认同。其实，这些左派自己觉得这些群体是低劣的。他们当然不会承认这一点，但他们确确实实是因为他们自己把这些群体看作是低劣的才认同与这些群体的问题的。(我们并没有说妇女、印第安人等等是低劣的，我们只是说明左派心理学的一个方面。)14.女权主义者们几近绝望地想证明妇女与男子一样强，一样有能力。很明显，这只不过是因为他们被妇女很可能不如男子强、不如男子有能力的恐惧所困扰。15.左派仇恨所有有着强大、优秀、成功的形象的东西。他们恨美国、恨西方文明、恨白人男子、恨理性。他们仇恨西方等事物的真实动机绝非他们所声称的那些理由。他们说他们之所以仇恨西方是因为西方好战、帝国主义、性别歧视、种族中心等等。但当社会主义国家和原始文化也存在同样的毛病时，左派却为他们找借口，或至多不情愿地承认这些问题存在;而当西方文明存在这些毛病时，左派就会十分起劲并且时常是竭力夸大的到处宣扬。因此我们可以断定，这些毛病并不是左派仇恨美国和西方的真实原因，真实原因是美国和西方的强大和成功。16.在自由派和左派的语汇中，很少有“自信”、“自力更生”、“首创”、“进取”、“乐观主义”等词汇的地位。左派反对个人主义而提倡集体主义。他们要求社会满足每一个人的需求，照顾每一个人。他们内心不相信一个人有能力解决自己的问题、满足自己的需求。左派抗拒竞争的概念，因为在内心深处，他们觉得自己是失败者。17.现代左派知识分子所喜爱的艺术形式热衷于表现污秽、失败和绝望，再不然就是纵欲狂欢，把任何理性的控制抛到一旁，似乎理性不可能有任何造就，唯有沉溺于当下的感官刺激。18.现代左派哲学家往往摒弃理性、科学、客观现实，而坚持任何事物都具有文化相对性。人们当然可以严肃地质疑科学知识的基础，可以质疑如何界定客观现实的概念。然而十分明显，现代左派哲学家并非头脑冷静的逻辑学家，他们并不系统的分析知识的基础。他们之所以攻击真理和现实是由于深陷于感情冲动而不能自拔。他们攻击真理和现实是出于自己的心理需求。他们的攻击从某种角度说是发泄敌意，将敌意发泄出来可以满足他们的权力欲。尤其重要的是，科学和理性把一些信念划分为真(也就是成功的、优越的)，另一些信念划分为假(也就是失败的、低劣的)，因此做派仇恨科学和理性。左派的自卑感几臻于极致，他们甚至忍受不了对事物做任何成败和优劣的划分。这也是许多左派不承认精神病和反对智商测验的原因。左派反对对人类的能力和行为作遗传学解释，因为这类解释使得一部分人显得优于或劣于其他人。左派往往将个人的能力大小归因于社会。这样，如果一个人“”低劣，则过错就不再与他而在于社会，在于他的成长环境。19.有些自卑者变成了自吹自擂者，恃强凌弱者、无情竞争者。这类人并未完全丧失自信。而左派则连这些人也不如。左派感觉不到自我的力量和价值，却还自认为有能力成为强者，而他们的令人讨厌的行为就出自其力图使自己成为强者的努力。[1]但他们的自卑感是如此根深蒂固，以至于他们无法想象自己个人可以成为强者或有价值的人。所以左派是集体主义者。他们只有在作为一个大组织或一场大运动中的一员时才感觉到自己是强者。20.请主义左派战术的受虐狂倾向。左派躺在车轮子前面进行抗议，他们故意挑逗警察和种族主义分子虐待自己。这些战术往往可能是有效的，但许多左派使用这些战术并不是因为她们是达到目的的手段，而是因为他们喜欢受虐战术。自我憎恨也是左派的一个特点。21.左派可以宣称他们的行动主义是出于同情心或道德原则的感召。确实，对于那些过度社会化类型的左派，道德原则起了一定作用。但同情心和道德原则并非左派行动主义的主要动机。敌意是左派行为的极为重要的组成部分，海游权力欲。尤其是，许多左派行为并不是经过理性计算来为他们声称要帮助的人们谋划的。例如，有人相信反歧视行动有利于黑人，然而，以充满敌意和冥顽不化的方式推行反歧视运动又能有什么意义?显然，至少在口头上或符号上，对那些认为受到反歧视行为的歧视的白人群众做一些让步之类的外交和安抚会更有效一些。但左派行动主义者们不干，因为这满足不了他们的感情需求。帮助黑人不是他们的真实目标。种族问题只是他们发泄自己的敌意和受挫的权力欲的一个借口。他们这样做实际上是损害了黑人，因为行动主义者对白人大多数的敌意会计划种族仇恨。22.即使我们的社会没有任何问题，左派也会发明出问题来给他们提供折腾的借口。23.我们必须强调指出，前面所述并非是对每一个左派的精确描绘。我们只是粗略勾画出左派的一般倾向。 过度社会化 24.心理学家使用“社会化”这个词来描述训练儿童按照社会的要求进行思考和行动的过程。如果一个人相信并遵从他所在社会的道德规范，并且能很好地适应社会，承担某一部分社会功能，我们就说他“社会化的很好”。如果我们说许多左派是过度社会化的，这好像很矛盾，因为人们都认为左派是反叛者。其实，许多左派实际上并不是反叛者。 25.我们社会的道德规范要求极高，以至于没有任何一个人在思考、感觉和行动时完全不违反道德。例如，道德规范要求我们不仇恨任何人，然而，几乎每一个人都在此时或彼时仇恨某个人，无论承认与否。某些人已被高度社会化，试图道德的思考、感觉和行动已经成了他们的一个沉重负担。为了不内疚，他们必须不断的在动机问题上欺骗自己，并且为他们在现实中并不道德的感觉和行为找到道德的解释。我们用“过度社会化”这个词汇来描述这些人. 26.过度社会化导致缺乏自尊心、无力感、失败主义、负罪感等等。我们的社会对儿童进行社会化训练的一个重要手段，就是让他们为自己有悖于社会期待的行为或言论感到羞耻。这一点如果做过了头，一个儿童就会对这种感觉特别敏感，他最后会变得为自己感到羞耻。尤其是，过度社会化的人们的思想与行为比轻度社会化的人们更受社会期待的限制。大多数人都会做不少不规矩的事。他们撒谎、小偷小摸、不遵守交通规则、在工作中偷懒、恨其他人、恶语伤人、背后做手脚把别人拽下来。过度社会化的人不敢做这些事，做了就会感到内疚或自我厌憎。过度社会化的人甚至不能毫不内疚地体验不不道德的想法和感觉;他们根本就不敢想到“不干净”的想法。社会化并不仅仅牵扯到道德，它要求我们遵从的许多行为规范并不能归到道德名下。过度社会化的人被套上了心理枷锁，只能按照社会为他指定的轨道了此一生。这使得许多过度社会化的人感到抑郁和无力，生活成为苦刑。我们认为过度社会化是人类折磨自己同类的酷刑之一。 27.我们认为现代左派之中非常重要、非常有影响的一部分是过度社会化，他们的过度社会化在很大程度上决定了现代左派的方向。过度社会化的左派多半是知识分子或出身于上层阶级的人。请注意大学里的知识分子[3]是我们社会中社会化程度最高的一部分，也是最左倾的部分。 28.过度社会化的左派试图通过反叛来摆脱其心理枷锁并实现自主权(autonomy)，但往往却缺乏反叛社会最基本价值观的力量。一般说来，今天的左派的目标不是与既定道德作斗争，正相反，左派接受既定的道德原则，把这种道德原则看成是自己的，然后指责主流社会违反了这些原则。例子:种族平等、性别平等、帮助穷人、和平反战、非暴力、言论自由、爱护动物;更为基本的:个人服务社会与社会照顾个人。所有这些都是我们社会(至少是中、上层阶级)长久以来的深层价值观。这些价值观都是由主流媒体和教育体制直接或间接地灌输给我们的。左派，尤其是过度社会化类型的左派，往往并不反叛这些原则，而是声称(倒也不失正确)社会没能实现这些原则，以此作为他们对于社会抱有敌意的正当理由. 29.这里举一个实例来说明，过度社会化的左派实际上与我们社会的常规难舍难分，却假装反叛者。许多左派一再要求反歧视行动，要求把黑人提升到高位，要求改善黑人学校的教育并投入更多的经费;他们把黑人“下层阶级”的生活方式看作是社会的耻辱。他们要求将黑人整合进体制，把黑人变成企业主管、律师、科学家，就像上中阶级的白人一样。左派声称他们决不想把黑人变成白人的复制品;他们是要保留非洲裔美国人的文化。然而，何谈保留非洲裔美国人的文化?除吃点黑人饭、听点黑人音乐、穿点黑人衣服、去几趟黑人教堂或清真寺，哪里还有什么黑人文化?黑人文化只能存在于这些最肤浅的东西之中了。在所有本质方面，多数过度社会化类型的左派都是要把黑人按照白人中产阶级的理想进行改造，他们要黑人学习技术专业，成为企业主管或科学家，把一生耗费在爬地位阶梯上，以证明黑人和白人一样优秀。他们要黑人父亲“负责”，他们要黑人团伙放弃暴力，等等。但是，这些都是不折不扣的工业–技术体系的价值观。这个体系并不在乎一个人听什么音乐，穿什么衣服，信什么宗教，只要他上学，有体面的工作，爬地位阶梯，做“负责”的父亲，非暴力等等。实际上，不管过度社会化的左派如何极力否认，他们是要黑人整合进体制，要黑人接受体制的价值。 30.我们并没有说左派，甚至过度社会化的左派，从未反叛过我们社会的基本价值。显然他们有时候也反叛。某些过度社会化的左派甚至翻盘现代社会最重要的原则，他们甚至诉诸暴力。照他们自己的话说，暴力对于他们是某种形式的“解放”。换句话说，通过暴力行为，他们打破了从小灌输进他们的心理制约。因为他们过度社会化，这些制约对于他们就比别人来得严厉，所以他们需要摆脱它们。然而他们却往往用主流价值来论证自己的反叛的正当性，如果它们使用暴力，他们总是声称他们在与种族主义战斗之类。 31.我们知道可以对前述的丑陋的左派心理学提出多种反论。实际情况十分复杂，即使所需的数据都可以得到，完整的描述也需要更多的笔墨。我们只是非常粗糙的勾画出现代左派的两种心理倾向。 32.左派的问题体现了我们社会整体的问题。缺乏自尊、抑郁倾向和失败主义并不仅仅局限于左派。虽然这些问题在左派身上特别明显，它们却是我们全社会的痼疾。今天的社会对我们进行的社会化的努力比过去的社会更高。我们甚至要有专家来知道如何吃、如何锻炼、如何做爱、如何带孩子等等。 ——Industrial Society and Its Future/希尔多·卡辛斯基(Theodore Kaczynski)]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出REST]]></title>
    <url>%2Fposts%2F46218.html</url>
    <content type="text"><![CDATA[不知你是否意识到，围绕着什么才是实现异构的应用到应用通信的“正确”方式，一场争论正进行的如火如荼：虽然当前主流的方式明显地集中在基于SOAP、WSDL和WS-*规范的Web Services领域，但也有少数人用细小但洪亮的声音主张说更好的方式是REST，表述性状态转移（REpresentational State Transfer）的简称。在本文中，我不会涉及争论的话题，而是尝试对REST和RESTful HTTP应用集成做实用性的介绍。以我的经验，有些话题一旦触及就会引来众多的讨论，当涉及到这方面话题的时候，我会深入详细地阐述。 REST关键原则大部分对REST的介绍是以其正式的定义和背景作为开场的。但这儿且先按下不表，我先提出一个简单扼要的定义：REST定义了应该如何正确地使用（这和大多数人的实际使用方式有很大不同）Web标准，例如HTTP和URI。如果你在设计应用程序时能坚持REST原则，那就预示着你将会得到一个使用了优质Web架构（这将让你受益）的系统。总之，五条关键原则列举如下： 为所有“事物”定义ID 将所有事物链接在一起 使用标准方法 资源多重表述 无状态通信 下面让我们进一步审视这些原则。 为所有“事物”定义ID在这里我使用了“事物”来代替更正式准确的术语“资源”，因为一条如此简单的原则，不应该被淹没在术语当中。思考一下人们构建的系统，通常会找到一系列值得被标识的关键抽象。每个事物都应该是可标识的，都应该拥有一个明显的ID——在Web中，代表ID的统一概念是：URI。URI构成了一个全局命名空间，使用URI标识你的关键资源意味着它们获得了一个唯一、全局的ID。 对事物使用一致的命名规则（naming scheme）最主要的好处就是你不需要提出自己的规则——而是依靠某个已被定义，在全球范围中几乎完美运行，并且能被绝大多数人所理解的规则。想一下你构建的上一个应用（假设它不是采用RESTful方式构建的）中的任意一个高级对象（high-level object），那就很有可能看到许多从使用唯一标识中受益的用例。比如，如果你的应用中包含一个对顾客的抽象，那么我可以相当肯定，用户会希望将一个指向某个顾客的链接，能通过电子邮件发送到同事那里，或者加入到浏览器的书签中，甚至写到纸上。更透彻地讲：如果在一个类似于Amazon.com的在线商城中，没有用唯一的ID（一个URI）标识它的每一件商品，可想而知这将是多么可怕的业务决策。 当面对这个原则时，许多人惊讶于这是否意味着需要直接向外界暴露数据库记录（或者数据库记录ID）——自从多年以来面向对象的实践告诫我们，要将持久化的信息作为实现细节隐藏起来之后，哪怕是刚有点想法都常会使人惊恐。但是这条原则与隐藏实现细节两者之间并没有任何冲突：通常，值得被URI标识的事物——资源——要比数据库记录抽象的多。例如，一个定单资源可以由定单项、地址以及许多其它方面（可能不希望作为单独标识的资源暴露出来）组成。标识所有值得标识的事物，领会这个观念可以进一步引导你创造出在传统的应用程序设计中不常见的资源：一个流程或者流程步骤、一次销售、一次谈判、一份报价请求——这都是应该被标识的事物的示例。同样，这也会导致创建比非RESTful设计更多的持久化实体。 下面是一些你可能想到的URI的例子： 1234http://example.com/customers/1234http://example.com/orders/2007/10/776654http://example.com/products/4554http://example.com/processes/salary-increase-234 正如我选择了创建便于阅读的URI——这是个有用的观点，尽管不是RESTful设计所必须的——应该能十分容易地推测出URI的含义：它们明显地标识着单一“数据项”。但是再往下看： 12http://example.com/orders/2007/11http://example.com/products?color=green 首先，这两个URI看起来与之前的稍有不同——毕竟，它们不是对一件事物的标识，而是对一类事物集合的标识（假定第一个URI标识了所有在2007年11月份提交的定单，第二个则是绿颜色产品的集合）。但是这些集合自身也是事物（资源），也应该被标识。 注意，使用唯一、全局统一的命名规则的好处，既适用于浏览器中的Web应用，也适用于机对机（machine-to-machine，m2m）通信。 来对第一个原则做下总结：使用URI标识所有值得标识的事物，特别是应用中提供的所有“高级”资源，无论这些资源代表单一数据项、数据项集合、虚拟亦或实际的对象还是计算结果等。 将所有事物链接在一起接下来要讨论的原则有一个有点令人害怕的正式描述：“超媒体被当作应用状态引擎（Hypermedia as the engine of application state）”，有时简写为HATEOAS。（严格地说，这不是我说的。）这个描述的核心是超媒体概念，换句话说：是链接的思想。链接是我们在HTML中常见的概念，但是它的用处绝不局限于此（用于人们网络浏览）。考虑一下下面这个虚构的XML片段： 12345&lt;order self=&quot;http://example.com/customers/1234&quot;&gt; &lt;amount&gt;23&lt;/amount&gt; &lt;product ref=&quot;http://example.com/products/4554&quot;&gt; &lt;customer ref=&quot;http://example.com/customers/1234&quot;&gt; &lt;/customer&gt; &lt;/product&gt;&lt;/order&gt; 如果你观察文档中product和customer的链接，就可以很容易地想象到，应用程序（已经检索过文档）如何“跟随”链接检索更多的信息。当然，如果使用一个遵守专用命名规范的简单“id”属性作为链接，也是可行的——但是仅限于应用环境之内。使用URI表示链接的优雅之处在于，链接可以指向由不同应用、不同服务器甚至位于另一个大陆上的不同公司提供的资源——因为URI命名规范是全球标准，构成Web的所有资源都可以互联互通。 超媒体原则还有一个更重要的方面——应用“状态”。简而言之，实际上服务器端（如果你愿意，也可以叫服务提供者）为客户端（服务消费者）提供一组链接，使客户端能通过链接将应用从一个状态改变为另一个状态。稍后我们会在另一篇文章中探究这个方面的影响；目前，只需要记住：链接是构成动态应用的非常有效的方式。 对此原则总结如下：任何可能的情况下，使用链接指引可以被标识的事物（资源）。也正是超链接造就了现在的Web。 使用标准方法在前两个原则的讨论中暗含着一个假设：接收URI的应用程序可以通过URI明确地做一些有意义的事情。如果你在公共汽车上看到一个URI，你可以将它输入浏览器的地址栏中并回车——但是你的浏览器如何知道需要对这个URI做些什么呢？ 它知道如何去处理URI的原因在于所有的资源都支持同样的接口，一套同样的方法（只要你乐意，也可以称为操作）集合。在HTTP中这被叫做动词（verb），除了两个大家熟知的（GET和POST）之外，标准方法集合中还包含PUT、DELETE、HEAD和OPTIONS。这些方法的含义连同行为许诺都一起定义在HTTP规范之中。如果你是一名OO开发人员，就可以想象到RESTful HTTP方案中的所有资源都继承自类似于这样的一个类（采用类Java、C#的伪语法描述，请注意关键的方法）： 1234567class Resource &#123; Resource(URI u); Response get(); Response post(Request r); Response put(Request r); Response delete();&#125; 由于所有资源使用了同样的接口，你可以依此使用GET方法检索一个表述（representation）——也就是对资源的描述。因为规范中定义了GET的语义，所以可以肯定当你调用它的时候不需要对后果负责——这就是为什么可以“安全”地调用此方法。GET方法支持非常高效、成熟的缓存，所以在很多情况下，你甚至不需要向服务器发送请求。还可以肯定的是，GET方法具有幂等性[译注：指多个相同请求返回相同的结果]——如果你发送了一个GET请求没有得到结果，你可能不知道原因是请求未能到达目的地，还是响应在反馈的途中丢失了。幂等性保证了你可以简单地再发送一次请求解决问题。幂等性同样适用于PUT（基本的含义是“更新资源数据，如果资源不存在的话，则根据此URI创建一个新的资源”）和DELETE（你完全可以一遍又一遍地操作它，直到得出结论——删除不存在的东西没有任何问题）方法。POST方法，通常表示“创建一个新资源”，也能被用于调用任意过程，因而它既不安全也不具有幂等性。 如果你采用RESTful的方式暴露应用功能（如果你乐意，也可以称为服务功能），那这条原则和它的约束同样也适用于你。如果你已经习惯于另外的设计方式，则很难去接受这条原则——毕竟，你很可能认为你的应用包含了超出这些操作表达范围的逻辑。请允许我花费一些时间来让你相信不存在这样的情况。 来看下面这个简单的采购方案例子： 可以看到，例子中定义了两个服务程序（没有包含任何实现细节）。这些服务程序的接口都是为了完成任务（正是我们讨论的OrderManagement和CustomerManagement服务）而定制的。如果客户端程序试图使用这些服务，那它必须针对这些特定接口进行编码——不可能在这些接口定义之前，使用客户程序去有目的地和接口协作。这些接口定义了服务程序的应用协议（application protocol）。 在RESTful HTTP方式中，你将通过组成HTTP应用协议的通用接口访问服务程序。你可能会想出像这样的方式： 可以看到，服务程序中的特定操作被映射成为标准的HTTP方法——为了消除歧义，我创建了一组全新的资源。“这是骗人的把戏”，我听见你叫嚷着。不，这不是欺骗。标识一个顾客的URI上的GET方法正好相当于getCustomerDetails操作。有人用三角形形象化地说明了这一点： 把三个顶点想象为你可以调节的按钮。可以看到在第一种方法中，你拥有许多操作，许多种类的数据以及固定数量的“实例”（本质上和你拥有的服务程序数量一致）。在第二种方法中，你拥有固定数量的操作，许多种类的数据和许多调用固定方法的对象。它的意义在于，证明了通过这两种方式，你基本上可以表示任何你喜欢的事情。 为什么使用标准方法如此重要？从根本上说，它使你的应用成为Web的一部分——应用程序为Web变成Internet上最成功的应用所做的贡献，与它添加到Web中的资源数量成比例。采用RESTful方式，一个应用可能会向Web中添加数以百万计的客户URI；如果采用CORBA技术并维持应用的原有设计方式，那它的贡献大抵只是一个“端点（endpoint）”——就好比一个非常小的门，仅仅允许有钥匙的人进入其中的资源域。 统一接口也使得所有理解HTTP应用协议的组件能与你的应用交互。通用客户程序（generic client）就是从中受益的组件的例子，例如curl、wget、代理、缓存、HTTP服务器、网关还有Google、Yahoo!、MSN等等。 总结如下：为使客户端程序能与你的资源相互协作，资源应该正确地实现默认的应用协议（HTTP），也就是使用标准的GET、PUT、POST和DELETE方法。 资源多重表述到目前为止我们一直忽略了一个稍微复杂的问题：客户程序如何知道该怎样处理检索到的数据，比如作为GET或者POST请求的结果？原因是，HTTP采取的方式是允许数据处理和操作调用之间关系分离的。换句话说，如果客户程序知道如何处理一种特定的数据格式，那就可以与所有提供这种表述格式的资源交互。让我们再用一个例子来阐明这个观点。利用HTTP内容协商（content negotiation），客户程序可以请求一种特定格式的表述： 123GET /customers/1234 HTTP/1.1Host: example.com Accept: application/vnd.mycompany.customer+xml 请求的结果可能是一些由公司专有的XML格式表述的客户信息。假设客户程序发送另外一个不同的请求，就如下面这样： 123GET /customers/1234 HTTP/1.1Host: example.com Accept: text/x-vcard 结果则可能是VCard格式的客户地址。（在这里我没有展示响应的内容，在其HTTP Content-type头中应该包含着关于数据类型的元数据。）这说明为什么理想的情况下，资源表述应该采用标准格式——如果客户程序对HTTP应用协议和一组数据格式都有所“了解”，那么它就可以用一种有意义的方式与世界上任意一个RESTful HTTP应用交互。不幸的是，我们不可能拿到所有东西的标准格式，但是，或许我们可以想到在公司或者一些合作伙伴中使用标准格式来营造一个小环境。当然以上情况不仅适用于从服务器端到客户端的数据，反之既然——倘若从客户端传来的数据符合应用协议，那么服务器端就可以使用特定的格式处理数据，而不去关心客户端的类型。 在实践中，资源多重表述还有着其它重要的好处：如果你为你的资源提供HTML和XML两种表述方式，那这些资源不仅可以被你的应用所用，还可以被任意标准Web浏览器所用——也就是说，你的应用信息可以被所有会使用Web的人获取到。 资源多重表述还有另外一种使用方式：你可以将应用的Web UI纳入到Web API中——毕竟，API的设计通常是由UI可以提供的功能驱动的，而UI也是通过API执行动作的。将这两个任务合二为一带来了令人惊讶的好处，这使得使用者和调用程序都能得到更好的Web接口。 总结：针对不同的需求提供资源多重表述。 无状态通信无状态通信是我要讲到的最后一个原则。首先，需要着重强调的是，虽然REST包含无状态性（statelessness）的观念，但这并不是说暴露功能的应用不能有状态——事实上，在大部分情况下这会导致整个做法没有任何用处。REST要求状态要么被放入资源状态中，要么保存在客户端上。或者换句话说，服务器端不能保持除了单次请求之外的，任何与其通信的客户端的通信状态。这样做的最直接的理由就是可伸缩性——如果服务器需要保持客户端状态，那么大量的客户端交互会严重影响服务器的内存可用空间（footprint）。（注意，要做到无状态通信往往需要需要一些重新设计——不能简单地将一些session状态绑缚在URI上，然后就宣称这个应用是RESTful。） 但除此以外，其它方面可能显得更为重要：无状态约束使服务器的变化对客户端是不可见的，因为在两次连续的请求中，客户端并不依赖于同一台服务器。一个客户端从某台服务器上收到一份包含链接的文档，当它要做一些处理时，这台服务器宕掉了，可能是硬盘坏掉而被拿去修理，可能是软件需要升级重启——如果这个客户端访问了从这台服务器接收的链接，它不会察觉到后台的服务器已经改变了。 理论上的REST我承认：以上我所说的REST不是真正的REST，而且我可能有点过多地热衷于简单化。但因为我想有一个与众不同的开场，所以没有在一开始就介绍其正式的定义和背景。现在就让我们稍微简要地介绍一下这方面的内容。 首先，先前我并没有明确地区分HTTP、RESTful HTTP和REST。要理解这些不同方面之间的关系，我们要先来看看REST的历史。 Roy T. Fielding在他的博士学位论文（实际上你应该访问这个链接——至少对于一篇学术论文来说，它是相当易读的。此论文已被翻译成中文）中定义了术语REST。Roy曾是许多基本Web协议的主要设计者，其中包括HTTP和URIs，并且他在论文中对这些协议提出了很多想法。（这篇论文被誉为“REST圣经”，这是恰当的——毕竟，是作者发明了这个术语，所以在定义上，他写的任何内容都被认为是权威的。）在论文中，Roy首先定义一种方法论来谈论架构风格——高级、抽象的模式，来表达架构方法背后的核心理念。每一个架构风格由一系列的约束（constraints）定义形成。架构风格的例子包括“没有风格”（根本没有任何约束）、管道和过滤器（pipe and filter）、客户端/服务器、分布式对象以及——你猜到它了——REST。 如果对你来说这些听起来都太抽象了，那就对了——REST在本质上是一个可以被许多不同技术实现的高层次的风格，而且可以被实例化——通过为它的抽象特性赋上不同的值。比如，REST中包含资源和统一接口的概念——也就是说，所有资源都应该对这些相同的方法作出反应。但是REST并没有说明是哪些方法，或者有多少方法。 REST风格的一个“化身”便是HTTP（以及一套相关的一套标准，比如URI），或者稍微抽象一些：Web架构自身。接着上面的例子，HTTP使用HTTP动词作为REST统一接口的“实例”。由于Fielding是在Web已经（或者至少是大部分）“完善”了之后才定义的REST风格，有人可能会争论两者是不是100%的匹配。但是无论如何，整体上来说Web、HTTP和URI仅仅是REST风格的一个主要实现。不过，由于Roy Fielding即是REST论文的作者，又对Web架构设计有过深远的影响，两者相似也在情理之中。 最后，我在前面一次又一次地使用着术语“RESTful HTTP”，原因很简单：许多使用HTTP的应用因为一些理由并没有遵循REST原则，有人会说使用HTTP而不遵循REST原则就等同于滥用HTTP。当然这听起来有点狂热——事实上违反REST约束的原因通常是，仅仅因为每个约束带来的设计权衡可能不适合于一些特殊情况。但通常，违背REST约束的原因可归咎于对其好处认知的缺乏。来看一个明显的反面案例：使用HTTP GET调用类似于删除对象的操作，这违反了REST的安全约束和一般性常识（客户程序不应为此负责，服务器端开发人员大概不是有意而为之）。但在随后的文章中，我会提及更多这样或那样的对HTTP的滥用。 总结本文试图对REST（Web架构）背后的概念提供快速的介绍。RESTful HTTP暴露功能的方式与RPC、分布式对象以及Web Services是不相同的；要真正理解这些不同是需要一些心态的转变。不管你构建的应用是仅仅想暴露Web UI还是想把API变成Web的一份子，了解下REST的原则还是有好处的。 Stefan Tilkov是InfoQ SOA社区的首席编辑，并且是位于德国和瑞士的innoQ公司的共同创始人、首席顾问和REST狂热分子首领。 查看英文原文：A Brief Introduction to REST]]></content>
      <categories>
        <category>rest</category>
      </categories>
      <tags>
        <tag>rest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST客户端编程实例]]></title>
    <url>%2Fposts%2F14233.html</url>
    <content type="text"><![CDATA[导读JAX-RS 2.0 又称 JSR 339 不仅定义了一套用于构建 RESTful 网络服务的 API，同时也通过增强客户端 API 功能简化了REST 客户端的构建过程。 JAX-RS: Java API for RESTful Web Services是一个Java编程语言的应用程序接口,支持按照 表象化状态转变 (REST)架构风格创建Web服务Web服务[1]. JAX-RS使用了Java SE 5引入的Java 标注来简化Web服务客户端和服务端的开发和部署 [wikipedia]。 在下面的教程中，我们将为一个预先设置好的 REST 服务构建一个客户端，并在这个过程中探索新的构建选项。例如，如何处理同步或者异步的请求，如何给一个请求注册一个回调，如何指定调用对象来构建一个请求使得请求可以被延迟执行。再或者比如，如何使用客户端请求和相应的过滤方法来过滤客户端与服务器之前的通信。 我们开始吧对于想要重建下述客户端例子的读者，我已经使用 Maven 创建好了一个完整的 RESTful 网络服务程序。程序中有内嵌的应用程序服务器，以及一个可独立运行的应用服务器 （war-file 可以通过下文中的下载地址获取）。 请根据下面的一系列命令来下载并启动 REST 服务器 （下载所有依赖可能会耗费些时间……）： 1clone https://bitbucket.org/hascode/jaxrs2-client-tutorial.git &amp;&amp; cd jaxrs2-client-tutorial &amp;&amp; make rest-server 现在，让我们先来看看这个 REST 服务的一些实现细节和我们的客户端示例中要用到的对象。如果你对这些没什么兴趣，大可以略过服务端的细节直接去看客户端示例。 REST 服务下面的代码就是个客户端提供服务的 REST 服务。这里的 BookRepository 就是一个由 @Singleton 和 @Startup 修饰的简单 session bean，这个 bean 用来模拟存储或获取 Book Entity。服务对外提供了保存一本书、删除一本书、根据标识查找书籍和获取所有可用书籍的接口。当一本书被保存在服务端时，服务器会为该书生成一个 id，并会返回一个 entity 或一组 entity 的 JSON 数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hascode.tutorial.jaxrs.server;import java.util.List;import javax.ejb.EJB;import javax.ejb.Stateless;import javax.ws.rs.Consumes;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.PathParam;import javax.ws.rs.Produces;import javax.ws.rs.core.GenericEntity;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import com.hascode.tutorial.jaxrs.entity.Book;@Stateless@Path("/book")public class BookStoreService &#123; @EJB private BookRepository bookRepository; @POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response saveBook(final Book book) &#123; Book bookPersisted = bookRepository.saveBook(book); return Response.ok(bookPersisted).build(); &#125; @DELETE @Path("/&#123;id&#125;") public Response deleteBook(final @PathParam("id") String id) &#123; bookRepository.deleteBook(id); return Response.ok().build(); &#125; @GET @Produces(MediaType.APPLICATION_JSON) public Response getAll() &#123; List&lt;Book&gt; books = bookRepository.getAll(); GenericEntity&lt;List&lt;Book&gt;&gt; bookWrapper = new GenericEntity&lt;List&lt;Book&gt;&gt;(books) &#123;&#125;; return Response.ok(bookWrapper).build(); &#125; @GET @Path("/&#123;id&#125;") @Produces(MediaType.APPLICATION_JSON) public Response getById(final @PathParam("id") String id) &#123; Book book = bookRepository.getById(id); return Response.ok(book).build(); &#125;&#125; 备注：我修改了应用服务器，以便使用 Jackson 提供的服务发现机制处理 JSON 数据。 Book Entity下面代码中的 bean 就是贯穿本教程的 Book Entity，它包含id、书名、价格和出版日期属性。 12345678910111213141516package com.hascode.tutorial.jaxrs.entity;import java.io.Serializable;import java.math.BigDecimal;import java.util.Calendar;public class Book implements Serializable &#123; private static final long serialVersionUID = 1L; private String id; private String title; private BigDecimal price; private Calendar published; // getter+setter..&#125; 创建并绑定一个客户端我们可以创建一个 REST 客户端，将其绑定到一个特定的目标 URL 上。并且为它指定专属的、参数化的路径。具体步骤如下： 通过 ClientBuilder 获取一个客户端的引用：*Client client = ClientBuilder.newClient();* 使用 target() 方法将客户端绑定到 REST 服务上提供的某个 URL：*client.target(“http://localhost:8080/myrestservice”);* 通过 path() 和 resolveTemplate() 方法来处理动态的 URL 路径参数：*client.target(..).path(“{id}”).resolveTemplate(“id”, someId);* 使用 request() 函数来初始化一个请求并用后续的 post 或者 get 等方法来指定请求的类型，例如：client.target(..).request().get(); 每一步都提供了多样的可选择的参数和配置选项，稍后的教程中我将用到其中的一些配置像异步请求、回调处理、还有过滤器注册和特性类等。 现在，让我们先看一些具备说明性的例子。 客户端例子由于我把所有客户端示例都融进了 jUnit 和 Hamcrest 驱动的测试用例，因此下面的代码实际上在每一个测试用例中都有使用。不过为了让文章尽量简练，重复代码将在后面的代码示例中省略。 12345678910111213141516private static final String REST_SERVICE_URL = "http://localhost:8080/tutorial/rs/book";private static final String TITLE = "One big book";private static final BigDecimal PRICE = new BigDecimal("20.0");private static final GregorianCalendar PUBLISHED = new GregorianCalendar(, 12, 24);Client client = ClientBuilder.newClient().register(JacksonFeature.class);public Book mockBook() &#123; Book book = new Book(); book.setTitle(TITLE); book.setPrice(PRICE); book.setPublished(PUBLISHED); return book;&#125; 唯一值得注意的是，我在客户端运行时中加入了 Jackson 框架，因此可以通过 javax.ws.rs.client.ClientBuilder 来获取客户端实例。 Maven 整合所有代码示例运行都需要用到下面依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 基础操作下面的示例中我们首先将一个书本实体的信息序列化成 JSON 格式，通过 POST 请求发送到服务端来保存这本书。 之后，我们使用客户端提供的 path() 和 resolveTemplate() 方法通过匹配服务端返回值的协议来获取该本书的标识。 第三步， 我们获取所有可用图书的列表，并在最后删除掉刚才保存的那本书。 1234567891011121314151617181920212223242526272829303132333435@Testpublic void crudExample() &#123; // 1. Save a new book Book book = mockBook(); Book bookPersisted = client .target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); // 2. Fetch book by id Book book2 = client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().get(Book.class); assertThat(book2, notNullValue()); assertThat(book2.getTitle(), equalTo(TITLE)); assertThat(book2.getPrice(), equalTo(PRICE)); assertThat(book2.getPublished().getTime(), equalTo(PUBLISHED.getTime())); // 3. Fetch all books GenericType&lt;List&lt;Book&gt;&gt; bookType = new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;; // generic type to wrap a generic list of books List&lt;Book&gt; books = client.target(REST_SERVICE_URL).request() .get(bookType); assertThat(books.size(), equalTo(1)); // 4. Delete a book client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().delete(); List&lt;Book&gt; books2 = client.target(REST_SERVICE_URL).request() .get(bookType); assertThat(books2.isEmpty(), equalTo(true));&#125; 异步处理只要给请求构造器加一个简单的 async() 方法，我们就可以使用 Java 的 Future API 提供的多种途径来异步地处理请求。 下面的例子中，我们在第一个请求中添加一本书，然后再删除它。最后获取所有可用图书的列表。 1234567891011121314151617181920212223242526@Testpublic void asyncExample() throws Exception &#123; Book book = mockBook(); Future&lt;Book&gt; fb = client .target(REST_SERVICE_URL) .request() .async() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); Book bookPersisted = fb.get(); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().async().delete() .get(); Future&lt;List&lt;Book&gt;&gt; bookRequest = client.target(REST_SERVICE_URL) .request().async().get(new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;); List&lt;Book&gt; books2 = bookRequest.get(); assertThat(books2.isEmpty(), equalTo(true));&#125; 发起回调在客户端与服务器通信过程中，我们还有另一种方式可以对服务器的相应进行修改，那就是在请求中加入一个 InvocationCallback 回调处理。 可以看到，下面代码段中有着很多缩进那部分就是我们的回调函数了，这些回调可以打印保存成功的图书的完整信息，或者在出现错误的情况下则打印错误和堆栈信息。 123456789101112131415161718192021222324252627282930313233343536@Testpublic void invocationCallbackExample() throws Exception &#123; Book book = mockBook(); client.target(REST_SERVICE_URL) .request() .async() .post(Entity.entity(book, MediaType.APPLICATION_JSON), new InvocationCallback&lt;Book&gt;() &#123; @Override public void completed(final Book bookPersisted) &#123; System.out.println("book saved: " + bookPersisted); assertThat(bookPersisted.getId(), notNullValue()); &#125; @Override public void failed(final Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;).get(); client.target(REST_SERVICE_URL).request().async() .get(new InvocationCallback&lt;List&lt;Book&gt;&gt;() &#123; @Override public void completed(final List&lt;Book&gt; books) &#123; System.out.println(books.size() + " books received"); assertThat(books.size(), greaterThanOrEqualTo(1)); &#125; @Override public void failed(final Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;).get();&#125; 延迟调用 / 请求构建通过 javax.ws.rs.client.Invocation 类，我们可以先构建一个请求而不用即时发送。这个请求可以是同步的, 也可以是异步的。 在下面的示例中，我们构建了两个调用但并不马上使用—— 一个请求用来保存图书，另一个请求则是获取所有可用的图书。然后，我们在后面调用时才使用这两个构建好的请求。 我们应当使用 invoke() 方法来同步地调用一个请求。当需要使用异步请求时，则需要用 submit() 方法——两种调用都会返回一个 javax.ws.rs.core.Response 对象。如果调用者在调用参数中给定了返回实体的类，则上述方法会返回该类。 1234567891011121314151617181920@Testpublic void requestPreparationExample() throws Exception &#123; Book book = mockBook(); Invocation saveBook = client.target(REST_SERVICE_URL).request() .buildPost(Entity.entity(book, MediaType.APPLICATION_JSON)); Invocation listBooks = client.target(REST_SERVICE_URL).request() .buildGet(); Response response = saveBook.invoke(); Book b1 = response.readEntity(Book.class); // alternative: Book b1 = saveBook.invoke(Book.class); assertThat(b1.getId(), notNullValue()); // async invocation Future&lt;List&lt;Book&gt;&gt; b = listBooks.submit(new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;); List&lt;Book&gt; books = b.get(); assertThat(books.size(), greaterThanOrEqualTo(2));&#125; 客户端请求过滤器JAX-RS 允许我们使用请求过滤器来截获客户端发送到服务器的请求。 为了达成这个目标，只需要实现 javax.ws.rs.client.ClientRequestFilter 这个接口。当创建客户端时，使用客户端的 register() 方法将 ClientRequestFilter 的具体实现注册到客户端中。 javax.ws.rs.client.ClientRequestContext 对象将赋予访问信息请求足够的权限。 下面就是一个客户端请求过滤的例子。这个例子中，所有客户端发出的 POST 请求中如果包含书籍实体，则书籍价格都会被这个过滤器修改（虽然这不是一个好的实际示例）。对价格的修改则依据相应的税率。 12345678910111213141516171819202122232425package com.hascode.tutorial.client;import java.io.IOException;import java.math.BigDecimal;import javax.ws.rs.client.ClientRequestContext;import javax.ws.rs.client.ClientRequestFilter;import com.hascode.tutorial.jaxrs.entity.Book;public class TaxAdjustmentFilter implements ClientRequestFilter &#123; public static final BigDecimal TAX_RATE = new BigDecimal("2.5"); @Override public void filter(final ClientRequestContext rc) throws IOException &#123; String method = rc.getMethod(); if ("POST".equals(method) &amp;&amp; rc.hasEntity()) &#123; Book book = (Book) rc.getEntity(); BigDecimal priceWithTaxes = book.getPrice().multiply(TAX_RATE); book.setPrice(priceWithTaxes); rc.setEntity(book); &#125; &#125;&#125; 在我们的测试用例中，只要把这个过滤器注册到客户端上，随后就会看到：保存书籍时候，书本的价格就会根据税率进行的调整。 12345678910111213141516171819@Testpublic void clientRequestFilterExample() &#123; Book book = mockBook(); Client client = ClientBuilder.newClient() .register(JacksonFeature.class) .register(TaxAdjustmentFilter.class); Book bookPersisted = client .target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); assertThat(bookPersisted.getPrice(), equalTo(PRICE.multiply(TaxAdjustmentFilter.TAX_RATE)));&#125; 客户端响应过滤器为了获得对服务器相应的控制，有一个十分类似的办法：客户端相应过滤器。 同样地，只要实现 javax.ws.rs.client.ClientResponseFilter 这个接口，就能够修改或者截获服务器返回的响应。 下面这个响应过滤器能够将一些 HTTP 响应头打印到标准输出（STDOUT）： 1234567891011121314151617181920212223242526272829303132package com.hascode.tutorial.client;import java.io.IOException;import java.util.List;import java.util.Map.Entry;import javax.ws.rs.client.ClientRequestContext;import javax.ws.rs.client.ClientResponseContext;import javax.ws.rs.client.ClientResponseFilter;public class ClientResponseLoggingFilter implements ClientResponseFilter &#123; @Override public void filter(final ClientRequestContext reqCtx, final ClientResponseContext resCtx) throws IOException &#123; System.out.println("status: " + resCtx.getStatus()); System.out.println("date: " + resCtx.getDate()); System.out.println("last-modified: " + resCtx.getLastModified()); System.out.println("location: " + resCtx.getLocation()); System.out.println("headers:"); for (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders() .entrySet()) &#123; System.out.print("\t" + header.getKey() + " :"); for (String value : header.getValue()) &#123; System.out.print(value + ", "); &#125; System.out.print("\n"); &#125; System.out.println("media-type: " + resCtx.getMediaType().getType()); &#125;&#125; 要使用这个过滤器，只需要把它注册到我们的客户端程序中： 123456789101112@Testpublic void clientResponseFilterExample() &#123; Book book = mockBook(); Client client = ClientBuilder.newClient() .register(JacksonFeature.class) .register(ClientResponseLoggingFilter.class); client.target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class);&#125; 使用内嵌的 GlassFish 服务，POST 请求将有如下结果： 1234567891011status: 200date: Sat Dec 28 18:50:16 CET 2013last-modified: nulllocation: nullheaders: Date :Sat, 28 Dec 2013 17:50:16 GMT, Transfer-Encoding :chunked, Content-Type :application/json, Server :GlassFish Server Open Source Edition 3.1, X-Powered-By :Servlet/3.0 JSP/2.2 (GlassFish Server Open Source Edition 3.1 Java/Oracle Corporation/1.7),media-type: application 译注：GlassFish是SUN所研发的开放源代码应用服务器，GlassFish以Java编写以增加跨平台性[wikipedia]。 教程源码欢迎下载本教程中的源码，你可以用 Git 来 Fork 或者直接 Clone：Bitbucket代码仓库。 下载 war-File REST 服务器你可以从这里下载 war-file 然后运行自己的 RESTful 服务：https://bitbucket.org/hascode/jaxrs2-client-tutorial/downloads JAX-RS 1.0 and JAX-B如果你对旧版本的协议感兴趣，这篇文章正是你需要的。 翻译： ImportNew.com - 靳禹 译文链接： http://www.importnew.com/8939.html]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>restClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request Mapping 基础用法]]></title>
    <url>%2Fposts%2F47293.html</url>
    <content type="text"><![CDATA[@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上。在这篇文章中，你将会看到 @RequestMapping 注解在被用来进行 Spring MVC 控制器方法的映射可以如何发挥其多才多艺的功能的。 Request Mapping 基础用法在 Spring MVC 应用程序中，RequestDispatcher (在 Front Controller 之下) 这个 servlet 负责将进入的 HTTP 请求路由到控制器的处理方法。 在对 Spring MVC 进行的配置的时候, 你需要指定请求与处理方法之间的映射关系。 要配置 Web 请求的映射，就需要你用上 @RequestMapping 注解。 @RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。 在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。 下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例： 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping("/") String get() &#123; //mapped to hostname:port/home/ return "Hello from get"; &#125; @RequestMapping("/index") String index() &#123; //mapped to hostname:port/home/index/ return "Hello from index"; &#125;&#125; 如上述代码所示，到 /home 的请求会由 get() 方法来处理，而到 /home/index 的请求会由 index() 来处理。 @RequestMapping 来处理多个 URI你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了。 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = &#123; "", "/page", "page*", "view/*,**/msg" &#125;) String indexMultipleMapping() &#123; return "Hello from index multiple mapping."; &#125;&#125; 如你在这段代码中所看到的，@RequestMapping 支持统配符以及ANT风格的路径。前面这段代码中，如下的这些 URL 都会由 indexMultipleMapping() 来处理： localhost:8080/home localhost:8080/home/ localhost:8080/home/page localhost:8080/home/pageabc localhost:8080/home/view/ localhost:8080/home/view/view 带有 @RequestParam 的 @RequestMapping@RequestParam 注解配合 @RequestMapping 一起使用，可以将请求的参数同处理方法的参数绑定在一起。 @RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数, 代码如下所示： 123456789101112131415@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/id") String getIdByValue(@RequestParam("id") String personId) &#123; System.out.println("ID is " + personId); return "Get ID from query string of URL with value element"; &#125; @RequestMapping(value = "/personId") String getId(@RequestParam String personId) &#123; System.out.println("ID is " + personId); return "Get ID from query string of URL without value element"; &#125;&#125; 在代码的第6行，id 这个请求参数被映射到了 thegetIdByValue() 这个处理方法的参数 personId 上。 如果请求参数和处理方法参数的名称一样的话，@RequestParam 注解的 value 这个参数就可省掉了, 如代码的第11行所示。 @RequestParam 注解的 required 这个参数定义了参数值是否是必须要传的。 12345678@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/name") String getName(@RequestParam(value = "person", required = false) String personName) &#123; return "Required element of request param"; &#125;&#125; 在这段代码中，因为 required 被指定为 false，所以 getName() 处理方法对于如下两个 URL 都会进行处理： /home/name?person=xyz /home/name @RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。 12345678@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/name") String getName(@RequestParam(value = "person", defaultValue = "John") String personName) &#123; return "Required element of request param"; &#125;&#125; 在这段代码中，如果 person 这个请求参数为空，那么 getName() 处理方法就会接收 John 这个默认值作为其参数。 用 @RequestMapping 处理 HTTP 的各种方法Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的请求默认都会是 HTTP GET 类型的。 为了能降一个请求映射到一个特定的 HTTP 方法，你需要在 @RequestMapping 中使用 method 来声明 HTTP 请求所使用的方法类型，如下所示： 123456789101112131415161718192021222324@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(method = RequestMethod.GET) String get() &#123; return "Hello from get"; &#125; @RequestMapping(method = RequestMethod.DELETE) String delete() &#123; return "Hello from delete"; &#125; @RequestMapping(method = RequestMethod.POST) String post() &#123; return "Hello from post"; &#125; @RequestMapping(method = RequestMethod.PUT) String put() &#123; return "Hello from put"; &#125; @RequestMapping(method = RequestMethod.PATCH) String patch() &#123; return "Hello from patch"; &#125;&#125; 在上述这段代码中， @RequestMapping 注解中的 method 元素声明了 HTTP 请求的 HTTP 方法的类型。 所有的处理处理方法会处理从这同一个 URL( /home)进来的请求, 但要看指定的 HTTP 方法是什么来决定用哪个方法来处理。 例如，一个 POST 类型的请求 /home 会交给 post() 方法来处理，而一个 DELETE 类型的请求 /home 则会由 delete() 方法来处理。 你会看到 Spring MVC 将使用这样相同的逻辑来映射其它的方法。 用 @RequestMapping 来处理生产和消费对象可以使用 @RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围。 为了能用请求的媒体类型来产生对象, 你要用到 @RequestMapping 的 produces 元素再结合着 @ResponseBody 注解。 你也可以利用 @RequestMapping 的 comsumes 元素再结合着 @RequestBody 注解用请求的媒体类型来消费对象。 下面这段代码就用到的 @RequestMapping 的生产和消费对象元素： 12345678910111213141516171819@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/prod", produces = &#123; "application/JSON" &#125;) @ResponseBody String getProduces() &#123; return "Produces attribute"; &#125; @RequestMapping(value = "/cons", consumes = &#123; "application/JSON", "application/XML" &#125;) String getConsumes() &#123; return "Consumes attribute"; &#125;&#125; 在这段代码中， getProduces() 处理方法会产生一个 JSON 响应， getConsumes() 处理方法可以同时处理请求中的 JSON 和 XML 内容。 使用 @RequestMapping 来处理消息头@RequestMapping 注解提供了一个 header 元素来根据请求中的消息头内容缩小请求映射的范围。 在可以指定 header 元素的值，用 myHeader = myValue 这样的格式： 12345678910@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/head", headers = &#123; "content-type=text/plain" &#125;) String post() &#123; return "Mapping applied along with headers"; &#125;&#125; 在上面这段代码中， @RequestMapping 注解的 headers 属性将映射范围缩小到了 post() 方法。有了这个，post() 方法就只会处理到 /home/head 并且 content-typeheader 被指定为 text/plain 这个值的请求。 你也可以像下面这样指定多个消息头： 12345678910@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/head", headers = &#123; "content-type=text/plain", "content-type=text/html" &#125;) String post() &#123; return "Mapping applied along with headers"; &#125;&#125; 这样， post() 方法就能同时接受 text/plain 还有 text/html 的请求了。 使用 @RequestMapping 来处理请求参数@RequestMapping 直接的 params 元素可以进一步帮助我们缩小请求映射的定位范围。使用 params 元素，你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。 你可以用 myParams = myValue 这种格式来定义参数，也可以使用通配符来指定特定的参数值在请求中是不受支持的。 12345678910111213141516@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/fetch", params = &#123; "personId=10" &#125;) String getParams(@RequestParam("personId") String id) &#123; return "Fetched parameter using params attribute = " + id; &#125; @RequestMapping(value = "/fetch", params = &#123; "personId=20" &#125;) String getParamsDifferent(@RequestParam("personId") String id) &#123; return "Fetched parameter using params attribute = " + id; &#125;&#125; 在这段代码中，getParams() 和 getParamsDifferent() 两个方法都能处理相同的一个 URL (/home/fetch) ，但是会根据 params 元素的配置不同而决定具体来执行哪一个方法。 例如，当 URL 是 /home/fetch?id=10 的时候, getParams() 会执行，因为 id 的值是10,。对于 localhost:8080/home/fetch?personId=20 这个URL, getParamsDifferent() 处理方法会得到执行，因为 id 值是 20。 使用 @RequestMapping 处理动态 URI@RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI，URI 的值可以作为控制器中处理方法的参数。你也可以使用正则表达式来只处理可以匹配到正则表达式的动态 URI。 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/fetch/&#123;id&#125;", method = RequestMethod.GET) String getDynamicUriValue(@PathVariable String id) &#123; System.out.println("ID is " + id); return "Dynamic URI parameter fetched"; &#125; @RequestMapping(value = "/fetch/&#123;id:[a-z]+&#125;/&#123;name&#125;", method = RequestMethod.GET) String getDynamicUriValueRegex(@PathVariable("name") String name) &#123; System.out.println("Name is " + name); return "Dynamic URI parameter fetched using regex"; &#125;&#125; 在这段代码中，方法 getDynamicUriValue() 会在发起到 localhost:8080/home/fetch/10 的请求时执行。这里 getDynamicUriValue() 方法 id 参数也会动态地被填充为 10 这个值。 方法 getDynamicUriValueRegex() 会在发起到 localhost:8080/home/fetch/category/shirt 的请求时执行。不过，如果发起的请求是 /home/fetch/10/shirt 的话，会抛出异常，因为这个URI并不能匹配正则表达式。 @PathVariable 同 @RequestParam的运行方式不同。你使用 @PathVariable 是为了从 URI 里取到查询参数值。换言之，你使用 @RequestParam 是为了从 URI 模板中获取参数值。 @RequestMapping 默认的处理方法在控制器类中，你可以有一个默认的处理方法，它可以在有一个向默认 URI 发起的请求时被执行。 下面是默认处理方法的示例： 123456789@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping() String default () &#123; return "This is a default method for the class"; &#125;&#125; 在这段代码中，向 /home 发起的一个请求将会由 default() 来处理，因为注解并没有指定任何值。 @RequestMapping 快捷方式Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。方法级别的注解变体有如下几个： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 如下代码展示了如何使用组合注解： 12345678910111213141516171819202122232425262728@RestController@RequestMapping("/home")public class IndexController &#123; @GetMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; getPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from GET", HttpStatus.OK); &#125; @GetMapping("/person/&#123;id&#125;") public @ResponseBody ResponseEntity &lt; String &gt; getPersonById(@PathVariable String id) &#123; return new ResponseEntity &lt; String &gt; ("Response from GET with id " + id, HttpStatus.OK); &#125; @PostMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; postPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from POST method", HttpStatus.OK); &#125; @PutMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; putPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from PUT method", HttpStatus.OK); &#125; @DeleteMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; deletePerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from DELETE method", HttpStatus.OK); &#125; @PatchMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; patchPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from PATCH method", HttpStatus.OK); &#125;&#125; 在这段代码中，每一个处理方法都使用 @RequestMapping 的组合变体进行了注解。尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现, 但组合变体仍然是一种最佳的实践 — 这主要是因为组合注解减少了在应用程序上要配置的元数据，并且代码也更易读。 @RequestMapping 总结如你在本文中所看到的，@RequestMapping 注解是非常灵活的。你可以使用该注解配置 Spring MVC 来处理大量的场景用例。它可以被用来在 Spring MVC 中配置传统的网页请求，也可以是 REST 风格的 Web 服务。]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker自定义TemplateDirectiveModel(二)]]></title>
    <url>%2Fposts%2F37707.html</url>
    <content type="text"><![CDATA[FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。 ​ 摘要: 采用的是freemarker版本 2.3.21 采用 BeansWrapperBuilder替代DEFAULT_WRAPPER 的方式。 自定义标签需要实现TemplateDirectiveModel这个接口中的execute方法 实例代码如下 123456789101112131415161718192021public class UserListDirective implements TemplateDirectiveModel&#123; @Autowired private UserDAO userDao; @Override public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; String name = params.get("name").toString(); List&lt;User&gt; userlist = userDao.findByProperty("name", name); env.setVariable("userList", getBeansWrapper().wrap(userlist)); body.render(env.getOut()); &#125; public static BeansWrapper getBeansWrapper()&#123; BeansWrapper beansWrapper = new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build(); return beansWrapper; &#125;&#125; 配置 UserListDirective 到spring bean xml中 1&lt;bean id="userListDirective" class="com.action.directive.UserListDirective"&gt;&lt;/bean&gt; 将spring bean 设置到freemarkerConfig全局变量中去。 1234567891011121314151617181920212223&lt;bean id="freemarkerConfig2" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="freemarkerVariables"&gt; &lt;map &gt; &lt;entry key="userListDirective" value="userListTag" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; ftl文件中的访问方式 1234567&lt;@userListTag name="zhangsan"&gt; &lt;#if userList?? &amp;&amp; userList?size gt 0&gt; &lt;#list userList as user&gt; &lt;a href=""&gt;$&#123;user.name&#125;&lt;/a&gt; &lt;/#list&gt; &lt;/#if&gt; &lt;/@userListTag&gt; freemarker 遍历 map 第一种方式（2.3.21版本之前好像可以用） 12345&lt;#list testMap?keys as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap.get(testKey)&#125; &lt;/option&gt; &lt;/#list&gt; 12345&lt;#list testMap.keySet() as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap.get(testKey)&#125; &lt;/option&gt; &lt;/#list&gt; 附摘： 在采用FreeMarker做前台视图模板的情况下，我们可以通过&lt;#include&gt;标签和自定义宏来解决很多重复性工作。 一个简单的FreeMarker宏： 123&lt;#macro sayHello name=""&gt; hello $&#123;name&#125;&lt;/#macro&gt; 然后通过如下的形式调用： 1&lt;@sayHello name="shannon" /&gt; ​ 不过这种在模板页中定义的宏能力有限。【1】假设，我们很多页面都要输出一个热门排行框，而排行数据需要从controller层动态获取，我们可以用这种宏来完成所有的展示工作，但前提是相应的controller和接口中层需要预先将这些排行数据放到model中去，因此对于后端来说这也是一个重复性的工作。那么有没有一种方式可以让后端也脱离这种重复工作呢？答案是肯定的，这也是写这篇博客的目的。 ​ 在一个偶然的机会发现jeecms项目中用到了这种方式，于是借鉴了一番。 ​ FreeMarker不仅可以在前端的模板页中定义宏，还可以通过扩展其接口在后端实现宏，这有什么好处呢？这种方式就好比让你的模板页具备了从前端再次回到后端的能力。这样我们就能很好的解决【1】处的假设，我们无需在各个controller的各个接口中去重复的向model中添加所需的排行数据，而是当FreeMarker渲染模板页时遇到相应的宏它可以回到后端去调用相应的方法取到所需的数据。例子如下： 1234567891011121314151617181920212223242526272829303132333435import freemarker.core.Environment;import freemarker.template.ObjectWrapper;import freemarker.template.TemplateDirectiveModel;/** * FreeMarker自定义宏 * 获取App下载排行列表 * 参数包括 length（列表长度） mtypeCode(主类型代码) typeCode（小类型代码） rankMode（排行模式1、2、3） * @author shannon * */public class FMAppRankDirective implements TemplateDirectiveModel &#123; @Resource(name = "appRankService") private AppRankService appRankService; @SuppressWarnings("unchecked") @Override public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; //DirectiveUtils是借用jeecms项目中的工具类，主要是因为它集成了一些异常处理功能， //其实完全可以不用它，params是个Map，自己通过key取值就可以了，做一下空值判断 Integer length = DirectiveUtils.getInt("length", params); Integer mtypeCode = DirectiveUtils.getInt("mtypeCode", params); Integer typeCode = DirectiveUtils.getInt("typeCode", params); Integer rankMode = DirectiveUtils.getInt("rankMode", params); ArrayList&lt;App&gt; rankList = appRankService.getRankList(length, mtypeCode, typeCode, rankMode); env.setVariable("appRankList", ObjectWrapper.DEFAULT_WRAPPER.wrap(rankList)); if (body != null) &#123; body.render(env.getOut()); &#125; &#125;&#125; ​ 通过实现FreeMarker的TemplateDirectiveModel就在后端实现了一个自定义的宏，这个宏的功能很简单，只是根据给定的参数将排行数据“appRankList”放到model中去，然后模板页中就可以使用这个变量了。 FreeMarker的配置参数中需要将这个宏加入进去。 12345678910&lt;bean id="appRankDirective" class="com.shannon.example.rank.util.FMAppRankDirective" /&gt;&lt;bean id="freemarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; ……其他配置略…… &lt;property name="freemarkerVariables"&gt; &lt;map&gt; ……其他配置略…… &lt;entry key="appRankDirective" value-ref="appRankDirective"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 在模板页中使用： 1234567891011121314&lt;#-- 应用下载排行框，title为该框的标题，length为排行列表长度，mtypeCode为主类型代码，typeCode为小类型代码，rankMode为排行方式 1为总下载量，2为月下载量，3为昨日增长下载量--&gt;&lt;#macro appRankBox title="" length=10 mtypeCode=1 typeCode=-1 rankMode=1&gt; &lt;@appRankDirective length=length mtypeCode=mtypeCode typeCode=typeCode rankMode=rankMode /&gt; &lt;h3 class="box-title"&gt;$&#123;title&#125;&lt;/h3&gt; &lt;div class="box"&gt; &lt;ul class="row-list"&gt; &lt;#list appRankList as item&gt; ……详细输出内容略…… &lt;/#list&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/#macro&gt; ​ 这里我在模板页中又定义了一个宏，负责内容及样式的输出，因为模板页中的宏比较直观，让后端的宏只负责拿数据。其他页面直接使用“appRankBox”就可以了，然后由它来调用后端的“appRankDirective”宏来拿数据。 这样，controller就从重复工作中脱身了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker自定义TemplateDirectiveModel(一)]]></title>
    <url>%2Fposts%2F21487.html</url>
    <content type="text"><![CDATA[FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。 一、Freemarker的介绍​ Freemarker 是一款模板引擎，是一种基于模版生成静态文件的通用 工具，它是为java程序员提供的一个开发包，或者说是一个类库，它不是面向最终用户的，而是为程序员提供了一款可以嵌入他们开发产品的应用程序。 ​ Freemarker 是使用纯java编写的，为了提高页面的访问速度，需要把页面静态化， 那么Freemarker就是被用来生成html页面。 ​ 到目前为止，Freemarker使用越来越广泛，不光光只是它强大的生成技术，而且它能够与spring进行很好的集成。 ​ 现在开始一层层揭开它的神秘面纱。。 二、Freemarker的准备条件​ freemarker.2.3.16.jar 三、Freemarker生成静态页面的原理​ Freemarker 生成静态页面，首先需要使用自己定义的模板页面，这个模板页面可以是最最普通的html，也可以是嵌套freemarker中的 取值表达式， 标签或者自定义标签等等，然后后台读取这个模板页面，解析其中的标签完成相对应的操作， 然后采用键值对的方式传递参数替换模板中的的取值表达式，做完之后 根据配置的路径生成一个新的html页面， 以达到静态化访问的目的。 四、Freemarker提供的标签Freemarker提供了很多有用 常用的标签，Freemarker标签都是&lt;#标签名称&gt;这样子命名的，${value} 表示输出变量名的内容 ，具体如下： list：该标签主要是进行迭代服务器端传递过来的List集合，比如： 123&lt;#list nameList as names&gt; $&#123;names&#125; &lt;/#list&gt; ​ name是list循环的时候取的一个循环变量，freemarker在解析list标签的时候，等价于： 123for (String names : nameList) &#123; System.out.println(names); &#125; if： 该标签主要是做if判断用的，比如： 123&lt;#if (names=="陈靖仇")&gt; 他的武器是: 十五~~&lt;/#if&gt; ​ 这个是条件判断标签，要注意的是条件等式必须用括号括起来， 等价于： 123if(names.equals("陈靖仇"))&#123; System.out.println("他的武器是: 十五~~"); &#125; include：该标签用于导入文件用的。 1&lt;#include "include.html"/&gt; ​ 这个导入标签非常好用，特别是页面的重用。 另外在静态文件中可以使用${} 获取值，取值方式和el表达式一样，非常方便。 ​ 下面举个例子（static.html）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;描述：$&#123;description&#125;&lt;br/&gt;集合大小:$&#123;nameList?size&#125;&lt;br/&gt;迭代list集合：&lt;br/&gt;&lt;#list nameList as names&gt;这是第$&#123;names_index+1&#125;个人，叫做：&lt;label style="color:red"&gt;$&#123;names&#125;&lt;/label&gt;if判断：&lt;br/&gt;&lt;#if (names=="陈靖仇")&gt; 他的武器是: 十五~~&lt;#elseif (names=="宇文拓")&gt; &lt;#--注意这里没有返回而是在最后面--&gt; 他的武器是: 轩辕剑~·&lt;#else&gt;她的绝招是：蛊毒~~&lt;/#if&gt;&lt;br/&gt;&lt;/#list&gt;迭代map集合：&lt;br/&gt;&lt;#list weaponMap?keys as key&gt;key---&gt;$&#123;key&#125;&lt;br/&gt;value-----&gt;$&#123;weaponMap[key]!("null")&#125;&lt;#-- fremarker 不支持null, 可以用！ 来代替为空的值。其实也可以给一个默认值 value-----$&#123;weaponMap[key]?default("null")&#125;还可以 在输出前判断是否为null&lt;#if weaponMap[key]??&gt;&lt;/#if&gt;都可以--&gt;&lt;br/&gt;&lt;/#list&gt;include导入文件：&lt;br/&gt;&lt;#include "include.html"/&gt;&lt;/body&gt;&lt;/html&gt; ​ 实际代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.chenghui.test;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import freemarker.template.Configuration;import freemarker.template.DefaultObjectWrapper;import freemarker.template.Template;import freemarker.template.TemplateException;public class CreateHtml &#123; public static void main(String[] args) &#123; try &#123; //创建一个合适的Configration对象 Configuration configuration = new Configuration(); configuration.setDirectoryForTemplateLoading(new File("D:\\project\\webProject\\WebContent\\WEB-INF\\template")); configuration.setObjectWrapper(new DefaultObjectWrapper()); configuration.setDefaultEncoding("UTF-8"); //这个一定要设置，不然在生成的页面中 会乱码 //获取或创建一个模版。 Template template = configuration.getTemplate("static.html"); Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put("description", "我正在学习使用Freemarker生成静态文件！"); List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); nameList.add("陈靖仇"); nameList.add("玉儿"); nameList.add("宇文拓"); paramMap.put("nameList", nameList); Map&lt;String, Object&gt; weaponMap = new HashMap&lt;String, Object&gt;(); weaponMap.put("first", "轩辕剑"); weaponMap.put("second", "崆峒印"); weaponMap.put("third", "女娲石"); weaponMap.put("fourth", "神农鼎"); weaponMap.put("fifth", "伏羲琴"); weaponMap.put("sixth", "昆仑镜"); weaponMap.put("seventh", null); paramMap.put("weaponMap", weaponMap); Writer writer = new OutputStreamWriter(new FileOutputStream("success.html"),"UTF-8"); template.process(paramMap, writer); System.out.println("恭喜，生成成功~~"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 这样子基本上可以算的上可以简单的去做一点简单的生成了，但是要在实际中去运用，还是差的很远的，因为freemarker给的标签完全满足不了我们的需要，这时候就需要自定义标签来完成我们的需求了。。 五、Freemarker自定义标签Freemarker自定义标签就是自己写标签，然后自己解析，完全由自己来控制标签的输入输出，极大的为程序员提供了很大的发挥空间。 基于步骤： ​ 以前写标签需要在&lt;后加# ，但是freemarker要识别自定义标签需要在后面加上@，然后后面可以定义一些参数，当程序执行template.process(paramMap, out);,就会去解析整个页面的所有的freemarker标签。 ​ 自定义标签 需要自定义一个类，然后实现TemplateDirectiveModel，重写execute方法，完成获取参数，根据参数do something等等。 ​ 将自定义标签与解析类绑定在一起需要在paramMap中放入该解析类的实例，存放的key与自定义标签一致即可。 ​ 注意：在自定义标签中，如果标签内什么也没有，开始标签和结束标签绝对不能再同一行，不然会报错 freemarker.log.JDK14LoggerFactory$JDK14Logger error 例:static.html模板 1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--自定义变量--&gt;&lt;#assign num='hehe'/&gt;$&#123;num&#125;&lt;br/&gt;自定义标签 &lt;@content name="chenghui" age="120"&gt; $&#123;output&#125; $&#123;append&#125; &lt;/@content&gt; &lt;/body&gt;&lt;/html&gt; static.html模板解析类： ​ 参数解释： TemplateDirectiveModel接口是freemarker自定标签或者自定义指令的核心处理接口。通过实现该接口，用户可以自定义标签（指令）进行任意操作， 任意文本写入模板的输出。该接口中只定义了如下方法，当模板页面遇到用户自定义的标签指令时，该方法会被执行。public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException; @param env：系统环境变量，通常用它来输出相关内容，如Writer out = env.getOut(); @param params：自定义标签传过来的对象，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等 @param loopVars 循环替代变量 @param body 用于处理自定义标签中的内容，如&lt;@myDirective&gt;将要被处理的内容&#x2f;&#x40;&#x6d;&#x79;&#68;&#105;&#x72;&#x65;&#x63;&#x74;&#x69;&#118;&#101;；当标签是&lt;@myDirective /&gt;格式时，body=null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.chenghui.test;import static freemarker.template.ObjectWrapper.DEFAULT_WRAPPER;import java.io.IOException;import java.io.Writer;import java.util.Map;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveBody;import freemarker.template.TemplateDirectiveModel;import freemarker.template.TemplateException;import freemarker.template.TemplateModel;import freemarker.template.TemplateModelException;import freemarker.template.TemplateNumberModel;import freemarker.template.TemplateScalarModel;/** * 自定义标签解析类 * @author Administrator * */public class ContentDirective implements TemplateDirectiveModel&#123; private static final String PARAM_NAME = "name"; private static final String PARAM_AGE = "age"; @Override public void execute(Environment env, Map params,TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; if(body==null)&#123; throw new TemplateModelException("null body"); &#125;else&#123; String name = getString(PARAM_NAME, params); Integer age = getInt(PARAM_AGE, params); //接收到参数之后可以根据做具体的操作，然后将数据再在页面中显示出来。 if(name!=null)&#123; env.setVariable("output", DEFAULT_WRAPPER.wrap("从ContentDirective解析类中获得的参数是："+name+", ")); &#125; if(age!=null)&#123; env.setVariable("append", DEFAULT_WRAPPER.wrap("年龄："+age)); &#125; Writer out = env.getOut(); out.write("从这里输出可以再页面看到具体的内容，就像document.writer写入操作一样。&lt;br/&gt;"); body.render(out); /* 如果细心的话，会发现页面上是显示out.write（）输出的语句，然后再输出output的内容， 可见 在body在解析的时候会先把参数放入env中，在页面遇到对应的而来表单时的才会去取值 但是，如果该表单时不存在，就会报错， 我觉得这里freemarker没有做好，解析的时候更加会把错误暴露在页面上。 可以这样子弥补$&#123;output!"null"&#125;,始终感觉没有el表达式那样好。 */ &#125; &#125; /** * 获取String类型的参数的值 * @param paramName * @param paramMap * @return * @throws TemplateModelException */ public static String getString(String paramName, Map&lt;String, TemplateModel&gt; paramMap) throws TemplateModelException&#123; TemplateModel model = paramMap.get(paramName); if(model == null)&#123; return null; &#125; if(model instanceof TemplateScalarModel)&#123; return ((TemplateScalarModel)model).getAsString(); &#125;else if (model instanceof TemplateNumberModel) &#123; return ((TemplateNumberModel)model).getAsNumber().toString(); &#125;else&#123; throw new TemplateModelException(paramName); &#125; &#125; /** * * 获得int类型的参数 * @param paramName * @param paramMap * @return * @throws TemplateModelException */ public static Integer getInt(String paramName, Map&lt;String, TemplateModel&gt; paramMap) throws TemplateModelException&#123; TemplateModel model = paramMap.get(paramName); if(model==null)&#123; return null; &#125; if(model instanceof TemplateScalarModel)&#123; String str = ((TemplateScalarModel)model).getAsString(); try &#123; return Integer.valueOf(str); &#125; catch (NumberFormatException e) &#123; throw new TemplateModelException(paramName); &#125; &#125;else if(model instanceof TemplateNumberModel)&#123; return ((TemplateNumberModel)model).getAsNumber().intValue(); &#125;else&#123; throw new TemplateModelException(paramName); &#125; &#125;&#125; ​ 然后再前面的实际代码中加上： 1paramMap.put("content", new ContentDirective()); 这样子基本上可以使用，freemarker完成自定义标签了，解决一写简单的业务逻辑， 但是在实际的项目中不可能这样子去做，因为还没有和spring进行集成使用，每次都需要在解析的时候把解析类的实例放进去。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（三）—— html&JavaScript&ajax部分]]></title>
    <url>%2Fposts%2F42994.html</url>
    <content type="text"><![CDATA[html&amp;JavaScript&amp;ajax 判断第二个日期比第一个日期大​ 如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答. //这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容 123456789101112131415161718192021222324252627282930&lt;scripttype="text/javascript"&gt;window.onload = function()&#123;//这么写是为了实现js代码与html代码的分离，当我修改js时，不能影响html代码。document.getElementById("frm1").onsubmit=function()&#123; var d1 =this.d1.value; var d2 =this.d2.value; if(!verifyDate (d1))&#123;alert("第一个日期格式不对");return false;&#125; if(!verifyDate (d2))&#123;alert("第二个日期格式不对");return false;&#125; if(!compareDate(d1,d2))&#123;alert("第二个日期比第一日期小");return false;&#125; &#125;;&#125;functioncompareDate(d1,d2)&#123; var arrayD1 =d1.split("-"); var date1 = new Date(arrayD1[0],arrayD1[1],arrayD1[2]); var arrayD2 =d2.split("-"); var date2 = newDate(arrayD2[0],arrayD2[1],arrayD2[2]); if(date1 &gt;date2) return false; return true;&#125;functionverifyDate(d)&#123; var datePattern= /^\d&#123;4&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/;returndatePattern.test(d);&#125;&lt;/script&gt;&lt;formid="frm1" action="xxx.html"&gt;&lt;inputtype="text" name="d1" /&gt;&lt;inputtype="text" name="d2" /&gt;&lt;inputtype="submit"/&gt;&lt;/form&gt; 用table显示n条记录，每3行换一次颜色，即1，2，3用红色字体，4，5，6用绿色字体，7，8，9用红颜色字体。12345678910111213141516171819202122232425&lt;body&gt;&lt;tableid="tbl"&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;9&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;scripttype="text/javascript"&gt;window.onload=function()&#123; var tbl =document.getElementById("tbl"); rows =tbl.getElementsByTagName("tr");for(i=0;i&lt;rows.length;i++)&#123; var j =parseInt(i/3); if(j%2==0)rows[i].style.backgroundColor="#f00"; else rows[i].style.backgroundColor="#0f0"; &#125;&#125;&lt;/script&gt; HTML 的 form 提交之前如何验证数值文本框的内容全部为数字? 否则的话提示用户并终止提交?12345678910111213141516&lt;formonsubmit=’return chkForm(this)’&gt;&lt;inputtype="text" name="d1"/&gt;&lt;inputtype="submit"/&gt;&lt;/form&gt;&lt;scripttype=”text/javascript” /&gt; function chkForm(this)&#123; var value= thist.d1.value; var len =value.length; for(vari=0;i&lt;len;i++)&#123; if(value.charAt(i)&gt;"9"|| value.charAt(i)&lt;"0")&#123; alert("含有非数字字符");return false; &#125; &#125; return true;&#125;&lt;/script&gt; 请写出用于校验HTML文本框中输入的内容全部为数字的javascript代码1234567891011121314&lt;inputtype="text" id="d1" onblur=" chkNumber(this)"/&gt;&lt;scripttype=”text/javascript” /&gt;functionchkNumber(eleText) &#123; var value =eleText.value; var len =value.length;for(vari=0;i&lt;len;i++)&#123; if(value.charAt(i)&gt;"9"|| value.charAt(i)&lt;"0")&#123; alert("含有非数字字符"); eleText.focus(); break; &#125; &#125;&#125;&lt;/script&gt; 除了写完代码，还应该在网页上写出实验步骤和在代码中加入实现思路，让面试官一看就明白你的意图和检查你的结果。]]></content>
      <categories>
        <category>Java</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>html</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（二）——算法与编程]]></title>
    <url>%2Fposts%2F44611.html</url>
    <content type="text"><![CDATA[Java算法编程。java排序算法，经典问题算法，单例模式 编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。答： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.File;import java.io.FileReader;import java.io.FileWriter;public class MainClass &#123; public static void main(String[] args) throws Exception &#123; FileManager a = new FileManager("a.txt", new char[] &#123; '\n' &#125;); FileManager b = new FileManager("b.txt", new char[] &#123; '\n', ' ' &#125;); FileWriter c = new FileWriter("c.txt"); String aWord = null; String bWord = null; while ((aWord = a.nextWord()) != null) &#123; c.write(aWord + "\n"); bWord = b.nextWord(); if (bWord != null) c.write(bWord + "\n"); &#125; while ((bWord = b.nextWord()) != null) &#123; c.write(bWord + "\n"); &#125; c.close(); &#125;&#125;class FileManager &#123; String[] words = null; int pos = 0; public FileManager(String filename, char[] seperators) throws Exception &#123; File f = new File(filename); FileReader reader = new FileReader(f); char[] buf = new char[(int) f.length()]; int len = reader.read(buf); String results = new String(buf, 0, len); String regex = null; if (seperators.length &gt; 1) &#123; regex = "" + seperators[0] + "|" + seperators[1]; &#125; else &#123; regex = "" + seperators[0]; &#125; words = results.split(regex); &#125; public String nextWord() &#123; if (pos == words.length) return null; return words[pos++]; &#125;&#125; 编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！） 答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FilenameFilter;import java.io.InputStream;import java.io.OutputStream;public class Jad2Java &#123; public static void main(String[] args) throws Exception &#123; File srcDir = new File("java"); if (!(srcDir.exists() &amp;&amp; srcDir.isDirectory())) throw new Exception("目录不存在"); File[] files = srcDir.listFiles(new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125; &#125;); System.out.println(files.length); File destDir = new File("jad"); if (!destDir.exists()) destDir.mkdir(); for (File f : files) &#123; FileInputStream fis = new FileInputStream(f); String destFileName = f.getName().replaceAll(".java", ".jad"); FileOutputStream fos = new FileOutputStream(new File(destDir, destFileName)); copy(fis, fos); fis.close(); fos.close(); &#125; &#125; private static void copy(InputStream ips, OutputStream ops) throws Exception &#123; int len = 0; byte[] buf = new byte[1024]; while ((len = ips.read(buf)) != -1) &#123; ops.write(buf, 0, len); &#125; &#125;&#125; 由本题总结的思想及策略模式的解析： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;import java.io.FileFilter;import java.util.Arrays;class jad2java1&#123;//得到某个目录下的所有的java文件集合//1.1得到目录 File srcDir =new File("d:java");//1.2 得到目录下的所有java文件： File[] files =srcDir.listFiles(new MyFileFilter());//1.3 只想得到.java的文件： class MyFileFilter implements FileFilter&#123; public boolean accept(File pathname)&#123; return pathname.getName().endsWith(".java"); &#125;&#125;//2.将每个文件复制到另外一个目录，并改扩展名//2.1 得到目标目录，如果目标目录不存在，则创建之//2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。//2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。 //要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。//2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。 //方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。&#125;//分析listFiles方法内部的策略模式实现原理File[] listFiles(FileFilter filter)&#123;File[] files = listFiles(filter);//Arraylist acceptedFilesList = newArrayList();File[] acceptedFiles = new File[files.length];int pos = 0;for(File file: files)&#123;boolean accepted = filter.accept(file);if(accepted)&#123;//acceptedFilesList.add(file);acceptedFiles[pos++] = file; &#125;&#125;Arrays.copyOf(acceptedFiles,pos);//return (File[])accpetedFilesList.toArray(); &#125;&#125; 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。答： 首先要了解中文字符有多种编码及各种编码的特征。 ​ 假设n为要截取的字节数。 123456789101112131415161718192021public class TrimGBK &#123; public static void main(String[] args) throws Exception &#123; String str = "我a爱中华abc我爱传智def"; int num = trimGBK(str.getBytes("GBK"), 5); System.out.println(str.substring(0, num)); &#125; public static int trimGBK(byte[] buf, int n) &#123; int num = 0; boolean bChineseFirstHalf = false; for (int i = 0; i &lt; n; i++) &#123; if (buf[i] &lt; 0 &amp;&amp; !bChineseFirstHalf) &#123; bChineseFirstHalf = true; &#125; else &#123; num++; bChineseFirstHalf = false; &#125; &#125; return num; &#125;&#125; 有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。答：如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。 1234567891011121314151617181920public class CountABC &#123; public static void main(String[] args) &#123; String str = "aaaabbc中国1512"; int engishCount = 0; int chineseCount = 0; int digitCount = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; digitCount++; &#125; else if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) &#123; engishCount++; &#125; else &#123; chineseCount++; &#125; &#125; System.out.println("英文字符的数量" + engishCount + ",中文字符的数量" + chineseCount + "，和数字字符的数量" + digitCount); &#125;&#125; 说明生活中遇到的二叉树，用java实现二叉树这是组合设计模式。 我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Node &#123; public int value; public Node left; public Node right; public void store(int value) &#123; if (value &lt; this.value) &#123; if (left == null) &#123; left = new Node(); left.value = value; &#125; else &#123; left.store(value); &#125; &#125; else if (value &gt; this.value) &#123; if (right == null) &#123; right = new Node(); right.value = value; &#125; else &#123; right.store(value); &#125; &#125; &#125; public boolean find(int value) &#123; System.out.println("happen" + this.value); if (value == this.value) &#123; return true; &#125; else if (value &gt; this.value) &#123; if (right == null) return false; return right.find(value); &#125; else &#123; if (left == null) return false; return left.find(value); &#125; &#125; public void preList() &#123; System.out.print(this.value + ","); if (left != null) left.preList(); if (right != null) right.preList(); &#125; public void middleList() &#123; if (left != null) left.preList(); System.out.print(this.value + ","); if (right != null) right.preList(); &#125; public void afterList() &#123; if (left != null) left.preList(); if (right != null) right.preList(); System.out.print(this.value + ","); &#125; public static void main(String[] args) &#123; int[] data = new int[20]; for (int i = 0; i &lt; data.length; i++) &#123; data[i] = (int) (Math.random() * 100) + 1; System.out.print(data[i] + ","); &#125; System.out.println(); Node root = new Node(); root.value = data[0]; for (int i = 1; i &lt; data.length; i++) &#123; root.store(data[i]); &#125; root.find(data[19]); root.preList(); System.out.println(); root.middleList(); System.out.println(); root.afterList(); &#125;&#125; 从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：1,张三,28 2,李四,35 3,张三,28 4,王五,35 5,张三,28 6,李四,35 7,赵六,28 8,田七,35 程序代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* * 从类似如下的文本文件中读取出所有的姓名，并打印出重复的 * 姓名和重复的次数，并按重复次数排序： */import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.TreeMap;public class CopyOfGetNameTest &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; results = new TreeMap&lt;String, Integer&gt;(); List&lt;User&gt; tm = new ArrayList&lt;User&gt;(); tm.add(new User("张三", 28)); tm.add(new User("李四", 35)); tm.add(new User("张三", 28)); tm.add(new User("王五", 35)); tm.add(new User("张三", 28)); tm.add(new User("李四", 35)); tm.add(new User("赵六", 28)); tm.add(new User("田七", 35)); for (User x : tm) &#123; dealLine(x, results); &#125; for (Map.Entry&lt;String, Integer&gt; m : results.entrySet()) &#123; System.out.println(m); &#125; &#125; private static void dealLine(User x, Map&lt;String, Integer&gt; map) &#123; String name = x.getName(); Integer value = (Integer) map.get(name); if (value == null) &#123; value = 0; &#125; map.put(name, value + 1); &#125; public static void dealLine(String line, Map&lt;String, Integer&gt; map) &#123; if (!"".equals(line.trim())) &#123; String[] results = line.split(","); if (results.length == 3) &#123; String name = results[1]; Integer value = (Integer) map.get(name); if (value == null) &#123; value = 0; &#125; map.put(name, value + 1); &#125; &#125; &#125;&#125;class User implements Comparable&lt;User&gt; &#123; public String name; public Integer value; public User(String name, Integer value) &#123; this.name = name; this.value = value; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return value; &#125; @Override public String toString() &#123; return "name = " + name + " value = " + value; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj instanceof User) &#123; User user = (User) obj; if ((this.name.equals(user.name)) &amp;&amp; (this.value == user.value)) &#123; return true; &#125; &#125; return false; &#125; public int compareTo(User user) &#123; int num = 0; int i = this.name.compareTo(user.name); if (i &gt; 0) &#123; num = 1; &#125; else if (i &lt; 0) &#123; num = -1; &#125; else &#123; num = this.value &gt; user.value ? 1 : (this.value == user.value ? 0 : -1); &#125; return num; &#125;&#125; 单实例Singleton设计模式单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。你希望这个类在整个系统中只能出现一个实例。当然，作为一个技术负责人的你，你当然有权利通过使用非技术的手段来达到你的目的。比如：你在团队内部明文规定，“XX类只能有一个全局实例，如果某人使用两次以上，那么该人将被处于2000元的罚款！”（呵呵），你当然有权这么做。但是如果你的设计的是东西是一个类库，或是一个需要提供给用户使用的API，恐怕你的这项规定将会失效。因为，你无权要求别人会那么做。所以，这就是为什么，我们希望通过使用技术的手段来达成这样一个目的的原因。 本文会带着你深入整个Singleton的世界，当然，我会放弃使用C++语言而改用Java语言，因为使用Java这个语言可能更容易让我说明一些事情。 Singleton的教学版本这里，我将直接给出一个Singleton的简单实现，因为我相信你已经有这方面的一些基础了。我们姑且把这个版本叫做1.0版 1234567891011// version 1.0public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; return singleton; &#125;&#125; 在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的） 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。 所形成的实例保存在自己类中的私有成员中。 我们取实例时，只需要使用Singleton.getInstance()就行了。 当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。 Singleton的实际版本上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示： 1234567891011121314// version 1.1public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; singleton= new Singleton(); &#125; &#125; return singleton; &#125;&#125; 嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示： 1234567891011121314// version 1.2public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; return singleton; &#125;&#125; 不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！ 还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。 12345678910111213141516// version 1.3public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明： 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。 不然，我们就开始同步线程。 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。 相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！ 但是，如果你认为这个版本大攻告成，你就错了。 主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 singleton 分配内存 调用 Singleton 的构造函数来初始化成员变量，形成实例 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版： 12345678910111213141516// version 1.4public class Singleton&#123; private volatile static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 使用 volatile 有两个功用： 1）这个变量不会在多个线程中存在复本，直接从内存读取。 2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。 但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。 Singleton 的简化版本上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式： 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 123456789// version 1.5public class Singleton&#123; private volatile static Singleton singleton = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。 于是，这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。 好吧，我们还得绕一下： 下面的这个1.6版是老版《Effective Java》中推荐的方式。 12345678910// version 1.6public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 Singleton 优雅版本123public enum Singleton&#123; INSTANCE;&#125; 居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。 默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。 这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。 Singleton的其它问题怎么？还有问题？！当然还有，请记住下面这条规则——“无论你的代码写得有多好，其只能在特定的范围内工作，超出这个范围就要出Bug了”，这是“陈式第一定理”，呵呵。你能想一想还有什么情况会让这个我们上面的代码出问题吗？ 在C++下，我不是很好举例，但是在Java的环境下，嘿嘿，还是让我们来看看下面的一些反例和一些别的事情的讨论（当然，有些反例可能属于钻牛角尖，可能有点学院派，不过也不排除其实际可能性，就算是提个醒吧）： Class Loader。不知道你对Java的Class Loader熟悉吗？“类装载器”？！C++可没有这个东西啊。这是Java动态性的核心。顾名思义，类装载器是用来把类(class)装载进JVM的。JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。 在一个JVM中可能存在多个ClassLoader，每个ClassLoader拥有自己的NameSpace。一个ClassLoader只能拥有一个class对象类型的实例，但是不同的ClassLoader可能拥有相同的class对象实例，这时可能产生致命的问题。如ClassLoaderA，装载了类A的类型实例A1，而ClassLoaderB，也装载了类A的对象实例A2。逻辑上讲A1=A2，但是由于A1和A2来自于不同的ClassLoader，它们实际上是完全不同的，如果A中定义了一个静态变量c，则c在不同的ClassLoader中的值是不同的。 于是，如果咱们的Singleton 1.3版本如果面对着多个Class Loader会怎么样？呵呵，多个实例同样会被多个Class Loader创建出来，当然，这个有点牵强，不过他确实存在。难道我们还要整出个1.4版吗？可是，我们怎么可能在我的Singleton类中操作Class Loader啊？是的，你根本不可能。在这种情况下，你能做的只有是——“保证多个Class Loader不会装载同一个Singleton”。 序例化。如果我们的这个Singleton类是一个关于我们程序配置信息的类。我们需要它有序列化的功能，那么，当反序列化的时候，我们将无法控制别人不多次反序列化。不过，我们可以利用一下Serializable接口的readResolve()方法，比如： 123456789public class Singleton implements Serializable&#123; ...... ...... protected Object readResolve() &#123; return getInstance(); &#125;&#125; 多个Java虚拟机。如果我们的程序运行在多个Java的虚拟机中。什么？多个虚拟机？这是一种什么样的情况啊。嗯，这种情况是有点极端，不过还是可能出现，比如EJB或RMI之流的东西。要在这种环境下避免多实例，看来只能通过良好的设计或非技术来解决了。 volatile变量。关于volatile这个关键字所声明的变量可以被看作是一种 “程度较轻的同步synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当然，如前面所述，我们需要的Singleton只是在创建的时候线程同步，而后面的读取则不需要同步。所以，volatile变量并不能帮助我们即能解决问题，又有好的性能。而且，这种变量只能在JDK 1.5+版后才能使用。 关于继承。是的，继承于Singleton后的子类也有可能造成多实例的问题。不过，因为我们早把Singleton的构造函数声明成了私有的，所以也就杜绝了继承这种事情。 关于代码重用。也话我们的系统中有很多个类需要用到这个模式，如果我们在每一个类都中有这样的代码，那么就显得有点傻了。那么，我们是否可以使用一种方法，把这具模式抽象出去？在C++下这是很容易的，因为有模板和友元，还支持栈上分配内存，所以比较容易一些（程序如下所示），Java下可能比较复杂一些，聪明的你知道怎么做吗？ 123456789101112131415161718192021222324template class Singleton&#123; public: static T&amp; Instance() &#123; static T theSingleInstance; //假设T有一个protected默认构造函数 return theSingleInstance; &#125;&#125;;class OnlyOne : public Singleton&#123; friend class Singleton; int example_data; public: int GetExampleData() const &#123;return example_data;&#125; protected: OnlyOne(): example_data(42) &#123;&#125; // 默认构造函数 OnlyOne(OnlyOne&amp;) &#123;&#125;&#125;;int main( )&#123; cout &lt;&lt; OnlyOne::Instance().GetExampleData() &lt;&lt; endl; return 0;&#125; 递归算法题1一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。例：n=1237则输出为：1237，2474，4948，9896，9896，4948，2474，1237， 提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。 123456public static void doubleNum(int n)&#123; System.out.println(n); if(n&lt;=5000) doubleNum(n*2); System.out.println(n);&#125; 递归算法题2第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 123456789101112public class Test &#123; public static void main(String[] args) &#123; System.out.println(computeAge(8)); &#125; public static int computeAge(int n) &#123; if (n == 1) &#123; return 10; &#125; else &#123; return computeAge(n - 1) + 2; &#125; &#125;&#125; 排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391//插入排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class InsertSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; int temp; for(int i=1;i&lt;data.length;i++)&#123; for(int j=i;(j&gt;0)&amp;&amp;(data[j]&lt;data[j-1]);j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125;&#125;//冒泡排序: for(var i=0; i&lt;arr.length; i++) &#123; for(var j=i+1; j&lt;=arr.length-1; j++) &#123; if(eval(arr[i]) &lt; eval(arr[j])) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125;&#125; package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class BubbleSort implements SortUtil.Sort public void sort(int[] data) &#123; int temp; for(int i=0;i&lt;data.length;i++)&#123; for(int j=data.length-1;j&gt;i;j--)&#123; if(data[j]&lt;data[j-1])&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125; &#125; //选择排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class SelectionSort implements SortUtil.Sort &#123; public void sort(int[] data) &#123; int temp; for (int i = 0; i &lt; data.length; i++) &#123; int lowIndex = i; for (int j = data.length - 1; j &gt; i; j--) &#123; if (data[j] &lt; data[lowIndex]) &#123; lowIndex = j; &#125; &#125; SortUtil.swap(data,i,lowIndex); &#125; &#125; &#125; //Shell排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class ShellSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; for(int i=data.length/2;i&gt;2;i/=2)&#123; for(int j=0;j&lt;i;j++)&#123; insertSort(data,j,i); &#125; &#125; insertSort(data,0,1); &#125; private void insertSort(int[] data, int start, int inc) &#123; int temp; for(int i=start+inc;i&lt;data.length;i+=inc)&#123; for(int j=i;(j&gt;=inc)&amp;&amp;(data[j]&lt;data[j-inc]);j-=inc)&#123; SortUtil.swap(data,j,j-inc); &#125; &#125; &#125; &#125; //快速排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class QuickSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; quickSort(data,0,data.length-1); &#125; private void quickSort(int[] data,int i,int j)&#123; int pivotIndex=(i+j)/2; //swap SortUtil.swap(data,pivotIndex,j); int k=partition(data,i-1,j,data[j]); SortUtil.swap(data,k,j); if((k-i)&gt;1) quickSort(data,i,k-1); if((j-k)&gt;1) quickSort(data,k+1,j); &#125; private int partition(int[] data, int l, int r,int pivot) &#123; do&#123; while(data[++l]&lt;pivot); while((r!=0)&amp;&amp;data[--r]&gt;pivot); SortUtil.swap(data,l,r); &#125; while(l&lt;r); SortUtil.swap(data,l,r); return l; &#125; &#125;//改进后的快速排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class ImprovedQuickSort implements SortUtil.Sort &#123; private static int MAX_STACK_SIZE=4096; private static int THRESHOLD=10; public void sort(int[] data) &#123; int[] stack=new int[MAX_STACK_SIZE]; int top=-1; int pivot; int pivotIndex,l,r; stack[++top]=0; stack[++top]=data.length-1; while(top&gt;0)&#123; int j=stack[top--]; int i=stack[top--]; pivotIndex=(i+j)/2; pivot=data[pivotIndex]; SortUtil.swap(data,pivotIndex,j); //partition l=i-1; r=j; do&#123; while(data[++l]&lt;pivot); while((r!=0)&amp;&amp;(data[--r]&gt;pivot)); SortUtil.swap(data,l,r); &#125; while(l&lt;r); SortUtil.swap(data,l,r); SortUtil.swap(data,l,j); if((l-i)&gt;THRESHOLD)&#123; stack[++top]=i; stack[++top]=l-1; &#125; if((j-l)&gt;THRESHOLD)&#123; stack[++top]=l+1; stack[++top]=j; &#125; &#125; //new InsertSort().sort(data); insertSort(data); &#125; private void insertSort(int[] data) &#123; int temp; for(int i=1;i&lt;data.length;i++)&#123; for(int j=i;(j&gt;0)&amp;&amp;(data[j]&lt;data[j-1]);j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125; //归并排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class MergeSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; int[] temp=new int[data.length]; mergeSort(data,temp,0,data.length-1); &#125; private void mergeSort(int[] data,int[] temp,int l,int r)&#123; int mid=(l+r)/2; if(l==r) return ; mergeSort(data,temp,l,mid); mergeSort(data,temp,mid+1,r); for(int i=l;i&lt;=r;i++)&#123; temp[i]=data[i]; &#125; int i1=l; int i2=mid+1; for(int cur=l;cur&lt;=r;cur++)&#123; if(i1==mid+1) data[cur]=temp[i2++]; else if(i2&gt;r) data[cur]=temp[i1++]; else if(temp[i1]&lt;temp[i2]) data[cur]=temp[i1++]; else data[cur]=temp[i2++]; &#125; &#125; &#125; //改进后的归并排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class ImprovedMergeSort implements SortUtil.Sort &#123; private static final int THRESHOLD = 10; public void sort(int[] data) &#123; int[] temp=new int[data.length]; mergeSort(data,temp,0,data.length-1); &#125; private void mergeSort(int[] data, int[] temp, int l, int r) &#123; int i, j, k; int mid = (l + r) / 2; if (l == r) return; if ((mid - l) &gt;= THRESHOLD) mergeSort(data, temp, l, mid); else insertSort(data, l, mid - l + 1); if ((r - mid) &gt; THRESHOLD) mergeSort(data, temp, mid + 1, r); else insertSort(data, mid + 1, r - mid); for (i = l; i &lt;= mid; i++) &#123; temp[i] = data[i]; &#125; for (j = 1; j &lt;= r - mid; j++) &#123; temp[r - j + 1] = data[j + mid]; &#125; int a = temp[l]; int b = temp[r]; for (i = l, j = r, k = l; k &lt;= r; k++) &#123; if (a &lt; b) &#123; data[k] = temp[i++]; a = temp[i]; &#125; else &#123; data[k] = temp[j--]; b = temp[j]; &#125; &#125; private void insertSort(int[] data, int start, int len) &#123; for(int i=start+1;i&lt;start+len;i++)&#123; for(int j=i;(j&gt;start) &amp;&amp; data[j]&lt;data[j-1];j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125;//堆排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class HeapSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; MaxHeap h=new MaxHeap(); h.init(data); for(int i=0;i&lt;data.length;i++) h.remove(); System.arraycopy(h.queue,1,data,0,data.length); &#125; private static class MaxHeap&#123; void init(int[] data)&#123; this.queue=new int[data.length+1]; for(int i=0;i&lt;data.length;i++)&#123; queue[++size]=data[i]; fixUp(size); &#125; &#125; private int size=0; private int[] queue; public int get() &#123; return queue[1]; &#125; public void remove() &#123; SortUtil.swap(queue,1,size--); fixDown(1); &#125; //fixdown private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size) &#123; if (j &lt; size &amp;&amp; queue[j]&lt;queue[j+1]) j++; if (queue[k]&gt;queue[j]) //不用交换 break; SortUtil.swap(queue,j,k); k = j; &#125; &#125; private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j]&gt;queue[k]) break; SortUtil.swap(queue,j,k); k = j; &#125; &#125; &#125; &#125; //SortUtil: package org.rut.util.algorithm; import org.rut.util.algorithm.support.BubbleSort;import org.rut.util.algorithm.support.HeapSort;import org.rut.util.algorithm.support.ImprovedMergeSort;import org.rut.util.algorithm.support.ImprovedQuickSort;import org.rut.util.algorithm.support.InsertSort;import org.rut.util.algorithm.support.MergeSort;import org.rut.util.algorithm.support.QuickSort;import org.rut.util.algorithm.support.SelectionSort;import org.rut.util.algorithm.support.ShellSort;public class SortUtil &#123; public final static int INSERT = 1; public final static int BUBBLE = 2; public final static int SELECTION = 3; public final static int SHELL = 4; public final static int QUICK = 5; public final static int IMPROVED_QUICK = 6; public final static int MERGE = 7; public final static int IMPROVED_MERGE = 8; public final static int HEAP = 9; public static void sort(int[] data) &#123; sort(data, IMPROVED_QUICK); &#125; private static String[] name=&#123; "insert","bubble","selection","shell","quick","improved_quick","merge","improved_merge","heap" &#125;; private static Sort[] impl=new Sort[]&#123; new InsertSort(), new BubbleSort(), new SelectionSort(), new ShellSort(), new QuickSort(), new ImprovedQuickSort(), new MergeSort(), new ImprovedMergeSort(), new HeapSort() &#125;; public static String toString(int algorithm)&#123; return name[algorithm-1]; &#125; public static void sort(int[] data, int algorithm) &#123; impl[algorithm-1].sort(data); &#125; public static interface Sort &#123; public void sort(int[] data); &#125; public static void swap(int[] data, int i, int j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125;&#125; 有数组a[n]，用java代码将数组元素顺序颠倒1234567891011121314151617public class Test &#123; public static void reverse(int[] a, int left, int right) &#123; if (left &gt;= right) return; int temp; temp = a[left]; a[left] = a[right]; a[right] = temp; reverse(a, ++left, --right); &#125; public static void main(String args[]) &#123; int[] a = &#123; 1, 2, 3, 4, 5 &#125;; reverse(a, 0, a.length - 1); for (int i = 0; i &lt; a.length; i++) System.out.println(a[i]); &#125; &#125; 12．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－&gt;（一千零一拾一元整）输出。 1234567891011121314151617181920212223public class Test &#123; private static final char[] data = new char[]&#123;'零','壹','贰','叁','肆','伍','陆','柒','捌','玖'&#125;; private static final char[] units = new char[]&#123;'元','拾','佰','仟','万','拾','佰','仟','亿'&#125;; /*去零的代码 return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");*/ /*去零倒序 return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");*/ public static void main(String[] args) &#123; System.out.println(convert(230009)); &#125; private static String convert(int money) &#123; StringBuffer sbf = new StringBuffer(); int unit = 0; while(money!=0) &#123; sbf.insert(0,units[unit++]); int number = money%10; sbf.insert(0, data[number]); money /= 10; &#125; return sbf.toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零"); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（一）——Java基础知识]]></title>
    <url>%2Fposts%2F50981.html</url>
    <content type="text"><![CDATA[基础部分的顺序：基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io 的语法，虚拟机方面的语法。 1. 一个”.Java”源文件中是否可以包括多个类（不是内部类）？有什么限制？​ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 2. Java有没有goto?​ Java中的保留字，现在没有在Java中使用。 3. 说说&amp;和&amp;&amp;的区别。&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式 例如，对于if(str != null&amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp; ++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表明自己理解透彻深入. 实际经验丰富。 4. 在Java中如何跳出当前的多重嵌套循环？在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如， 12345678ok:for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123;System.out.println(“i=” + i+ “,j=” + j);if(j == 5) break ok; &#125;&#125; 另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。 1234567891011int arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;boolean found = false;for(int i=0;i&lt;arr.length &amp;&amp;!found;i++)&#123;for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i+ “,j=” + j); if(arri == 5) &#123;found = true;break; &#125; &#125;&#125; 5. switch语句能否作用在byte上，能否作用在long上，能否作用在String上?在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 6. short s1 = 1; s1= s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1 = 1; s1 += 1;由于 += 是Java语言规定的运算符，Java编译器会对它进行特殊处理，因此可以正确编译。 7.char型变量中能不能存贮一个中文汉字?为什么?char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 ​ 备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 8.用最有效率的方法算出2乘以8等於几?2 &lt;&lt; 3， 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。 9. 请设计一个一百亿的计算器首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚. 要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。 首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。-1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下： 1234int a = Integer.MAX_VALUE;int b = Integer.MAX_VALUE;int sum = a + b;System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum); 先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于210001000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下： （）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数 （）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中 （）提供加减乘除的功能 12345678910111213141516public class BigInteger&#123; int sign;byte[] val;public Biginteger(String val)&#123;sign = ;val = ; &#125;public BigInteger add(BigInteger other)&#123; &#125;public BigInteger subtract(BigIntegerother)&#123; &#125;public BigInteger multiply(BigIntegerother)&#123; &#125;public BigInteger divide(BigIntegerother)&#123; &#125;&#125; 备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看jdk中自带的Java.math.BigInteger类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力. 经验. 专业性. 英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 10. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： 1final StringBuffer a=new StringBuffer("immutable"); 执行如下语句将报告编译期错误： 1a=new StringBuffer(""); 但是，执行如下语句则可以通过编译： 1a.append(" broken!"); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： 12public voidmethod(final StringBuffer param)&#123;&#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： 1param.append("a"); 11. “==”和equals方法究竟有什么区别？（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚） ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = newObject();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码： 12String a=new String("foo");String b=new String("foo"); 两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下： 123boolean equals(Object o)&#123;return this==o;&#125; 这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 12. 静态变量和实例变量的区别？在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。 123456789public class VariantTest&#123; public static int staticVar = 0; public int instanceVar = 0; public VariantTest()&#123; staticVar++; instanceVar++; System.out.println(“staticVar=” +staticVar + ”,instanceVar=” + instanceVar); &#125;&#125; 备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷, 超过一般程序员，有写作能力！ 13. 是否可以从一个static方法内部发出对非static方法的调用？不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不可以发出对非static方法的调用。 14. Integer与int的区别int是Java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是Java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 15. Math.round(11.5)等於多少? Math.round(-11.5)等於多少?Math类中提供了三个与取整有关的方法：ceil. floor. round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.ceil(11.6)的结果为11,Math.ceil(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 16. 下面的代码有什么不妥之处? if(username.equals(“zxx”){} int x = 1; return x==1?true:false; 17. 请说出作用域public，private，protected，以及不写时的区别这四个作用域的可见范围如下表所示。 说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。 作用域 当前类 同一package 子孙类其他package public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。 18. Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?​ Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点： 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点： 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 不能通过访问权限. 返回类型. 抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 19. 构造器Constructor是否可被override?构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 20. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concreteclass)? 抽象类中是否可以有静态的main方法？​ 接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是Java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 21. 写clone()方法时，通常都有一行代码，是什么？clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 22. 面向对象的特征有哪些方面计算机软件系统是现实生活中的业务在计算机中的映射，而现实生活中的业务其实就是一个个对象协作的过程。面向对象编程就是按现实业务一样的方式将程序代码按一个个对象进行组织和编写，让计算机系统能够识别和理解用对象方式组织和编写的程序代码，这样就可以把现实生活中的业务对象映射到计算机系统中。 面向对象的编程语言有封装. 继承 . 抽象. 多态等4个主要的特征。 封装： 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚. 低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰. 更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 例如，人要在黑板上画圆，这一共涉及三个对象：人. 黑板. 圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法. 表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。 抽象： 抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下： 1234class Person&#123; String name; int age;&#125; 人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。 继承： 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法： 12UserDao userDao =daofactory.getDao(); userDao.insertUser(user); 比喻：人吃饭，你看到的是左手，还是右手？ 23. Java中实现多态的机制是什么？靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 24. abstract class和interface有什么区别?含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public staticfinal。 下面比较一下两者的语法区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public staticfinal类型，并且默认即为public staticfinal类型。 一个类可以实现多个接口，但只能继承一个抽象类。 下面接着再说说两者在应用上的区别： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断. 记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断. 记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： 123456789101112131415161718192021public abstract class BaseServletextends HttpServlet&#123;public final voidservice(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException&#123;记录访问日志进行权限判断 if(具有权限)&#123; try&#123; doService(request,response); &#125; catch(Excetpion e)&#123; 记录异常信息 &#125; &#125;&#125;protected abstract voiddoService(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException; //注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的&#125; public class MyServlet1 extendsBaseServlet&#123; protected voiddoService(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException&#123; 本Servlet只处理的具体业务逻辑代码 &#125;&#125; 父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法. 普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 25. abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下： private native void open(String name)throws FileNotFoundException; 如果我们要用Java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照Java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按Java的要求来写的，我们这个c语言函数就可以与Java对接上，Java那边的对接方式就是定义出与我们这个c函数相对应的方法，Java中对应的方法不需要写具体的代码，但需要在前面声明native。 关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。 26. 什么是内部类？Static NestedClass 和 Inner Class的不同。内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示： 1234567891011121314public class Outer&#123; int out_x = 0; public void method()&#123; Inner1 inner1 = new Inner1(); public class Inner2 //在方法体内部定义的内部类&#123; public method()&#123; out_x = 3; &#125; &#125; Inner2 inner2 = new Inner2(); &#125; public class Inner1 //在方法体外面定义的内部类&#123; &#125;&#125; ​ 在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下： 12Outer outer = new Outer();Outer.Inner1 inner1 = outer.newInnner1(); ​ 在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。 对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。 在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称： 12345public class Outer&#123; public void start()&#123; new Thread(new Runable()&#123;public void run()&#123;&#125;;&#125;).start(); &#125;&#125; ​ 最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static NestedClass，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static NestedClass与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public. protected. 默认的. private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static NestedClass类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static NestedClass，例如，假设Inner是定义在Outer类中的Static NestedClass，那么可以使用如下语句创建Inner类： 1Outer.Inner inner = new Outer.Inner(); ​ 由于static Nested Class不依赖于外部类的实例对象，所以，static NestedClass能访问外部类的非static成员变量。当在外部类中访问Static NestedClass时，可以直接使用Static NestedClass的名字，而不需要加上外部类的名字了，在Static NestedClass中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 ​ 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static NestedClass与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 ​ 备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。 27. 内部类可以引用它的包含类的成员吗？有没有什么限制？完全可以。如果不是静态内部类，那没有什么限制！ 如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码： 12345678class Outer&#123; static int x; static class Inner&#123; void test()&#123; syso(x); &#125; &#125;&#125; ​ 答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情况，让人家吃惊。 28. Anonymous InnerClass (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?​ 可以继承其他类或实现其他接口。不仅是可以，而是必须! 29. super.getClass()方法调用，下面程序的输出结果是多少？123456789import Java.util.Date;public class Test extends Date&#123; public static void main(String[]args) &#123; new Test().test(); &#125; public void test()&#123; System.out.println(super.getClass().getName()); &#125;&#125; 很奇怪，结果是Test 这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。 在test方法中，直接调用getClass().getName()方法，返回的是Test类名 由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在 test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。 如果想得到父类的名称，应该用如下代码： ​ getClass().getSuperClass().getName(); 30. String是最基本的数据类型吗?​ 基本数据类型包括byte. int. char. long. float. double. boolean和short。 Java.lang.String类是final类型的，因此不可以继承这个类. 不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 31. String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？​ 没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。 ​ 通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做： 12345678public class Demo &#123; private String s;... public Demo &#123; s = "Initial Value"; &#125;...&#125; 而非 1s = new String("Initial Value"); ​ 后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。​ 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。​ 至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。 32. 是否可以继承String类?​ String类是final类故不可以继承。 33. String s = newString(“xyz”);创建了几个StringObject? 二者之间有什么区别？​ 两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。 34. String 和StringBuffer的区别​ Java平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(newString(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，newStringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。 ​ 接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。 12345StringBuffer sbf = new StringBuffer(); for(int i=0;i&lt;100;i++) &#123; sbf.append(i); &#125; 上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。 1234String str = new String(); for(int i=0;i&lt;100;i++)&#123; str = str + i;&#125; ​ 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。 ​ String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 35. 如何把一段逗号分割的字符串转换成一个数组?​ 如果不查jdk api，我很难写出来！我可以说说我的思路： 用正则表达式，代码大概为：String [] result = orgStr.split(“,”); 用 StingTokenizer ,代码为：StringTokenizer tokener = StringTokenizer(orgStr,”,”); 12345String [] result = new String[tokener .countTokens()]; Int i=0;while(tokener.hasNext()&#123; result[i++]=toker.nextToken();&#125; 36. 数组有没有length()这个方法? String有没有length()这个方法？​ 数组没有length()这个方法，有length的属性。String有有length()这个方法。 37. 下面这条语句一共创建了多少个对象：Strings=”a”+”b”+”c”+”d”;答：对于如下代码： 12345String s1= "a";String s2 = s1 + "b";String s3 = "a" +"b";System.out.println(s2 =="ab");System.out.println(s3 =="ab"); ​ 第一条语句打印的结果为false，第二条语句打印的结果为true，这说明Javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 ​ 题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码， 12String s = "a" + "b"+ "c" + "d";System.out.println(s =="abcd"); ​ 最终打印的结果应该为true。 38. try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?​ 也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果： 1234567891011121314public class Test &#123; public static void main(String[]args) &#123; System.out.println(new Test().test());; &#125;static int test()&#123; int x =1;try&#123; return x; &#125; finally&#123; ++x; &#125; &#125;&#125; ———执行结果 1 ​ 运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。 39. 下面的程序代码输出的结果是多少？123456789101112131415public class smallT&#123; public static void main(Stringargs[])&#123; smallT t = new smallT(); int b = t.get(); System.out.println(b); &#125; public int get()&#123; try&#123; return 1 ; &#125; finally&#123; return 2 ; &#125; &#125;&#125; 返回的结果是2。 ​ 我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。 在讲解答案时可以用下面的程序来帮助分析： 123456789101112131415161718192021public class Test &#123; public static void main(String[]args) &#123; System.out.println(new Test().test());; &#125; int test()&#123; try&#123; return func1(); &#125; finally&#123; return func2(); &#125; &#125;int func1()&#123; System.out.println("func1"); return 1; &#125;int func2()&#123; System.out.println("func2"); return 2; &#125;&#125; ———–执行结果—————- func1 func2 2 结论：finally中的代码比return 和break语句后执行 40. final, finally,finalize的区别。final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码…… finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用 41. 运行时异常与一般异常有何异同？​ 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 42. error和exception有什么区别?​ error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 43. Java中的异常处理机制的简单原理和应用。​ 异常是指Java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间. 地点. 人物. 情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 ​ Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为Java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）. 类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 ​ Java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。 ​ 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误； 44. 请写出你最常见到的5个runtime exception。这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！ 所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException. ArrayIndexOutOfBoundsException. ClassCastException。 45. Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？46. Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？Java5以前，有如下两种： 第一种： new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下： 1234new Thread()&#123; public void run()&#123; &#125;&#125;.start(); 第二种： new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下： 1234new Thread(new Runnable()&#123; public void run()&#123; &#125; &#125;).start(); 从Java5开始，还有如下一些线程池创建多线程的方式： 123456ExecutorService pool =Executors.newFixedThreadPool(3) for(int i=0;i&lt;10;i++)&#123; pool.execute(new Runable()&#123;publicvoid run()&#123;&#125;&#125;); &#125;Executors.newCachedThreadPool().execute(newRunable()&#123;public void run()&#123;&#125;&#125;);Executors.newSingleThreadExecutor().execute(newRunable()&#123;public void run()&#123;&#125;&#125;); ​ 有两种实现方法，分别使用new Thread()和newThread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。 ​ 有两种实现方法，分别是继承Thread类与实现Runnable接口 用synchronized关键字修饰同步方法 ​ 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 47. sleep() 和 wait() 有什么区别?​ （网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） ​ sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.huawei.interview; public class MultiThread &#123; public static void main(String[]args) &#123; new Thread(new Thread1()).start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable &#123; @Override public void run() &#123; //由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。 synchronized (MultiThread.class) &#123; System.out.println("enterthread1..."); System.out.println("thread1is waiting"); try &#123; //释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键 字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方 法。这里，使用wait方法释放锁。 MultiThread.class.wait(); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; System.out.println("thread1is going on..."); System.out.println("thread1is being over!"); &#125; &#125; &#125; private static class Thread2 implements Runnable &#123; @Override public void run() &#123; synchronized (MultiThread.class) &#123; System.out.println("enterthread2..."); System.out.println("thread2notify other thread can release wait status.."); //由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。 MultiThread.class.notify(); System.out.println("thread2is sleeping ten millisecond..."); try &#123; Thread.sleep(10); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; System.out.println("thread2is going on..."); System.out.println("thread2is being over!"); &#125; &#125; &#125;&#125; 48. 同步和异步有何异同，在什么情况下分别使用他们？举例说明。​ 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 49. 下面两个方法同步吗？（自己发明）12345class Test&#123; synchronized static void sayHello3()&#123; &#125; synchronized void getX()&#123;&#125;&#125; 50. 多线程有几种实现方法?同步有几种实现方法?​ 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 同步的实现方面有两种，分别是synchronized,wait与notify wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 51. 启动一个线程是用run()还是start()? .​ 启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 52. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?分几种情况： 其他方法前是否加了synchronized关键字，如果没加，则能。 如果这个方法内部调用了wait，则可以进入其他synchronized方法。 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。 如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。 53. 线程的基本概念. 线程的基本状态以及状态之间的关系​ 一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。 调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 54. 简述synchronized和Java.util.concurrent.locks.Lock的异同 ？ 主要相同点：Lock能完成synchronized所实现的所有功能 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 举例说明（对下面的题用lock进行了改写）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.huawei.interview; import Java.util.concurrent.locks.Lock; import Java.util.concurrent.locks.ReentrantLock; public class ThreadTest &#123; private int j; private Lock lock = new ReentrantLock(); public static void main(String[]args) &#123; ThreadTest tt = new ThreadTest(); for(int i=0;i&lt;2;i++)&#123; new Thread(tt.new Adder()).start(); new Thread(tt.new Subtractor()).start(); &#125; &#125; private class Subtractor implements Runnable&#123; public void run() &#123; while(true)&#123; /*synchronized (ThreadTest.this) &#123; System.out.println("j--=" +j--); //这里抛异常了，锁能释放吗？ &#125;*/ lock.lock(); try&#123; System.out.println("j--="+ j--); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; private class Adder implements Runnable&#123; public void run() &#123; while(true)&#123; /*synchronized (ThreadTest.this) &#123; System.out.println("j++=" +j++); &#125;*/ lock.lock(); try&#123; System.out.println("j++="+ j++); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; &#125;&#125; 55. 设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。​ 以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 123456789101112131415161718192021222324252627282930313233343536public class ThreadTest1&#123; private int j; public static void main(String args[])&#123; ThreadTest1 tt=newThreadTest1(); Inc inc=tt.new Inc(); Dec dec=tt.new Dec(); for(inti=0;i&lt;2;i++)&#123; Threadt=new Thread(inc); t.start(); t=new Thread(dec); t.start(); &#125; &#125; private synchronized void inc()&#123; j++; System.out.println(Thread.currentThread().getName()+"-inc:"+j); &#125; private synchronized void dec()&#123; j--; System.out.println(Thread.currentThread().getName()+"-dec:"+j); &#125; class Inc implements Runnable&#123; public void run()&#123; for(inti=0;i&lt;100;i++)&#123; inc(); &#125; &#125; &#125; class Dec implements Runnable&#123; public void run()&#123; for(inti=0;i&lt;100;i++)&#123; dec(); &#125; &#125; &#125;&#125; ———-随手再写的一个————- 123456789101112131415161718192021222324class A&#123; JManger j =new JManager(); main()&#123; new A().call(); &#125; void call&#123; for(int i=0;i&lt;2;i++) &#123; new Thread( new Runnable()&#123; public voidrun()&#123;while(true)&#123;j.accumulate()&#125;&#125;&#125; ).start(); new Thread(new Runnable()&#123; public voidrun()&#123;while(true)&#123;j.sub()&#125;&#125;&#125;).start(); &#125; &#125;&#125; class JManager&#123; private j = 0; public synchronized void subtract()&#123; j-- &#125; public synchronized void accumulate()&#123; j++; &#125;&#125; 56. 子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。最终的程序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ThreadTest &#123; public static void main(String[]args) &#123; new ThreadTest().init(); &#125; public void init()&#123; final Business business = new Business(); new Thread( new Runnable()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; business.SubThread(i); &#125; &#125; &#125; ).start(); for(int i=0;i&lt;50;i++)&#123; business.MainThread(i); &#125; &#125; private class Business&#123; boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯 public synchronized void MainThread(int i)&#123; if(bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedExceptione) &#123; // TODO Auto-generatedcatch block e.printStackTrace(); &#125; for(int j=0;j&lt;5;j++)&#123; System.out.println(Thread.currentThread().getName()+ ":i=" + i +",j=" + j); &#125; bShouldSub = true; this.notify(); &#125; public synchronized void SubThread(int i)&#123; if(!bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ":i=" + i +",j=" + j); &#125; bShouldSub = false; this.notify(); &#125; &#125;&#125; 备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 package com.huawei.interview.lym; public class ThreadTest &#123; private static boolean bShouldMain = false; public static void main(String[] args) &#123; // TODO Auto-generatedmethod stub /*new Thread()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; for(int j=0;j&lt;10;j++)&#123; System.out.println("i=" + i +",j=" + j); &#125; &#125; &#125; &#125;.start();*/ //final String str = newString(""); new Thread( new Runnable()&#123; public void run()&#123; for(int i=0;i&lt;50;i++)&#123; synchronized (ThreadTest.class) &#123; if(bShouldMain)&#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+"i=" + i + ",j=" +j); &#125; bShouldMain = true; ThreadTest.class.notify(); &#125; &#125; &#125; &#125;).start(); for(int i=0;i&lt;50;i++)&#123; synchronized (ThreadTest.class) &#123; if(!bShouldMain)&#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;5;j++)&#123; System.out.println(Thread.currentThread().getName()+"i=" + i + ",j=" +j); &#125; bShouldMain = false; ThreadTest.class.notify(); &#125; &#125; &#125;&#125; 下面使用jdk5中的并发库来实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import Java.util.concurrent.Executors;importJava.util.concurrent.ExecutorService;import Java.util.concurrent.locks.Lock;importJava.util.concurrent.locks.ReentrantLock;importJava.util.concurrent.locks.Condition;public class ThreadTest&#123; private static Lock lock = newReentrantLock(); private static ConditionsubThreadCondition = lock.newCondition(); private static boolean bBhouldSubThread= false; public static void main(String [] args)&#123; ExecutorService threadPool =Executors.newFixedThreadPool(3); threadPool.execute(new Runnable()&#123; public void run()&#123; for(int i=0;i&lt;50;i++)&#123; lock.lock(); try&#123; if(!bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ",j=" + j); &#125; bBhouldSubThread = false; subThreadCondition.signal(); &#125;catch(Exception e)&#123; &#125; finally&#123; lock.unlock(); &#125; &#125; &#125; &#125;); threadPool.shutdown(); for(int i=0;i&lt;50;i++)&#123; lock.lock(); try&#123; if(bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ",j=" + j); &#125; bBhouldSubThread = true; subThreadCondition.signal(); &#125;catch(Exception e)&#123; &#125; finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; 57. 介绍Collection框架的结构​ 答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。 58. Collection框架中实现比较要实现什么接口​ comparable/comparator 59. ArrayList和Vector的区别答：这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。 接着才说ArrayList与Vector的区别，这主要包括两个方面： 同步性：Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 ​ 备注：对于Vector&amp;ArrayList. Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是Java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是Java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。 数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 ​ 总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。 60. HashMap和Hashtable的区别（条理上还需要整理，也是先说相同点，再说不同点） ​ HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 ​ HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 ​ HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 ​ Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 ​ Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 就HashMap与HashTable主要从三方面来说。 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 值：只有HashMap可以让你将空值作为一个表的条目的key或value 61. List 和 Map 区别?​ 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 62. List, Set, Map是否继承自Collection接口? List，Set是，Map不是 63. List. Map. Set三个接口，存取元素时，各有什么特点？​ 这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。 ​ 首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 ​ List表示有先后顺序的集合， 注意，不是那种按年龄. 按大小. 按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。 ​ Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,objvalue)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。 List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。 ​ HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，”abc”—&gt; 78，”def”—&gt; 62，”xyz”—&gt; 65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。 ​ 同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。 64. 说出ArrayList,Vector,LinkedList的存储性能和特性​ ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 65. 去掉一个Vector集合中重复的元素123456Vector newVector = new Vector();For (int i=0;i&lt;vector.size();i++)&#123; Object obj = vector.get(i); if(!newVector.contains(obj); newVector.add(obj); &#125; 还有一种简单的方式，HashSet set = new HashSet(vector); 66. Collection 和 Collections的区别。​ Collection是集合类的上级接口，继承与他的接口主要有Set 和List. ​ Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索. 排序. 线程安全化等操作。 67. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 68. 你所知道的集合类都有哪些？主要方法？​ 最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建. 存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。 ArrayList/VectoràList ​ àCollection HashSet/TreeSetàSet PropetiesàHashTable àMap Treemap/HashMap ​ 我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove,contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。 69. 两个对象值相同(x.equals(y) ==true)，但却可有不同的hash code，这句话对不对?对。 ​ 如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。 如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。 70. TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的） 实验代码： 1234567891011121314151617181920212223242526272829public class Parent implements Comparable&#123; private int age = 0; public Parent(int age)&#123; this.age = age; &#125; public int compareTo(Objecto) &#123; System.out.println("methodof parent"); Parent o1 = (Parent)o; return age&gt;o1.age?1:age&lt;o1.age?-1:0; &#125; &#125; public class Child extends Parent&#123; public Child()&#123; super(3); &#125; public int compareTo(Objecto) &#123; System.out.println("methodof child"); return 1; &#125; &#125; public class TreeSetTest &#123; public static void main(String[]args) &#123; TreeSet set = new TreeSet(); set.add(new Parent(3)); set.add(new Child()); set.add(new Parent(4)); System.out.println(set.size()); &#125;&#125; ##### 71. 说出一些常用的类，包，接口，请各举5个 要让人家感觉你对Java ee开发很熟，所以，不能仅仅只列core Java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。 常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer Java.util.Date，System，Class，List,HashMap 常用的包：Java.lang Java.io Java.util Java.sql,Javax.servlet,org.apache.strtuts.action,org.hibernate 常用的接口：Remote List Map Document NodeList,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate). Session(Hibernate),HttpSession 72. Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？​ 字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在Java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 73. 字节流与字符流的区别​ 要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。 在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。 字符向字节转换时，要注意编码的问题，因为字符串转成字节数组， 其实是转成该字符的某种编码的字节形式，读取也是反之的道理。 讲解字节流与字符流关系的代码案例： 12345678910111213141516171819202122232425262728293031323334353637import Java.io.BufferedReader;import Java.io.FileInputStream;import Java.io.FileOutputStream;import Java.io.FileReader;import Java.io.FileWriter;import Java.io.InputStreamReader;import Java.io.PrintWriter;public class IOTest &#123; public static void main(String[] args)throws Exception &#123; String str = "中国人"; /*FileOutputStream fos = newFileOutputStream("1.txt"); fos.write(str.getBytes("UTF-8")); fos.close();*/ /*FileWriter fw = newFileWriter("1.txt"); fw.write(str); fw.close();*/ PrintWriter pw = newPrintWriter("1.txt","utf-8"); pw.write(str); pw.close(); /*FileReader fr = newFileReader("1.txt"); char[] buf = new char[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len); System.out.println(myStr);*/ /*FileInputStream fr = newFileInputStream("1.txt"); byte[] buf = new byte[1024]; int len = fr.read(buf); String myStr = newString(buf,0,len,"UTF-8"); System.out.println(myStr);*/ BufferedReader br = new BufferedReader( new InputStreamReader(newFileInputStream("1.txt"),"UTF-8")); String myStr = br.readLine(); br.close(); System.out.println(myStr); &#125;&#125; 74. 什么是Java序列化，如何实现Java序列化？或者请解释Serializable接口的作用。​ 我们有时候将一个Java对象变成字节流的形式传出去或者从一个字节流中恢复成一个Java对象，例如，要将Java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个Java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让Java 帮我们做，要被传输的对象必须实现serializable接口，这样，Javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implementsSerializable只是为了标注该对象是可被序列化的。 ​ 例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。 75. 描述一下JVM加载class文件的原理机制?​ JVM中类的装载是由ClassLoader和它的子类来实现的,JavaClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 76. heap和stack有什么区别。​ Java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 77. GC是什么? 为什么要有GC?GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 78. 垃圾回收的优点和原理。并考虑2种回收机制。​ Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 79. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？​ 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址. 大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行. 80. 什么时候用assert。​ assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。一般来说，assertion用于保证程序最基本. 关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 123456789101112package com.huawei.interview;public class AssertTest &#123; public static void main(String[]args) &#123; int i = 0; for(i=0;i&lt;5;i++)&#123; System.out.println(i); &#125; //假设程序不小心多了一句--i; --i; assert i==5; &#125;&#125; 81. Java中会存在内存泄漏吗，请简单描述。​ 所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.huawei.interview;import Java.io.IOException; public class GarbageTest &#123; public static void main(String[]args) throws IOException &#123; try &#123; gcTest(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; System.out.println("hasexited gcTest!"); System.in.read(); System.in.read(); System.out.println("outbegin gc!"); for(int i=0;i&lt;100;i++)&#123; System.gc(); System.in.read(); System.in.read(); &#125; &#125; private static void gcTest() throws IOException&#123; System.in.read(); System.in.read(); Person p1 = new Person(); System.in.read(); System.in.read(); Person p2 = new Person(); p1.setMate(p2); p2.setMate(p1); System.out.println("beforeexit gctest!"); System.in.read(); System.in.read(); System.gc(); System.out.println("exitgctest!"); &#125; private static class Person&#123; byte[] data = new byte[20000000]; Person mate = null; public void setMate(Personother) &#123; mate = other; &#125; &#125;&#125; ​ Java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 ​ 检查Java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 ​ 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 ​ 下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为null即可）： ​ 我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。 1234567891011121314151617181920public class Stack &#123; private Object[] elements=new Object[10]; private int size = 0; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if( size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * elements.length+1]; System.arraycopy(oldElements,0, elements, 0, size); &#125; &#125;&#125; ​ 上面的原理应该很简单，假如堆栈加了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。 ​ 但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上G了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。 ​ 例子1 12345678public class Bad&#123; public static Stack s=Stack(); static&#123; s.push(new Object()); s.pop(); //这里有一个对象发生内存泄露 s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 &#125; &#125; 因为是static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收其实这个应该很容易理解，Stack内部持有100个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！ ​ 内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 82. 能不能自己写个类，也叫Java.lang.String？可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个Java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个Java.lang.String，这时候Servlet程序加载的就是我们自己写的Java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了Java.lang.String类的都将出现问题。 ​ 虽然Java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括Java.lang这样的包中的类。 （下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题目泄露了）例如，运行下面的程序： ​ 123456package Java.lang; public class String &#123; public static void main(String[]args) &#123; System.out.println("string"); &#125;&#125; 报告的错误如下： ​ Java.lang.NoSuchMethodError: main ​ Exception in thread “main” 这是因为加载了jre自带的Java.lang.String，而该类中没有main方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的语法及基本命令]]></title>
    <url>%2Fposts%2F20927.html</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。 概述宗旨Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTMLMarkdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 123456789这是一个普通段落。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： 1http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： 1http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： 1&amp;copy; Markdown 会保留它不动。而若你写： 1AT&amp;T Markdown 就会将它转为： 1AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 14 &lt; 5 Markdown 将会把它转换为： 14 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的# 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的列表标记写成： 1231. Bird1. McHale1. Parish 或甚至是： 1233. Bird1. McHale8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来，举例来说： 12* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个： 123* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 123这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： 1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： 12345Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beepend tell&lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： 123&lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 会被转换为： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： 12345&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： 1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： 12[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12[link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： 1[Google][] 然后定义链接内容： 1[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： 1Visit [Daring Fireball][] for more information. 然后接着定义链接： 1[Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： 123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： 123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： 123I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或_ 包起来的话，则会被转成 &lt;strong&gt;，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： 1un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（12 Use the printf() function. 12会产生： Use the printf() function. 12如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 12这段语法会产生： There is a literal backtick (`) here. 12代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 12会产生： A single backtick in a code span: ` A backtick-delimited string in a code span: foo 12在代码区段内，`&amp;` 和方括号**都**会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any &lt;blink&gt; tags. 12转为： Please don’t use any &lt;blink&gt; tags. 12你也可以这样写： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. 12以产生： &amp;#8212; is the decimal-encodedequivalent of &amp;mdash;. 12345678### 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式*和*参考式*。行内式的图片语法看起来像是： 12345678详细叙述如下：- 一个惊叹号 `!`- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &apos;title&apos; 文字。参考式的图片语法则长得像这样： 12「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 12345678910到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `&lt;img&gt;` 标签。------## 其它### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12Markdown 会转为： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &#x61;&#x64;&#x64;&#x72;&#101;&#x73;&#115;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d; 12Markdown 会转成： &#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61; &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109; 12345678在浏览器里面，这段字串（其实是 `&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;`）会变成一个可以点击的「address@example.com」链接。（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `&lt;em&gt;` 标签），你可以在星号的前面加上反斜杠： *literal asterisks* 12Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧#. 井字号 加号 减号. 英文句点! 惊叹号``` Markdown基本语法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an example link.引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：引用方式： 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello^hello 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JEECMS自定义标签]]></title>
    <url>%2Fposts%2F25712.html</url>
    <content type="text"><![CDATA[CMS是”Content Management System”的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。 自定义标签[mycontent_list]实现步骤:创建jc_mycontent的表12345678910111213141516171819202122232425-- Create tablecreate table JC_MYCONTENT( id NUMBER not null, title VARCHAR2(250), content VARCHAR2(250))tablespace CMS pctfree 10 initrans 1 maxtrans 255 storage ( initial 64K minextents 1 maxextents unlimited );-- Create/Recreate primary, unique and foreign key constraints alter table JC_MYCONTENT add constraint PK_ID primary key (ID) using index tablespace CMS pctfree 10 initrans 2 maxtrans 255; 创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.jeecms.cms.entity.main;public class MyContent &#123; private Integer id; private String title; private String content; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public MyContent(Integer id, String title, String content) &#123; super(); this.id = id; this.title = title; this.content = content; &#125; public MyContent() &#123; super(); &#125;&#125; 接下来是配置hibernate中jc_mycontent表的配置文件123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.jeecms.cms.entity.main"&gt; &lt;class name="MyContent" table="jc_mycontent"&gt; &lt;meta attribute="sync-DAO"&gt;false&lt;/meta&gt; &lt;cache usage="read-write" /&gt; &lt;id name="id" type="java.lang.Integer" column="id"&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;property name="title" column="title" type="java.lang.String" not-null="true" /&gt; &lt;property name="content" column="content" type="java.lang.String" not-null="true" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 持久层接口123456789package com.jeecms.cms.dao.main;import java.util.List;import com.jeecms.cms.entity.main.MyContent;public interface MyContentDao &#123; public List&lt;MyContent&gt; getList();&#125; 持久层实现类12345678910111213141516171819202122232425262728293031package com.jeecms.cms.dao.main.impl;import java.util.List;import org.springframework.stereotype.Repository;import com.jeecms.cms.dao.main.MyContentDao;import com.jeecms.cms.entity.main.MyContent;import com.jeecms.common.hibernate4.Finder;import com.jeecms.common.hibernate4.HibernateBaseDao;@Repository// 持久层public class MyContentDaoImpl extends HibernateBaseDao&lt;MyContent, Integer&gt; implements MyContentDao &#123; @SuppressWarnings("unchecked") public List&lt;MyContent&gt; getList() &#123; return find(byNothing()); &#125; private Finder byNothing() &#123; Finder f = Finder.create(); f.append("from MyContent");// 可以在此处添加查询条件或者添加各种方法进行动态查询 f.setCacheable(true); return f; &#125; @Override protected Class&lt;MyContent&gt; getEntityClass() &#123; return MyContent.class; &#125;&#125; 业务层接口123456789package com.jeecms.cms.manager.main;import java.util.List;public interface MyContentMng &#123; public List getList();&#125;public interface MyContentMng &#123; public List getList();&#125; 业务层实现类1234567891011121314151617181920212223242526272829303132333435363738package com.jeecms.cms.manager.main.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jeecms.cms.dao.main.MyContentDao;import com.jeecms.cms.entity.main.MyContent;import com.jeecms.cms.manager.main.MyContentMng;import com.jeecms.cms.service.ContentListener;@Service// ()业务层@Transactionalpublic class MyContentMngImpl implements MyContentMng &#123; @Transactional(readOnly = true) // 配置事务为只读 public List&lt;MyContent&gt; getList() &#123; return myContentDao.getList(); &#125; private MyContentDao myContentDao; @Autowired // 自动绑定 public void setMyContentDao(MyContentDao myContentDao) &#123; this.myContentDao = myContentDao; &#125; private List&lt;ContentListener&gt; listenerList; @Autowired public void setListenerList(List&lt;ContentListener&gt; listenerList) &#123; this.listenerList = listenerList; &#125;&#125; 标签类的抽象类最主要的就是getData这个方法，以及绑定业务层(其中也可以添加多种查询方法，可参考类AbstractContentDirective )。 1234567891011121314151617181920package com.jeecms.cms.action.directive.abs;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import com.jeecms.cms.manager.main.MyContentMng;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveModel;import freemarker.template.TemplateException;public abstract class AbstractMyContentDirective implements TemplateDirectiveModel &#123; protected Object getData(Map params, Environment env) throws TemplateException &#123; return myContentMng.getList(); &#125; @Autowired protected MyContentMng myContentMng;&#125; 标签工具类DirectiveUtils下定义输出参数:MYOUT_LIST1public static final String MYOUT_LIST = "mytag_list"; 自定义标签中最重要的类继承上边的抽象类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jeecms.cms.action.directive;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;import com.jeecms.cms.action.directive.abs.AbstractMyContentDirective;import com.jeecms.cms.entity.main.MyContent;import static com.jeecms.common.web.freemarker.DirectiveUtils.MYOUT_LIST;import com.jeecms.common.web.freemarker.DefaultObjectWrapperBuilderFactory;import com.jeecms.common.web.freemarker.DirectiveUtils;import com.jeecms.core.entity.CmsSite;import com.jeecms.core.web.util.FrontUtils;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveBody;import freemarker.template.TemplateException;import freemarker.template.TemplateModel;public class MyContentListDirective extends AbstractMyContentDirective &#123; /** * 模板名称 */ public static final String TPL_NAME = "mycontent_list"; @SuppressWarnings("unchecked") public void execute(Environment env, @SuppressWarnings("rawtypes") Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; // 获取站点 CmsSite site = FrontUtils.getSite(env); // 获取内容列表 List&lt;MyContent&gt; list = getList(params, env); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;(params); // OUT_LIST值为tag_list，将内容列表放入其中 paramWrap.put(MYOUT_LIST, DefaultObjectWrapperBuilderFactory.getDefaultObjectWrapper() .wrap(list)); // 将params的值复制到variable中 Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); // 没有采用默认的模板，直接采用自己写的简单的模板（mycontent_list.html） FrontUtils.includeTpl(TPL_NAME, site, params, env); // 将variable中的params值移除 DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; @SuppressWarnings("unchecked") protected List&lt;MyContent&gt; getList(Map&lt;String, TemplateModel&gt; params, Environment env) throws TemplateException &#123; return myContentMng.getList(); &#125;&#125; 在jeecms-context.xml中声明标签1&lt;bean id="cms_mycontent_list" class="com.jeecms.cms.action.directive.MyContentListDirective"/&gt; 在jeecms-context.xml中注入DAO1&lt;bean id="myContentDao" class="com.jeecms.cms.dao.main.impl.MyContentDaoImpl"/&gt; 在jeecms-context.xml中注入Manager1&lt;bean id="myContentMng" class="com.jeecms.cms.manager.main.impl.MyContentMngImpl"/&gt; 配置文件jeecms-servlet-front.xml中有一段对标签的配置jeecms.properties中配置标签名1directive.cms_mycontent_list=cms_mycontent_list 新建模板WEB-INF\t\cms\www\oa\tag下新建模板mycontent_list.html,并加入如下代码(里边也可以自己添加一些样式，可参考WEB-INF\t\cms_sys_defined\style_list下样式文件) 12345[#list mytag_list as a] &lt;li&gt; &lt;a href="$&#123;a.title&#125;"&gt;"$&#123;a.content&#125;"&lt;/a&gt; &lt;/li&gt;[/#list] 调用代码1234567[@cms_mycontent_list] [#list mycontent_list as a] &lt;li&gt; &lt;a href="$&#123;a.title&#125;"&gt;"$&#123;a.content&#125;"&lt;/a&gt; &lt;/li&gt; [/#list][/@cms_mycontent_list] 通过以上这些代码，实现将自己的表jc_mycontent中的数据查询并显示在页面上]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>cms</tag>
        <tag>jeecms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO主题图配置]]></title>
    <url>%2Fposts%2F13957.html</url>
    <content type="text"><![CDATA[为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。 然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。 主题图片我比较喜欢像36氪那样，一篇文章带一张相关图片。图片能传达的信息永远比文字丰富。当浏览文章列表时，除了标题最吸引人的自然就属文章主题图片了。 所以为了方便使用，我创建了一个图片样式叫img-topic，大概是长这样子的。 12345678910/themes/jacman/source/css/_partial/index.styl.img-topic max-width: 300px; max-height: 1800px; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right; 在博客中，我更希望主题图片居右，并且点进文章正文后该图片不会显示。我们可以使用HTML语法插入图片。 1&lt;img src=&quot;图片路径&quot; class=&quot;img-topic&quot; /&gt; 这儿是一张使用img-topic样式后的效果图。 img-topic效果图 Logo 图片Logo 图片可以快速定义一篇文章的主题。与主题图片非常类似，只不过 Logo 图片放置的是 Logo ，而且一般比主题图片要小。类似的，Logo 图片也是居右，并且在文章正文中不会显示。 关于img-logo的样式如下 12345678910/themes/jacman/source/css/_partial/index.styl.img-logo max-width: 180px; max-height: 96px; display: block; margin-right: .7em; margin-left: .7em; padding: 0; float: right; clear: right; 使用HTML语法插入图片 1&lt;img src=&quot;图片路径&quot; class=&quot;img-logo&quot; /&gt; 效果如下图： img-logo效果图 居中图片有网友抱怨 Jacman 的图片只能居左，他喜欢让图片居中却不知道该怎么做。为此，我也创建了一个图片样式叫img-center，所需的代码很短。 1234/themes/jacman/source/css/_partial/article.styl.img-center display: block ; margin: auto; 阴影图片有时候添加的图片可能会与文章背景混淆，使得读者看不清到底哪部分是图片哪部分是文章。使用img-shadow为图片添加边角阴影可以更加凸显图片的位置，也能更美观。 123/themes/jacman/source/css/_partial/article.styl.img-shadow box-shadow: 0 0 2px 3px #ddd; 使用HTML语法插入图片 1&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg&quot; class=&quot;img-shadow&quot; /&gt; 画廊图片Hexo 中提供了一种文章类别叫photo，Jacman 也为这种文章设计了图片浏览方式。具体效果可以看这篇 Demo。photo类文章的写法可以看 Demo Sample。 photo文章效果图 图片备注Jacman 中可以方便地为图片提供备注。 1![添加你的备注](http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg) 效果就如下图，在图片左下方会显示关于图片的描述。 添加你的备注 OK，就这么多了，希望大家喜欢。如果嫌折腾麻烦，欢迎使用最新版的 Jacman，可以直接使用以上定义的样式！ PS:有任何关于 Hexo 的问题，欢迎来 Hexo 中文社区 咨询。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth2认证的基本流程]]></title>
    <url>%2Fposts%2F8224.html</url>
    <content type="text"><![CDATA[在一个单位中，可能是存在多个不同的应用，比如学校会有财务的系统会有学生工作的系统，还有图书馆的系统等等，如果每个系统都用独立的账号认证体系，会给用户带来很大困扰，也给管理带来很大不便。所以需要设计一种统一登录的解决方案。比如我登陆了百度账号，进贴吧时发现已经登录了，进糯米发现也自动登录了。常见的有两种情况，一种是SSO（单点登录）效果是一次输入密码多个网站可以识别在线状态；还有一种是多平台登录，效果是可以用一个账号（比如QQ账号）登录多个不同的网站。 SSO与多平台登录SSO一般用于同一单位的多个站点的登陆状态保持，技术上一般参考CAS协议；多平台登录一般是Oauth体系的协议，有多种认证模式但是不具备会话管理和状态保持。不过从本质上讲，我觉得两者都是通过可信的第三方进行身份验证，如果说同一单位的多个子系统共同只围绕一个第三方账户（可以称为认证中心）进行多平台登录验证，那么在第三方平台登录后再访问其他网站，效果和统一登录是差不多的。此外，Oauth2还有个好处就是可以实现跨平台的登录管理，因为他的认证过程不依赖于session和cookie，比如对于移动端设备，以及在前后端分离后这种登录认证方式也可以起到很大作用。这篇文章里我就着结合之前项目中整合过的OAUTH2来讲一讲这种登录认证的过程。项目是基于Shiro+ALTU实现，参考方案mkk/oauth2-shiro - 码云 - 开源中国 。 oauth2的基本概念在Oauth中至少是有用户，应用服务器，认证服务器这几个角色在交互。OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”应用服务器”进行互动。 OAuth2的基本流程用户通过浏览器访问一个应用，比如我要上慕课网学习。 网站要求我登录，我选择使用QQ登录，这里的QQ登录就是那个认证服务器。 这个时候慕课提供的QQ登录链接会把我带到QQ登录页面 在QQ的登录页面完成登录后，选择授权，也就是允许慕课网获取我的资料。 这个时候我们看到浏览器经过几次跳转后返回慕课网，这个时候我们已经完成了登录。 重点在于几次跳转的过程中，慕课网和QQ登录的服务之间还有过几次交互。 我们选择了授权的时候QQ登录服务器会根据慕课跳转到QQ时候给出的重定向链接返回给慕课网一个code，这个code代表QQ的登录服务器认可慕课网这个应用服务器的这个请求是合法的予以放行. 慕课这个时候就会用这个code再次向QQ登录服务发起请求服务令牌（token）。 拿到这个令牌之后，接下来慕课需要用户的一些基本信息时就可以通过在向QQ服务提交的请求头里带上这个令牌，令牌验证通过就可以拿到用户资源。 这一部分的操作是应用服务器和验证服务器之间的交互，这个过程对用户是透明的。这个过程中慕课网是不需要知道用户的账号密码也可以完成对用户身份的认证，这个token就可以用来标识用户资源。官方的运行流程图是这样的: OAuth的几种认证模式上述讲的是OAuth2中支持的授权码（CODE）方式的认证流程，也是其支持的四种认证方式里最复杂的，其他的三种种包括： 简化模式（implicit），(在redirect_uri 的Hash传递token; Auth客户端运行在浏览器中,如JS,Flash) 密码模式（resource owner password credentials），将用户名,密码传过去,直接获取token； 客户端模式（client credentials），无用户,用户向客户端注册,然后客户端以自己的名义向’服务端’获取资源；详细的OAuth2资料参考理解OAuth 2.0|阮一峰的网络日志分别适用不同场景，复杂度也比授权码模式要低，所以这里就只说说授权码模式的具体过程。 CODE方式认证实例假设现在有一个应用服务器跑在我本机8000端口，认证服务器在8090端口。在需要用户登录时候把用户带到以下的一个URL. 1http://localhost:8090/oauth/authorize?response_type=code&amp;scope=read write&amp;client_id=test&amp;redirect_uri=http://localhost:8000/login&amp;state=09876999 我们注意到几个重要的参数： response_type：表示授权类型，就是上面讲的那四种类型，这里用的是code方式。 client_id：表示客户端的ID，代表哪个应用请求验证 redirect_uri：表示重定向URI，验证以后的回调地址，一般用来接收返回的code，以及做下一步处理。 scope：表示申请的权限范围， state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。作为安全校验。 下面是验证服务器接受这个请求的控制器关键代码： 1234567891011121314151617@RequestMapping(&quot;authorize&quot;)public void authorize(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; try &#123; OAuthAuthxRequest oauthRequest = new OAuthAuthxRequest(request); if (oauthRequest.isCode()) &#123; CodeAuthorizeHandler codeAuthorizeHandler = new CodeAuthorizeHandler(oauthRequest, response); LOG.debug(&quot;Go to response_type = &apos;code&apos; handler: &#123;&#125;&quot;, codeAuthorizeHandler); codeAuthorizeHandler.handle(); &#125; else if (oauthRequest.isToken()) &#123; TokenAuthorizeHandler tokenAuthorizeHandler = new TokenAuthorizeHandler(oauthRequest, response); LOG.debug(&quot;Go to response_type = &apos;token&apos; handler: &#123;&#125;&quot;, tokenAuthorizeHandler); tokenAuthorizeHandler.handle(); &#125; else &#123; unsupportResponseType(oauthRequest, response); &#125; &#125; &#125; 首先拿到这个请求以后根据请求的参数将其封装成一个OAuthAuthxRequest,基本就是把请求过来的参数，方法绑定便于使用。这是由oltu提供的OAuthRequest的进一步封装。然后判断这个请求的授权的类型是否是code，也就是判断下请求参数的response_type是否为code，可以看到目前制作了两种类型的授权。然后根据对应的授权类型，构造对应的方法处理器。下面是handle的实现接口： 123456789101112131415161718192021222324public void handle() throws OAuthSystemException, ServletException, IOException &#123; //验证请求是否合法，主要是针对参数做基本的校验，重定向链接，客户端ID授权范围等这些信息与注册的是否相同。 if (validateFailed()) &#123; return; &#125; //判断用户是否登录过，根据session判断。因此多个应用使用同一个授权服务的话，是可以直接跳过登录步骤的也就实现了单点登录的效果。如果没有登录的话，这一步的请求会被重定向至登录页面。（登录也得隐藏域会带上这些参数） if (goLogin()) &#123; return; &#125; //这个请求如果是从登录页面提交过来的，那么就提交用户的登录，这个框架中交给shiro去做登录相关的操作。 if (submitLogin()) &#123; return; &#125; // 本系统中把登录和授权放在两个步骤中完成，有点像新浪微博的方式，QQ是一步完成授权。用户未授权则跳转授权页面 if (goApproval()) &#123; return; &#125; //与登录类似，也是提交用户批准或拒绝了权限请求 if (submitApproval()) &#123; return; &#125; //以上任意一步没有通过都是授权失败会进行相应处理，如果都通过了就发放Code码。 handleResponse(); &#125; 如果以上步骤都通过的话，认证服务器会转向这个会调地址，带上发放的Code码，类似如下： 1http://localhost:8000/login?code=bca654ab6133ab3cbc55bb751da93b1c&amp;state=09876999 可以看到带回了返回的参数，以及原样返回的状态码。应用服务器这时候拿到返回的code去换token,发起如下的一个请求： 1localhost:8090/oauth/token?client_id=test&amp;client_secret=test&amp;grant_type=authorization_code&amp;code=bca654ab6133ab3cbc55bb751da93b1c&amp;redirect_uri=http://localhost:8000/login&amp;scope=read%20write&amp;state=09876999 与之前请求类似只是多了一个code字段，去验证客户端的合法性。 验证服务器会在收到code以后去查找是否有支持这种code的处理器，如果有则发放token。 1234567for (OAuthTokenHandler handler : handlers) &#123; if (handler.support(tokenRequest)) &#123; LOG.debug(&quot;Found &apos;&#123;&#125;&apos; handle OAuthTokenxRequest: &#123;&#125;&quot;, handler, tokenRequest); handler.handle(tokenRequest, response); return; &#125; &#125; 初始化支持的handler 123456private void initialHandlers() &#123; handlers.add(new AuthorizationCodeTokenHandler()); handlers.add(new PasswordTokenHandler()); handlers.add(new RefreshTokenHandler()); handlers.add(new ClientCredentialsTokenHandler()); &#125; 验证通过后应用服务器会接受到包含token的一个json数据： 123456&#123;&quot;access_token&quot;: &quot;23e003b5e4b9b7eda228b845532d8336&quot;,&quot;refresh_token&quot;: &quot;d6b49710f398c405a62f31a6676c5830&quot;,&quot;token_type&quot;: &quot;Bearer&quot;,&quot;expires_in&quot;: 43199&#125; 这个token是有一定的有效期的，在服务端会缓存这个token以便下一次查询，应用客户端也应该保留这个token，访问受限资源时候需要带上这个token去验证身份。比如请求一个API如下： 123curl -i -X GET \ -H &quot;Authorization:Bearer 33dbfc80f5659c6fdec73a044ff724c3&quot; \ &apos;http://localhost:8090/api/test&apos; 资源服务器上使用shiro做安全验证，配置OAuth2对应的realms即可： 123456&lt;property name=&quot;realms&quot;&gt;&lt;list&gt; &lt;bean id=&quot;systemAuthorizingRealm&quot; class=&quot;me.kbiao.example.modules.sys.security.SystemAuthorizingRealm&quot;/&gt; &lt;bean id=&quot;oAuth2Realm&quot; class=&quot;me.kbiao.example..modules.sys.security.OAuth2Realm&quot;/&gt;&lt;/list&gt;&lt;/property&gt; 在这个reamls中根据token去查到用户信息，再去分发对应的资源。自此便完成了整个oauth2的流程。这个流程中认证服务系统需要配置三张数据表： client_details表中存放注册的客户端数据。如回调地址，授权类型，是否信任，权限信息等 code中存放发放给客户端应用的code，使用后失效，以保证安全性 access_token中存放用户信息、客户端和token的对应关系。 项目是基于Shiro+ALTU实现，参考方案mkk/oauth2-shiro - 码云 - 开源中国 ，更详细的内容，可以去读读Shengzhao Li开源的代码 总结 本文简单介绍了几种统一认证的解决方案，然后详细介绍了OAuth2的认证流程，并结合实例详细介绍了CODE授权的流程。尽管OAuth2被广泛用于多平台登录解决方案，我觉得在设置cookie、session共享之后也可以被应用于单点登录的解决方案。 作者： K_Biao 来源：慕课网]]></content>
      <categories>
        <category>OAuth</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2Fposts%2F5063.html</url>
    <content type="text"><![CDATA[NodeJS基础什么是NodeJSJS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。 有啥用处尽管存在一听说可以直接运行JS文件就觉得很酷的同学，但大多数同学在接触新东西时首先关心的是有啥用处，以及能带来啥价值。 NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。 如他所愿，NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。 因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。 NodeJS生态圈正欣欣向荣。 如何安装安装程序NodeJS提供了一些安装程序，都可以在nodejs.org这里下载并安装。 Windows系统下，选择和系统版本匹配的.msi后缀的安装文件。Mac OS X系统下，选择.pkg后缀的安装文件。 编译安装Linux系统下没有现成的安装程序可用，虽然一些发行版可以使用apt-get之类的方式安装，但不一定能安装到最新版。因此Linux系统下一般使用以下方式编译方式安装NodeJS。 确保系统下g++版本在4.6以上，python版本在2.6以上。 从nodejs.org下载tar.gz后缀的NodeJS最新版源代码包并解压到某个位置。 进入解压到的目录，使用以下命令编译和安装。 123$ ./configure$ make$ sudo make install 如何运行打开终端，键入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如： 123$ node&gt; console.log(&apos;Hello World!&apos;);Hello World! 如果要运行一大段代码的话，可以先写一个JS文件再运行。例如有以下hello.js。 1234function hello() &#123; console.log(&apos;Hello World!&apos;);&#125;hello(); 写好后在终端下键入node hello.js运行，结果如下： 12$ node hello.jsHello World! 权限问题在Linux系统下，使用NodeJS监听80或443端口提供HTTP(S)服务时需要root权限，有两种方式可以做到。 一种方式是使用sudo命令运行NodeJS。例如通过以下命令运行的server.js中有权限使用80和443端口。一般推荐这种方式，可以保证仅为有需要的JS脚本提供root权限。 1$ sudo node server.js 另一种方式是使用chmod +s命令让NodeJS总是以root权限运行，具体做法如下。因为这种方式让任何JS脚本都有了root权限，不太安全，因此在需要很考虑安全的系统下不推荐使用。 12$ sudo chown root /usr/local/bin/node$ sudo chmod +s /usr/local/bin/node 模块编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。 在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。 requirerequire函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。 123456var foo1 = require(&apos;./foo&apos;);var foo2 = require(&apos;./foo.js&apos;);var foo3 = require(&apos;/home/user/foo&apos;);var foo4 = require(&apos;/home/user/foo.js&apos;);// foo1至foo4中保存的是同一个模块的导出对象。 另外，可以使用以下方式加载和使用一个JSON文件。 1var data = require(&apos;./data.json&apos;); exportsexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。 123exports.hello = function () &#123; console.log(&apos;Hello World!&apos;);&#125;; module通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。 123module.exports = function () &#123; console.log(&apos;Hello World!&apos;);&#125;; 以上代码中，模块默认导出对象被替换为一个函数。 模块初始化一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。 主模块通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。 1$ node main.js 完整示例例如有以下目录。 1234- /home/user/hello/ - util/ counter.js main.js 其中counter.js内容如下： 1234567var i = 0;function count() &#123; return ++i;&#125;exports.count = count; 该模块内部定义了一个私有变量i，并在exports对象导出了一个公有方法count。 主模块main.js内容如下： 123456var counter1 = require(&apos;./util/counter&apos;);var counter2 = require(&apos;./util/counter&apos;);console.log(counter1.count());console.log(counter2.count());console.log(counter2.count()); 运行该程序的结果如下： 1234$ node main.js123 可以看到，counter.js并没有因为被require了两次而初始化两次。 二进制模块虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端同学而言编写过于困难，并且难以跨平台使用，因此不在本教程的覆盖范围内。 小结本章介绍了有关NodeJS的基本概念和使用方法，总结起来有以下知识点： NodeJS是一个JS脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令。 终端下直接输入node命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式。 NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。 除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天。 代码的组织和部署有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。 模块路径解析规则我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。 内置模块 如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(&#39;fs&#39;)。 node_modules目录 NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(&#39;foo/bar&#39;)方式加载模块时，则NodeJS依次尝试使用以下路径。 123/home/user/node_modules/foo/bar/home/node_modules/foo/bar/node_modules/foo/bar NODE_PATH环境变量 与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量： 1NODE_PATH=/home/user/lib:/home/lib 当使用require(&#39;foo/bar&#39;)的方式加载模块时，则NodeJS依次尝试以下路径。 12/home/user/lib/foo/bar/home/lib/foo/bar 包（package）我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。 在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。 12345- /home/user/lib/ - cat/ head.js body.js main.js 其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下： 12345678910var head = require(&apos;./head&apos;);var body = require(&apos;./body&apos;);exports.create = function (name) &#123; return &#123; name: name, head: head.create(), body: body.create() &#125;;&#125;; 在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用require(&#39;/home/user/lib/cat/main&#39;)能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。 index.js当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。 12var cat = require(&apos;/home/user/lib/cat&apos;);var cat = require(&apos;/home/user/lib/cat/index&apos;); 这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。 package.json如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径。上例中的cat模块可以重构如下。 123456789- /home/user/lib/ - cat/ + doc/ - lib/ head.js body.js main.js + tests/ package.json 其中package.json内容如下。 1234&#123; &quot;name&quot;: &quot;cat&quot;, &quot;main&quot;: &quot;./lib/main.js&quot;&#125; 如此一来，就同样可以使用require(&#39;/home/user/lib/cat&#39;)的方式加载模块。NodeJS会根据包目录下的package.json找到入口模块所在位置。 命令行程序使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。 例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在/home/user/bin/node-echo.js这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。 12$ node /home/user/bin/node-echo.js Hello WorldHello World 这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式。 1$ node-echo Hello World Linux在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下： 在shell脚本中，可以通过#!注释来指定当前脚本使用的解析器。所以我们首先在node-echo.js文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。 1#! /usr/bin/env node NodeJS会忽略掉位于JS模块首行的#!注释，不必担心这行注释是非法语句。 然后，我们使用以下命令赋予node-echo.js文件执行权限。 1$ chmod +x /home/user/bin/node-echo.js 最后，我们在PATH环境变量中指定的某个目录下，例如在/usr/local/bin下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下： 1$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo 这样处理后，我们就可以在任何目录下使用node-echo命令了。 Windows在Windows系统下的做法完全不同，我们得靠.cmd文件来解决问题。假设node-echo.js存放在C:\Users\user\bin目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为node-echo.cmd的文件，文件内容如下： 1@node &quot;C:\User\user\bin\node-echo.js&quot; %* 这样处理后，我们就可以在任何目录下使用node-echo命令了。 工程目录了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。 1234567891011- /home/user/workspace/node-echo/ # 工程目录 - bin/ # 存放命令行相关代码 node-echo + doc/ # 存放文档 - lib/ # 存放API相关代码 echo.js - node_modules/ # 存放三方包 + argv/ + tests/ # 存放测试用例 package.json # 元数据文件 README.md # 说明文件 其中部分文件内容如下： 123456789101112131415/* bin/node-echo */var argv = require(&apos;argv&apos;), echo = require(&apos;../lib/echo&apos;);console.log(echo(argv.join(&apos; &apos;)));/* lib/echo.js */module.exports = function (message) &#123; return message;&#125;;/* package.json */&#123; &quot;name&quot;: &quot;node-echo&quot;, &quot;main&quot;: &quot;./lib/echo.js&quot;&#125; 以上例子中分类存放了不同类型的文件，并通过node_moudles目录直接使用三方包名加载模块。此外，定义了package.json之后，node-echo目录也可被当作一个包来使用。 NPMNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。 下载三方包需要使用三方包时，首先得知道有哪些包可用。虽然npmjs.org提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。知道了包名后，比如上边例子中的argv，就可以在工程目录下打开终端，使用以下命令来下载三方包。 123$ npm install argv...argv@0.0.2 node_modules\argv 下载好之后，argv包就放在了工程目录下的node_modules目录中，因此在代码中只需要通过require(&#39;argv&#39;)的方式就好，无需指定三方包路径。 以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上@&lt;version&gt;，例如通过以下命令可下载0.0.1版的argv。 123$ npm install argv@0.0.1...argv@0.0.1 node_modules\argv 如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对package.json的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的package.json可以改写如下： 1234567&#123; &quot;name&quot;: &quot;node-echo&quot;, &quot;main&quot;: &quot;./lib/echo.js&quot;, &quot;dependencies&quot;: &#123; &quot;argv&quot;: &quot;0.0.2&quot; &#125;&#125; 这样处理后，在工程目录下就可以使用npm install命令批量安装三方包了。更重要的是，当以后node-echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用npm install node-echo命令时，NPM会自动创建以下目录结构。 1234567- project/ - node_modules/ - node-echo/ - node_modules/ + argv/ ... ... 如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。 安装命令行程序从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的node-echo提供了命令行使用方式，只要node-echo自己配置好了相关的package.json字段，对于用户而言，只需要使用以下命令安装程序。 1$ npm install node-echo -g 参数中的-g表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的.cmd文件。 123456789101112131415- /usr/local/ # Linux系统下 - lib/node_modules/ + node-echo/ ... - bin/ node-echo ... ...- %APPDATA%\npm\ # Windows系统下 - node_modules\ + node-echo\ ... node-echo.cmd ... 发布代码第一次使用NPM发布代码前需要注册一个账号。终端下运行npm adduser，之后按照提示做即可。账号搞定后，接着我们需要编辑package.json文件，加入NPM必需的字段。接着上边node-echo的例子，package.json里必要的字段如下。 1234567891011&#123; &quot;name&quot;: &quot;node-echo&quot;, # 包名，在NPM服务器上须要保持唯一 &quot;version&quot;: &quot;1.0.0&quot;, # 当前版本号 &quot;dependencies&quot;: &#123; # 三方包依赖，需要指定包名和版本号 &quot;argv&quot;: &quot;0.0.2&quot; &#125;, &quot;main&quot;: &quot;./lib/echo.js&quot;, # 入口模块位置 &quot;bin&quot; : &#123; &quot;node-echo&quot;: &quot;./bin/node-echo&quot; # 命令行程序名和主模块位置 &#125;&#125; 之后，我们就可以在package.json所在目录下运行npm publish发布代码了。 版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 12345+ 如果只是修复bug，需要更新Z位。+ 如果是新增了功能，但是向下兼容，需要更新Y位。+ 如果有大变动，向下不兼容，需要更新X位。 版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如&quot;argv&quot;: &quot;0.0.x&quot;表示依赖于0.0.x系列的最新版argv。NPM支持的所有版本号范围指定方式可以查看官方文档。 灵机一点除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update &lt;package&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update &lt;package&gt; -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish &lt;package&gt;@&lt;version&gt;可以撤销发布自己发布过的某个版本代码。 小结本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点： 编写代码前先规划好目录结构，才能做到有条不紊。 稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。 合理使用node_modules和NODE_PATH来解耦包的使用方式和物理路径。 使用NPM加入NodeJS生态圈互通有无。 想到了心仪的包名时请提前在NPM上抢注。 文件操作让前端觉得如获神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件。小至文件查找，大至代码编译，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的NodeJS内置模块。 开门红NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。 小文件拷贝我们使用NodeJS内置的fs模块简单实现这个程序如下。 1234567891011var fs = require(&apos;fs&apos;);function copy(src, dst) &#123; fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。 豆知识： process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。 大文件拷贝上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。 1234567891011var fs = require(&apos;fs&apos;);function copy(src, dst) &#123; fs.createReadStream(src).pipe(fs.createWriteStream(dst));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 以上程序使用fs.createReadStream创建了一个源文件的只读数据流，并使用fs.createWriteStream创建了一个目标文件的只写数据流，并且用pipe方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。 API走马观花我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 Buffer（数据块） 官方文档： http://nodejs.org/api/buffer.html JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。除了可以读取文件得到Buffer的实例外，还能够直接构造，例如： 1var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]); Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如： 1bin[0]; // =&gt; 0x68; Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串： 1var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot; 或者反过来，将字符串转换为指定编码下的二进制数据： 1var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt; Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。 1bin[0] = 0x48; 而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。 1234[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ] ^ ^ | | bin bin.slice(2) 因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如： 12345var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);var sub = bin.slice(2);sub[0] = 0x65;console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt; 也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。 1234567var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);var dup = new Buffer(bin.length);bin.copy(dup);dup[0] = 0x48;console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt; 总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。 Stream（数据流） 官方文档： http://nodejs.org/api/stream.html 当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作。 以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下： 123456789var rs = fs.createReadStream(pathname);rs.on(&apos;data&apos;, function (chunk) &#123; doSomething(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; cleanUp();&#125;); 豆知识： Stream基于事件机制工作，所有Stream的实例都继承于NodeJS提供的EventEmitter。 上边的代码中data事件会源源不断地被触发，不管doSomething函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。 123456789101112var rs = fs.createReadStream(src);rs.on(&apos;data&apos;, function (chunk) &#123; rs.pause(); doSomething(chunk, function () &#123; rs.resume(); &#125;);&#125;);rs.on(&apos;end&apos;, function () &#123; cleanUp();&#125;); 以上代码给doSomething函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。 此外，我们也可以为数据目标创建一个只写数据流，示例如下： 12345678910var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on(&apos;data&apos;, function (chunk) &#123; ws.write(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; ws.end();&#125;); 我们把doSomething换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据.write方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下： 12345678910111213141516var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on(&apos;data&apos;, function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on(&apos;end&apos;, function () &#123; ws.end();&#125;);ws.on(&apos;drain&apos;, function () &#123; rs.resume();&#125;); 以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了.pipe方法来做这件事情，其内部实现方式与上边的代码类似。 File System（文件系统） 官方文档： http://nodejs.org/api/fs.html NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类： 文件属性读写。 其中常用的有fs.stat、fs.chmod、fs.chown等等。 文件内容读写。 其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。 底层文件操作。 其中常用的有fs.open、fs.read、fs.write、fs.close等等。 NodeJS最精华的异步IO模型在fs模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以fs.readFile为例： 1234567fs.readFile(pathname, function (err, data) &#123; if (err) &#123; // Deal with error. &#125; else &#123; // Deal with data. &#125;&#125;); 如上边代码所示，基本上所有fs模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。 此外，fs模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。同样以fs.readFileSync为例： 123456try &#123; var data = fs.readFileSync(pathname); // Deal with data.&#125; catch (err) &#123; // Deal with error.&#125; fs模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。 Path（路径） 官方文档： http://nodejs.org/api/path.html 操作文件时难免不与文件路径打交道。NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。 path.normalize 将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子： 123456789var cache = &#123;&#125;;function store(key, value) &#123; cache[path.normalize(key)] = value;&#125;store(&apos;foo/bar&apos;, 1);store(&apos;foo//baz//../bar&apos;, 2);console.log(cache); // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125; 坑出没注意： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &#39;/&#39;)再替换一下标准路径。 path.join 将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子： 1path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot; path.extname 当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子： 1path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot; path模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。 遍历目录遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。 递归算法遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。 1234567function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。 陷阱： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。 遍历算法目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是A &gt; B &gt; D &gt; E &gt; C &gt; F。 12345 A / \ B C / \ \D E F 同步遍历了解了必要的算法后，我们可以简单地实现以下目录遍历函数。 1234567891011function travel(dir, callback) &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;);&#125; 可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录： 123456- /home/user/ - foo/ x.js - bar/ y.js z.css 使用以下代码遍历该目录时，得到的输入如下。 12345678travel(&apos;/home/user&apos;, function (pathname) &#123; console.log(pathname);&#125;);------------------------/home/user/foo/x.js/home/user/bar/y.js/home/user/z.css 异步遍历如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下。 1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125; 这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。 文本编码使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。 BOM的移除BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下： 12345 Bytes Encoding---------------------------- FE FF UTF16BE FF FE UTF16LE EF BB BF UTF8 因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。 123456789function readText(pathname) &#123; var bin = fs.readFileSync(pathname); if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3); &#125; return bin.toString(&apos;utf-8&apos;);&#125; GBK转UTF8NodeJS支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助iconv-lite这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。 1234567var iconv = require(&apos;iconv-lite&apos;);function readGBKText(pathname) &#123; var bin = fs.readFileSync(pathname); return iconv.decode(bin, &apos;gbk&apos;);&#125; 单字节编码有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。 首先我们知道，如果一个文本文件只包含英文字符，比如Hello World，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。 反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。 1234567891011121. GBK编码源文件内容： var foo = &apos;中文&apos;;2. 对应字节： 76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B3. 使用单字节编码读取后得到的内容： var foo = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;4. 替换内容： var bar = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;5. 使用单字节编码保存后对应字节： 76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B6. 使用GBK编码读取后得到内容： var bar = &apos;中文&apos;; 这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。 NodeJS中自带了一种binary编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写。 12345function replace(pathname) &#123; var str = fs.readFileSync(pathname, &apos;binary&apos;); str = str.replace(&apos;foo&apos;, &apos;bar&apos;); fs.writeFileSync(pathname, str, &apos;binary&apos;);&#125; 小结本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点： 学好文件操作，编写各种程序都不怕。 如果不是很在意性能，fs模块的同步API能让生活更加美好。 需要对文件读写做到字节级别的精细控制时，请使用fs模块的文件底层操作API。 不要使用拼接字符串的方式来处理路径，使用path模块。 掌握好目录遍历和文件编码处理技巧，很实用。 网络操作不了解网络编程的程序员不是好前端，而NodeJS恰好提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的NodeJS内置模块。 开门红NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的http模块简单实现一个HTTP服务器。 123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text-plain&apos; &#125;); response.end(&apos;Hello World\n&apos;);&#125;).listen(8124); 以上程序创建了一个HTTP服务器并监听8124端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。 豆知识： 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用sudo命令启动程序。 API走马观花我们先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 HTTP 官方文档： http://nodejs.org/api/http.html ‘http’模块提供两种使用方式： 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。 首先我们来看看服务端模式下如何工作。如开门红中的例子所示，首先需要使用.createServer方法创建一个服务器，然后调用.listen方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。 HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。 12345678POST / HTTP/1.1User-Agent: curl/7.26.0Host: localhostAccept: */*Content-Length: 11Content-Type: application/x-www-form-urlencodedHello World 可以看到，空行之上是请求头，之下是请求体。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。以下是一个例子。 123456789101112131415161718192021222324http.createServer(function (request, response) &#123; var body = []; console.log(request.method); console.log(request.headers); request.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); request.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;).listen(80);------------------------------------POST&#123; &apos;user-agent&apos;: &apos;curl/7.26.0&apos;, host: &apos;localhost&apos;, accept: &apos;*/*&apos;, &apos;content-length&apos;: &apos;11&apos;, &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;Hello World HTTP响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的HTTP请求数据内容。 1234567HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 11Date: Tue, 05 Nov 2013 05:31:38 GMTConnection: keep-aliveHello World 在回调函数中，除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。 1234567891011http.createServer(function (request, response) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); request.on(&apos;data&apos;, function (chunk) &#123; response.write(chunk); &#125;); request.on(&apos;end&apos;, function () &#123; response.end(); &#125;);&#125;).listen(80); 接下来我们看看客户端模式下如何工作。为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。 1234567891011121314var options = &#123; hostname: &apos;www.example.com&apos;, port: 80, path: &apos;/upload&apos;, method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;;var request = http.request(options, function (response) &#123;&#125;);request.write(&apos;Hello World&apos;);request.end(); 可以看到，.request方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把request对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中GET请求是最常见的一种，并且不需要请求体，因此http模块也提供了以下便捷API。 1http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;); 当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用response对象访问响应头数据外，还能把response对象当作一个只读数据流来访问响应体数据。以下是一个例子。 12345678910111213141516171819202122232425http.get(&apos;http://www.example.com/&apos;, function (response) &#123; var body = []; console.log(response.statusCode); console.log(response.headers); response.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); response.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;);------------------------------------200&#123; &apos;content-type&apos;: &apos;text/html&apos;, server: &apos;Apache&apos;, &apos;content-length&apos;: &apos;801&apos;, date: &apos;Tue, 05 Nov 2013 06:08:41 GMT&apos;, connection: &apos;keep-alive&apos; &#125;&lt;!DOCTYPE html&gt;... HTTPS 官方文档： http://nodejs.org/api/https.html https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。 在服务端模式下，创建一个HTTPS服务器的示例如下。 12345678var options = &#123; key: fs.readFileSync(&apos;./ssl/default.key&apos;), cert: fs.readFileSync(&apos;./ssl/default.cer&apos;) &#125;;var server = https.createServer(options, function (request, response) &#123; // ... &#125;); 可以看到，与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。 另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。 123456789server.addContext(&apos;foo.com&apos;, &#123; key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;), cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)&#125;);server.addContext(&apos;bar.com&apos;, &#123; key: fs.readFileSync(&apos;./ssl/bar.com.key&apos;), cert: fs.readFileSync(&apos;./ssl/bar.com.cer&apos;)&#125;); 在客户端模式下，发起一个HTTPS客户端请求与http模块几乎相同，示例如下。 12345678910var options = &#123; hostname: &apos;www.example.com&apos;, port: 443, path: &apos;/&apos;, method: &apos;GET&apos; &#125;;var request = https.request(options, function (response) &#123;&#125;);request.end(); 但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下https模块会拒绝连接，提示说有证书安全问题。在options里加入rejectUnauthorized: false字段可以禁用对证书有效性的检查，从而允许https模块请求开发环境下使用自制证书的HTTPS服务器。 URL 官方文档： http://nodejs.org/api/url.html 处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。 123456789 href ----------------------------------------------------------------- host path --------------- ---------------------------- http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash ----- --------- -------- ---- -------- ------------- -----protocol auth hostname port pathname search hash ------------ query 我们可以使用.parse方法来将一个URL字符串转换为URL对象，示例如下。 1234567891011121314url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);/* =&gt;&#123; protocol: &apos;http:&apos;, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/p/a/t/h&apos;, path: &apos;/p/a/t/h?query=string&apos;, href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;*/ 传给.parse方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，request.url不包含协议头和域名，但同样可以用.parse方法解析。 123456789101112131415161718http.createServer(function (request, response) &#123; var tmp = request.url; // =&gt; &quot;/foo/bar?a=b&quot; url.parse(tmp); /* =&gt; &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: &apos;?a=b&apos;, query: &apos;a=b&apos;, pathname: &apos;/foo/bar&apos;, path: &apos;/foo/bar?a=b&apos;, href: &apos;/foo/bar?a=b&apos; &#125; */&#125;).listen(80); .parse方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。 反过来，format方法允许将一个URL对象转换为URL字符串，示例如下。 123456789url.format(&#123; protocol: &apos;http:&apos;, host: &apos;www.example.com&apos;, pathname: &apos;/p/a/t/h&apos;, search: &apos;query=string&apos;&#125;);/* =&gt;&apos;http://www.example.com/p/a/t/h?query=string&apos;*/ 另外，.resolve方法可以用于拼接URL，示例如下。 1234url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);/* =&gt;http://www.example.com/baz*/ Query String 官方文档： http://nodejs.org/api/querystring.html querystring模块用于实现URL参数字符串与参数对象的互相转换，示例如下。 123456789querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);/* =&gt;&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;*/querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);/* =&gt;&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;*/ Zlib 官方文档： http://nodejs.org/api/zlib.html zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。 首先我们看一个使用zlib模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。 1234567891011121314151617181920212223http.createServer(function (request, response) &#123; var i = 1024, data = &apos;&apos;; while (i--) &#123; data += &apos;.&apos;; &#125; if ((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123; zlib.gzip(data, function (err, data) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos; &#125;); response.end(data); &#125;); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); response.end(data); &#125;&#125;).listen(80); 接着我们看一个使用zlib模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用zlib模块解压响应体数据。 1234567891011121314151617181920212223242526272829var options = &#123; hostname: &apos;www.example.com&apos;, port: 80, path: &apos;/&apos;, method: &apos;GET&apos;, headers: &#123; &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos; &#125; &#125;;http.request(options, function (response) &#123; var body = []; response.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); response.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); if (response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123; zlib.gunzip(body, function (err, data) &#123; console.log(data.toString()); &#125;); &#125; else &#123; console.log(data.toString()); &#125; &#125;);&#125;).end(); Net 官方文档： http://nodejs.org/api/net.html net模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。 首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。 1234567891011net.createServer(function (conn) &#123; conn.on(&apos;data&apos;, function (data) &#123; conn.write([ &apos;HTTP/1.1 200 OK&apos;, &apos;Content-Type: text/plain&apos;, &apos;Content-Length: 11&apos;, &apos;&apos;, &apos;Hello World&apos; ].join(&apos;\n&apos;)); &#125;);&#125;).listen(80); 接着我们来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过data事件监听函数来获取服务器响应。 1234567891011121314151617181920var options = &#123; port: 80, host: &apos;www.example.com&apos; &#125;;var client = net.connect(options, function () &#123; client.write([ &apos;GET / HTTP/1.1&apos;, &apos;User-Agent: curl/7.26.0&apos;, &apos;Host: www.baidu.com&apos;, &apos;Accept: */*&apos;, &apos;&apos;, &apos;&apos; ].join(&apos;\n&apos;)); &#125;);client.on(&apos;data&apos;, function (data) &#123; console.log(data.toString()); client.end();&#125;); 灵机一点使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。 问： 为什么通过headers对象访问到的HTTP请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers[&#39;content-length&#39;]。 问： 为什么http模块创建的HTTP服务器返回的响应是chunked传输方式的？ 答： 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了Transfer-Encoding: chunked字段，并采用chunked传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后NodeJS就不会自动添加Transfer-Encoding字段和使用chunked传输方式。 问： 为什么使用http模块发起HTTP客户端请求时，有时候会发生socket hang up错误？ 答： 发起客户端HTTP请求前需要先创建一个客户端。http模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。 小结本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点： http和https模块支持服务端模式和客户端模式两种使用方式。 request和response对象除了用于读写头数据外，都可以当作数据流来操作。 url.parse方法加上request.url属性是处理HTTP请求时的固定搭配。 使用zlib模块可以减少使用HTTP协议时的数据传输量。 通过net模块的Socket服务器与客户端可对HTTP协议做底层操作。 小心踩坑。 进程管理NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。 开门红我们已经知道了NodeJS自带的fs模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的cp命令比较好用，一条cp -r source/* target命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下： 1234567891011var child_process = require(&apos;child_process&apos;);var util = require(&apos;util&apos;);function copy(source, target, callback) &#123; child_process.exec( util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);&#125;copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123; // ...&#125;); 从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。 API走马观花我们先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 Process 官方文档： http://nodejs.org/api/process.html 任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过process对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。 Child Process 官方文档： http://nodejs.org/api/child_process.html 使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。 Cluster 官方文档： http://nodejs.org/api/cluster.html cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。 应用场景和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。 如何获取命令行参数在NodeJS中可以通过process.argv获取命令行参数。但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。为了让argv使用起来更加自然，可以按照以下方式处理。 12345function main(argv) &#123; // ...&#125;main(process.argv.slice(2)); 如何退出程序通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为0。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于0。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如1，就可以按照以下方式： 123456try &#123; // ...&#125; catch (err) &#123; // ... process.exit(1);&#125; 如何控制输入输出NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，console.log可以按照以下方式实现。 1234function log() &#123; process.stdout.write( util.format.apply(util, arguments) + &apos;\n&apos;);&#125; 如何降权在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。 12345678http.createServer(callback).listen(80, function () &#123; var env = process.env, uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10), gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10); process.setgid(gid); process.setuid(uid);&#125;); 上例中有几点需要注意： 如果是通过sudo获取root权限的，运行程序的用户的UID和GID保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过chmod +s方式获取root权限的，运行程序的用户的UID和GID可直接通过process.getuid和process.getgid方法获取。 process.setuid和process.setgid方法只接受number类型的参数。 降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。 如何创建子进程以下是一个创建NodeJS子进程的例子。 12345678910111213var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);child.stdout.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stdout: &apos; + data);&#125;);child.stderr.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stderr: &apos; + data);&#125;);child.on(&apos;close&apos;, function (code) &#123; console.log(&apos;child process exited with code &apos; + code);&#125;); 上例中使用了.spawn(exec, args, options)方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。 另外，上例中虽然通过子进程对象的.stdout和.stderr访问子进程的输出，但通过options.stdio字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。 进程间如何通讯在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。 12345678910/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);child.kill(&apos;SIGTERM&apos;);/* child.js */process.on(&apos;SIGTERM&apos;, function () &#123; cleanUp(); process.exit(0);&#125;); 在上例中，父进程通过.kill方法向子进程发送SIGTERM信号，子进程监听process对象的SIGTERM事件响应信号。不要被.kill方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。 另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。 12345678910111213141516/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123; stdio: [ 0, 1, 2, &apos;ipc&apos; ] &#125;);child.on(&apos;message&apos;, function (msg) &#123; console.log(msg);&#125;);child.send(&#123; hello: &apos;hello&apos; &#125;);/* child.js */process.on(&apos;message&apos;, function (msg) &#123; msg.hello = msg.hello.toUpperCase(); process.send(msg);&#125;); 可以看到，父进程在创建子进程时，在options.stdio字段中通过ipc开启了一条IPC通道，之后就可以监听子进程对象的message事件接收来自子进程的消息，并通过.send方法给子进程发送消息。在子进程这边，可以在process对象上监听message事件接收来自父进程的消息，并通过.send方法向父进程发送消息。数据在传递过程中，会先在发送端使用JSON.stringify方法序列化，再在接收端使用JSON.parse方法反序列化。 如何守护子进程守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。 123456789101112/* daemon.js */function spawn(mainModule) &#123; var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]); worker.on(&apos;exit&apos;, function (code) &#123; if (code !== 0) &#123; spawn(mainModule); &#125; &#125;);&#125;spawn(&apos;worker.js&apos;); 可以看到，工作进程非正常退出时，守护进程立即重启工作进程。 小结本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点： 使用process对象管理自身。 使用child_process模块创建和管理子进程。 异步编程NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。 回调在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。 12345678910111213141516171819202122function heavyCompute(n, callback) &#123; var count = 0, i, j; for (i = n; i &gt; 0; --i) &#123; for (j = n; j &gt; 0; --j) &#123; count += 1; &#125; &#125; callback(count);&#125;heavyCompute(10000, function (count) &#123; console.log(count);&#125;);console.log(&apos;hello&apos;);-- Console ------------------------------100000000hello 可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。 但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。 123456789setTimeout(function () &#123; console.log(&apos;world&apos;);&#125;, 1000);console.log(&apos;hello&apos;);-- Console ------------------------------helloworld 这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API。 另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。 123456789101112131415161718192021function heavyCompute(n) &#123; var count = 0, i, j; for (i = n; i &gt; 0; --i) &#123; for (j = n; j &gt; 0; --j) &#123; count += 1; &#125; &#125;&#125;var t = new Date();setTimeout(function () &#123; console.log(new Date() - t);&#125;, 1000);heavyCompute(50000);-- Console ------------------------------8520 可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。 代码设计模式异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。 函数返回值使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码： 12var output = fn1(fn2(&apos;input&apos;));// Do something. 而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码： 12345fn2(&apos;input&apos;, function (output2) &#123; fn1(output2, function (output1) &#123; // Do something. &#125;);&#125;); 可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出&gt;形状的代码。 遍历数组在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码： 12345678var len = arr.length, i = 0;for (; i &lt; len; ++i) &#123; arr[i] = sync(arr[i]);&#125;// All array items have processed. 如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码： 123456789101112(function next(i, len, callback) &#123; if (i &lt; len) &#123; async(arr[i], function (value) &#123; arr[i] = value; next(i + 1, len, callback); &#125;); &#125; else &#123; callback(); &#125;&#125;(0, arr.length, function () &#123; // All array items have processed.&#125;)); 可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。 如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式： 1234567891011121314(function (i, len, count, callback) &#123; for (; i &lt; len; ++i) &#123; (function (i) &#123; async(arr[i], function (value) &#123; arr[i] = value; if (++count === len) &#123; callback(); &#125; &#125;); &#125;(i)); &#125;&#125;(0, arr.length, 0, function () &#123; // All array items have processed.&#125;)); 可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。 异常处理JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。以下是一个例子。 12345678910111213function sync(fn) &#123; return fn();&#125;try &#123; sync(null); // Do something.&#125; catch (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;-- Console ------------------------------Error: object is not a function 可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个try语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。以下是一个例子。 12345678910111213141516171819202122function async(fn, callback) &#123; // Code execution path breaks here. setTimeout(function () &#123; callback(fn()); &#125;, 0);&#125;try &#123; async(null, function (data) &#123; // Do something. &#125;);&#125; catch (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;-- Console ------------------------------/home/user/test.js:4 callback(fn()); ^TypeError: object is not a function at null._onTimeout (/home/user/test.js:4:13) at Timer.listOnTimeout [as ontimeout] (timers.js:110:15) 因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。 123456789101112131415161718192021function async(fn, callback) &#123; // Code execution path breaks here. setTimeout(function () &#123; try &#123; callback(null, fn()); &#125; catch (err) &#123; callback(err); &#125; &#125;, 0);&#125;async(null, function (err, data) &#123; if (err) &#123; console.log(&apos;Error: %s&apos;, err.message); &#125; else &#123; // Do something. &#125;&#125;);-- Console ------------------------------Error: object is not a function 可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是err。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。 有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个try语句就能捕获所有冒泡上来的异常，示例如下。 1234567891011121314function main() &#123; // Do something. syncA(); // Do something. syncB(); // Do something. syncC();&#125;try &#123; main();&#125; catch (err) &#123; // Deal with exception.&#125; 但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。 12345678910111213141516171819202122232425262728293031function main(callback) &#123; // Do something. asyncA(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncB(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncC(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something callback(null); &#125; &#125;); &#125; &#125;); &#125; &#125;);&#125;main(function (err) &#123; if (err) &#123; // Deal with exception. &#125;&#125;); 可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。 域（Domain） 官方文档： http://nodejs.org/api/domain.html NodeJS提供了domain模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法，示例代码如下 12345678910process.on(&apos;uncaughtException&apos;, function (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;);setTimeout(function (fn) &#123; fn();&#125;);-- Console ------------------------------Error: undefined is not a function 虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子： 12345678910111213141516171819202122232425262728293031323334353637function async(request, callback) &#123; // Do something. asyncA(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncB(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncC(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something callback(null, data); &#125; &#125;); &#125; &#125;); &#125; &#125;);&#125;http.createServer(function (request, response) &#123; async(request, function (err, data) &#123; if (err) &#123; response.writeHead(500); response.end(); &#125; else &#123; response.writeHead(200); response.end(data); &#125; &#125;);&#125;); 以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此async函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用domain模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。于是以上代码可以做如下改造： 1234567891011121314151617181920212223242526272829function async(request, callback) &#123; // Do something. asyncA(request, function (data) &#123; // Do something asyncB(request, function (data) &#123; // Do something asyncC(request, function (data) &#123; // Do something callback(data); &#125;); &#125;); &#125;);&#125;http.createServer(function (request, response) &#123; var d = domain.create(); d.on(&apos;error&apos;, function () &#123; response.writeHead(500); response.end(); &#125;); d.run(function () &#123; async(request, function (data) &#123; response.writeHead(200); response.end(data); &#125;); &#125;);&#125;); 可以看到，我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。 陷阱无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。 但这里需要澄清一些事实。JS本身的throw..try..catch异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。 因此，使用uncaughtException或domain捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用try语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。 小结本章介绍了JS异步编程相关的知识，总结起来有以下几点： 不掌握异步编程就不算学会NodeJS。 异步编程依托于回调来实现，而使用回调不一定就是异步编程。 异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。 使用domain模块简化异步代码的异常处理，并小心陷阱。 大示例学习讲究的是学以致用和融会贯通。至此我们已经分别介绍了NodeJS的很多知识点，本章作为最后一章，将完整地介绍一个使用NodeJS开发Web服务器的示例。 需求我们要开发的是一个简单的静态文件合并服务器，该服务器需要支持类似以下格式的JS或CSS文件合并请求。 1http://assets.example.com/foo/??bar.js,baz.js 在以上URL中，??是一个分隔符，之前是需要合并的多个文件的URL的公共部分，之后是使用,分隔的差异部分。因此服务器处理这个URL时，返回的是以下两个文件按顺序合并后的内容。 12/foo/bar.js/foo/baz.js 另外，服务器也需要能支持类似以下格式的普通的JS或CSS文件请求。 1http://assets.example.com/foo/bar.js 以上就是整个需求。 第一次迭代快速迭代是一种不错的开发方式，因此我们在第一次迭代时先实现服务器的基本功能。 设计简单分析了需求之后，我们大致会得到以下的设计方案。 123 +---------+ +-----------+ +----------+request --&gt;| parse |--&gt;| combine |--&gt;| output |--&gt; response +---------+ +-----------+ +----------+ 也就是说，服务器会首先分析URL，得到请求的文件的路径和类型（MIME）。然后，服务器会读取请求的文件，并按顺序合并文件内容。最后，服务器返回响应，完成对一次请求的处理。 另外，服务器在读取文件时需要有个根目录，并且服务器监听的HTTP端口最好也不要写死在代码里，因此服务器需要是可配置的。 实现根据以上设计，我们写出了第一版代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var fs = require(&apos;fs&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);var MIME = &#123; &apos;.css&apos;: &apos;text/css&apos;, &apos;.js&apos;: &apos;application/javascript&apos;&#125;;function combineFiles(pathnames, callback) &#123; var output = []; (function next(i, len) &#123; if (i &lt; len) &#123; fs.readFile(pathnames[i], function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; output.push(data); next(i + 1, len); &#125; &#125;); &#125; else &#123; callback(null, Buffer.concat(output)); &#125; &#125;(0, pathnames.length));&#125;function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80; http.createServer(function (request, response) &#123; var urlInfo = parseURL(root, request.url); combineFiles(urlInfo.pathnames, function (err, data) &#123; if (err) &#123; response.writeHead(404); response.end(err.message); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: urlInfo.mime &#125;); response.end(data); &#125; &#125;); &#125;).listen(port);&#125;function parseURL(root, url) &#123; var base, pathnames, parts; if (url.indexOf(&apos;??&apos;) === -1) &#123; url = url.replace(&apos;/&apos;, &apos;/??&apos;); &#125; parts = url.split(&apos;??&apos;); base = parts[0]; pathnames = parts[1].split(&apos;,&apos;).map(function (value) &#123; return path.join(root, base, value); &#125;); return &#123; mime: MIME[path.extname(pathnames[0])] || &apos;text/plain&apos;, pathnames: pathnames &#125;;&#125;main(process.argv.slice(2)); 以上代码完整实现了服务器所需的功能，并且有以下几点值得注意： 使用命令行参数传递JSON配置文件路径，入口函数负责读取配置并创建服务器。 入口函数完整描述了程序的运行逻辑，其中解析URL和合并文件的具体实现封装在其它两个函数里。 解析URL时先将普通URL转换为了文件合并URL，使得两种URL的处理方式可以一致。 合并文件时使用异步API读取文件，避免服务器因等待磁盘IO而发生阻塞。 我们可以把以上代码保存为server.js，之后就可以通过node server.js config.json命令启动程序，于是我们的第一版静态文件合并服务器就顺利完工了。 另外，以上代码存在一个不那么明显的逻辑缺陷。例如，使用以下URL请求服务器时会有惊喜。 1http://assets.example.com/foo/bar.js,foo/baz.js 经过分析之后我们会发现问题出在/被自动替换/??这个行为上，而这个问题我们可以到第二次迭代时再解决。 第二次迭代在第一次迭代之后，我们已经有了一个可工作的版本，满足了功能需求。接下来我们需要从性能的角度出发，看看代码还有哪些改进余地。 设计把map方法换成for循环或许会更快一些，但第一版代码最大的性能问题存在于从读取文件到输出响应的过程当中。我们以处理/??a.js,b.js,c.js这个请求为例，看看整个处理过程中耗时在哪儿。 12345678 发送请求 等待服务端响应 接收响应---------+----------------------+-------------&gt; -- 解析请求 ------ 读取a.js ------ 读取b.js ------ 读取c.js -- 合并数据 -- 输出响应 可以看到，第一版代码依次把请求的文件读取到内存中之后，再合并数据和输出响应。这会导致以下两个问题： 当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。 由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数较大时，会有较大的内存开销。 对于第一个问题，很容易想到把读取文件的方式从串行改为并行。但是别这样做，因为对于机械磁盘而言，因为只有一个磁头，尝试并行读取文件只会造成磁头频繁抖动，反而降低IO效率。而对于固态硬盘，虽然的确存在多个并行IO通道，但是对于服务器并行处理的多个请求而言，硬盘已经在做并行IO了，对单个请求采用并行IO无异于拆东墙补西墙。因此，正确的做法不是改用并行IO，而是一边读取文件一边输出响应，把响应输出时机提前至读取第一个文件的时刻。这样调整后，整个请求处理过程变成下边这样。 12345678发送请求 等待服务端响应 接收响应---------+----+-------------------------------&gt; -- 解析请求 -- 检查文件是否存在 -- 输出响应头 ------ 读取和输出a.js ------ 读取和输出b.js ------ 读取和输出c.js 按上述方式解决第一个问题后，因为服务器不需要完整地缓存每个请求的输出数据了，第二个问题也迎刃而解。 实现根据以上设计，第二版代码按以下方式调整了部分函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80; http.createServer(function (request, response) &#123; var urlInfo = parseURL(root, request.url); validateFiles(urlInfo.pathnames, function (err, pathnames) &#123; if (err) &#123; response.writeHead(404); response.end(err.message); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: urlInfo.mime &#125;); outputFiles(pathnames, response); &#125; &#125;); &#125;).listen(port);&#125;function outputFiles(pathnames, writer) &#123; (function next(i, len) &#123; if (i &lt; len) &#123; var reader = fs.createReadStream(pathnames[i]); reader.pipe(writer, &#123; end: false &#125;); reader.on(&apos;end&apos;, function() &#123; next(i + 1, len); &#125;); &#125; else &#123; writer.end(); &#125; &#125;(0, pathnames.length));&#125;function validateFiles(pathnames, callback) &#123; (function next(i, len) &#123; if (i &lt; len) &#123; fs.stat(pathnames[i], function (err, stats) &#123; if (err) &#123; callback(err); &#125; else if (!stats.isFile()) &#123; callback(new Error()); &#125; else &#123; next(i + 1, len); &#125; &#125;); &#125; else &#123; callback(null, pathnames); &#125; &#125;(0, pathnames.length));&#125; 可以看到，第二版代码在检查了请求的所有文件是否有效之后，立即就输出了响应头，并接着一边按顺序读取文件一边输出响应内容。并且，在读取文件时，第二版代码直接使用了只读数据流来简化代码。 第三次迭代第二次迭代之后，服务器本身的功能和性能已经得到了初步满足。接下来我们需要从稳定性的角度重新审视一下代码，看看还需要做些什么。 设计从工程角度上讲，没有绝对可靠的系统。即使第二次迭代的代码经过反复检查后能确保没有bug，也很难说是否会因为NodeJS本身，或者是操作系统本身，甚至是硬件本身导致我们的服务器程序在某一天挂掉。因此一般生产环境下的服务器程序都配有一个守护进程，在服务挂掉的时候立即重启服务。一般守护进程的代码会远比服务进程的代码简单，从概率上可以保证守护进程更难挂掉。如果再做得严谨一些，甚至守护进程自身可以在自己挂掉时重启自己，从而实现双保险。 因此在本次迭代时，我们先利用NodeJS的进程管理机制，将守护进程作为父进程，将服务器程序作为子进程，并让父进程监控子进程的运行状态，在其异常退出时重启子进程。 实现根据以上设计，我们编写了守护进程需要的代码。 12345678910111213141516171819202122var cp = require(&apos;child_process&apos;);var worker;function spawn(server, config) &#123; worker = cp.spawn(&apos;node&apos;, [ server, config ]); worker.on(&apos;exit&apos;, function (code) &#123; if (code !== 0) &#123; spawn(server, config); &#125; &#125;);&#125;function main(argv) &#123; spawn(&apos;server.js&apos;, argv[0]); process.on(&apos;SIGTERM&apos;, function () &#123; worker.kill(); process.exit(0); &#125;);&#125;main(process.argv.slice(2)); 此外，服务器代码本身的入口函数也要做以下调整。 12345678910111213141516function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80, server; server = http.createServer(function (request, response) &#123; ... &#125;).listen(port); process.on(&apos;SIGTERM&apos;, function () &#123; server.close(function () &#123; process.exit(0); &#125;); &#125;);&#125; 我们可以把守护进程的代码保存为daemon.js，之后我们可以通过node daemon.js config.json启动服务，而守护进程会进一步启动和监控服务器进程。此外，为了能够正常终止服务，我们让守护进程在接收到SIGTERM信号时终止服务器进程。而在服务器进程这一端，同样在收到SIGTERM信号时先停掉HTTP服务再正常退出。至此，我们的服务器程序就靠谱很多了。 第四次迭代在我们解决了服务器本身的功能、性能和可靠性的问题后，接着我们需要考虑一下代码部署的问题，以及服务器控制的问题。 设计一般而言，程序在服务器上有一个固定的部署目录，每次程序有更新后，都重新发布到部署目录里。而一旦完成部署后，一般也可以通过固定的服务控制脚本启动和停止服务。因此我们的服务器程序部署目录可以做如下设计。 123456789- deploy/ - bin/ startws.sh killws.sh + conf/ config.json + lib/ daemon.js server.js 在以上目录结构中，我们分类存放了服务控制脚本、配置文件和服务器代码。 实现按以上目录结构分别存放对应的文件之后，接下来我们看看控制脚本怎么写。首先是start.sh。 123456#!/bin/shif [ ! -f &quot;pid&quot; ]then node ../lib/daemon.js ../conf/config.json &amp; echo $! &gt; pidfi 然后是killws.sh。 123456#!/bin/shif [ -f &quot;pid&quot; ]then kill $(tr -d &apos;\r\n&apos; &lt; pid) rm pidfi 于是这样我们就有了一个简单的代码部署目录和服务控制脚本，我们的服务器程序就可以上线工作了。 后续迭代我们的服务器程序正式上线工作后，我们接下来或许会发现还有很多可以改进的点。比如服务器程序在合并JS文件时可以自动在JS文件之间插入一个;来避免一些语法问题，比如服务器程序需要提供日志来统计访问量，比如服务器程序需要能充分利用多核CPU，等等。而此时的你，在学习了这么久NodeJS之后，应该已经知道该怎么做了。 小结本章将之前零散介绍的知识点串了起来，完整地演示了一个使用NodeJS开发程序的例子，至此我们的课程就全部结束了。以下是对新诞生的NodeJSer的一些建议。 要熟悉官方API文档。并不是说要熟悉到能记住每个API的名称和用法，而是要熟悉NodeJS提供了哪些功能，一旦需要时知道查询API文档的哪块地方。 要先设计再实现。在开发一个程序前首先要有一个全局的设计，不一定要很周全，但要足够能写出一些代码。 要实现后再设计。在写了一些代码，有了一些具体的东西后，一定会发现一些之前忽略掉的细节。这时再反过来改进之前的设计，为第二轮迭代做准备。 要充分利用三方包。NodeJS有一个庞大的生态圈，在写代码之前先看看有没有现成的三方包能节省不少时间。 不要迷信三方包。任何事情做过头了就不好了，三方包也是一样。三方包是一个黑盒，每多使用一个三方包，就为程序增加了一份潜在风险。并且三方包很难恰好只提供程序需要的功能，每多使用一个三方包，就让程序更加臃肿一些。因此在决定使用某个三方包之前，最好三思而后行。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约定优于配置（convention over configuration）]]></title>
    <url>%2Fposts%2F2779.html</url>
    <content type="text"><![CDATA[文章来自维基百科 约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。 本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。 如果您所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式 动机设计不好的框架通常需要多个配置文件，每一个都有许多设置。这些配置文件为每一个项目提供信息说明从URL到将类映射到数据库表的各种信息。大量包含太多参数的配置文件通常是过度复杂的应用设计的指标（代码坏味道）。 例如，在知名的Java对象关系映射框架hibernate的早期版本中，将类及其属性映射到数据库上需要是在XML文件中的描述，其中大部分信息都应能够按照约定得到，如将类映射到同名的数据库表，将属性分别映射到表上的字段。后续的版本抛弃了XML配置文件，而是使用这些恰当的约定，对于不符合这些约定的情形，可以使用Java 标注来说明（参见下面提供的JavaBeans规范）。 使用许多新的框架使用了约定优于配置的方法，包括：spring，Ruby on Rails，Kohana PHP，Grails，Grok，Zend Framework，CakePHP，symfony，Maven，ASP.NET MVC，Web2py（MVC），Apache Wicket。 这是一个古老的概念, 甚至在Java类库中也可以找出这一概念的踪迹。例如，JavaBean规范非常多的依赖这一概念。下面摘录JavaBeans 1.1版规范的一段： 按照一般的规则，我们不希望造出一个奇怪的java.beans.everything类，其他类需要从该类派生。而是希望在运行时JavaBeans为一般的对象提供缺省的行为特征，但是允许对象通过继承特定的java.beans.something接口来覆盖缺省的行为特征的一部分。Maven约定的项目结构如下图： 只需配置很少的信息，Maven就可以自动完成编译、测试和打包等工作。]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常用命令]]></title>
    <url>%2Fposts%2F32362.html</url>
    <content type="text"><![CDATA[hexo 常用的命令 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] &lt;title&gt; 模版 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 ​ title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作 hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错 1.找不到git部署 ​ ERROR Deployer not found: git ​ 解决方法 npm install hexo-deployer-git --save 3.部署类型设置git hexo 3.0 部署类型不再是github，_config.yml 中修改 ​ # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master xcodebuild xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt RSS不显示 安装RSS插件 npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： ​ rss: /atom.xml #rss地址 默认即可 开启评论 1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\landscape\layout_partial\article.ejs把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; ​ 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt; ####hexo命令 更新hexo：npm update -g hexo 更新主题：cd 到主题文件夹，执行命令：git pull 更新插件：npm update]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet中web.xml配置详解]]></title>
    <url>%2Fposts%2F40270.html</url>
    <content type="text"><![CDATA[Web.xml常用元素 Web.xml常用元素1234567891011121314151617181920212223&lt;web-app&gt;&lt;display-name&gt;&lt;/display-name&gt; 定义了WEB应用的名字&lt;description&gt;&lt;/description&gt; 声明WEB应用的描述信息&lt;context-param&gt;&lt;/context-param&gt;context-param元素声明应用范围内的初始化参数。 &lt;filter&gt;&lt;/filter&gt;过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。 &lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。 &lt;listener&gt;&lt;/listener&gt; servletAPI的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。 Listener元素指出事件监听程序类。 &lt;servlet&gt;&lt;/servlet&gt; 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。 但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素。 &lt;session-config&gt;&lt;/session-config&gt; 如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值。 &lt;mime-mapping&gt;&lt;/mime-mapping&gt;如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证。 &lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。 &lt;error-page&gt;&lt;/error-page&gt; 在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。 &lt;taglib&gt;&lt;/taglib&gt; 对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置， 而不用编辑使用这些文件的JSP页面。 &lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;声明与资源相关的一个管理对象。 &lt;resource-ref&gt;&lt;/resource-ref&gt; 声明一个资源工厂使用的外部资源。 &lt;security-constraint&gt;&lt;/security-constraint&gt; 制定应该保护的URL。它与login-config元素联合使用 &lt;login-config&gt;&lt;/login-config&gt; 指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。 &lt;security-role&gt;&lt;/security-role&gt;给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。&lt;env-entry&gt;&lt;/env-entry&gt;声明Web应用的环境项。 &lt;ejb-ref&gt;&lt;/ejb-ref&gt;声明一个EJB的主目录的引用。 &lt; ejb-local-ref&gt;&lt;/ ejb-local-ref&gt;声明一个EJB的本地主目录的应用。 &lt;/web-app&gt; 相应元素配置 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标 1234&lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; Web 应用名称：提供GUI工具可能会用来标记这个特定的Web应用的一个名称 1&lt;display-name&gt;Tomcat Example&lt;/display-name&gt; Web 应用描述： 给出于此相关的说明性文本 1&lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; 上下文参数：声明应用范围内的初始化参数。 12345&lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; 在servlet里面可以通过getServletContext().getInitParameter(“context/param”)得到 过滤器配置：将一个名字与一个实现javaxs.servlet.Filter接口的类相关联。 123456789101112&lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;GB2312&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器配置 123&lt;listener&gt; &lt;listerner-class&gt;listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; Servlet配置 基本配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 高级配置 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;foo&lt;/param-name&gt; &lt;param-value&gt;bar&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;Security role for anonymous access&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 元素说明123456789 &lt;servlet&gt;&lt;/servlet&gt; 用来声明一个servlet的数据，主要有以下子元素： &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;servlet-class&gt;&lt;/servlet-class&gt; 指定servlet的类名称 &lt;jsp-file&gt;&lt;/jsp-file&gt; 指定web站台中的某个JSP网页的完整路径 &lt;init-param&gt;&lt;/init-param&gt; 用来定义参数，可有多个init-param。在servlet类中通过getInitParamenter(String name)方法访问初始化参数 &lt;load-on-startup&gt;&lt;/load-on-startup&gt;指定当Web应用启动时，装载Servlet的次序。当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet.当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 用来定义servlet所对应的URL，包含两个子元素 &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;url-pattern&gt;&lt;/url-pattern&gt; 指定servlet所对应的URL 会话超时配置（单位为分钟） 123&lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; MIME类型配置 1234&lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; 指定欢迎文件页配置 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 配置错误页面 通过错误码来配置error-page1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp。 通过异常的类型配置error-page1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp TLD配置 1234&lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/debug-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; 如果MyEclipse一直在报错,应该把 放到 中 123456&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/pager-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; 资源管理对象配置 123&lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;jms/StockQueue&lt;/resource-env-ref-name&gt; &lt;/resource-env-ref&gt; 资源工厂配置 12345&lt;resource-ref&gt; &lt;res-ref-name&gt;mail/Session&lt;/res-ref-name&gt; &lt;res-type&gt;javax.mail.Session&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 配置数据库连接池就可在此配置： 123456&lt;resource-ref&gt; &lt;description&gt;JNDI JDBC DataSource of shop&lt;/description&gt; &lt;res-ref-name&gt;jdbc/sample_db&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 安全限制配置 123456789101112131415&lt;security-constraint&gt; &lt;display-name&gt;Example Security Constraint&lt;/display-name&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Protected Area&lt;/web-resource-name&gt; &lt;url-pattern&gt;/jsp/security/protected/*&lt;/url-pattern&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;role-name&gt;role1&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; 登陆验证配置 12345678&lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; &lt;realm-name&gt;Example-Based Authentiation Area&lt;/realm-name&gt; &lt;form-login-config&gt; &lt;form-login-page&gt;/jsp/security/protected/login.jsp&lt;/form-login-page&gt; &lt;form-error-page&gt;/jsp/security/protected/error.jsp&lt;/form-error-page&gt; &lt;/form-login-config&gt; &lt;/login-config&gt; 安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。 123&lt;security-role&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/security-role&gt; 123456718. Web环境参数：env-entry元素声明Web应用的环境项 ​```XML&lt;env-entry&gt; &lt;env-entry-name&gt;minExemptions&lt;/env-entry-name&gt; &lt;env-entry-value&gt;1&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; &lt;/env-entry&gt; EJB 声明 1234567&lt;ejb-ref&gt; &lt;description&gt;Example EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/Account&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt; &lt;home&gt;com.mycompany.mypackage.AccountHome&lt;/home&gt; &lt;remote&gt;com.mycompany.mypackage.Account&lt;/remote&gt; &lt;/ejb-ref&gt; 本地EJB声明 1234567&lt;ejb-local-ref&gt; &lt;description&gt;Example Loacal EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/ProcessOrder&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt; &lt;local-home&gt;com.mycompany.mypackage.ProcessOrderHome&lt;/local-home&gt; &lt;local&gt;com.mycompany.mypackage.ProcessOrder&lt;/local&gt; &lt;/ejb-local-ref&gt; 配置DWR 12345678&lt;servlet&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;servlet-class&gt;uk.ltd.getahead.dwr.DWRServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Struts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;display-name&gt;Struts Blank Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt; org.apache.struts.action.ActionServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;detail&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;application&lt;/param-name&gt; &lt;param-value&gt;ApplicationResources&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- Struts Tag Library Descriptors --&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-bean&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-bean.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-html&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-html.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-nested&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-nested.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-logic&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-logic.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-tiles&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-tiles.tld&lt;/taglib-location&gt; &lt;/taglib&gt; 配置Spring（基本上都是在Struts中配置的） 123456789101112131415161718 &lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!--加载多个spring配置文件 --&gt; /WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义SPRING监听器，加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; -end-]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题集成gitment评论系统]]></title>
    <url>%2Fposts%2F47815.html</url>
    <content type="text"><![CDATA[简介本文介绍hexo next主题(5.1.2)集成giment评论系统的过程。所谓gitment就是把评论放到github的issues系统里，评论支持md，比较适合程序员. 一.注册OAuth Application点击https://github.com/settings/applications/new注册，注意Authorization callback URL填自己的网站urlhttp://yangq.me/.记下Client ID和Client Secret. 二.修改themes/next/_config.yml在config.yml中添加:123456789# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true githubID: yourid repo: yourrepo ClientID: yourid ClientSecret: yoursecret lazy: true 注意:格式要正确，该空格的一定要空格。所有的yourXXX都换成自己的. 在主题的en.yml增加:1gitmentbutton: Show comments from Gitment zh-Hans.yml增加:1gitmentbutton: 显示 Gitment 评论 三.修改主题layout/_partials/comments.swig找到这个文件里的这两行: 12&#123;% elseif theme.valine.appidand theme.valine.appkey %&#125; "vcomments"&gt; 上面是最后一个elseif分支，在下面加一个elseif分支: 1234567&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="ShowGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; 加完之后下面的内容是原来的，保持不变: 123&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 四.增加gitment.swig在主题下layout/_third-party/comments/目录下中添加文件gitment.swig：12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.githubID %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.ClientID %&#125; &#123;% set cs = theme.gitment.ClientSecret %&#125; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &#123;% if not theme.gitment.lazy %&#125; &lt;script type="text/javascript"&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &lt;/script&gt; &#123;% else %&#125; &lt;script type="text/javascript"&gt; function ShowGitment()&#123; document.getElementById("gitment-display-button").style.display = "none"; document.getElementById("gitment-container").style.display = "block"; var gitment = new Gitment(&#123; id: document.location.href, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &#125; &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在主题下layout/_third-party/comments/index.swig文件中引入gitment.swig文件：1&#123;% include'gitment.swig' %&#125; 五.添加gitment.styl在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件，设置button的样式： 12345678910111213#gitment-display-button&#123; display: inline-block; padding: 0 15px; color: #0a9caf; cursor: pointer; font-size: 14px; border: 1px solid #0a9caf; border-radius: 4px; &#125; #gitment-display-button:hover&#123; color: #fff; background: #0a9caf; &#125; 然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可: 1@import"gitment"; 这样就ok了！ 易错点修改themes/next/_config.yml这个文件时，格式要正确。另外，repo是你要想创建issues的仓库，完全可以跟博文所放的仓库不一个。id就写自己的github用户名就可以，这个用户名跟repo必须匹配。gitment可能不支持链接地址里有中文，所以安装gitment前一定要参考前文把链接持久化搞成全是英文的。同一篇文章需要初始化comment两次的问题，是因为http://xxx.com/post/ab9bb85a.html和点击阅读全文进去的链接http://xxx.com/post/ab9bb85a.html#more对issues来说是不同的，所以创建两次。解决方法就是gitment.swig里id弄成window.location.pathname而不是document.location.href。初始化评论后，可以到github里自己放issues的仓库查看issues是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。参考文档 主要参考文档 一种相对简略的配置方式 作者issue]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery使用技巧]]></title>
    <url>%2Fposts%2F12197.html</url>
    <content type="text"><![CDATA[禁用页面的右键菜单12345$(document).ready(function()&#123; $(document).bind("contextmenu",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="https://www.google.com"&gt;google_新窗口&lt;/a&gt; &lt;a href="https://www.google.com" rel="external"&gt;google_新窗口&lt;/a&gt; &lt;a href="demo1.html"&gt;当前窗口&lt;/a&gt;&lt;script&gt; $(function()&#123; $('a[href^="http://"]').attr("target","_blank"); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 输入框文字获取和失去焦点【推荐】 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" class="text1" /&gt;&lt;script&gt;$(document).ready(function() &#123; $("input.text1").val("Enter your search text here."); textFill( $('input.text1') ); &#125;);function textFill(input)&#123; //input focus text function var originalvalue = input.val(); input.focus( function()&#123; if( $.trim(input.val()) == originalvalue )&#123; input.val(''); &#125; &#125;).blur( function()&#123; if( $.trim(input.val()) == '' )&#123; input.val(originalvalue); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 返回头部滑动动画123456789101112&lt;script&gt;jQuery.fn.scrollTo = function(speed) &#123; var targetOffset = $(this).offset().top; $('html,body').stop().animate(&#123;scrollTop: targetOffset&#125;, speed); return this;&#125;; // use$("#goheader").click(function()&#123; $("body").scrollTo(500); return false;&#125;); &lt;/script&gt; 获取鼠标位置123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="XY" &gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(document).mousemove(function(e)&#123; $('#XY').html("X : " + e.pageX + " | Y : " + e.pageY); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关闭所有 jQuery 动画效果1jQuery.fx.off = true; 检测鼠标的右键和左键123$('#box').mousedown(function(e) &#123; alert(e.which);&#125;); 回车提交表单1234567$(function() &#123; $('input').keyup(function(e) &#123; if(e.which == '13') &#123; alert('回车提交'); &#125; &#125;);&#125;); 切换复选框12345var tog = false;$('button').click(function() &#123; $("input[type=checkbox]").attr("checked",!tog); tog = !tog;&#125;); 使用 siblings() 来选择同辈元素123456789//不这样做$('#nav li').click(function()&#123; $('#nav li').removeClass('active'); $(this).addClass('active');&#125;);//替代做法是$('#nav li').click(function() &#123; $(this).addClass('active').siblings().removeClass('active');&#125;); 为任何与选择器相匹配的元素绑定事件123$("table").on("click","td",function()&#123; $(this).toggleClass("hover"); &#125;); $.proxy 的使用使用回调方法的缺点之一是当执行类库中的方法后，上下文对象被设置到另外一个元素，比如，执行下面代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click(function()&#123; $(this).fadeOut(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你将遇到问题，button 元素会消失，而不是 panel 元素。可以使用 $.proxy 方法解决这个问题，代码如下：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click($.proxy(function()&#123; $(this).fadeOut(); &#125;,this)); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样才正确执行。 限制 Text-Area 域中的字符的个数12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id="mytextarea"&gt;&lt;/textarea&gt; &lt;script&gt; jQuery.fn.maxLength = function(max)&#123; this.each(function()&#123; var type = this.tagName.toLowerCase(); var inputType = this.type? this.type.toLowerCase() : null; if(type == "input" &amp;&amp; inputType == "text" || inputType == "password")&#123; //应用标准的maxLength this.maxLength = max; &#125;else if(type == "textarea")&#123; this.onkeypress = function(e)&#123; var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection); &#125;; this.onkeyup = function()&#123; if(this.value.length &gt; max)&#123; this.value = this.value.substring(0,max); &#125; &#125;; &#125; &#125;); &#125;; //use $('#mytextarea').maxLength(10); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解析 json 数据时报 parseError 错误jQuery 在 1.4 版本后，采用了更为严格的 json 解析方式，即所有内容都必须要有双引号，如果升级 jQuery 版本后，ajax 加载 json 报错，有可能就是这个原因。比如：12345// 1.4之前版本，key没引号，这样没问题&#123; key:"coco", status:"0"&#125; 但升级成jQuery1.4后，都必须加上双引号，格式如下：1234&#123; "key":"coco", "status":"0"&#125; 从元素中除去 HTML12345678910111213&lt;script&gt;(function($) &#123; $.fn.stripHtml = function() &#123; var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi; this.each(function() &#123; $(this).html( $(this).html().replace(regexp,'') ); &#125;); return $(this); &#125; &#125;)(jQuery); //用法： $('div').stripHtml(); &lt;/script&gt; 扩展 String 对象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" /&gt;&lt;button &gt;check&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $.extend(String.prototype, &#123; isPositiveInteger:function()&#123; return (new RegExp(/^[1-9]\d*$/).test(this)); &#125;, isInteger:function()&#123; return (new RegExp(/^\d+$/).test(this)); &#125;, isNumber: function(value, element) &#123; return (new RegExp(/^-?(?:\d+|\d&#123;1,3&#125;(?:,\d&#123;3&#125;)+)(?:\.\d+)?$/).test(this)); &#125;, trim:function()&#123; return this.replace(/(^\s*)|(\s*$)|\r|\n/g, ""); &#125;, trans:function() &#123; return this.replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g, '"'); &#125;, replaceAll:function(os, ns) &#123; return this.replace(new RegExp(os,"gm"),ns); &#125;, skipChar:function(ch) &#123; if (!this || this.length===0) &#123;return '';&#125; if (this.charAt(0)===ch) &#123;return this.substring(1).skipChar(ch);&#125; return this; &#125;, isValidPwd:function() &#123; return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this)); &#125;, isValidMail:function()&#123; return(new RegExp(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/).test(this.trim())); &#125;, isSpaces:function() &#123; for(var i=0; i&lt;this.length; i+=1) &#123; var ch = this.charAt(i); if (ch!=' '&amp;&amp; ch!="\n" &amp;&amp; ch!="\t" &amp;&amp; ch!="\r") &#123;return false;&#125; &#125; return true; &#125;, isPhone:function() &#123; return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?\d&#123;3,8&#125;(-\d&#123;1,6&#125;)?$)|(^\([0-9]&#123;3,4&#125;\)\d&#123;3,8&#125;(\(\d&#123;1,6&#125;\))?$)|(^\d&#123;3,8&#125;$)/).test(this)); &#125;, isUrl:function()&#123; return (new RegExp(/^[a-zA-z]+:\/\/([a-zA-Z0-9\-\.]+)([-\w .\/?%&amp;=:]*)$/).test(this)); &#125;, isExternalUrl:function()&#123; return this.isUrl() &amp;&amp; this.indexOf("://"+document.domain) == -1; &#125; &#125;); $("button").click(function()&#123; alert( $("input").val().isInteger() ); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习总结]]></title>
    <url>%2Fposts%2F43183.html</url>
    <content type="text"><![CDATA[git 简介git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。在 git 中，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。 实用指令详解merge通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。git merge --no-ff -m &#39;merge with no-ff&#39; dev因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。 合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。 fetch一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回 origin 主机的 master 分支git fetch origin master所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。 git fetch -p ：取回远程更新，删除不存在的分支。 pullgit pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。12git fetch origingit merge origin/master 在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。git 也允许手动建立追踪关系。git branch --set-upstream master origin/next上面的命令指定 master 分支追踪 origin/next 分支。如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。git pull origin上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以忽略。git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用 rebase 模式，可以使用 -rebase 选项。git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; pushgit push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。git push origin master上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master等同于git push origin --delete master上面命令表示删除 origin 主机的 master 分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。git push origin上面命令表示，将当前分支推送到 origin 主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。git push -u origin master上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。git config --global push.default matching或者git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。git push --all origin上面命令表示，将所有本地分支都推送到 origin 主机。如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。git push --force origin上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。最后，git push 不会推送标签(tag)，除非使用 -tags 选项。git push origin --tags loggit log 命令可以查看历史记录，git log 命令显示从最近到最远的提交日志；如果嫌输出信息太多，看得眼花缭乱的，可以试试 git log --pretty=oneline 。我们可以看到当前版本以及之前的版本日志以及版本号。用 git log --graph 命令可以看到分支合并图。或者两个参数一起用：git log --graph --pretty=onelinegit log --graph --pretty=oneline --abbrev-commit首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ， 当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100 。现在，我们要把当前版本回退到上一个版本，就可以使用 git reset 命令：git reset --hard HEAD^当你回退到了某个版本后，git log 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？Git 提供了一个命令 git reflog 用来记录你的每一次命令 tag查看标签（用来标记标志性的稳定版本信息）发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。相比于 commit 的版本号(40位16进制)，标签号则要好使的多。所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。 git tag [tag name]如果没有标签名，则为查看所有标签，带标签名则为新建标签 git tag &lt;tag name&gt; 就可以打一个新标签 还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。git tag -a &lt;tag name&gt; -m &lt;comment&gt; ：添加带注释的标签eg: git tag -a v1.2 -m &#39;version 1.2 released&#39; git tag -a &lt;tag name&gt; &lt;md5&gt; ：对某个版本打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的 commit id，然后打上就可以了。git log --pretty=oneline --abbrev-commit比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：git tag v1.2 6224937再用命令 git log 查看标签 可以用 git show &lt;tagname&gt; 查看标签信息 如果标签打错了，也可以删除：git tag -d v1.2 如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;eg: git push origin v1.2 如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：git tag -d v1.2然后，从远程删除；删除命令也是 push ，但是格式如下：git push origin :ref/tags/v1.2 git tag -l &#39;[expression]&#39;查看那符合正则表达式的 stashgit stash备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。git stash pop从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。git stash list显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。git stash clear : 清空 Git 栈。 使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。 看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。 注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。 remote查看远程仓库名 git remote -v查看远程仓库url git remote add &lt;basename&gt; &lt;url&gt;新增远程仓库 git remote show &lt;basename&gt;查看远程仓库详细信息 git remote rename &lt;old basename&gt; &lt;new basename&gt;重命名远程仓库 commitgit commit -a -m &#39;xx&#39;暂存并提交 branchgit branch查看本地仓库分支 git branch -r查看远程分支情况 git branch -a查看本地和远程的所有分支情况 git branch -v查看本地仓库分支最后一次提交情况 git branch -vv查看分支跟踪情况 git branch &lt;branch name&gt;新建分支 git branch -d &lt;branch name&gt;删除分支 git branch -D &lt;branch name&gt;强制删除分支 git branch [--merged | --no-merged]查看已合并|未合并的本地仓库分支 git branch -u &lt;remote base&gt;/&lt;remote branch&gt;修改当前跟踪分支 checkoutgit checkout -- [file] ：恢复文件git checkout -- demo.html 意思就是，把 demo.html 文件在工作区的修改全部撤销，这里有两种情况：一种是 demo.html 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是 demo.html 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。总之，就是让这个文件回到最后一次 git commit 或 git add 时的状态。 但是如果 git add 到暂存区了，在 commit 之前，想撤销：Git 同样告诉我们，用命令 git reset HEAD file 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 HEAD 时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改：还记得如果丢弃工作区的修改吗？对的，使用：git checkout -- demo.html git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。 git checkout -b [branchname] [tagname]在特定的版本上创建一个新的分支并切换到此分支 git checkout -b [local branch] [remote base]/[remote branch]将远程分支检出到本地分支，并追踪 git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;让当前分支跟踪远程分支 rebasegit rebase [basebranch]变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 常见问题git clonegit clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。 git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;如果不写本地目录名，默认就是版本库的名字 如何新建分支本地建立 branch 並立即切换到新分支git checkout -b &lt;branch_name&gt; 下面的命令表示，在 origin/master 的基础上，创建一个分支。git checkout -b newBranch origin/master 修改分支名称git branch -m &lt;new_name&gt; 从远程仓库拉取代码到本地仓库，并建立跟踪关系git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt; 如何在远程仓库新建一个分支新建一个本地分支，按照正常流程提交完代码后，推送到远程git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt; 比较文件git diff HEAD -- demo.html命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。 忽略某些文件默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除git rm --cached [file]不删除文件，只移除追踪。123cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 # 开头的目录都会被 git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 bug 分支git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。git stash修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？git stash list ：查看 stash 列表(stash 是一个栈的结构)git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除；另一种方式是用 git stash pop ，恢复的同时把 stash 内容也删了；你可以多次 stash ，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令：git stash apply stash@{0} 配置文件配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 查看配置git config -1 设置git push 默认git config --global push.default current 设置别名git config --global alias.&lt;name&gt; &lt;commend&gt;我的设置：git config --global alias.st statusgit config --global alias.cm &quot;commit -m&quot;git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot; 保存用户名和密码对于http(s)协议，可以用下面命令临时缓存git config --global credential.helper cache开启linux缓存git config --global credential.helper wincred开启windows缓存 对于 ssh 协议，可以用 ssh key，具体教程网上很多解决问题问题一git 中执行命令 add .报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n) 因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 .exe 文件，我们是不需要添加到版本管理工具的。所以我们选择 n 。 问题二git 中生成 sshkey: ssh-keygen -t rsa -C &quot;youremail&quot;这个email并没有什么用所以我们使用ssh-keygen -t rsa来生成sshkey就可以了。然后git中的配置文件：git config --listgit config --global user.name &quot;yu&quot;git config --global user.email &quot;react.dong.yu@gmail.com&quot;这种配置将会对本地所有的git仓库有效。那么在 push 的时候，远程就知道这个push来自于哪个email.但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。这个时候就可以不设置global的配置了，而是在自己的仓库中设置git config --local user.email &quot;react.dong.yu@gmail.com&quot; 问题三使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：git add App.class如果你确实想添加该文件，可以用 -f 制添加到 git：git add -f App.class或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。可以用 git check-ignore 命令检查：git check-ignore -v App.class 问题四为什么我把我生成的 ssh key 添加到了 github 中然后 也 remote 了 https://github.com/Neveryu/Xxx.git为什么提交的时候报错，或者提示 输入密码账号是为什么 ssh key 是 ssh 协议的密钥，http 协议没权限 问题五git怎样删除未监视的文件 untracked files?用 git clean12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd 我的常用命令12git branch -avvgit remote -v 权威教程Pro Git 简体中文版]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（五）]]></title>
    <url>%2Fposts%2F64470.html</url>
    <content type="text"><![CDATA[在这之前，我写过四篇关于 Hexo + NexT 构建博客的文章。=》【传送门】 本文将会介绍一些自定义的功能。相较于之前主要是修改配置文件中的内容，现在更多的是动手改源码来实现功能，而且还能帮你搞懂一些 Hexo NexT 的源码。如果你能弄懂源码的一些流程和逻辑，那么，你将能更好的来实现自己的一些想法。 文章封面文章封面的意思就是：在博客首页的时候会显示文章的封面图片，进入这篇文章的详细页面后，将不显示这张图片。 如果想添加文章封面的话，需要添加一个字段属性：summary_img，summary_img 的值是图片的路径。 例如：12345678---title: CSS 各种Hack手段date: 2017-06-25 03:25:24categories: 前端tags: [CSS]comments: falsesummary_img: /images/css-hack-1.png--- 具体实现细节如下：修改 \themes\next\layout\_macro\post.swing 文件。将代码：12345&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;img-topic&quot;&gt; &lt;/div&gt;&#123;% endif %&#125; 添加到下图所示的位置 这样的话，就可以使用 summary_img: imageurl 来设置文章封面了。 开启了文章封面的文章，我建议将 &lt;!-- more --&gt; 放在文章内容的开头，像这样： 网页加载进度条打开 /themes/next/layout/_partials/head.swing 文件，在文件末尾添加如下代码：12&lt;!-- 网页加载条 --&gt;&lt;script src=&quot;https://neveryu.github.io/js/src/pace.min.js&quot;&gt;&lt;/script&gt; 然后，打开 /themes/source/css/_custom/custom.styl 文件，在文件末尾添加如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*网页加载条*//* This is a compiled file, you should be editing the file in the templates directory */.pace &#123; -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125;.pace-inactive &#123; display: none;&#125;.pace .pace-progress &#123; background: #1e92fb; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 3px;&#125;.pace .pace-progress-inner &#123; display: block; position: absolute; right: 0px; width: 100px; height: 100%; box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92; opacity: 1.0; -webkit-transform: rotate(3deg) translate(0px, -4px); -moz-transform: rotate(3deg) translate(0px, -4px); -ms-transform: rotate(3deg) translate(0px, -4px); -o-transform: rotate(3deg) translate(0px, -4px); transform: rotate(3deg) translate(0px, -4px);&#125;.pace .pace-activity &#123; display: block; position: fixed; z-index: 2000; top: 15px; right: 15px; width: 14px; height: 14px; border: solid 2px transparent; border-top-color: #e90f92; border-left-color: #e90f92; border-radius: 10px; -webkit-animation: pace-spinner 400ms linear infinite; -moz-animation: pace-spinner 400ms linear infinite; -ms-animation: pace-spinner 400ms linear infinite; -o-animation: pace-spinner 400ms linear infinite; animation: pace-spinner 400ms linear infinite;&#125;@-webkit-keyframes pace-spinner &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-moz-keyframes pace-spinner &#123; 0% &#123; -moz-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -moz-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-o-keyframes pace-spinner &#123; 0% &#123; -o-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -o-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-ms-keyframes pace-spinner &#123; 0% &#123; -ms-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -ms-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@keyframes pace-spinner &#123; 0% &#123; transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;/*网页加载条 END*/ 开发环境自动刷新在 Hexo-NexT搭建个人博客（一） 已经提到了本地调试三部曲：123hexo cleanhexo generatehexo server --debug 然后我在项目的 package.json 中配成了这样：1&quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug&quot;, 这样的话，我执行 npm run dev 就可以启动本地环境了，省去了前面需要分别敲三次命令的步骤。为什么可以这样写，详情看这里：npm 全面介绍npm 的一个小细节 这样还不爽，我希望在写博客的时候，按下 Ctrl + S 后能自动刷新浏览器，看到实时的效果，省去了自己手动刷新浏览器的过程，在双屏下，真的很好用，一边写一边看。具体的做法是:在项目的根目录下添加一个 gulpfile.js 文件，文件内容参看 源码，这里我就不贴了。然后安装 gulpfile.js 里面的依赖包。 gulpfile.js 里面有一个 dev-proxy 方法，会代理本地的 4000 端口，并且监听文件变化，如有变化就会自动刷新浏览器。 最后，我们的开发步骤就变成这样了：先打开一个 Terminal ，使用 npm run dev 开启本地的博客服务。然后再开一个 Terminal，使用 gulp 命令来开启监听和代理服务。 代码压缩在项目的根目录下，执行以下命令：12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码，详情查看 源码 。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 自定义页面与目录下面介绍两种方法： 第一种方法是使用 Hexo 提供的跳过渲染配置，适用于整个目录的设置。 具体步骤，打开博客根目录_config.yml，找到其中 skip_render 配置项，这个用来配置 /source/ 中需要跳过渲染的文件或目录，例如希望跳过 /source/projects/ 里的所有文件渲染，可以配置为：1skip_render: projects/** 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外在测试这个功能的时候发现，Hexo 的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下 hexo clean 命令，清除掉旧的生成文件和缓存。 第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个 html 格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 这样，这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。 关于 categories 和 tags 页面 Cannot GET 的解决方案有同学反馈在配置文件中配置了 categories 和 tags 后依然没有 categories 和 tags 页面，提示 Cannot GET。 其实在配置了 categories 和 tags 后，还需要在 /source/ 目录下新建 categories 目录和 tags 目录，里面的要有 index.md 文件，并且文件开头不能少，也不能写错。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（四）]]></title>
    <url>%2Fposts%2F14696.html</url>
    <content type="text"><![CDATA[提示：本篇文章将介绍在使用 heox 做博客框架中的一些 bug 处理情况。 按照之前的教程介绍应该是会比较顺利的搭建好你的博客，但是难免会遇到一些意外，这个时候就要学会解决问题了。解决问题的原则是：查看 bug 信息，从上到下依次解决 bug。下面来看几个例子： 首先这个是在 hexo clean 时报的错：提示插件 hexo-deployer-git 加载失败，想了一下，应该是上次我在移动博客目录的时候，这个模块中有一些文件名比较长的文件，系统会提示移动不过来，导致这个模块异常，很简单，文件夹中删除这个模块，重新安装即可。（或者使用 npm 来卸载这个模块，然后重新安装）如下： OK ， 现在好了，hexo clean 没有报错了。 下面，我是在执行 hexo g 的操作，同样也出现了错误： 按照图中我标注的步骤，来看一下错误信息：如 1 所示：我们首先会发现缺少模块 isarray ，但是我们查看 package.json 文件，我们的项目根本就没有引入 isarray 这个模块，我猜测这个 isarray 模块应该是某个模块的子模块 。 如 2 所示：我们顺着 at 一路往下找。 如 3 所示：发现这个 isarray 是在 hexo-generator-sitemap 里面的 ，所以我们删除这个 hexo-generator-sitemap 模块，然后重新安装这个模块。如下： OK ， 现在好了，hexo g 没有报错了。 那么，就以这两个例子来作为本次的示范吧，其实，Hexo 中的一些问题还是比较好解决的，因为它都是依赖其他模块的，定位到出问题的模块，卸载重装即可。 总结：遇到问题 bug，一定要仔细查阅错误提示信息，遵守从上往下解决的方案。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（三）]]></title>
    <url>%2Fposts%2F22441.html</url>
    <content type="text"><![CDATA[经过前面两期文章，我相信你已经可以在本地建立一个非常令人满意的静态博客了，本篇文章将介绍如何将自己的静态博客部署到 gitpage 上，并托管到 github 上；以及关于 Hexo 和 NexT 中更深层次的一些问题及解方案。 一、菜单栏中标签与侧边栏中标签关联的问题 以我的博客为例，关于菜单栏中的选项 与侧边栏中的选项，由于顶部菜单栏中位置有限，所以我就想在顶部菜单栏中不显示标签这一项，于是我在 主题配置文件 中 将 menu 配置项中的标签这一个选项给注释掉了，所以它不会在菜单栏中显示，但是不代表没有这个页面，这个页面是存在的，我们只是使其不显示在顶部的菜单栏中而已，我们可以直接输入绝对地址来查看这个页面，例如：https://neveryu.github.io/tags/。但是与此同时，我们发现侧边栏中的标签选项只能显示标签数量，不能点击。 这是因为侧边栏中的点击链接是根据菜单栏中对应的项来添加的，什么意思呢？就是说如果顶部菜单栏中有 标签 这一项，那么就会给侧边栏中标签这一项也添加点击链接；如果顶部菜单栏中没有标签这一项，那么就不给侧边栏中标签这一项添加点击链接，导致侧边栏中的标签项只有显示数据，不提供点击链接。 如果我们不想在菜单栏中显示标签项，但是希望侧边栏中的标签项 可以点击，该怎么做呢？ 在 主题配置文件 \themes\next\layout\_macro\sidebar.swing_ 中，将12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &#123;% if theme.menu.tags %&#125;&lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt;&#123;% endif %&#125; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 改成：12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 同理，关于菜单栏中 归档 和 分类 的类似操作也是如此。 二、关于High一下中的音乐多次点击重叠播放的解决方案 在之前的 High一下 的播放音乐，如果多次点击的话，音乐会重复叠加播放，严重影响听歌体验，而且只能播放一首歌。 而现在的 High一下 已经解决了这个问题，而且可以列表循环多首歌曲。我将之前的那段播放音乐的代码换了。由于代码太长了，就不在这里贴出来了。大家可以去查看我的源码：https://github.com/Neveryu/Blog。关于播放音乐的代码是在： https://github.com/Neveryu/Blog/blob/master/themes/next/layout/_partials/header.swig 中的第 60 行开始。 需要说明的是：现在的 High一下 实现了歌曲列表循环，所以，我们可以放入多首歌的链接。在代码中以数组元素的形式加入歌曲链接。1234var songs = [ &quot;http://v.65dj.com/wailian/84791c997d8c55023dad0d5690e48c28.mp3&quot;, &quot;http://7xoiki.com1.z0.glb.clouddn.com/Music-sunburst.mp3&quot;]; 三、关于github屏蔽vendors ，导致页面空白的解决方案关于 Github Pages 过滤掉了 source/vendors 目录的访问，导致加载 vendor 里面的文件全部 404 ，页面大面积空白。1.在根目录添加 .nojekyll 文件。2.也可以手动将 source/vendors 目录修改成 source/lib 同时，修改主题配置文件 _config.yml ，将 _internal: vendors 改成你所修改的名字，例如 _internal: lib 。 四、关于如何获取自己的多说userid首先进入自己的帐号管理页面，点击左上自己的名字此时地址栏后面的一串数字就是你的多说 userid。 五、关于如何修改内容区域宽度Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。编辑主题的 source\css_variables\custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme ， Pisces Scheme 编辑 themes\next\source\css\_schemes\Picses\_layout.styl 文件，更改以下 css 选项定义值：123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 六、图片模式新建博文，设置 type: &quot;picture&quot; ，使用 {\% gp x-x \%}...{\% endgp \%} 标签引用要展示的图片地址，如下所示：1234567891011121314---title: Naruto-Picturescategories: [picture]tags: [picture,naruto]date: 2016-11-02 14:36:04type: &quot;picture&quot;---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%}：设置图片展示效果，参考 themes\next\scripts\tags\group-pictures.js 注释示意图。5-3 的意思就是5张图片将会按照这种布局来展示，Next 提供了多张图片的多种布局，你可以随意选择。 注意点主题目前首页可以正常显示设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（二）]]></title>
    <url>%2Fposts%2F23504.html</url>
    <content type="text"><![CDATA[本篇文章将介绍基于NexT主题下的一些扩展功能的实现。首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 1.设置侧栏的位置修改 主题配置文件 中 sidebar.position 的值，支持的选项有：left right目前仅 Pisces Scheme 支持 position 配置，也就是说NexT主题的侧栏位置是不能设置的，设置了也没用，反正都在右边。 2. 关于添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 3. 添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 4. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 5. 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 6. 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 7.修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 8. 多说评论不稳定，加载速度慢怎么办？把多说评论依赖的 embed.js 放置底部，这里需要修改的文件是 duoshuo.swig。将1(document.getElementsByTagName(&apos;head&apos;)[0] 修改成下面的代码1(document.getElementById(&apos;footer&apos;) 9. 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 10. 给 Blog 添加 LICENSE在 主题配置文件 中的 160 行左右：12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 将其中第 4 行的注释放开，然后选择你想使用的 LICENSE 即可，可选项参照第 3 行。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
    <url>%2Fposts%2F52138.html</url>
    <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
